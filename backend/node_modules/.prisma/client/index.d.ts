
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model EmployeeBenefit
 * 
 */
export type EmployeeBenefit = $Result.DefaultSelection<Prisma.$EmployeeBenefitPayload>
/**
 * Model EmployeeBenefitUsage
 * 
 */
export type EmployeeBenefitUsage = $Result.DefaultSelection<Prisma.$EmployeeBenefitUsagePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model PatientBook
 * 
 */
export type PatientBook = $Result.DefaultSelection<Prisma.$PatientBookPayload>
/**
 * Model VisitCard
 * 
 */
export type VisitCard = $Result.DefaultSelection<Prisma.$VisitCardPayload>
/**
 * Model OrthoCard
 * 
 */
export type OrthoCard = $Result.DefaultSelection<Prisma.$OrthoCardPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model EncounterConsent
 * 
 */
export type EncounterConsent = $Result.DefaultSelection<Prisma.$EncounterConsentPayload>
/**
 * Model ChartTooth
 * 
 */
export type ChartTooth = $Result.DefaultSelection<Prisma.$ChartToothPayload>
/**
 * Model ChartNote
 * 
 */
export type ChartNote = $Result.DefaultSelection<Prisma.$ChartNotePayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model DiagnosisProblem
 * 
 */
export type DiagnosisProblem = $Result.DefaultSelection<Prisma.$DiagnosisProblemPayload>
/**
 * Model EncounterDiagnosis
 * 
 */
export type EncounterDiagnosis = $Result.DefaultSelection<Prisma.$EncounterDiagnosisPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceBranch
 * 
 */
export type ServiceBranch = $Result.DefaultSelection<Prisma.$ServiceBranchPayload>
/**
 * Model EncounterService
 * 
 */
export type EncounterService = $Result.DefaultSelection<Prisma.$EncounterServicePayload>
/**
 * Model Procedure
 * 
 */
export type Procedure = $Result.DefaultSelection<Prisma.$ProcedurePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionItem
 * 
 */
export type PrescriptionItem = $Result.DefaultSelection<Prisma.$PrescriptionItemPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model EBarimtReceipt
 * 
 */
export type EBarimtReceipt = $Result.DefaultSelection<Prisma.$EBarimtReceiptPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model AuthorizationCode
 * 
 */
export type AuthorizationCode = $Result.DefaultSelection<Prisma.$AuthorizationCodePayload>
/**
 * Model EmployeeVoucher
 * 
 */
export type EmployeeVoucher = $Result.DefaultSelection<Prisma.$EmployeeVoucherPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model DoctorSchedule
 * 
 */
export type DoctorSchedule = $Result.DefaultSelection<Prisma.$DoctorSchedulePayload>
/**
 * Model ReceptionSchedule
 * 
 */
export type ReceptionSchedule = $Result.DefaultSelection<Prisma.$ReceptionSchedulePayload>
/**
 * Model DoctorBranch
 * 
 */
export type DoctorBranch = $Result.DefaultSelection<Prisma.$DoctorBranchPayload>
/**
 * Model ReceptionBranch
 * 
 */
export type ReceptionBranch = $Result.DefaultSelection<Prisma.$ReceptionBranchPayload>
/**
 * Model NurseBranch
 * 
 */
export type NurseBranch = $Result.DefaultSelection<Prisma.$NurseBranchPayload>
/**
 * Model NurseSchedule
 * 
 */
export type NurseSchedule = $Result.DefaultSelection<Prisma.$NurseSchedulePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  doctor: 'doctor',
  receptionist: 'receptionist',
  accountant: 'accountant',
  nurse: 'nurse',
  manager: 'manager'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VisitCardType: {
  ADULT: 'ADULT',
  CHILD: 'CHILD'
};

export type VisitCardType = (typeof VisitCardType)[keyof typeof VisitCardType]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const ServiceCategory: {
  ORTHODONTIC_TREATMENT: 'ORTHODONTIC_TREATMENT',
  IMAGING: 'IMAGING',
  DEFECT_CORRECTION: 'DEFECT_CORRECTION',
  ADULT_TREATMENT: 'ADULT_TREATMENT',
  WHITENING: 'WHITENING',
  CHILD_TREATMENT: 'CHILD_TREATMENT',
  SURGERY: 'SURGERY'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const DiscountPercent: {
  ZERO: 'ZERO',
  FIVE: 'FIVE',
  TEN: 'TEN'
};

export type DiscountPercent = (typeof DiscountPercent)[keyof typeof DiscountPercent]


export const InvoiceItemType: {
  SERVICE: 'SERVICE',
  PRODUCT: 'PRODUCT'
};

export type InvoiceItemType = (typeof InvoiceItemType)[keyof typeof InvoiceItemType]


export const InvoiceItemSource: {
  ENCOUNTER: 'ENCOUNTER',
  MANUAL: 'MANUAL'
};

export type InvoiceItemSource = (typeof InvoiceItemSource)[keyof typeof InvoiceItemSource]


export const LedgerEntryType: {
  CASH: 'CASH',
  QPAY: 'QPAY',
  POS: 'POS',
  FIN_APP: 'FIN_APP',
  BOOKING_ADVANCE: 'BOOKING_ADVANCE',
  INSURANCE_PENDING: 'INSURANCE_PENDING',
  INSURANCE_SETTLED: 'INSURANCE_SETTLED',
  EMPLOYEE_VOUCHER: 'EMPLOYEE_VOUCHER',
  BARTER: 'BARTER',
  REFUND: 'REFUND'
};

export type LedgerEntryType = (typeof LedgerEntryType)[keyof typeof LedgerEntryType]


export const EmployeeVoucherStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED',
  EXPIRED: 'EXPIRED'
};

export type EmployeeVoucherStatus = (typeof EmployeeVoucherStatus)[keyof typeof EmployeeVoucherStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VisitCardType = $Enums.VisitCardType

export const VisitCardType: typeof $Enums.VisitCardType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type DiscountPercent = $Enums.DiscountPercent

export const DiscountPercent: typeof $Enums.DiscountPercent

export type InvoiceItemType = $Enums.InvoiceItemType

export const InvoiceItemType: typeof $Enums.InvoiceItemType

export type InvoiceItemSource = $Enums.InvoiceItemSource

export const InvoiceItemSource: typeof $Enums.InvoiceItemSource

export type LedgerEntryType = $Enums.LedgerEntryType

export const LedgerEntryType: typeof $Enums.LedgerEntryType

export type EmployeeVoucherStatus = $Enums.EmployeeVoucherStatus

export const EmployeeVoucherStatus: typeof $Enums.EmployeeVoucherStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Branches
 * const branches = await prisma.branch.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Branches
   * const branches = await prisma.branch.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.employeeBenefit`: Exposes CRUD operations for the **EmployeeBenefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeBenefits
    * const employeeBenefits = await prisma.employeeBenefit.findMany()
    * ```
    */
  get employeeBenefit(): Prisma.EmployeeBenefitDelegate<ExtArgs>;

  /**
   * `prisma.employeeBenefitUsage`: Exposes CRUD operations for the **EmployeeBenefitUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeBenefitUsages
    * const employeeBenefitUsages = await prisma.employeeBenefitUsage.findMany()
    * ```
    */
  get employeeBenefitUsage(): Prisma.EmployeeBenefitUsageDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.patientBook`: Exposes CRUD operations for the **PatientBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientBooks
    * const patientBooks = await prisma.patientBook.findMany()
    * ```
    */
  get patientBook(): Prisma.PatientBookDelegate<ExtArgs>;

  /**
   * `prisma.visitCard`: Exposes CRUD operations for the **VisitCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitCards
    * const visitCards = await prisma.visitCard.findMany()
    * ```
    */
  get visitCard(): Prisma.VisitCardDelegate<ExtArgs>;

  /**
   * `prisma.orthoCard`: Exposes CRUD operations for the **OrthoCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrthoCards
    * const orthoCards = await prisma.orthoCard.findMany()
    * ```
    */
  get orthoCard(): Prisma.OrthoCardDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs>;

  /**
   * `prisma.encounterConsent`: Exposes CRUD operations for the **EncounterConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterConsents
    * const encounterConsents = await prisma.encounterConsent.findMany()
    * ```
    */
  get encounterConsent(): Prisma.EncounterConsentDelegate<ExtArgs>;

  /**
   * `prisma.chartTooth`: Exposes CRUD operations for the **ChartTooth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartTooths
    * const chartTooths = await prisma.chartTooth.findMany()
    * ```
    */
  get chartTooth(): Prisma.ChartToothDelegate<ExtArgs>;

  /**
   * `prisma.chartNote`: Exposes CRUD operations for the **ChartNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartNotes
    * const chartNotes = await prisma.chartNote.findMany()
    * ```
    */
  get chartNote(): Prisma.ChartNoteDelegate<ExtArgs>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.diagnosisProblem`: Exposes CRUD operations for the **DiagnosisProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiagnosisProblems
    * const diagnosisProblems = await prisma.diagnosisProblem.findMany()
    * ```
    */
  get diagnosisProblem(): Prisma.DiagnosisProblemDelegate<ExtArgs>;

  /**
   * `prisma.encounterDiagnosis`: Exposes CRUD operations for the **EncounterDiagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterDiagnoses
    * const encounterDiagnoses = await prisma.encounterDiagnosis.findMany()
    * ```
    */
  get encounterDiagnosis(): Prisma.EncounterDiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.serviceBranch`: Exposes CRUD operations for the **ServiceBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceBranches
    * const serviceBranches = await prisma.serviceBranch.findMany()
    * ```
    */
  get serviceBranch(): Prisma.ServiceBranchDelegate<ExtArgs>;

  /**
   * `prisma.encounterService`: Exposes CRUD operations for the **EncounterService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterServices
    * const encounterServices = await prisma.encounterService.findMany()
    * ```
    */
  get encounterService(): Prisma.EncounterServiceDelegate<ExtArgs>;

  /**
   * `prisma.procedure`: Exposes CRUD operations for the **Procedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedures
    * const procedures = await prisma.procedure.findMany()
    * ```
    */
  get procedure(): Prisma.ProcedureDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs>;

  /**
   * `prisma.prescriptionItem`: Exposes CRUD operations for the **PrescriptionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionItems
    * const prescriptionItems = await prisma.prescriptionItem.findMany()
    * ```
    */
  get prescriptionItem(): Prisma.PrescriptionItemDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.eBarimtReceipt`: Exposes CRUD operations for the **EBarimtReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EBarimtReceipts
    * const eBarimtReceipts = await prisma.eBarimtReceipt.findMany()
    * ```
    */
  get eBarimtReceipt(): Prisma.EBarimtReceiptDelegate<ExtArgs>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs>;

  /**
   * `prisma.authorizationCode`: Exposes CRUD operations for the **AuthorizationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorizationCodes
    * const authorizationCodes = await prisma.authorizationCode.findMany()
    * ```
    */
  get authorizationCode(): Prisma.AuthorizationCodeDelegate<ExtArgs>;

  /**
   * `prisma.employeeVoucher`: Exposes CRUD operations for the **EmployeeVoucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeVouchers
    * const employeeVouchers = await prisma.employeeVoucher.findMany()
    * ```
    */
  get employeeVoucher(): Prisma.EmployeeVoucherDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.doctorSchedule`: Exposes CRUD operations for the **DoctorSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorSchedules
    * const doctorSchedules = await prisma.doctorSchedule.findMany()
    * ```
    */
  get doctorSchedule(): Prisma.DoctorScheduleDelegate<ExtArgs>;

  /**
   * `prisma.receptionSchedule`: Exposes CRUD operations for the **ReceptionSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceptionSchedules
    * const receptionSchedules = await prisma.receptionSchedule.findMany()
    * ```
    */
  get receptionSchedule(): Prisma.ReceptionScheduleDelegate<ExtArgs>;

  /**
   * `prisma.doctorBranch`: Exposes CRUD operations for the **DoctorBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorBranches
    * const doctorBranches = await prisma.doctorBranch.findMany()
    * ```
    */
  get doctorBranch(): Prisma.DoctorBranchDelegate<ExtArgs>;

  /**
   * `prisma.receptionBranch`: Exposes CRUD operations for the **ReceptionBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceptionBranches
    * const receptionBranches = await prisma.receptionBranch.findMany()
    * ```
    */
  get receptionBranch(): Prisma.ReceptionBranchDelegate<ExtArgs>;

  /**
   * `prisma.nurseBranch`: Exposes CRUD operations for the **NurseBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NurseBranches
    * const nurseBranches = await prisma.nurseBranch.findMany()
    * ```
    */
  get nurseBranch(): Prisma.NurseBranchDelegate<ExtArgs>;

  /**
   * `prisma.nurseSchedule`: Exposes CRUD operations for the **NurseSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NurseSchedules
    * const nurseSchedules = await prisma.nurseSchedule.findMany()
    * ```
    */
  get nurseSchedule(): Prisma.NurseScheduleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Branch: 'Branch',
    EmployeeBenefit: 'EmployeeBenefit',
    EmployeeBenefitUsage: 'EmployeeBenefitUsage',
    User: 'User',
    Patient: 'Patient',
    PatientBook: 'PatientBook',
    VisitCard: 'VisitCard',
    OrthoCard: 'OrthoCard',
    Appointment: 'Appointment',
    Booking: 'Booking',
    Encounter: 'Encounter',
    EncounterConsent: 'EncounterConsent',
    ChartTooth: 'ChartTooth',
    ChartNote: 'ChartNote',
    Diagnosis: 'Diagnosis',
    DiagnosisProblem: 'DiagnosisProblem',
    EncounterDiagnosis: 'EncounterDiagnosis',
    Service: 'Service',
    ServiceBranch: 'ServiceBranch',
    EncounterService: 'EncounterService',
    Procedure: 'Procedure',
    Product: 'Product',
    Prescription: 'Prescription',
    PrescriptionItem: 'PrescriptionItem',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    EBarimtReceipt: 'EBarimtReceipt',
    LedgerEntry: 'LedgerEntry',
    AuthorizationCode: 'AuthorizationCode',
    EmployeeVoucher: 'EmployeeVoucher',
    Media: 'Media',
    DoctorSchedule: 'DoctorSchedule',
    ReceptionSchedule: 'ReceptionSchedule',
    DoctorBranch: 'DoctorBranch',
    ReceptionBranch: 'ReceptionBranch',
    NurseBranch: 'NurseBranch',
    NurseSchedule: 'NurseSchedule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "branch" | "employeeBenefit" | "employeeBenefitUsage" | "user" | "patient" | "patientBook" | "visitCard" | "orthoCard" | "appointment" | "booking" | "encounter" | "encounterConsent" | "chartTooth" | "chartNote" | "diagnosis" | "diagnosisProblem" | "encounterDiagnosis" | "service" | "serviceBranch" | "encounterService" | "procedure" | "product" | "prescription" | "prescriptionItem" | "invoice" | "invoiceItem" | "payment" | "eBarimtReceipt" | "ledgerEntry" | "authorizationCode" | "employeeVoucher" | "media" | "doctorSchedule" | "receptionSchedule" | "doctorBranch" | "receptionBranch" | "nurseBranch" | "nurseSchedule"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      EmployeeBenefit: {
        payload: Prisma.$EmployeeBenefitPayload<ExtArgs>
        fields: Prisma.EmployeeBenefitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeBenefitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeBenefitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          findFirst: {
            args: Prisma.EmployeeBenefitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeBenefitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          findMany: {
            args: Prisma.EmployeeBenefitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>[]
          }
          create: {
            args: Prisma.EmployeeBenefitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          createMany: {
            args: Prisma.EmployeeBenefitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeBenefitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>[]
          }
          delete: {
            args: Prisma.EmployeeBenefitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          update: {
            args: Prisma.EmployeeBenefitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeBenefitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeBenefitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeBenefitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          aggregate: {
            args: Prisma.EmployeeBenefitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeBenefit>
          }
          groupBy: {
            args: Prisma.EmployeeBenefitGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeBenefitCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitCountAggregateOutputType> | number
          }
        }
      }
      EmployeeBenefitUsage: {
        payload: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>
        fields: Prisma.EmployeeBenefitUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeBenefitUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeBenefitUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          findFirst: {
            args: Prisma.EmployeeBenefitUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeBenefitUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          findMany: {
            args: Prisma.EmployeeBenefitUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>[]
          }
          create: {
            args: Prisma.EmployeeBenefitUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          createMany: {
            args: Prisma.EmployeeBenefitUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeBenefitUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>[]
          }
          delete: {
            args: Prisma.EmployeeBenefitUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          update: {
            args: Prisma.EmployeeBenefitUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeBenefitUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeBenefitUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeBenefitUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          aggregate: {
            args: Prisma.EmployeeBenefitUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeBenefitUsage>
          }
          groupBy: {
            args: Prisma.EmployeeBenefitUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeBenefitUsageCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitUsageCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      PatientBook: {
        payload: Prisma.$PatientBookPayload<ExtArgs>
        fields: Prisma.PatientBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          findFirst: {
            args: Prisma.PatientBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          findMany: {
            args: Prisma.PatientBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>[]
          }
          create: {
            args: Prisma.PatientBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          createMany: {
            args: Prisma.PatientBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>[]
          }
          delete: {
            args: Prisma.PatientBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          update: {
            args: Prisma.PatientBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          deleteMany: {
            args: Prisma.PatientBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          aggregate: {
            args: Prisma.PatientBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientBook>
          }
          groupBy: {
            args: Prisma.PatientBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientBookCountArgs<ExtArgs>
            result: $Utils.Optional<PatientBookCountAggregateOutputType> | number
          }
        }
      }
      VisitCard: {
        payload: Prisma.$VisitCardPayload<ExtArgs>
        fields: Prisma.VisitCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          findFirst: {
            args: Prisma.VisitCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          findMany: {
            args: Prisma.VisitCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>[]
          }
          create: {
            args: Prisma.VisitCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          createMany: {
            args: Prisma.VisitCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>[]
          }
          delete: {
            args: Prisma.VisitCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          update: {
            args: Prisma.VisitCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          deleteMany: {
            args: Prisma.VisitCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          aggregate: {
            args: Prisma.VisitCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitCard>
          }
          groupBy: {
            args: Prisma.VisitCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitCardCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCardCountAggregateOutputType> | number
          }
        }
      }
      OrthoCard: {
        payload: Prisma.$OrthoCardPayload<ExtArgs>
        fields: Prisma.OrthoCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrthoCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrthoCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          findFirst: {
            args: Prisma.OrthoCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrthoCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          findMany: {
            args: Prisma.OrthoCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>[]
          }
          create: {
            args: Prisma.OrthoCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          createMany: {
            args: Prisma.OrthoCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrthoCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>[]
          }
          delete: {
            args: Prisma.OrthoCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          update: {
            args: Prisma.OrthoCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          deleteMany: {
            args: Prisma.OrthoCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrthoCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrthoCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          aggregate: {
            args: Prisma.OrthoCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrthoCard>
          }
          groupBy: {
            args: Prisma.OrthoCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrthoCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrthoCardCountArgs<ExtArgs>
            result: $Utils.Optional<OrthoCardCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      EncounterConsent: {
        payload: Prisma.$EncounterConsentPayload<ExtArgs>
        fields: Prisma.EncounterConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          findFirst: {
            args: Prisma.EncounterConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          findMany: {
            args: Prisma.EncounterConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>[]
          }
          create: {
            args: Prisma.EncounterConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          createMany: {
            args: Prisma.EncounterConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>[]
          }
          delete: {
            args: Prisma.EncounterConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          update: {
            args: Prisma.EncounterConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          deleteMany: {
            args: Prisma.EncounterConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          aggregate: {
            args: Prisma.EncounterConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterConsent>
          }
          groupBy: {
            args: Prisma.EncounterConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterConsentCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterConsentCountAggregateOutputType> | number
          }
        }
      }
      ChartTooth: {
        payload: Prisma.$ChartToothPayload<ExtArgs>
        fields: Prisma.ChartToothFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartToothFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartToothFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          findFirst: {
            args: Prisma.ChartToothFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartToothFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          findMany: {
            args: Prisma.ChartToothFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>[]
          }
          create: {
            args: Prisma.ChartToothCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          createMany: {
            args: Prisma.ChartToothCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartToothCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>[]
          }
          delete: {
            args: Prisma.ChartToothDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          update: {
            args: Prisma.ChartToothUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          deleteMany: {
            args: Prisma.ChartToothDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartToothUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChartToothUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          aggregate: {
            args: Prisma.ChartToothAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartTooth>
          }
          groupBy: {
            args: Prisma.ChartToothGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartToothGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartToothCountArgs<ExtArgs>
            result: $Utils.Optional<ChartToothCountAggregateOutputType> | number
          }
        }
      }
      ChartNote: {
        payload: Prisma.$ChartNotePayload<ExtArgs>
        fields: Prisma.ChartNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          findFirst: {
            args: Prisma.ChartNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          findMany: {
            args: Prisma.ChartNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>[]
          }
          create: {
            args: Prisma.ChartNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          createMany: {
            args: Prisma.ChartNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>[]
          }
          delete: {
            args: Prisma.ChartNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          update: {
            args: Prisma.ChartNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          deleteMany: {
            args: Prisma.ChartNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChartNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          aggregate: {
            args: Prisma.ChartNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartNote>
          }
          groupBy: {
            args: Prisma.ChartNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ChartNoteCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      DiagnosisProblem: {
        payload: Prisma.$DiagnosisProblemPayload<ExtArgs>
        fields: Prisma.DiagnosisProblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisProblemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisProblemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisProblemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisProblemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          findMany: {
            args: Prisma.DiagnosisProblemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>[]
          }
          create: {
            args: Prisma.DiagnosisProblemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          createMany: {
            args: Prisma.DiagnosisProblemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisProblemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisProblemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          update: {
            args: Prisma.DiagnosisProblemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisProblemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisProblemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisProblemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisProblemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosisProblem>
          }
          groupBy: {
            args: Prisma.DiagnosisProblemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisProblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisProblemCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisProblemCountAggregateOutputType> | number
          }
        }
      }
      EncounterDiagnosis: {
        payload: Prisma.$EncounterDiagnosisPayload<ExtArgs>
        fields: Prisma.EncounterDiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterDiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterDiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          findFirst: {
            args: Prisma.EncounterDiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterDiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          findMany: {
            args: Prisma.EncounterDiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>[]
          }
          create: {
            args: Prisma.EncounterDiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          createMany: {
            args: Prisma.EncounterDiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterDiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>[]
          }
          delete: {
            args: Prisma.EncounterDiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          update: {
            args: Prisma.EncounterDiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterDiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterDiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          aggregate: {
            args: Prisma.EncounterDiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterDiagnosis>
          }
          groupBy: {
            args: Prisma.EncounterDiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterDiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterDiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterDiagnosisCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceBranch: {
        payload: Prisma.$ServiceBranchPayload<ExtArgs>
        fields: Prisma.ServiceBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          findFirst: {
            args: Prisma.ServiceBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          findMany: {
            args: Prisma.ServiceBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          create: {
            args: Prisma.ServiceBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          createMany: {
            args: Prisma.ServiceBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          delete: {
            args: Prisma.ServiceBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          update: {
            args: Prisma.ServiceBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          deleteMany: {
            args: Prisma.ServiceBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          aggregate: {
            args: Prisma.ServiceBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceBranch>
          }
          groupBy: {
            args: Prisma.ServiceBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceBranchCountAggregateOutputType> | number
          }
        }
      }
      EncounterService: {
        payload: Prisma.$EncounterServicePayload<ExtArgs>
        fields: Prisma.EncounterServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          findFirst: {
            args: Prisma.EncounterServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          findMany: {
            args: Prisma.EncounterServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>[]
          }
          create: {
            args: Prisma.EncounterServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          createMany: {
            args: Prisma.EncounterServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>[]
          }
          delete: {
            args: Prisma.EncounterServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          update: {
            args: Prisma.EncounterServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          deleteMany: {
            args: Prisma.EncounterServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          aggregate: {
            args: Prisma.EncounterServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterService>
          }
          groupBy: {
            args: Prisma.EncounterServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterServiceCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterServiceCountAggregateOutputType> | number
          }
        }
      }
      Procedure: {
        payload: Prisma.$ProcedurePayload<ExtArgs>
        fields: Prisma.ProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findFirst: {
            args: Prisma.ProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findMany: {
            args: Prisma.ProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          create: {
            args: Prisma.ProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          createMany: {
            args: Prisma.ProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          delete: {
            args: Prisma.ProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          update: {
            args: Prisma.ProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          deleteMany: {
            args: Prisma.ProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          aggregate: {
            args: Prisma.ProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedure>
          }
          groupBy: {
            args: Prisma.ProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionItem: {
        payload: Prisma.$PrescriptionItemPayload<ExtArgs>
        fields: Prisma.PrescriptionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findMany: {
            args: Prisma.PrescriptionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          create: {
            args: Prisma.PrescriptionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          createMany: {
            args: Prisma.PrescriptionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          update: {
            args: Prisma.PrescriptionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionItem>
          }
          groupBy: {
            args: Prisma.PrescriptionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionItemCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      EBarimtReceipt: {
        payload: Prisma.$EBarimtReceiptPayload<ExtArgs>
        fields: Prisma.EBarimtReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EBarimtReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EBarimtReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          findFirst: {
            args: Prisma.EBarimtReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EBarimtReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          findMany: {
            args: Prisma.EBarimtReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>[]
          }
          create: {
            args: Prisma.EBarimtReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          createMany: {
            args: Prisma.EBarimtReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EBarimtReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>[]
          }
          delete: {
            args: Prisma.EBarimtReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          update: {
            args: Prisma.EBarimtReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          deleteMany: {
            args: Prisma.EBarimtReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EBarimtReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EBarimtReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          aggregate: {
            args: Prisma.EBarimtReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEBarimtReceipt>
          }
          groupBy: {
            args: Prisma.EBarimtReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<EBarimtReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.EBarimtReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<EBarimtReceiptCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      AuthorizationCode: {
        payload: Prisma.$AuthorizationCodePayload<ExtArgs>
        fields: Prisma.AuthorizationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorizationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          findFirst: {
            args: Prisma.AuthorizationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorizationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          findMany: {
            args: Prisma.AuthorizationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>[]
          }
          create: {
            args: Prisma.AuthorizationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          createMany: {
            args: Prisma.AuthorizationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorizationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>[]
          }
          delete: {
            args: Prisma.AuthorizationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          update: {
            args: Prisma.AuthorizationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          deleteMany: {
            args: Prisma.AuthorizationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorizationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthorizationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          aggregate: {
            args: Prisma.AuthorizationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthorizationCode>
          }
          groupBy: {
            args: Prisma.AuthorizationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorizationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorizationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorizationCodeCountAggregateOutputType> | number
          }
        }
      }
      EmployeeVoucher: {
        payload: Prisma.$EmployeeVoucherPayload<ExtArgs>
        fields: Prisma.EmployeeVoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeVoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeVoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          findFirst: {
            args: Prisma.EmployeeVoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeVoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          findMany: {
            args: Prisma.EmployeeVoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>[]
          }
          create: {
            args: Prisma.EmployeeVoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          createMany: {
            args: Prisma.EmployeeVoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeVoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>[]
          }
          delete: {
            args: Prisma.EmployeeVoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          update: {
            args: Prisma.EmployeeVoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeVoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeVoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeVoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          aggregate: {
            args: Prisma.EmployeeVoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeVoucher>
          }
          groupBy: {
            args: Prisma.EmployeeVoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeVoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeVoucherCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeVoucherCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      DoctorSchedule: {
        payload: Prisma.$DoctorSchedulePayload<ExtArgs>
        fields: Prisma.DoctorScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          findFirst: {
            args: Prisma.DoctorScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          findMany: {
            args: Prisma.DoctorScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          create: {
            args: Prisma.DoctorScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          createMany: {
            args: Prisma.DoctorScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          delete: {
            args: Prisma.DoctorScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          update: {
            args: Prisma.DoctorScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          deleteMany: {
            args: Prisma.DoctorScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          aggregate: {
            args: Prisma.DoctorScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorSchedule>
          }
          groupBy: {
            args: Prisma.DoctorScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorScheduleCountAggregateOutputType> | number
          }
        }
      }
      ReceptionSchedule: {
        payload: Prisma.$ReceptionSchedulePayload<ExtArgs>
        fields: Prisma.ReceptionScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceptionScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceptionScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          findFirst: {
            args: Prisma.ReceptionScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceptionScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          findMany: {
            args: Prisma.ReceptionScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>[]
          }
          create: {
            args: Prisma.ReceptionScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          createMany: {
            args: Prisma.ReceptionScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceptionScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>[]
          }
          delete: {
            args: Prisma.ReceptionScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          update: {
            args: Prisma.ReceptionScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ReceptionScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceptionScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceptionScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          aggregate: {
            args: Prisma.ReceptionScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceptionSchedule>
          }
          groupBy: {
            args: Prisma.ReceptionScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceptionScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceptionScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ReceptionScheduleCountAggregateOutputType> | number
          }
        }
      }
      DoctorBranch: {
        payload: Prisma.$DoctorBranchPayload<ExtArgs>
        fields: Prisma.DoctorBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          findFirst: {
            args: Prisma.DoctorBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          findMany: {
            args: Prisma.DoctorBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>[]
          }
          create: {
            args: Prisma.DoctorBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          createMany: {
            args: Prisma.DoctorBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>[]
          }
          delete: {
            args: Prisma.DoctorBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          update: {
            args: Prisma.DoctorBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          deleteMany: {
            args: Prisma.DoctorBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          aggregate: {
            args: Prisma.DoctorBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorBranch>
          }
          groupBy: {
            args: Prisma.DoctorBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorBranchCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorBranchCountAggregateOutputType> | number
          }
        }
      }
      ReceptionBranch: {
        payload: Prisma.$ReceptionBranchPayload<ExtArgs>
        fields: Prisma.ReceptionBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceptionBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceptionBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          findFirst: {
            args: Prisma.ReceptionBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceptionBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          findMany: {
            args: Prisma.ReceptionBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>[]
          }
          create: {
            args: Prisma.ReceptionBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          createMany: {
            args: Prisma.ReceptionBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceptionBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>[]
          }
          delete: {
            args: Prisma.ReceptionBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          update: {
            args: Prisma.ReceptionBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          deleteMany: {
            args: Prisma.ReceptionBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceptionBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceptionBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          aggregate: {
            args: Prisma.ReceptionBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceptionBranch>
          }
          groupBy: {
            args: Prisma.ReceptionBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceptionBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceptionBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ReceptionBranchCountAggregateOutputType> | number
          }
        }
      }
      NurseBranch: {
        payload: Prisma.$NurseBranchPayload<ExtArgs>
        fields: Prisma.NurseBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NurseBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NurseBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          findFirst: {
            args: Prisma.NurseBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NurseBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          findMany: {
            args: Prisma.NurseBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>[]
          }
          create: {
            args: Prisma.NurseBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          createMany: {
            args: Prisma.NurseBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NurseBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>[]
          }
          delete: {
            args: Prisma.NurseBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          update: {
            args: Prisma.NurseBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          deleteMany: {
            args: Prisma.NurseBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NurseBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NurseBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          aggregate: {
            args: Prisma.NurseBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurseBranch>
          }
          groupBy: {
            args: Prisma.NurseBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.NurseBranchCountArgs<ExtArgs>
            result: $Utils.Optional<NurseBranchCountAggregateOutputType> | number
          }
        }
      }
      NurseSchedule: {
        payload: Prisma.$NurseSchedulePayload<ExtArgs>
        fields: Prisma.NurseScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NurseScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NurseScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          findFirst: {
            args: Prisma.NurseScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NurseScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          findMany: {
            args: Prisma.NurseScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>[]
          }
          create: {
            args: Prisma.NurseScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          createMany: {
            args: Prisma.NurseScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NurseScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>[]
          }
          delete: {
            args: Prisma.NurseScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          update: {
            args: Prisma.NurseScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          deleteMany: {
            args: Prisma.NurseScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NurseScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NurseScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          aggregate: {
            args: Prisma.NurseScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurseSchedule>
          }
          groupBy: {
            args: Prisma.NurseScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NurseScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<NurseScheduleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    users: number
    patients: number
    doctorSchedules: number
    serviceBranches: number
    doctorBranches: number
    appointments: number
    bookings: number
    receptionSchedules: number
    receptionBranches: number
    nurseSchedules: number
    nurseBranches: number
    products: number
    invoices: number
    ledgerEntries: number
    employeeVouchers: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    patients?: boolean | BranchCountOutputTypeCountPatientsArgs
    doctorSchedules?: boolean | BranchCountOutputTypeCountDoctorSchedulesArgs
    serviceBranches?: boolean | BranchCountOutputTypeCountServiceBranchesArgs
    doctorBranches?: boolean | BranchCountOutputTypeCountDoctorBranchesArgs
    appointments?: boolean | BranchCountOutputTypeCountAppointmentsArgs
    bookings?: boolean | BranchCountOutputTypeCountBookingsArgs
    receptionSchedules?: boolean | BranchCountOutputTypeCountReceptionSchedulesArgs
    receptionBranches?: boolean | BranchCountOutputTypeCountReceptionBranchesArgs
    nurseSchedules?: boolean | BranchCountOutputTypeCountNurseSchedulesArgs
    nurseBranches?: boolean | BranchCountOutputTypeCountNurseBranchesArgs
    products?: boolean | BranchCountOutputTypeCountProductsArgs
    invoices?: boolean | BranchCountOutputTypeCountInvoicesArgs
    ledgerEntries?: boolean | BranchCountOutputTypeCountLedgerEntriesArgs
    employeeVouchers?: boolean | BranchCountOutputTypeCountEmployeeVouchersArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDoctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServiceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDoctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountReceptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionScheduleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountReceptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountNurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseScheduleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountNurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
  }


  /**
   * Count Type EmployeeBenefitCountOutputType
   */

  export type EmployeeBenefitCountOutputType = {
    usages: number
  }

  export type EmployeeBenefitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | EmployeeBenefitCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeBenefitCountOutputType without action
   */
  export type EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitCountOutputType
     */
    select?: EmployeeBenefitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeBenefitCountOutputType without action
   */
  export type EmployeeBenefitCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    encounters: number
    nurseEncounters: number
    doctorSchedules: number
    doctorBranches: number
    receptionSchedules: number
    receptionBranches: number
    nurseSchedules: number
    nurseBranches: number
    appointments: number
    bookings: number
    employeeBenefits: number
    createdLedgerEntries: number
    approvedLedgerEntries: number
    employeeVouchers: number
    createdEmployeeVouchers: number
    authorizationCodes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | UserCountOutputTypeCountEncountersArgs
    nurseEncounters?: boolean | UserCountOutputTypeCountNurseEncountersArgs
    doctorSchedules?: boolean | UserCountOutputTypeCountDoctorSchedulesArgs
    doctorBranches?: boolean | UserCountOutputTypeCountDoctorBranchesArgs
    receptionSchedules?: boolean | UserCountOutputTypeCountReceptionSchedulesArgs
    receptionBranches?: boolean | UserCountOutputTypeCountReceptionBranchesArgs
    nurseSchedules?: boolean | UserCountOutputTypeCountNurseSchedulesArgs
    nurseBranches?: boolean | UserCountOutputTypeCountNurseBranchesArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    employeeBenefits?: boolean | UserCountOutputTypeCountEmployeeBenefitsArgs
    createdLedgerEntries?: boolean | UserCountOutputTypeCountCreatedLedgerEntriesArgs
    approvedLedgerEntries?: boolean | UserCountOutputTypeCountApprovedLedgerEntriesArgs
    employeeVouchers?: boolean | UserCountOutputTypeCountEmployeeVouchersArgs
    createdEmployeeVouchers?: boolean | UserCountOutputTypeCountCreatedEmployeeVouchersArgs
    authorizationCodes?: boolean | UserCountOutputTypeCountAuthorizationCodesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNurseEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorBranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionBranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseBranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthorizationCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorizationCodeWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    bookings: number
    invoices: number
    ledgerEntries: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    bookings?: boolean | PatientCountOutputTypeCountBookingsArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    ledgerEntries?: boolean | PatientCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type PatientBookCountOutputType
   */

  export type PatientBookCountOutputType = {
    encounters: number
  }

  export type PatientBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | PatientBookCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * PatientBookCountOutputType without action
   */
  export type PatientBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBookCountOutputType
     */
    select?: PatientBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientBookCountOutputType without action
   */
  export type PatientBookCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    encounters: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | AppointmentCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    chartTeeth: number
    media: number
    encounterServices: number
    diagnoses: number
    consents: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartTeeth?: boolean | EncounterCountOutputTypeCountChartTeethArgs
    media?: boolean | EncounterCountOutputTypeCountMediaArgs
    encounterServices?: boolean | EncounterCountOutputTypeCountEncounterServicesArgs
    diagnoses?: boolean | EncounterCountOutputTypeCountDiagnosesArgs
    consents?: boolean | EncounterCountOutputTypeCountConsentsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountChartTeethArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartToothWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountEncounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterServiceWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountDiagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConsentWhereInput
  }


  /**
   * Count Type ChartToothCountOutputType
   */

  export type ChartToothCountOutputType = {
    chartNotes: number
  }

  export type ChartToothCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartNotes?: boolean | ChartToothCountOutputTypeCountChartNotesArgs
  }

  // Custom InputTypes
  /**
   * ChartToothCountOutputType without action
   */
  export type ChartToothCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartToothCountOutputType
     */
    select?: ChartToothCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChartToothCountOutputType without action
   */
  export type ChartToothCountOutputTypeCountChartNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartNoteWhereInput
  }


  /**
   * Count Type DiagnosisCountOutputType
   */

  export type DiagnosisCountOutputType = {
    problems: number
    encounters: number
  }

  export type DiagnosisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems?: boolean | DiagnosisCountOutputTypeCountProblemsArgs
    encounters?: boolean | DiagnosisCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisCountOutputType
     */
    select?: DiagnosisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeCountProblemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisProblemWhereInput
  }

  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    encounterServices: number
    serviceBranches: number
    invoiceItems: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterServices?: boolean | ServiceCountOutputTypeCountEncounterServicesArgs
    serviceBranches?: boolean | ServiceCountOutputTypeCountServiceBranchesArgs
    invoiceItems?: boolean | ServiceCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountEncounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type ProcedureCountOutputType
   */

  export type ProcedureCountOutputType = {
    invoiceItems: number
  }

  export type ProcedureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | ProcedureCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureCountOutputType
     */
    select?: ProcedureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    invoiceItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | ProductCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    items: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PrescriptionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    ledgerEntries: number
    payments: number
    employeeBenefitUsages: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    ledgerEntries?: boolean | InvoiceCountOutputTypeCountLedgerEntriesArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    employeeBenefitUsages?: boolean | InvoiceCountOutputTypeCountEmployeeBenefitUsagesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountEmployeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
  }


  /**
   * Count Type AuthorizationCodeCountOutputType
   */

  export type AuthorizationCodeCountOutputType = {
    ledgerEntries: number
  }

  export type AuthorizationCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerEntries?: boolean | AuthorizationCodeCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * AuthorizationCodeCountOutputType without action
   */
  export type AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCodeCountOutputType
     */
    select?: AuthorizationCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorizationCodeCountOutputType without action
   */
  export type AuthorizationCodeCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type EmployeeVoucherCountOutputType
   */

  export type EmployeeVoucherCountOutputType = {
    ledgerEntries: number
  }

  export type EmployeeVoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerEntries?: boolean | EmployeeVoucherCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeVoucherCountOutputType without action
   */
  export type EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucherCountOutputType
     */
    select?: EmployeeVoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeVoucherCountOutputType without action
   */
  export type EmployeeVoucherCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    createdAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    createdAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    createdAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    name: string
    address: string | null
    createdAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    doctorSchedules?: boolean | Branch$doctorSchedulesArgs<ExtArgs>
    serviceBranches?: boolean | Branch$serviceBranchesArgs<ExtArgs>
    doctorBranches?: boolean | Branch$doctorBranchesArgs<ExtArgs>
    appointments?: boolean | Branch$appointmentsArgs<ExtArgs>
    bookings?: boolean | Branch$bookingsArgs<ExtArgs>
    receptionSchedules?: boolean | Branch$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | Branch$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | Branch$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | Branch$nurseBranchesArgs<ExtArgs>
    products?: boolean | Branch$productsArgs<ExtArgs>
    invoices?: boolean | Branch$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Branch$ledgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | Branch$employeeVouchersArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    doctorSchedules?: boolean | Branch$doctorSchedulesArgs<ExtArgs>
    serviceBranches?: boolean | Branch$serviceBranchesArgs<ExtArgs>
    doctorBranches?: boolean | Branch$doctorBranchesArgs<ExtArgs>
    appointments?: boolean | Branch$appointmentsArgs<ExtArgs>
    bookings?: boolean | Branch$bookingsArgs<ExtArgs>
    receptionSchedules?: boolean | Branch$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | Branch$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | Branch$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | Branch$nurseBranchesArgs<ExtArgs>
    products?: boolean | Branch$productsArgs<ExtArgs>
    invoices?: boolean | Branch$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Branch$ledgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | Branch$employeeVouchersArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      doctorSchedules: Prisma.$DoctorSchedulePayload<ExtArgs>[]
      serviceBranches: Prisma.$ServiceBranchPayload<ExtArgs>[]
      doctorBranches: Prisma.$DoctorBranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      receptionSchedules: Prisma.$ReceptionSchedulePayload<ExtArgs>[]
      receptionBranches: Prisma.$ReceptionBranchPayload<ExtArgs>[]
      nurseSchedules: Prisma.$NurseSchedulePayload<ExtArgs>[]
      nurseBranches: Prisma.$NurseBranchPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      employeeVouchers: Prisma.$EmployeeVoucherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      createdAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    patients<T extends Branch$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany"> | Null>
    doctorSchedules<T extends Branch$doctorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$doctorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    serviceBranches<T extends Branch$serviceBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$serviceBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany"> | Null>
    doctorBranches<T extends Branch$doctorBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$doctorBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Branch$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Branch$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    receptionSchedules<T extends Branch$receptionSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$receptionSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    receptionBranches<T extends Branch$receptionBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$receptionBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findMany"> | Null>
    nurseSchedules<T extends Branch$nurseSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$nurseSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    nurseBranches<T extends Branch$nurseBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$nurseBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Branch$productsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Branch$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Branch$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    employeeVouchers<T extends Branch$employeeVouchersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$employeeVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.patients
   */
  export type Branch$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Branch.doctorSchedules
   */
  export type Branch$doctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    cursor?: DoctorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * Branch.serviceBranches
   */
  export type Branch$serviceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    cursor?: ServiceBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * Branch.doctorBranches
   */
  export type Branch$doctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    where?: DoctorBranchWhereInput
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    cursor?: DoctorBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * Branch.appointments
   */
  export type Branch$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Branch.bookings
   */
  export type Branch$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Branch.receptionSchedules
   */
  export type Branch$receptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    where?: ReceptionScheduleWhereInput
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    cursor?: ReceptionScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * Branch.receptionBranches
   */
  export type Branch$receptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    where?: ReceptionBranchWhereInput
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    cursor?: ReceptionBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * Branch.nurseSchedules
   */
  export type Branch$nurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    where?: NurseScheduleWhereInput
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    cursor?: NurseScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * Branch.nurseBranches
   */
  export type Branch$nurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    where?: NurseBranchWhereInput
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    cursor?: NurseBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * Branch.products
   */
  export type Branch$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Branch.invoices
   */
  export type Branch$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Branch.ledgerEntries
   */
  export type Branch$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Branch.employeeVouchers
   */
  export type Branch$employeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    cursor?: EmployeeVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeBenefit
   */

  export type AggregateEmployeeBenefit = {
    _count: EmployeeBenefitCountAggregateOutputType | null
    _avg: EmployeeBenefitAvgAggregateOutputType | null
    _sum: EmployeeBenefitSumAggregateOutputType | null
    _min: EmployeeBenefitMinAggregateOutputType | null
    _max: EmployeeBenefitMaxAggregateOutputType | null
  }

  export type EmployeeBenefitAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
  }

  export type EmployeeBenefitSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
  }

  export type EmployeeBenefitMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    code: string | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
    fromDate: Date | null
    toDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeBenefitMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    code: string | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
    fromDate: Date | null
    toDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeBenefitCountAggregateOutputType = {
    id: number
    employeeId: number
    code: number
    branchId: number
    initialAmount: number
    remainingAmount: number
    fromDate: number
    toDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeBenefitAvgAggregateInputType = {
    id?: true
    employeeId?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
  }

  export type EmployeeBenefitSumAggregateInputType = {
    id?: true
    employeeId?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
  }

  export type EmployeeBenefitMinAggregateInputType = {
    id?: true
    employeeId?: true
    code?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
    fromDate?: true
    toDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeBenefitMaxAggregateInputType = {
    id?: true
    employeeId?: true
    code?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
    fromDate?: true
    toDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeBenefitCountAggregateInputType = {
    id?: true
    employeeId?: true
    code?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
    fromDate?: true
    toDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeBenefitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefit to aggregate.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeBenefits
    **/
    _count?: true | EmployeeBenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeBenefitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeBenefitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeBenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeBenefitMaxAggregateInputType
  }

  export type GetEmployeeBenefitAggregateType<T extends EmployeeBenefitAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeBenefit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeBenefit[P]>
      : GetScalarType<T[P], AggregateEmployeeBenefit[P]>
  }




  export type EmployeeBenefitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitWhereInput
    orderBy?: EmployeeBenefitOrderByWithAggregationInput | EmployeeBenefitOrderByWithAggregationInput[]
    by: EmployeeBenefitScalarFieldEnum[] | EmployeeBenefitScalarFieldEnum
    having?: EmployeeBenefitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeBenefitCountAggregateInputType | true
    _avg?: EmployeeBenefitAvgAggregateInputType
    _sum?: EmployeeBenefitSumAggregateInputType
    _min?: EmployeeBenefitMinAggregateInputType
    _max?: EmployeeBenefitMaxAggregateInputType
  }

  export type EmployeeBenefitGroupByOutputType = {
    id: number
    employeeId: number
    code: string
    branchId: number | null
    initialAmount: number
    remainingAmount: number
    fromDate: Date | null
    toDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeeBenefitCountAggregateOutputType | null
    _avg: EmployeeBenefitAvgAggregateOutputType | null
    _sum: EmployeeBenefitSumAggregateOutputType | null
    _min: EmployeeBenefitMinAggregateOutputType | null
    _max: EmployeeBenefitMaxAggregateOutputType | null
  }

  type GetEmployeeBenefitGroupByPayload<T extends EmployeeBenefitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeBenefitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeBenefitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeBenefitGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeBenefitGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeBenefitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    code?: boolean
    branchId?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    fromDate?: boolean
    toDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    usages?: boolean | EmployeeBenefit$usagesArgs<ExtArgs>
    _count?: boolean | EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefit"]>

  export type EmployeeBenefitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    code?: boolean
    branchId?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    fromDate?: boolean
    toDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefit"]>

  export type EmployeeBenefitSelectScalar = {
    id?: boolean
    employeeId?: boolean
    code?: boolean
    branchId?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    fromDate?: boolean
    toDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeBenefitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    usages?: boolean | EmployeeBenefit$usagesArgs<ExtArgs>
    _count?: boolean | EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeBenefitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeBenefitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeBenefit"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      usages: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      code: string
      branchId: number | null
      initialAmount: number
      remainingAmount: number
      fromDate: Date | null
      toDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeBenefit"]>
    composites: {}
  }

  type EmployeeBenefitGetPayload<S extends boolean | null | undefined | EmployeeBenefitDefaultArgs> = $Result.GetResult<Prisma.$EmployeeBenefitPayload, S>

  type EmployeeBenefitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeBenefitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeBenefitCountAggregateInputType | true
    }

  export interface EmployeeBenefitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeBenefit'], meta: { name: 'EmployeeBenefit' } }
    /**
     * Find zero or one EmployeeBenefit that matches the filter.
     * @param {EmployeeBenefitFindUniqueArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeBenefitFindUniqueArgs>(args: SelectSubset<T, EmployeeBenefitFindUniqueArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeBenefit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeBenefitFindUniqueOrThrowArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeBenefitFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeBenefitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeBenefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitFindFirstArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeBenefitFindFirstArgs>(args?: SelectSubset<T, EmployeeBenefitFindFirstArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeBenefit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitFindFirstOrThrowArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeBenefitFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeBenefitFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeBenefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeBenefits
     * const employeeBenefits = await prisma.employeeBenefit.findMany()
     * 
     * // Get first 10 EmployeeBenefits
     * const employeeBenefits = await prisma.employeeBenefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeBenefitWithIdOnly = await prisma.employeeBenefit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeBenefitFindManyArgs>(args?: SelectSubset<T, EmployeeBenefitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeBenefit.
     * @param {EmployeeBenefitCreateArgs} args - Arguments to create a EmployeeBenefit.
     * @example
     * // Create one EmployeeBenefit
     * const EmployeeBenefit = await prisma.employeeBenefit.create({
     *   data: {
     *     // ... data to create a EmployeeBenefit
     *   }
     * })
     * 
     */
    create<T extends EmployeeBenefitCreateArgs>(args: SelectSubset<T, EmployeeBenefitCreateArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeBenefits.
     * @param {EmployeeBenefitCreateManyArgs} args - Arguments to create many EmployeeBenefits.
     * @example
     * // Create many EmployeeBenefits
     * const employeeBenefit = await prisma.employeeBenefit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeBenefitCreateManyArgs>(args?: SelectSubset<T, EmployeeBenefitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeBenefits and returns the data saved in the database.
     * @param {EmployeeBenefitCreateManyAndReturnArgs} args - Arguments to create many EmployeeBenefits.
     * @example
     * // Create many EmployeeBenefits
     * const employeeBenefit = await prisma.employeeBenefit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeBenefits and only return the `id`
     * const employeeBenefitWithIdOnly = await prisma.employeeBenefit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeBenefitCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeBenefitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeBenefit.
     * @param {EmployeeBenefitDeleteArgs} args - Arguments to delete one EmployeeBenefit.
     * @example
     * // Delete one EmployeeBenefit
     * const EmployeeBenefit = await prisma.employeeBenefit.delete({
     *   where: {
     *     // ... filter to delete one EmployeeBenefit
     *   }
     * })
     * 
     */
    delete<T extends EmployeeBenefitDeleteArgs>(args: SelectSubset<T, EmployeeBenefitDeleteArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeBenefit.
     * @param {EmployeeBenefitUpdateArgs} args - Arguments to update one EmployeeBenefit.
     * @example
     * // Update one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeBenefitUpdateArgs>(args: SelectSubset<T, EmployeeBenefitUpdateArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeBenefits.
     * @param {EmployeeBenefitDeleteManyArgs} args - Arguments to filter EmployeeBenefits to delete.
     * @example
     * // Delete a few EmployeeBenefits
     * const { count } = await prisma.employeeBenefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeBenefitDeleteManyArgs>(args?: SelectSubset<T, EmployeeBenefitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeBenefits
     * const employeeBenefit = await prisma.employeeBenefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeBenefitUpdateManyArgs>(args: SelectSubset<T, EmployeeBenefitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeBenefit.
     * @param {EmployeeBenefitUpsertArgs} args - Arguments to update or create a EmployeeBenefit.
     * @example
     * // Update or create a EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.upsert({
     *   create: {
     *     // ... data to create a EmployeeBenefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeBenefit we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeBenefitUpsertArgs>(args: SelectSubset<T, EmployeeBenefitUpsertArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitCountArgs} args - Arguments to filter EmployeeBenefits to count.
     * @example
     * // Count the number of EmployeeBenefits
     * const count = await prisma.employeeBenefit.count({
     *   where: {
     *     // ... the filter for the EmployeeBenefits we want to count
     *   }
     * })
    **/
    count<T extends EmployeeBenefitCountArgs>(
      args?: Subset<T, EmployeeBenefitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeBenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeBenefitAggregateArgs>(args: Subset<T, EmployeeBenefitAggregateArgs>): Prisma.PrismaPromise<GetEmployeeBenefitAggregateType<T>>

    /**
     * Group by EmployeeBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeBenefitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeBenefitGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeBenefitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeBenefitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeBenefitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeBenefit model
   */
  readonly fields: EmployeeBenefitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeBenefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeBenefitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usages<T extends EmployeeBenefit$usagesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeBenefit$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeBenefit model
   */ 
  interface EmployeeBenefitFieldRefs {
    readonly id: FieldRef<"EmployeeBenefit", 'Int'>
    readonly employeeId: FieldRef<"EmployeeBenefit", 'Int'>
    readonly code: FieldRef<"EmployeeBenefit", 'String'>
    readonly branchId: FieldRef<"EmployeeBenefit", 'Int'>
    readonly initialAmount: FieldRef<"EmployeeBenefit", 'Int'>
    readonly remainingAmount: FieldRef<"EmployeeBenefit", 'Int'>
    readonly fromDate: FieldRef<"EmployeeBenefit", 'DateTime'>
    readonly toDate: FieldRef<"EmployeeBenefit", 'DateTime'>
    readonly isActive: FieldRef<"EmployeeBenefit", 'Boolean'>
    readonly createdAt: FieldRef<"EmployeeBenefit", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeBenefit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeBenefit findUnique
   */
  export type EmployeeBenefitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit findUniqueOrThrow
   */
  export type EmployeeBenefitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit findFirst
   */
  export type EmployeeBenefitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefits.
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefits.
     */
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit findFirstOrThrow
   */
  export type EmployeeBenefitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefits.
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefits.
     */
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit findMany
   */
  export type EmployeeBenefitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefits to fetch.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeBenefits.
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit create
   */
  export type EmployeeBenefitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeBenefit.
     */
    data: XOR<EmployeeBenefitCreateInput, EmployeeBenefitUncheckedCreateInput>
  }

  /**
   * EmployeeBenefit createMany
   */
  export type EmployeeBenefitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeBenefits.
     */
    data: EmployeeBenefitCreateManyInput | EmployeeBenefitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeBenefit createManyAndReturn
   */
  export type EmployeeBenefitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeBenefits.
     */
    data: EmployeeBenefitCreateManyInput | EmployeeBenefitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeBenefit update
   */
  export type EmployeeBenefitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeBenefit.
     */
    data: XOR<EmployeeBenefitUpdateInput, EmployeeBenefitUncheckedUpdateInput>
    /**
     * Choose, which EmployeeBenefit to update.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit updateMany
   */
  export type EmployeeBenefitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeBenefits.
     */
    data: XOR<EmployeeBenefitUpdateManyMutationInput, EmployeeBenefitUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeBenefits to update
     */
    where?: EmployeeBenefitWhereInput
  }

  /**
   * EmployeeBenefit upsert
   */
  export type EmployeeBenefitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeBenefit to update in case it exists.
     */
    where: EmployeeBenefitWhereUniqueInput
    /**
     * In case the EmployeeBenefit found by the `where` argument doesn't exist, create a new EmployeeBenefit with this data.
     */
    create: XOR<EmployeeBenefitCreateInput, EmployeeBenefitUncheckedCreateInput>
    /**
     * In case the EmployeeBenefit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeBenefitUpdateInput, EmployeeBenefitUncheckedUpdateInput>
  }

  /**
   * EmployeeBenefit delete
   */
  export type EmployeeBenefitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter which EmployeeBenefit to delete.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit deleteMany
   */
  export type EmployeeBenefitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefits to delete
     */
    where?: EmployeeBenefitWhereInput
  }

  /**
   * EmployeeBenefit.usages
   */
  export type EmployeeBenefit$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit without action
   */
  export type EmployeeBenefitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeBenefitUsage
   */

  export type AggregateEmployeeBenefitUsage = {
    _count: EmployeeBenefitUsageCountAggregateOutputType | null
    _avg: EmployeeBenefitUsageAvgAggregateOutputType | null
    _sum: EmployeeBenefitUsageSumAggregateOutputType | null
    _min: EmployeeBenefitUsageMinAggregateOutputType | null
    _max: EmployeeBenefitUsageMaxAggregateOutputType | null
  }

  export type EmployeeBenefitUsageAvgAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
  }

  export type EmployeeBenefitUsageSumAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
  }

  export type EmployeeBenefitUsageMinAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
    createdAt: Date | null
  }

  export type EmployeeBenefitUsageMaxAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
    createdAt: Date | null
  }

  export type EmployeeBenefitUsageCountAggregateOutputType = {
    id: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt: number
    _all: number
  }


  export type EmployeeBenefitUsageAvgAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
  }

  export type EmployeeBenefitUsageSumAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
  }

  export type EmployeeBenefitUsageMinAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
    createdAt?: true
  }

  export type EmployeeBenefitUsageMaxAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
    createdAt?: true
  }

  export type EmployeeBenefitUsageCountAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
    createdAt?: true
    _all?: true
  }

  export type EmployeeBenefitUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefitUsage to aggregate.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeBenefitUsages
    **/
    _count?: true | EmployeeBenefitUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeBenefitUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeBenefitUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeBenefitUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeBenefitUsageMaxAggregateInputType
  }

  export type GetEmployeeBenefitUsageAggregateType<T extends EmployeeBenefitUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeBenefitUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeBenefitUsage[P]>
      : GetScalarType<T[P], AggregateEmployeeBenefitUsage[P]>
  }




  export type EmployeeBenefitUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithAggregationInput | EmployeeBenefitUsageOrderByWithAggregationInput[]
    by: EmployeeBenefitUsageScalarFieldEnum[] | EmployeeBenefitUsageScalarFieldEnum
    having?: EmployeeBenefitUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeBenefitUsageCountAggregateInputType | true
    _avg?: EmployeeBenefitUsageAvgAggregateInputType
    _sum?: EmployeeBenefitUsageSumAggregateInputType
    _min?: EmployeeBenefitUsageMinAggregateInputType
    _max?: EmployeeBenefitUsageMaxAggregateInputType
  }

  export type EmployeeBenefitUsageGroupByOutputType = {
    id: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt: Date
    _count: EmployeeBenefitUsageCountAggregateOutputType | null
    _avg: EmployeeBenefitUsageAvgAggregateOutputType | null
    _sum: EmployeeBenefitUsageSumAggregateOutputType | null
    _min: EmployeeBenefitUsageMinAggregateOutputType | null
    _max: EmployeeBenefitUsageMaxAggregateOutputType | null
  }

  type GetEmployeeBenefitUsageGroupByPayload<T extends EmployeeBenefitUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeBenefitUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeBenefitUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeBenefitUsageGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeBenefitUsageGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeBenefitUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeBenefitId?: boolean
    invoiceId?: boolean
    encounterId?: boolean
    amountUsed?: boolean
    patientId?: boolean
    createdAt?: boolean
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefitUsage"]>

  export type EmployeeBenefitUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeBenefitId?: boolean
    invoiceId?: boolean
    encounterId?: boolean
    amountUsed?: boolean
    patientId?: boolean
    createdAt?: boolean
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefitUsage"]>

  export type EmployeeBenefitUsageSelectScalar = {
    id?: boolean
    employeeBenefitId?: boolean
    invoiceId?: boolean
    encounterId?: boolean
    amountUsed?: boolean
    patientId?: boolean
    createdAt?: boolean
  }

  export type EmployeeBenefitUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type EmployeeBenefitUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $EmployeeBenefitUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeBenefitUsage"
    objects: {
      employeeBenefit: Prisma.$EmployeeBenefitPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeBenefitId: number
      invoiceId: number
      encounterId: number
      amountUsed: number
      patientId: number
      createdAt: Date
    }, ExtArgs["result"]["employeeBenefitUsage"]>
    composites: {}
  }

  type EmployeeBenefitUsageGetPayload<S extends boolean | null | undefined | EmployeeBenefitUsageDefaultArgs> = $Result.GetResult<Prisma.$EmployeeBenefitUsagePayload, S>

  type EmployeeBenefitUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeBenefitUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeBenefitUsageCountAggregateInputType | true
    }

  export interface EmployeeBenefitUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeBenefitUsage'], meta: { name: 'EmployeeBenefitUsage' } }
    /**
     * Find zero or one EmployeeBenefitUsage that matches the filter.
     * @param {EmployeeBenefitUsageFindUniqueArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeBenefitUsageFindUniqueArgs>(args: SelectSubset<T, EmployeeBenefitUsageFindUniqueArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeBenefitUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeBenefitUsageFindUniqueOrThrowArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeBenefitUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeBenefitUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeBenefitUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageFindFirstArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeBenefitUsageFindFirstArgs>(args?: SelectSubset<T, EmployeeBenefitUsageFindFirstArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeBenefitUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageFindFirstOrThrowArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeBenefitUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeBenefitUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeBenefitUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeBenefitUsages
     * const employeeBenefitUsages = await prisma.employeeBenefitUsage.findMany()
     * 
     * // Get first 10 EmployeeBenefitUsages
     * const employeeBenefitUsages = await prisma.employeeBenefitUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeBenefitUsageWithIdOnly = await prisma.employeeBenefitUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeBenefitUsageFindManyArgs>(args?: SelectSubset<T, EmployeeBenefitUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageCreateArgs} args - Arguments to create a EmployeeBenefitUsage.
     * @example
     * // Create one EmployeeBenefitUsage
     * const EmployeeBenefitUsage = await prisma.employeeBenefitUsage.create({
     *   data: {
     *     // ... data to create a EmployeeBenefitUsage
     *   }
     * })
     * 
     */
    create<T extends EmployeeBenefitUsageCreateArgs>(args: SelectSubset<T, EmployeeBenefitUsageCreateArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeBenefitUsages.
     * @param {EmployeeBenefitUsageCreateManyArgs} args - Arguments to create many EmployeeBenefitUsages.
     * @example
     * // Create many EmployeeBenefitUsages
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeBenefitUsageCreateManyArgs>(args?: SelectSubset<T, EmployeeBenefitUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeBenefitUsages and returns the data saved in the database.
     * @param {EmployeeBenefitUsageCreateManyAndReturnArgs} args - Arguments to create many EmployeeBenefitUsages.
     * @example
     * // Create many EmployeeBenefitUsages
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeBenefitUsages and only return the `id`
     * const employeeBenefitUsageWithIdOnly = await prisma.employeeBenefitUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeBenefitUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeBenefitUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageDeleteArgs} args - Arguments to delete one EmployeeBenefitUsage.
     * @example
     * // Delete one EmployeeBenefitUsage
     * const EmployeeBenefitUsage = await prisma.employeeBenefitUsage.delete({
     *   where: {
     *     // ... filter to delete one EmployeeBenefitUsage
     *   }
     * })
     * 
     */
    delete<T extends EmployeeBenefitUsageDeleteArgs>(args: SelectSubset<T, EmployeeBenefitUsageDeleteArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageUpdateArgs} args - Arguments to update one EmployeeBenefitUsage.
     * @example
     * // Update one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeBenefitUsageUpdateArgs>(args: SelectSubset<T, EmployeeBenefitUsageUpdateArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeBenefitUsages.
     * @param {EmployeeBenefitUsageDeleteManyArgs} args - Arguments to filter EmployeeBenefitUsages to delete.
     * @example
     * // Delete a few EmployeeBenefitUsages
     * const { count } = await prisma.employeeBenefitUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeBenefitUsageDeleteManyArgs>(args?: SelectSubset<T, EmployeeBenefitUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeBenefitUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeBenefitUsages
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeBenefitUsageUpdateManyArgs>(args: SelectSubset<T, EmployeeBenefitUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageUpsertArgs} args - Arguments to update or create a EmployeeBenefitUsage.
     * @example
     * // Update or create a EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.upsert({
     *   create: {
     *     // ... data to create a EmployeeBenefitUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeBenefitUsage we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeBenefitUsageUpsertArgs>(args: SelectSubset<T, EmployeeBenefitUsageUpsertArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeBenefitUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageCountArgs} args - Arguments to filter EmployeeBenefitUsages to count.
     * @example
     * // Count the number of EmployeeBenefitUsages
     * const count = await prisma.employeeBenefitUsage.count({
     *   where: {
     *     // ... the filter for the EmployeeBenefitUsages we want to count
     *   }
     * })
    **/
    count<T extends EmployeeBenefitUsageCountArgs>(
      args?: Subset<T, EmployeeBenefitUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeBenefitUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeBenefitUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeBenefitUsageAggregateArgs>(args: Subset<T, EmployeeBenefitUsageAggregateArgs>): Prisma.PrismaPromise<GetEmployeeBenefitUsageAggregateType<T>>

    /**
     * Group by EmployeeBenefitUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeBenefitUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeBenefitUsageGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeBenefitUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeBenefitUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeBenefitUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeBenefitUsage model
   */
  readonly fields: EmployeeBenefitUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeBenefitUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeBenefitUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeBenefit<T extends EmployeeBenefitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeBenefitDefaultArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeBenefitUsage model
   */ 
  interface EmployeeBenefitUsageFieldRefs {
    readonly id: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly employeeBenefitId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly invoiceId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly encounterId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly amountUsed: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly patientId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly createdAt: FieldRef<"EmployeeBenefitUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeBenefitUsage findUnique
   */
  export type EmployeeBenefitUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage findUniqueOrThrow
   */
  export type EmployeeBenefitUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage findFirst
   */
  export type EmployeeBenefitUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefitUsages.
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefitUsages.
     */
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefitUsage findFirstOrThrow
   */
  export type EmployeeBenefitUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefitUsages.
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefitUsages.
     */
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefitUsage findMany
   */
  export type EmployeeBenefitUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsages to fetch.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeBenefitUsages.
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefitUsage create
   */
  export type EmployeeBenefitUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeBenefitUsage.
     */
    data: XOR<EmployeeBenefitUsageCreateInput, EmployeeBenefitUsageUncheckedCreateInput>
  }

  /**
   * EmployeeBenefitUsage createMany
   */
  export type EmployeeBenefitUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeBenefitUsages.
     */
    data: EmployeeBenefitUsageCreateManyInput | EmployeeBenefitUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeBenefitUsage createManyAndReturn
   */
  export type EmployeeBenefitUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeBenefitUsages.
     */
    data: EmployeeBenefitUsageCreateManyInput | EmployeeBenefitUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeBenefitUsage update
   */
  export type EmployeeBenefitUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeBenefitUsage.
     */
    data: XOR<EmployeeBenefitUsageUpdateInput, EmployeeBenefitUsageUncheckedUpdateInput>
    /**
     * Choose, which EmployeeBenefitUsage to update.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage updateMany
   */
  export type EmployeeBenefitUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeBenefitUsages.
     */
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeBenefitUsages to update
     */
    where?: EmployeeBenefitUsageWhereInput
  }

  /**
   * EmployeeBenefitUsage upsert
   */
  export type EmployeeBenefitUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeBenefitUsage to update in case it exists.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
    /**
     * In case the EmployeeBenefitUsage found by the `where` argument doesn't exist, create a new EmployeeBenefitUsage with this data.
     */
    create: XOR<EmployeeBenefitUsageCreateInput, EmployeeBenefitUsageUncheckedCreateInput>
    /**
     * In case the EmployeeBenefitUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeBenefitUsageUpdateInput, EmployeeBenefitUsageUncheckedUpdateInput>
  }

  /**
   * EmployeeBenefitUsage delete
   */
  export type EmployeeBenefitUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter which EmployeeBenefitUsage to delete.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage deleteMany
   */
  export type EmployeeBenefitUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefitUsages to delete
     */
    where?: EmployeeBenefitUsageWhereInput
  }

  /**
   * EmployeeBenefitUsage without action
   */
  export type EmployeeBenefitUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    calendarOrder: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    calendarOrder: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    ovog: string | null
    name: string | null
    role: $Enums.UserRole | null
    branchId: number | null
    createdAt: Date | null
    phone: string | null
    regNo: string | null
    licenseNumber: string | null
    licenseExpiryDate: Date | null
    signatureImagePath: string | null
    stampImagePath: string | null
    idPhotoPath: string | null
    calendarOrder: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    ovog: string | null
    name: string | null
    role: $Enums.UserRole | null
    branchId: number | null
    createdAt: Date | null
    phone: string | null
    regNo: string | null
    licenseNumber: string | null
    licenseExpiryDate: Date | null
    signatureImagePath: string | null
    stampImagePath: string | null
    idPhotoPath: string | null
    calendarOrder: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    ovog: number
    name: number
    role: number
    branchId: number
    createdAt: number
    phone: number
    regNo: number
    licenseNumber: number
    licenseExpiryDate: number
    signatureImagePath: number
    stampImagePath: number
    idPhotoPath: number
    calendarOrder: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    branchId?: true
    calendarOrder?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    branchId?: true
    calendarOrder?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    ovog?: true
    name?: true
    role?: true
    branchId?: true
    createdAt?: true
    phone?: true
    regNo?: true
    licenseNumber?: true
    licenseExpiryDate?: true
    signatureImagePath?: true
    stampImagePath?: true
    idPhotoPath?: true
    calendarOrder?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    ovog?: true
    name?: true
    role?: true
    branchId?: true
    createdAt?: true
    phone?: true
    regNo?: true
    licenseNumber?: true
    licenseExpiryDate?: true
    signatureImagePath?: true
    stampImagePath?: true
    idPhotoPath?: true
    calendarOrder?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    ovog?: true
    name?: true
    role?: true
    branchId?: true
    createdAt?: true
    phone?: true
    regNo?: true
    licenseNumber?: true
    licenseExpiryDate?: true
    signatureImagePath?: true
    stampImagePath?: true
    idPhotoPath?: true
    calendarOrder?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    ovog: string | null
    name: string | null
    role: $Enums.UserRole
    branchId: number | null
    createdAt: Date
    phone: string | null
    regNo: string | null
    licenseNumber: string | null
    licenseExpiryDate: Date | null
    signatureImagePath: string | null
    stampImagePath: string | null
    idPhotoPath: string | null
    calendarOrder: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    ovog?: boolean
    name?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    phone?: boolean
    regNo?: boolean
    licenseNumber?: boolean
    licenseExpiryDate?: boolean
    signatureImagePath?: boolean
    stampImagePath?: boolean
    idPhotoPath?: boolean
    calendarOrder?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    encounters?: boolean | User$encountersArgs<ExtArgs>
    nurseEncounters?: boolean | User$nurseEncountersArgs<ExtArgs>
    doctorSchedules?: boolean | User$doctorSchedulesArgs<ExtArgs>
    doctorBranches?: boolean | User$doctorBranchesArgs<ExtArgs>
    receptionSchedules?: boolean | User$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | User$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | User$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | User$nurseBranchesArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    employeeBenefits?: boolean | User$employeeBenefitsArgs<ExtArgs>
    createdLedgerEntries?: boolean | User$createdLedgerEntriesArgs<ExtArgs>
    approvedLedgerEntries?: boolean | User$approvedLedgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | User$employeeVouchersArgs<ExtArgs>
    createdEmployeeVouchers?: boolean | User$createdEmployeeVouchersArgs<ExtArgs>
    authorizationCodes?: boolean | User$authorizationCodesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    ovog?: boolean
    name?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    phone?: boolean
    regNo?: boolean
    licenseNumber?: boolean
    licenseExpiryDate?: boolean
    signatureImagePath?: boolean
    stampImagePath?: boolean
    idPhotoPath?: boolean
    calendarOrder?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    ovog?: boolean
    name?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    phone?: boolean
    regNo?: boolean
    licenseNumber?: boolean
    licenseExpiryDate?: boolean
    signatureImagePath?: boolean
    stampImagePath?: boolean
    idPhotoPath?: boolean
    calendarOrder?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    encounters?: boolean | User$encountersArgs<ExtArgs>
    nurseEncounters?: boolean | User$nurseEncountersArgs<ExtArgs>
    doctorSchedules?: boolean | User$doctorSchedulesArgs<ExtArgs>
    doctorBranches?: boolean | User$doctorBranchesArgs<ExtArgs>
    receptionSchedules?: boolean | User$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | User$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | User$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | User$nurseBranchesArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    employeeBenefits?: boolean | User$employeeBenefitsArgs<ExtArgs>
    createdLedgerEntries?: boolean | User$createdLedgerEntriesArgs<ExtArgs>
    approvedLedgerEntries?: boolean | User$approvedLedgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | User$employeeVouchersArgs<ExtArgs>
    createdEmployeeVouchers?: boolean | User$createdEmployeeVouchersArgs<ExtArgs>
    authorizationCodes?: boolean | User$authorizationCodesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      nurseEncounters: Prisma.$EncounterPayload<ExtArgs>[]
      doctorSchedules: Prisma.$DoctorSchedulePayload<ExtArgs>[]
      doctorBranches: Prisma.$DoctorBranchPayload<ExtArgs>[]
      receptionSchedules: Prisma.$ReceptionSchedulePayload<ExtArgs>[]
      receptionBranches: Prisma.$ReceptionBranchPayload<ExtArgs>[]
      nurseSchedules: Prisma.$NurseSchedulePayload<ExtArgs>[]
      nurseBranches: Prisma.$NurseBranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      employeeBenefits: Prisma.$EmployeeBenefitPayload<ExtArgs>[]
      createdLedgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      approvedLedgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      employeeVouchers: Prisma.$EmployeeVoucherPayload<ExtArgs>[]
      createdEmployeeVouchers: Prisma.$EmployeeVoucherPayload<ExtArgs>[]
      authorizationCodes: Prisma.$AuthorizationCodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      ovog: string | null
      name: string | null
      role: $Enums.UserRole
      branchId: number | null
      createdAt: Date
      phone: string | null
      regNo: string | null
      licenseNumber: string | null
      licenseExpiryDate: Date | null
      signatureImagePath: string | null
      stampImagePath: string | null
      idPhotoPath: string | null
      calendarOrder: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    encounters<T extends User$encountersArgs<ExtArgs> = {}>(args?: Subset<T, User$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    nurseEncounters<T extends User$nurseEncountersArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseEncountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    doctorSchedules<T extends User$doctorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    doctorBranches<T extends User$doctorBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findMany"> | Null>
    receptionSchedules<T extends User$receptionSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$receptionSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    receptionBranches<T extends User$receptionBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$receptionBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findMany"> | Null>
    nurseSchedules<T extends User$nurseSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    nurseBranches<T extends User$nurseBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    employeeBenefits<T extends User$employeeBenefitsArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeBenefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findMany"> | Null>
    createdLedgerEntries<T extends User$createdLedgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLedgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    approvedLedgerEntries<T extends User$approvedLedgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedLedgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    employeeVouchers<T extends User$employeeVouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    createdEmployeeVouchers<T extends User$createdEmployeeVouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdEmployeeVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    authorizationCodes<T extends User$authorizationCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$authorizationCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly ovog: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly branchId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly regNo: FieldRef<"User", 'String'>
    readonly licenseNumber: FieldRef<"User", 'String'>
    readonly licenseExpiryDate: FieldRef<"User", 'DateTime'>
    readonly signatureImagePath: FieldRef<"User", 'String'>
    readonly stampImagePath: FieldRef<"User", 'String'>
    readonly idPhotoPath: FieldRef<"User", 'String'>
    readonly calendarOrder: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.encounters
   */
  export type User$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * User.nurseEncounters
   */
  export type User$nurseEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * User.doctorSchedules
   */
  export type User$doctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    cursor?: DoctorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * User.doctorBranches
   */
  export type User$doctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    where?: DoctorBranchWhereInput
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    cursor?: DoctorBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * User.receptionSchedules
   */
  export type User$receptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    where?: ReceptionScheduleWhereInput
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    cursor?: ReceptionScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * User.receptionBranches
   */
  export type User$receptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    where?: ReceptionBranchWhereInput
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    cursor?: ReceptionBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * User.nurseSchedules
   */
  export type User$nurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    where?: NurseScheduleWhereInput
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    cursor?: NurseScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * User.nurseBranches
   */
  export type User$nurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    where?: NurseBranchWhereInput
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    cursor?: NurseBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.employeeBenefits
   */
  export type User$employeeBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    where?: EmployeeBenefitWhereInput
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    cursor?: EmployeeBenefitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * User.createdLedgerEntries
   */
  export type User$createdLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * User.approvedLedgerEntries
   */
  export type User$approvedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * User.employeeVouchers
   */
  export type User$employeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    cursor?: EmployeeVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * User.createdEmployeeVouchers
   */
  export type User$createdEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    cursor?: EmployeeVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * User.authorizationCodes
   */
  export type User$authorizationCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    where?: AuthorizationCodeWhereInput
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    cursor?: AuthorizationCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    regNo: string | null
    ovog: string | null
    name: string | null
    gender: string | null
    birthDate: Date | null
    phone: string | null
    address: string | null
    bloodType: string | null
    citizenship: string | null
    emergencyPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    branchId: number | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    regNo: string | null
    ovog: string | null
    name: string | null
    gender: string | null
    birthDate: Date | null
    phone: string | null
    address: string | null
    bloodType: string | null
    citizenship: string | null
    emergencyPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    branchId: number | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    regNo: number
    ovog: number
    name: number
    gender: number
    birthDate: number
    phone: number
    address: number
    bloodType: number
    citizenship: number
    emergencyPhone: number
    notes: number
    createdAt: number
    updatedAt: number
    branchId: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    regNo?: true
    ovog?: true
    name?: true
    gender?: true
    birthDate?: true
    phone?: true
    address?: true
    bloodType?: true
    citizenship?: true
    emergencyPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    regNo?: true
    ovog?: true
    name?: true
    gender?: true
    birthDate?: true
    phone?: true
    address?: true
    bloodType?: true
    citizenship?: true
    emergencyPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    regNo?: true
    ovog?: true
    name?: true
    gender?: true
    birthDate?: true
    phone?: true
    address?: true
    bloodType?: true
    citizenship?: true
    emergencyPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    regNo: string | null
    ovog: string | null
    name: string
    gender: string | null
    birthDate: Date | null
    phone: string | null
    address: string | null
    bloodType: string | null
    citizenship: string | null
    emergencyPhone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    branchId: number
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    ovog?: boolean
    name?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    address?: boolean
    bloodType?: boolean
    citizenship?: boolean
    emergencyPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patientBook?: boolean | Patient$patientBookArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    bookings?: boolean | Patient$bookingsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Patient$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    ovog?: boolean
    name?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    address?: boolean
    bloodType?: boolean
    citizenship?: boolean
    emergencyPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    regNo?: boolean
    ovog?: boolean
    name?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    address?: boolean
    bloodType?: boolean
    citizenship?: boolean
    emergencyPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patientBook?: boolean | Patient$patientBookArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    bookings?: boolean | Patient$bookingsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Patient$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patientBook: Prisma.$PatientBookPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regNo: string | null
      ovog: string | null
      name: string
      gender: string | null
      birthDate: Date | null
      phone: string | null
      address: string | null
      bloodType: string | null
      citizenship: string | null
      emergencyPhone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      branchId: number
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patientBook<T extends Patient$patientBookArgs<ExtArgs> = {}>(args?: Subset<T, Patient$patientBookArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Patient$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Patient$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly regNo: FieldRef<"Patient", 'String'>
    readonly ovog: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly bloodType: FieldRef<"Patient", 'String'>
    readonly citizenship: FieldRef<"Patient", 'String'>
    readonly emergencyPhone: FieldRef<"Patient", 'String'>
    readonly notes: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly branchId: FieldRef<"Patient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.patientBook
   */
  export type Patient$patientBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    where?: PatientBookWhereInput
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.bookings
   */
  export type Patient$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.ledgerEntries
   */
  export type Patient$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model PatientBook
   */

  export type AggregatePatientBook = {
    _count: PatientBookCountAggregateOutputType | null
    _avg: PatientBookAvgAggregateOutputType | null
    _sum: PatientBookSumAggregateOutputType | null
    _min: PatientBookMinAggregateOutputType | null
    _max: PatientBookMaxAggregateOutputType | null
  }

  export type PatientBookAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
  }

  export type PatientBookSumAggregateOutputType = {
    id: number | null
    patientId: number | null
  }

  export type PatientBookMinAggregateOutputType = {
    id: number | null
    bookNumber: string | null
    patientId: number | null
  }

  export type PatientBookMaxAggregateOutputType = {
    id: number | null
    bookNumber: string | null
    patientId: number | null
  }

  export type PatientBookCountAggregateOutputType = {
    id: number
    bookNumber: number
    patientId: number
    _all: number
  }


  export type PatientBookAvgAggregateInputType = {
    id?: true
    patientId?: true
  }

  export type PatientBookSumAggregateInputType = {
    id?: true
    patientId?: true
  }

  export type PatientBookMinAggregateInputType = {
    id?: true
    bookNumber?: true
    patientId?: true
  }

  export type PatientBookMaxAggregateInputType = {
    id?: true
    bookNumber?: true
    patientId?: true
  }

  export type PatientBookCountAggregateInputType = {
    id?: true
    bookNumber?: true
    patientId?: true
    _all?: true
  }

  export type PatientBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientBook to aggregate.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientBooks
    **/
    _count?: true | PatientBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientBookMaxAggregateInputType
  }

  export type GetPatientBookAggregateType<T extends PatientBookAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientBook[P]>
      : GetScalarType<T[P], AggregatePatientBook[P]>
  }




  export type PatientBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientBookWhereInput
    orderBy?: PatientBookOrderByWithAggregationInput | PatientBookOrderByWithAggregationInput[]
    by: PatientBookScalarFieldEnum[] | PatientBookScalarFieldEnum
    having?: PatientBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientBookCountAggregateInputType | true
    _avg?: PatientBookAvgAggregateInputType
    _sum?: PatientBookSumAggregateInputType
    _min?: PatientBookMinAggregateInputType
    _max?: PatientBookMaxAggregateInputType
  }

  export type PatientBookGroupByOutputType = {
    id: number
    bookNumber: string
    patientId: number
    _count: PatientBookCountAggregateOutputType | null
    _avg: PatientBookAvgAggregateOutputType | null
    _sum: PatientBookSumAggregateOutputType | null
    _min: PatientBookMinAggregateOutputType | null
    _max: PatientBookMaxAggregateOutputType | null
  }

  type GetPatientBookGroupByPayload<T extends PatientBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientBookGroupByOutputType[P]>
            : GetScalarType<T[P], PatientBookGroupByOutputType[P]>
        }
      >
    >


  export type PatientBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookNumber?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    encounters?: boolean | PatientBook$encountersArgs<ExtArgs>
    visitCard?: boolean | PatientBook$visitCardArgs<ExtArgs>
    orthoCard?: boolean | PatientBook$orthoCardArgs<ExtArgs>
    _count?: boolean | PatientBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBook"]>

  export type PatientBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookNumber?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBook"]>

  export type PatientBookSelectScalar = {
    id?: boolean
    bookNumber?: boolean
    patientId?: boolean
  }

  export type PatientBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    encounters?: boolean | PatientBook$encountersArgs<ExtArgs>
    visitCard?: boolean | PatientBook$visitCardArgs<ExtArgs>
    orthoCard?: boolean | PatientBook$orthoCardArgs<ExtArgs>
    _count?: boolean | PatientBookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PatientBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientBook"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      visitCard: Prisma.$VisitCardPayload<ExtArgs> | null
      orthoCard: Prisma.$OrthoCardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookNumber: string
      patientId: number
    }, ExtArgs["result"]["patientBook"]>
    composites: {}
  }

  type PatientBookGetPayload<S extends boolean | null | undefined | PatientBookDefaultArgs> = $Result.GetResult<Prisma.$PatientBookPayload, S>

  type PatientBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientBookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientBookCountAggregateInputType | true
    }

  export interface PatientBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientBook'], meta: { name: 'PatientBook' } }
    /**
     * Find zero or one PatientBook that matches the filter.
     * @param {PatientBookFindUniqueArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientBookFindUniqueArgs>(args: SelectSubset<T, PatientBookFindUniqueArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientBook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientBookFindUniqueOrThrowArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientBookFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookFindFirstArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientBookFindFirstArgs>(args?: SelectSubset<T, PatientBookFindFirstArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookFindFirstOrThrowArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientBookFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientBooks
     * const patientBooks = await prisma.patientBook.findMany()
     * 
     * // Get first 10 PatientBooks
     * const patientBooks = await prisma.patientBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientBookWithIdOnly = await prisma.patientBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientBookFindManyArgs>(args?: SelectSubset<T, PatientBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientBook.
     * @param {PatientBookCreateArgs} args - Arguments to create a PatientBook.
     * @example
     * // Create one PatientBook
     * const PatientBook = await prisma.patientBook.create({
     *   data: {
     *     // ... data to create a PatientBook
     *   }
     * })
     * 
     */
    create<T extends PatientBookCreateArgs>(args: SelectSubset<T, PatientBookCreateArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientBooks.
     * @param {PatientBookCreateManyArgs} args - Arguments to create many PatientBooks.
     * @example
     * // Create many PatientBooks
     * const patientBook = await prisma.patientBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientBookCreateManyArgs>(args?: SelectSubset<T, PatientBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientBooks and returns the data saved in the database.
     * @param {PatientBookCreateManyAndReturnArgs} args - Arguments to create many PatientBooks.
     * @example
     * // Create many PatientBooks
     * const patientBook = await prisma.patientBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientBooks and only return the `id`
     * const patientBookWithIdOnly = await prisma.patientBook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientBookCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientBook.
     * @param {PatientBookDeleteArgs} args - Arguments to delete one PatientBook.
     * @example
     * // Delete one PatientBook
     * const PatientBook = await prisma.patientBook.delete({
     *   where: {
     *     // ... filter to delete one PatientBook
     *   }
     * })
     * 
     */
    delete<T extends PatientBookDeleteArgs>(args: SelectSubset<T, PatientBookDeleteArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientBook.
     * @param {PatientBookUpdateArgs} args - Arguments to update one PatientBook.
     * @example
     * // Update one PatientBook
     * const patientBook = await prisma.patientBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientBookUpdateArgs>(args: SelectSubset<T, PatientBookUpdateArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientBooks.
     * @param {PatientBookDeleteManyArgs} args - Arguments to filter PatientBooks to delete.
     * @example
     * // Delete a few PatientBooks
     * const { count } = await prisma.patientBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientBookDeleteManyArgs>(args?: SelectSubset<T, PatientBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientBooks
     * const patientBook = await prisma.patientBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientBookUpdateManyArgs>(args: SelectSubset<T, PatientBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientBook.
     * @param {PatientBookUpsertArgs} args - Arguments to update or create a PatientBook.
     * @example
     * // Update or create a PatientBook
     * const patientBook = await prisma.patientBook.upsert({
     *   create: {
     *     // ... data to create a PatientBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientBook we want to update
     *   }
     * })
     */
    upsert<T extends PatientBookUpsertArgs>(args: SelectSubset<T, PatientBookUpsertArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookCountArgs} args - Arguments to filter PatientBooks to count.
     * @example
     * // Count the number of PatientBooks
     * const count = await prisma.patientBook.count({
     *   where: {
     *     // ... the filter for the PatientBooks we want to count
     *   }
     * })
    **/
    count<T extends PatientBookCountArgs>(
      args?: Subset<T, PatientBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientBookAggregateArgs>(args: Subset<T, PatientBookAggregateArgs>): Prisma.PrismaPromise<GetPatientBookAggregateType<T>>

    /**
     * Group by PatientBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientBookGroupByArgs['orderBy'] }
        : { orderBy?: PatientBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientBook model
   */
  readonly fields: PatientBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends PatientBook$encountersArgs<ExtArgs> = {}>(args?: Subset<T, PatientBook$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    visitCard<T extends PatientBook$visitCardArgs<ExtArgs> = {}>(args?: Subset<T, PatientBook$visitCardArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    orthoCard<T extends PatientBook$orthoCardArgs<ExtArgs> = {}>(args?: Subset<T, PatientBook$orthoCardArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientBook model
   */ 
  interface PatientBookFieldRefs {
    readonly id: FieldRef<"PatientBook", 'Int'>
    readonly bookNumber: FieldRef<"PatientBook", 'String'>
    readonly patientId: FieldRef<"PatientBook", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PatientBook findUnique
   */
  export type PatientBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook findUniqueOrThrow
   */
  export type PatientBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook findFirst
   */
  export type PatientBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientBooks.
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientBooks.
     */
    distinct?: PatientBookScalarFieldEnum | PatientBookScalarFieldEnum[]
  }

  /**
   * PatientBook findFirstOrThrow
   */
  export type PatientBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientBooks.
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientBooks.
     */
    distinct?: PatientBookScalarFieldEnum | PatientBookScalarFieldEnum[]
  }

  /**
   * PatientBook findMany
   */
  export type PatientBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBooks to fetch.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientBooks.
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    distinct?: PatientBookScalarFieldEnum | PatientBookScalarFieldEnum[]
  }

  /**
   * PatientBook create
   */
  export type PatientBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientBook.
     */
    data: XOR<PatientBookCreateInput, PatientBookUncheckedCreateInput>
  }

  /**
   * PatientBook createMany
   */
  export type PatientBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientBooks.
     */
    data: PatientBookCreateManyInput | PatientBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientBook createManyAndReturn
   */
  export type PatientBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientBooks.
     */
    data: PatientBookCreateManyInput | PatientBookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientBook update
   */
  export type PatientBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientBook.
     */
    data: XOR<PatientBookUpdateInput, PatientBookUncheckedUpdateInput>
    /**
     * Choose, which PatientBook to update.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook updateMany
   */
  export type PatientBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientBooks.
     */
    data: XOR<PatientBookUpdateManyMutationInput, PatientBookUncheckedUpdateManyInput>
    /**
     * Filter which PatientBooks to update
     */
    where?: PatientBookWhereInput
  }

  /**
   * PatientBook upsert
   */
  export type PatientBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientBook to update in case it exists.
     */
    where: PatientBookWhereUniqueInput
    /**
     * In case the PatientBook found by the `where` argument doesn't exist, create a new PatientBook with this data.
     */
    create: XOR<PatientBookCreateInput, PatientBookUncheckedCreateInput>
    /**
     * In case the PatientBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientBookUpdateInput, PatientBookUncheckedUpdateInput>
  }

  /**
   * PatientBook delete
   */
  export type PatientBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter which PatientBook to delete.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook deleteMany
   */
  export type PatientBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientBooks to delete
     */
    where?: PatientBookWhereInput
  }

  /**
   * PatientBook.encounters
   */
  export type PatientBook$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * PatientBook.visitCard
   */
  export type PatientBook$visitCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    where?: VisitCardWhereInput
  }

  /**
   * PatientBook.orthoCard
   */
  export type PatientBook$orthoCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    where?: OrthoCardWhereInput
  }

  /**
   * PatientBook without action
   */
  export type PatientBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
  }


  /**
   * Model VisitCard
   */

  export type AggregateVisitCard = {
    _count: VisitCardCountAggregateOutputType | null
    _avg: VisitCardAvgAggregateOutputType | null
    _sum: VisitCardSumAggregateOutputType | null
    _min: VisitCardMinAggregateOutputType | null
    _max: VisitCardMaxAggregateOutputType | null
  }

  export type VisitCardAvgAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type VisitCardSumAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type VisitCardMinAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    type: $Enums.VisitCardType | null
    patientSignaturePath: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCardMaxAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    type: $Enums.VisitCardType | null
    patientSignaturePath: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCardCountAggregateOutputType = {
    id: number
    patientBookId: number
    type: number
    answers: number
    patientSignaturePath: number
    signedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitCardAvgAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type VisitCardSumAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type VisitCardMinAggregateInputType = {
    id?: true
    patientBookId?: true
    type?: true
    patientSignaturePath?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCardMaxAggregateInputType = {
    id?: true
    patientBookId?: true
    type?: true
    patientSignaturePath?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCardCountAggregateInputType = {
    id?: true
    patientBookId?: true
    type?: true
    answers?: true
    patientSignaturePath?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitCard to aggregate.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitCards
    **/
    _count?: true | VisitCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitCardMaxAggregateInputType
  }

  export type GetVisitCardAggregateType<T extends VisitCardAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitCard[P]>
      : GetScalarType<T[P], AggregateVisitCard[P]>
  }




  export type VisitCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitCardWhereInput
    orderBy?: VisitCardOrderByWithAggregationInput | VisitCardOrderByWithAggregationInput[]
    by: VisitCardScalarFieldEnum[] | VisitCardScalarFieldEnum
    having?: VisitCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCardCountAggregateInputType | true
    _avg?: VisitCardAvgAggregateInputType
    _sum?: VisitCardSumAggregateInputType
    _min?: VisitCardMinAggregateInputType
    _max?: VisitCardMaxAggregateInputType
  }

  export type VisitCardGroupByOutputType = {
    id: number
    patientBookId: number
    type: $Enums.VisitCardType
    answers: JsonValue
    patientSignaturePath: string | null
    signedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VisitCardCountAggregateOutputType | null
    _avg: VisitCardAvgAggregateOutputType | null
    _sum: VisitCardSumAggregateOutputType | null
    _min: VisitCardMinAggregateOutputType | null
    _max: VisitCardMaxAggregateOutputType | null
  }

  type GetVisitCardGroupByPayload<T extends VisitCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitCardGroupByOutputType[P]>
            : GetScalarType<T[P], VisitCardGroupByOutputType[P]>
        }
      >
    >


  export type VisitCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    type?: boolean
    answers?: boolean
    patientSignaturePath?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitCard"]>

  export type VisitCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    type?: boolean
    answers?: boolean
    patientSignaturePath?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitCard"]>

  export type VisitCardSelectScalar = {
    id?: boolean
    patientBookId?: boolean
    type?: boolean
    answers?: boolean
    patientSignaturePath?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }
  export type VisitCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }

  export type $VisitCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitCard"
    objects: {
      patientBook: Prisma.$PatientBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientBookId: number
      type: $Enums.VisitCardType
      answers: Prisma.JsonValue
      patientSignaturePath: string | null
      signedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitCard"]>
    composites: {}
  }

  type VisitCardGetPayload<S extends boolean | null | undefined | VisitCardDefaultArgs> = $Result.GetResult<Prisma.$VisitCardPayload, S>

  type VisitCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitCardCountAggregateInputType | true
    }

  export interface VisitCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitCard'], meta: { name: 'VisitCard' } }
    /**
     * Find zero or one VisitCard that matches the filter.
     * @param {VisitCardFindUniqueArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitCardFindUniqueArgs>(args: SelectSubset<T, VisitCardFindUniqueArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitCardFindUniqueOrThrowArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitCardFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardFindFirstArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitCardFindFirstArgs>(args?: SelectSubset<T, VisitCardFindFirstArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardFindFirstOrThrowArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitCardFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitCards
     * const visitCards = await prisma.visitCard.findMany()
     * 
     * // Get first 10 VisitCards
     * const visitCards = await prisma.visitCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitCardWithIdOnly = await prisma.visitCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitCardFindManyArgs>(args?: SelectSubset<T, VisitCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitCard.
     * @param {VisitCardCreateArgs} args - Arguments to create a VisitCard.
     * @example
     * // Create one VisitCard
     * const VisitCard = await prisma.visitCard.create({
     *   data: {
     *     // ... data to create a VisitCard
     *   }
     * })
     * 
     */
    create<T extends VisitCardCreateArgs>(args: SelectSubset<T, VisitCardCreateArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitCards.
     * @param {VisitCardCreateManyArgs} args - Arguments to create many VisitCards.
     * @example
     * // Create many VisitCards
     * const visitCard = await prisma.visitCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCardCreateManyArgs>(args?: SelectSubset<T, VisitCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitCards and returns the data saved in the database.
     * @param {VisitCardCreateManyAndReturnArgs} args - Arguments to create many VisitCards.
     * @example
     * // Create many VisitCards
     * const visitCard = await prisma.visitCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitCards and only return the `id`
     * const visitCardWithIdOnly = await prisma.visitCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitCardCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitCard.
     * @param {VisitCardDeleteArgs} args - Arguments to delete one VisitCard.
     * @example
     * // Delete one VisitCard
     * const VisitCard = await prisma.visitCard.delete({
     *   where: {
     *     // ... filter to delete one VisitCard
     *   }
     * })
     * 
     */
    delete<T extends VisitCardDeleteArgs>(args: SelectSubset<T, VisitCardDeleteArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitCard.
     * @param {VisitCardUpdateArgs} args - Arguments to update one VisitCard.
     * @example
     * // Update one VisitCard
     * const visitCard = await prisma.visitCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitCardUpdateArgs>(args: SelectSubset<T, VisitCardUpdateArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitCards.
     * @param {VisitCardDeleteManyArgs} args - Arguments to filter VisitCards to delete.
     * @example
     * // Delete a few VisitCards
     * const { count } = await prisma.visitCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitCardDeleteManyArgs>(args?: SelectSubset<T, VisitCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitCards
     * const visitCard = await prisma.visitCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitCardUpdateManyArgs>(args: SelectSubset<T, VisitCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitCard.
     * @param {VisitCardUpsertArgs} args - Arguments to update or create a VisitCard.
     * @example
     * // Update or create a VisitCard
     * const visitCard = await prisma.visitCard.upsert({
     *   create: {
     *     // ... data to create a VisitCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitCard we want to update
     *   }
     * })
     */
    upsert<T extends VisitCardUpsertArgs>(args: SelectSubset<T, VisitCardUpsertArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardCountArgs} args - Arguments to filter VisitCards to count.
     * @example
     * // Count the number of VisitCards
     * const count = await prisma.visitCard.count({
     *   where: {
     *     // ... the filter for the VisitCards we want to count
     *   }
     * })
    **/
    count<T extends VisitCardCountArgs>(
      args?: Subset<T, VisitCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitCardAggregateArgs>(args: Subset<T, VisitCardAggregateArgs>): Prisma.PrismaPromise<GetVisitCardAggregateType<T>>

    /**
     * Group by VisitCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitCardGroupByArgs['orderBy'] }
        : { orderBy?: VisitCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitCard model
   */
  readonly fields: VisitCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientBook<T extends PatientBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientBookDefaultArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitCard model
   */ 
  interface VisitCardFieldRefs {
    readonly id: FieldRef<"VisitCard", 'Int'>
    readonly patientBookId: FieldRef<"VisitCard", 'Int'>
    readonly type: FieldRef<"VisitCard", 'VisitCardType'>
    readonly answers: FieldRef<"VisitCard", 'Json'>
    readonly patientSignaturePath: FieldRef<"VisitCard", 'String'>
    readonly signedAt: FieldRef<"VisitCard", 'DateTime'>
    readonly createdAt: FieldRef<"VisitCard", 'DateTime'>
    readonly updatedAt: FieldRef<"VisitCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitCard findUnique
   */
  export type VisitCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard findUniqueOrThrow
   */
  export type VisitCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard findFirst
   */
  export type VisitCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitCards.
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitCards.
     */
    distinct?: VisitCardScalarFieldEnum | VisitCardScalarFieldEnum[]
  }

  /**
   * VisitCard findFirstOrThrow
   */
  export type VisitCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitCards.
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitCards.
     */
    distinct?: VisitCardScalarFieldEnum | VisitCardScalarFieldEnum[]
  }

  /**
   * VisitCard findMany
   */
  export type VisitCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCards to fetch.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitCards.
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    distinct?: VisitCardScalarFieldEnum | VisitCardScalarFieldEnum[]
  }

  /**
   * VisitCard create
   */
  export type VisitCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitCard.
     */
    data: XOR<VisitCardCreateInput, VisitCardUncheckedCreateInput>
  }

  /**
   * VisitCard createMany
   */
  export type VisitCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitCards.
     */
    data: VisitCardCreateManyInput | VisitCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitCard createManyAndReturn
   */
  export type VisitCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitCards.
     */
    data: VisitCardCreateManyInput | VisitCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitCard update
   */
  export type VisitCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitCard.
     */
    data: XOR<VisitCardUpdateInput, VisitCardUncheckedUpdateInput>
    /**
     * Choose, which VisitCard to update.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard updateMany
   */
  export type VisitCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitCards.
     */
    data: XOR<VisitCardUpdateManyMutationInput, VisitCardUncheckedUpdateManyInput>
    /**
     * Filter which VisitCards to update
     */
    where?: VisitCardWhereInput
  }

  /**
   * VisitCard upsert
   */
  export type VisitCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitCard to update in case it exists.
     */
    where: VisitCardWhereUniqueInput
    /**
     * In case the VisitCard found by the `where` argument doesn't exist, create a new VisitCard with this data.
     */
    create: XOR<VisitCardCreateInput, VisitCardUncheckedCreateInput>
    /**
     * In case the VisitCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitCardUpdateInput, VisitCardUncheckedUpdateInput>
  }

  /**
   * VisitCard delete
   */
  export type VisitCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter which VisitCard to delete.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard deleteMany
   */
  export type VisitCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitCards to delete
     */
    where?: VisitCardWhereInput
  }

  /**
   * VisitCard without action
   */
  export type VisitCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
  }


  /**
   * Model OrthoCard
   */

  export type AggregateOrthoCard = {
    _count: OrthoCardCountAggregateOutputType | null
    _avg: OrthoCardAvgAggregateOutputType | null
    _sum: OrthoCardSumAggregateOutputType | null
    _min: OrthoCardMinAggregateOutputType | null
    _max: OrthoCardMaxAggregateOutputType | null
  }

  export type OrthoCardAvgAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type OrthoCardSumAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type OrthoCardMinAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrthoCardMaxAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrthoCardCountAggregateOutputType = {
    id: number
    patientBookId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrthoCardAvgAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type OrthoCardSumAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type OrthoCardMinAggregateInputType = {
    id?: true
    patientBookId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrthoCardMaxAggregateInputType = {
    id?: true
    patientBookId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrthoCardCountAggregateInputType = {
    id?: true
    patientBookId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrthoCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrthoCard to aggregate.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrthoCards
    **/
    _count?: true | OrthoCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrthoCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrthoCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrthoCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrthoCardMaxAggregateInputType
  }

  export type GetOrthoCardAggregateType<T extends OrthoCardAggregateArgs> = {
        [P in keyof T & keyof AggregateOrthoCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrthoCard[P]>
      : GetScalarType<T[P], AggregateOrthoCard[P]>
  }




  export type OrthoCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrthoCardWhereInput
    orderBy?: OrthoCardOrderByWithAggregationInput | OrthoCardOrderByWithAggregationInput[]
    by: OrthoCardScalarFieldEnum[] | OrthoCardScalarFieldEnum
    having?: OrthoCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrthoCardCountAggregateInputType | true
    _avg?: OrthoCardAvgAggregateInputType
    _sum?: OrthoCardSumAggregateInputType
    _min?: OrthoCardMinAggregateInputType
    _max?: OrthoCardMaxAggregateInputType
  }

  export type OrthoCardGroupByOutputType = {
    id: number
    patientBookId: number
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: OrthoCardCountAggregateOutputType | null
    _avg: OrthoCardAvgAggregateOutputType | null
    _sum: OrthoCardSumAggregateOutputType | null
    _min: OrthoCardMinAggregateOutputType | null
    _max: OrthoCardMaxAggregateOutputType | null
  }

  type GetOrthoCardGroupByPayload<T extends OrthoCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrthoCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrthoCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrthoCardGroupByOutputType[P]>
            : GetScalarType<T[P], OrthoCardGroupByOutputType[P]>
        }
      >
    >


  export type OrthoCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orthoCard"]>

  export type OrthoCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orthoCard"]>

  export type OrthoCardSelectScalar = {
    id?: boolean
    patientBookId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrthoCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }
  export type OrthoCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }

  export type $OrthoCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrthoCard"
    objects: {
      patientBook: Prisma.$PatientBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientBookId: number
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orthoCard"]>
    composites: {}
  }

  type OrthoCardGetPayload<S extends boolean | null | undefined | OrthoCardDefaultArgs> = $Result.GetResult<Prisma.$OrthoCardPayload, S>

  type OrthoCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrthoCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrthoCardCountAggregateInputType | true
    }

  export interface OrthoCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrthoCard'], meta: { name: 'OrthoCard' } }
    /**
     * Find zero or one OrthoCard that matches the filter.
     * @param {OrthoCardFindUniqueArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrthoCardFindUniqueArgs>(args: SelectSubset<T, OrthoCardFindUniqueArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrthoCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrthoCardFindUniqueOrThrowArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrthoCardFindUniqueOrThrowArgs>(args: SelectSubset<T, OrthoCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrthoCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardFindFirstArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrthoCardFindFirstArgs>(args?: SelectSubset<T, OrthoCardFindFirstArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrthoCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardFindFirstOrThrowArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrthoCardFindFirstOrThrowArgs>(args?: SelectSubset<T, OrthoCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrthoCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrthoCards
     * const orthoCards = await prisma.orthoCard.findMany()
     * 
     * // Get first 10 OrthoCards
     * const orthoCards = await prisma.orthoCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orthoCardWithIdOnly = await prisma.orthoCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrthoCardFindManyArgs>(args?: SelectSubset<T, OrthoCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrthoCard.
     * @param {OrthoCardCreateArgs} args - Arguments to create a OrthoCard.
     * @example
     * // Create one OrthoCard
     * const OrthoCard = await prisma.orthoCard.create({
     *   data: {
     *     // ... data to create a OrthoCard
     *   }
     * })
     * 
     */
    create<T extends OrthoCardCreateArgs>(args: SelectSubset<T, OrthoCardCreateArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrthoCards.
     * @param {OrthoCardCreateManyArgs} args - Arguments to create many OrthoCards.
     * @example
     * // Create many OrthoCards
     * const orthoCard = await prisma.orthoCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrthoCardCreateManyArgs>(args?: SelectSubset<T, OrthoCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrthoCards and returns the data saved in the database.
     * @param {OrthoCardCreateManyAndReturnArgs} args - Arguments to create many OrthoCards.
     * @example
     * // Create many OrthoCards
     * const orthoCard = await prisma.orthoCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrthoCards and only return the `id`
     * const orthoCardWithIdOnly = await prisma.orthoCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrthoCardCreateManyAndReturnArgs>(args?: SelectSubset<T, OrthoCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrthoCard.
     * @param {OrthoCardDeleteArgs} args - Arguments to delete one OrthoCard.
     * @example
     * // Delete one OrthoCard
     * const OrthoCard = await prisma.orthoCard.delete({
     *   where: {
     *     // ... filter to delete one OrthoCard
     *   }
     * })
     * 
     */
    delete<T extends OrthoCardDeleteArgs>(args: SelectSubset<T, OrthoCardDeleteArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrthoCard.
     * @param {OrthoCardUpdateArgs} args - Arguments to update one OrthoCard.
     * @example
     * // Update one OrthoCard
     * const orthoCard = await prisma.orthoCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrthoCardUpdateArgs>(args: SelectSubset<T, OrthoCardUpdateArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrthoCards.
     * @param {OrthoCardDeleteManyArgs} args - Arguments to filter OrthoCards to delete.
     * @example
     * // Delete a few OrthoCards
     * const { count } = await prisma.orthoCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrthoCardDeleteManyArgs>(args?: SelectSubset<T, OrthoCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrthoCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrthoCards
     * const orthoCard = await prisma.orthoCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrthoCardUpdateManyArgs>(args: SelectSubset<T, OrthoCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrthoCard.
     * @param {OrthoCardUpsertArgs} args - Arguments to update or create a OrthoCard.
     * @example
     * // Update or create a OrthoCard
     * const orthoCard = await prisma.orthoCard.upsert({
     *   create: {
     *     // ... data to create a OrthoCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrthoCard we want to update
     *   }
     * })
     */
    upsert<T extends OrthoCardUpsertArgs>(args: SelectSubset<T, OrthoCardUpsertArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrthoCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardCountArgs} args - Arguments to filter OrthoCards to count.
     * @example
     * // Count the number of OrthoCards
     * const count = await prisma.orthoCard.count({
     *   where: {
     *     // ... the filter for the OrthoCards we want to count
     *   }
     * })
    **/
    count<T extends OrthoCardCountArgs>(
      args?: Subset<T, OrthoCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrthoCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrthoCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrthoCardAggregateArgs>(args: Subset<T, OrthoCardAggregateArgs>): Prisma.PrismaPromise<GetOrthoCardAggregateType<T>>

    /**
     * Group by OrthoCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrthoCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrthoCardGroupByArgs['orderBy'] }
        : { orderBy?: OrthoCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrthoCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrthoCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrthoCard model
   */
  readonly fields: OrthoCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrthoCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrthoCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientBook<T extends PatientBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientBookDefaultArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrthoCard model
   */ 
  interface OrthoCardFieldRefs {
    readonly id: FieldRef<"OrthoCard", 'Int'>
    readonly patientBookId: FieldRef<"OrthoCard", 'Int'>
    readonly data: FieldRef<"OrthoCard", 'Json'>
    readonly createdAt: FieldRef<"OrthoCard", 'DateTime'>
    readonly updatedAt: FieldRef<"OrthoCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrthoCard findUnique
   */
  export type OrthoCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard findUniqueOrThrow
   */
  export type OrthoCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard findFirst
   */
  export type OrthoCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrthoCards.
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrthoCards.
     */
    distinct?: OrthoCardScalarFieldEnum | OrthoCardScalarFieldEnum[]
  }

  /**
   * OrthoCard findFirstOrThrow
   */
  export type OrthoCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrthoCards.
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrthoCards.
     */
    distinct?: OrthoCardScalarFieldEnum | OrthoCardScalarFieldEnum[]
  }

  /**
   * OrthoCard findMany
   */
  export type OrthoCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCards to fetch.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrthoCards.
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    distinct?: OrthoCardScalarFieldEnum | OrthoCardScalarFieldEnum[]
  }

  /**
   * OrthoCard create
   */
  export type OrthoCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * The data needed to create a OrthoCard.
     */
    data: XOR<OrthoCardCreateInput, OrthoCardUncheckedCreateInput>
  }

  /**
   * OrthoCard createMany
   */
  export type OrthoCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrthoCards.
     */
    data: OrthoCardCreateManyInput | OrthoCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrthoCard createManyAndReturn
   */
  export type OrthoCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrthoCards.
     */
    data: OrthoCardCreateManyInput | OrthoCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrthoCard update
   */
  export type OrthoCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * The data needed to update a OrthoCard.
     */
    data: XOR<OrthoCardUpdateInput, OrthoCardUncheckedUpdateInput>
    /**
     * Choose, which OrthoCard to update.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard updateMany
   */
  export type OrthoCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrthoCards.
     */
    data: XOR<OrthoCardUpdateManyMutationInput, OrthoCardUncheckedUpdateManyInput>
    /**
     * Filter which OrthoCards to update
     */
    where?: OrthoCardWhereInput
  }

  /**
   * OrthoCard upsert
   */
  export type OrthoCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * The filter to search for the OrthoCard to update in case it exists.
     */
    where: OrthoCardWhereUniqueInput
    /**
     * In case the OrthoCard found by the `where` argument doesn't exist, create a new OrthoCard with this data.
     */
    create: XOR<OrthoCardCreateInput, OrthoCardUncheckedCreateInput>
    /**
     * In case the OrthoCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrthoCardUpdateInput, OrthoCardUncheckedUpdateInput>
  }

  /**
   * OrthoCard delete
   */
  export type OrthoCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter which OrthoCard to delete.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard deleteMany
   */
  export type OrthoCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrthoCards to delete
     */
    where?: OrthoCardWhereInput
  }

  /**
   * OrthoCard without action
   */
  export type OrthoCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
    scheduledAt: Date | null
    endAt: Date | null
    status: string | null
    notes: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
    scheduledAt: Date | null
    endAt: Date | null
    status: string | null
    notes: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    branchId: number
    scheduledAt: number
    endAt: number
    status: number
    notes: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
    scheduledAt?: true
    endAt?: true
    status?: true
    notes?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
    scheduledAt?: true
    endAt?: true
    status?: true
    notes?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
    scheduledAt?: true
    endAt?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    patientId: number
    doctorId: number | null
    branchId: number
    scheduledAt: Date
    endAt: Date | null
    status: string
    notes: string | null
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    branchId?: boolean
    scheduledAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Appointment$encountersArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    branchId?: boolean
    scheduledAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    branchId?: boolean
    scheduledAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Appointment$encountersArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      doctorId: number | null
      branchId: number
      scheduledAt: Date
      endAt: Date | null
      status: string
      notes: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends Appointment$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends Appointment$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly patientId: FieldRef<"Appointment", 'Int'>
    readonly doctorId: FieldRef<"Appointment", 'Int'>
    readonly branchId: FieldRef<"Appointment", 'Int'>
    readonly scheduledAt: FieldRef<"Appointment", 'DateTime'>
    readonly endAt: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment.doctor
   */
  export type Appointment$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment.encounters
   */
  export type Appointment$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    status: $Enums.BookingStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    status: $Enums.BookingStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    doctorId: number
    branchId: number
    patientId: number
    date: number
    startTime: number
    endTime: number
    status: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    doctorId: number
    branchId: number
    patientId: number
    date: Date
    startTime: string
    endTime: string
    status: $Enums.BookingStatus
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    patientId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    patientId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    patientId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctorId: number
      branchId: number
      patientId: number
      date: Date
      startTime: string
      endTime: string
      status: $Enums.BookingStatus
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly doctorId: FieldRef<"Booking", 'Int'>
    readonly branchId: FieldRef<"Booking", 'Int'>
    readonly patientId: FieldRef<"Booking", 'Int'>
    readonly date: FieldRef<"Booking", 'DateTime'>
    readonly startTime: FieldRef<"Booking", 'String'>
    readonly endTime: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly note: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterAvgAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    appointmentId: number | null
    nurseId: number | null
  }

  export type EncounterSumAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    appointmentId: number | null
    nurseId: number | null
  }

  export type EncounterMinAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    visitDate: Date | null
    notes: string | null
    appointmentId: number | null
    nurseId: number | null
    patientSignaturePath: string | null
    patientSignedAt: Date | null
    doctorSignaturePath: string | null
    doctorSignedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    visitDate: Date | null
    notes: string | null
    appointmentId: number | null
    nurseId: number | null
    patientSignaturePath: string | null
    patientSignedAt: Date | null
    doctorSignaturePath: string | null
    doctorSignedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    patientBookId: number
    doctorId: number
    visitDate: number
    notes: number
    appointmentId: number
    nurseId: number
    patientSignaturePath: number
    patientSignedAt: number
    doctorSignaturePath: number
    doctorSignedAt: number
    _all: number
  }


  export type EncounterAvgAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    appointmentId?: true
    nurseId?: true
  }

  export type EncounterSumAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    appointmentId?: true
    nurseId?: true
  }

  export type EncounterMinAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    visitDate?: true
    notes?: true
    appointmentId?: true
    nurseId?: true
    patientSignaturePath?: true
    patientSignedAt?: true
    doctorSignaturePath?: true
    doctorSignedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    visitDate?: true
    notes?: true
    appointmentId?: true
    nurseId?: true
    patientSignaturePath?: true
    patientSignedAt?: true
    doctorSignaturePath?: true
    doctorSignedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    visitDate?: true
    notes?: true
    appointmentId?: true
    nurseId?: true
    patientSignaturePath?: true
    patientSignedAt?: true
    doctorSignaturePath?: true
    doctorSignedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _avg?: EncounterAvgAggregateInputType
    _sum?: EncounterSumAggregateInputType
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: number
    patientBookId: number
    doctorId: number
    visitDate: Date
    notes: string | null
    appointmentId: number | null
    nurseId: number | null
    patientSignaturePath: string | null
    patientSignedAt: Date | null
    doctorSignaturePath: string | null
    doctorSignedAt: Date | null
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    notes?: boolean
    appointmentId?: boolean
    nurseId?: boolean
    patientSignaturePath?: boolean
    patientSignedAt?: boolean
    doctorSignaturePath?: boolean
    doctorSignedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
    chartTeeth?: boolean | Encounter$chartTeethArgs<ExtArgs>
    invoice?: boolean | Encounter$invoiceArgs<ExtArgs>
    prescription?: boolean | Encounter$prescriptionArgs<ExtArgs>
    media?: boolean | Encounter$mediaArgs<ExtArgs>
    encounterServices?: boolean | Encounter$encounterServicesArgs<ExtArgs>
    diagnoses?: boolean | Encounter$diagnosesArgs<ExtArgs>
    consents?: boolean | Encounter$consentsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    notes?: boolean
    appointmentId?: boolean
    nurseId?: boolean
    patientSignaturePath?: boolean
    patientSignedAt?: boolean
    doctorSignaturePath?: boolean
    doctorSignedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    patientBookId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    notes?: boolean
    appointmentId?: boolean
    nurseId?: boolean
    patientSignaturePath?: boolean
    patientSignedAt?: boolean
    doctorSignaturePath?: boolean
    doctorSignedAt?: boolean
  }

  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
    chartTeeth?: boolean | Encounter$chartTeethArgs<ExtArgs>
    invoice?: boolean | Encounter$invoiceArgs<ExtArgs>
    prescription?: boolean | Encounter$prescriptionArgs<ExtArgs>
    media?: boolean | Encounter$mediaArgs<ExtArgs>
    encounterServices?: boolean | Encounter$encounterServicesArgs<ExtArgs>
    diagnoses?: boolean | Encounter$diagnosesArgs<ExtArgs>
    consents?: boolean | Encounter$consentsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      patientBook: Prisma.$PatientBookPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      nurse: Prisma.$UserPayload<ExtArgs> | null
      chartTeeth: Prisma.$ChartToothPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
      media: Prisma.$MediaPayload<ExtArgs>[]
      encounterServices: Prisma.$EncounterServicePayload<ExtArgs>[]
      diagnoses: Prisma.$EncounterDiagnosisPayload<ExtArgs>[]
      consents: Prisma.$EncounterConsentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientBookId: number
      doctorId: number
      visitDate: Date
      notes: string | null
      appointmentId: number | null
      nurseId: number | null
      patientSignaturePath: string | null
      patientSignedAt: Date | null
      doctorSignaturePath: string | null
      doctorSignedAt: Date | null
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientBook<T extends PatientBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientBookDefaultArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    appointment<T extends Encounter$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    nurse<T extends Encounter$nurseArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$nurseArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chartTeeth<T extends Encounter$chartTeethArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$chartTeethArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findMany"> | Null>
    invoice<T extends Encounter$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prescription<T extends Encounter$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    media<T extends Encounter$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    encounterServices<T extends Encounter$encounterServicesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$encounterServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findMany"> | Null>
    diagnoses<T extends Encounter$diagnosesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$diagnosesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findMany"> | Null>
    consents<T extends Encounter$consentsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */ 
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'Int'>
    readonly patientBookId: FieldRef<"Encounter", 'Int'>
    readonly doctorId: FieldRef<"Encounter", 'Int'>
    readonly visitDate: FieldRef<"Encounter", 'DateTime'>
    readonly notes: FieldRef<"Encounter", 'String'>
    readonly appointmentId: FieldRef<"Encounter", 'Int'>
    readonly nurseId: FieldRef<"Encounter", 'Int'>
    readonly patientSignaturePath: FieldRef<"Encounter", 'String'>
    readonly patientSignedAt: FieldRef<"Encounter", 'DateTime'>
    readonly doctorSignaturePath: FieldRef<"Encounter", 'String'>
    readonly doctorSignedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter.appointment
   */
  export type Encounter$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Encounter.nurse
   */
  export type Encounter$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Encounter.chartTeeth
   */
  export type Encounter$chartTeethArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    where?: ChartToothWhereInput
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    cursor?: ChartToothWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * Encounter.invoice
   */
  export type Encounter$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Encounter.prescription
   */
  export type Encounter$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }

  /**
   * Encounter.media
   */
  export type Encounter$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Encounter.encounterServices
   */
  export type Encounter$encounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    where?: EncounterServiceWhereInput
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    cursor?: EncounterServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * Encounter.diagnoses
   */
  export type Encounter$diagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    where?: EncounterDiagnosisWhereInput
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    cursor?: EncounterDiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * Encounter.consents
   */
  export type Encounter$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    where?: EncounterConsentWhereInput
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    cursor?: EncounterConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model EncounterConsent
   */

  export type AggregateEncounterConsent = {
    _count: EncounterConsentCountAggregateOutputType | null
    _avg: EncounterConsentAvgAggregateOutputType | null
    _sum: EncounterConsentSumAggregateOutputType | null
    _min: EncounterConsentMinAggregateOutputType | null
    _max: EncounterConsentMaxAggregateOutputType | null
  }

  export type EncounterConsentAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type EncounterConsentSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type EncounterConsentMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterConsentMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterConsentCountAggregateOutputType = {
    id: number
    encounterId: number
    type: number
    answers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncounterConsentAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type EncounterConsentSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type EncounterConsentMinAggregateInputType = {
    id?: true
    encounterId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterConsentMaxAggregateInputType = {
    id?: true
    encounterId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterConsentCountAggregateInputType = {
    id?: true
    encounterId?: true
    type?: true
    answers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncounterConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConsent to aggregate.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterConsents
    **/
    _count?: true | EncounterConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterConsentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterConsentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterConsentMaxAggregateInputType
  }

  export type GetEncounterConsentAggregateType<T extends EncounterConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterConsent[P]>
      : GetScalarType<T[P], AggregateEncounterConsent[P]>
  }




  export type EncounterConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConsentWhereInput
    orderBy?: EncounterConsentOrderByWithAggregationInput | EncounterConsentOrderByWithAggregationInput[]
    by: EncounterConsentScalarFieldEnum[] | EncounterConsentScalarFieldEnum
    having?: EncounterConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterConsentCountAggregateInputType | true
    _avg?: EncounterConsentAvgAggregateInputType
    _sum?: EncounterConsentSumAggregateInputType
    _min?: EncounterConsentMinAggregateInputType
    _max?: EncounterConsentMaxAggregateInputType
  }

  export type EncounterConsentGroupByOutputType = {
    id: number
    encounterId: number
    type: string
    answers: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: EncounterConsentCountAggregateOutputType | null
    _avg: EncounterConsentAvgAggregateOutputType | null
    _sum: EncounterConsentSumAggregateOutputType | null
    _min: EncounterConsentMinAggregateOutputType | null
    _max: EncounterConsentMaxAggregateOutputType | null
  }

  type GetEncounterConsentGroupByPayload<T extends EncounterConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterConsentGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterConsentGroupByOutputType[P]>
        }
      >
    >


  export type EncounterConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    type?: boolean
    answers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConsent"]>

  export type EncounterConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    type?: boolean
    answers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConsent"]>

  export type EncounterConsentSelectScalar = {
    id?: boolean
    encounterId?: boolean
    type?: boolean
    answers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncounterConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type EncounterConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $EncounterConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterConsent"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      type: string
      answers: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encounterConsent"]>
    composites: {}
  }

  type EncounterConsentGetPayload<S extends boolean | null | undefined | EncounterConsentDefaultArgs> = $Result.GetResult<Prisma.$EncounterConsentPayload, S>

  type EncounterConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterConsentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterConsentCountAggregateInputType | true
    }

  export interface EncounterConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterConsent'], meta: { name: 'EncounterConsent' } }
    /**
     * Find zero or one EncounterConsent that matches the filter.
     * @param {EncounterConsentFindUniqueArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterConsentFindUniqueArgs>(args: SelectSubset<T, EncounterConsentFindUniqueArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterConsent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterConsentFindUniqueOrThrowArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentFindFirstArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterConsentFindFirstArgs>(args?: SelectSubset<T, EncounterConsentFindFirstArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentFindFirstOrThrowArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterConsents
     * const encounterConsents = await prisma.encounterConsent.findMany()
     * 
     * // Get first 10 EncounterConsents
     * const encounterConsents = await prisma.encounterConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterConsentWithIdOnly = await prisma.encounterConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterConsentFindManyArgs>(args?: SelectSubset<T, EncounterConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterConsent.
     * @param {EncounterConsentCreateArgs} args - Arguments to create a EncounterConsent.
     * @example
     * // Create one EncounterConsent
     * const EncounterConsent = await prisma.encounterConsent.create({
     *   data: {
     *     // ... data to create a EncounterConsent
     *   }
     * })
     * 
     */
    create<T extends EncounterConsentCreateArgs>(args: SelectSubset<T, EncounterConsentCreateArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterConsents.
     * @param {EncounterConsentCreateManyArgs} args - Arguments to create many EncounterConsents.
     * @example
     * // Create many EncounterConsents
     * const encounterConsent = await prisma.encounterConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterConsentCreateManyArgs>(args?: SelectSubset<T, EncounterConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterConsents and returns the data saved in the database.
     * @param {EncounterConsentCreateManyAndReturnArgs} args - Arguments to create many EncounterConsents.
     * @example
     * // Create many EncounterConsents
     * const encounterConsent = await prisma.encounterConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterConsents and only return the `id`
     * const encounterConsentWithIdOnly = await prisma.encounterConsent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterConsent.
     * @param {EncounterConsentDeleteArgs} args - Arguments to delete one EncounterConsent.
     * @example
     * // Delete one EncounterConsent
     * const EncounterConsent = await prisma.encounterConsent.delete({
     *   where: {
     *     // ... filter to delete one EncounterConsent
     *   }
     * })
     * 
     */
    delete<T extends EncounterConsentDeleteArgs>(args: SelectSubset<T, EncounterConsentDeleteArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterConsent.
     * @param {EncounterConsentUpdateArgs} args - Arguments to update one EncounterConsent.
     * @example
     * // Update one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterConsentUpdateArgs>(args: SelectSubset<T, EncounterConsentUpdateArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterConsents.
     * @param {EncounterConsentDeleteManyArgs} args - Arguments to filter EncounterConsents to delete.
     * @example
     * // Delete a few EncounterConsents
     * const { count } = await prisma.encounterConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterConsentDeleteManyArgs>(args?: SelectSubset<T, EncounterConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterConsents
     * const encounterConsent = await prisma.encounterConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterConsentUpdateManyArgs>(args: SelectSubset<T, EncounterConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterConsent.
     * @param {EncounterConsentUpsertArgs} args - Arguments to update or create a EncounterConsent.
     * @example
     * // Update or create a EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.upsert({
     *   create: {
     *     // ... data to create a EncounterConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterConsent we want to update
     *   }
     * })
     */
    upsert<T extends EncounterConsentUpsertArgs>(args: SelectSubset<T, EncounterConsentUpsertArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentCountArgs} args - Arguments to filter EncounterConsents to count.
     * @example
     * // Count the number of EncounterConsents
     * const count = await prisma.encounterConsent.count({
     *   where: {
     *     // ... the filter for the EncounterConsents we want to count
     *   }
     * })
    **/
    count<T extends EncounterConsentCountArgs>(
      args?: Subset<T, EncounterConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterConsentAggregateArgs>(args: Subset<T, EncounterConsentAggregateArgs>): Prisma.PrismaPromise<GetEncounterConsentAggregateType<T>>

    /**
     * Group by EncounterConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterConsentGroupByArgs['orderBy'] }
        : { orderBy?: EncounterConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterConsent model
   */
  readonly fields: EncounterConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterConsent model
   */ 
  interface EncounterConsentFieldRefs {
    readonly id: FieldRef<"EncounterConsent", 'Int'>
    readonly encounterId: FieldRef<"EncounterConsent", 'Int'>
    readonly type: FieldRef<"EncounterConsent", 'String'>
    readonly answers: FieldRef<"EncounterConsent", 'Json'>
    readonly createdAt: FieldRef<"EncounterConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"EncounterConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterConsent findUnique
   */
  export type EncounterConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent findUniqueOrThrow
   */
  export type EncounterConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent findFirst
   */
  export type EncounterConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConsents.
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConsents.
     */
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * EncounterConsent findFirstOrThrow
   */
  export type EncounterConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConsents.
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConsents.
     */
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * EncounterConsent findMany
   */
  export type EncounterConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsents to fetch.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterConsents.
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * EncounterConsent create
   */
  export type EncounterConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterConsent.
     */
    data: XOR<EncounterConsentCreateInput, EncounterConsentUncheckedCreateInput>
  }

  /**
   * EncounterConsent createMany
   */
  export type EncounterConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterConsents.
     */
    data: EncounterConsentCreateManyInput | EncounterConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterConsent createManyAndReturn
   */
  export type EncounterConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterConsents.
     */
    data: EncounterConsentCreateManyInput | EncounterConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterConsent update
   */
  export type EncounterConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterConsent.
     */
    data: XOR<EncounterConsentUpdateInput, EncounterConsentUncheckedUpdateInput>
    /**
     * Choose, which EncounterConsent to update.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent updateMany
   */
  export type EncounterConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterConsents.
     */
    data: XOR<EncounterConsentUpdateManyMutationInput, EncounterConsentUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConsents to update
     */
    where?: EncounterConsentWhereInput
  }

  /**
   * EncounterConsent upsert
   */
  export type EncounterConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterConsent to update in case it exists.
     */
    where: EncounterConsentWhereUniqueInput
    /**
     * In case the EncounterConsent found by the `where` argument doesn't exist, create a new EncounterConsent with this data.
     */
    create: XOR<EncounterConsentCreateInput, EncounterConsentUncheckedCreateInput>
    /**
     * In case the EncounterConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterConsentUpdateInput, EncounterConsentUncheckedUpdateInput>
  }

  /**
   * EncounterConsent delete
   */
  export type EncounterConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter which EncounterConsent to delete.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent deleteMany
   */
  export type EncounterConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConsents to delete
     */
    where?: EncounterConsentWhereInput
  }

  /**
   * EncounterConsent without action
   */
  export type EncounterConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
  }


  /**
   * Model ChartTooth
   */

  export type AggregateChartTooth = {
    _count: ChartToothCountAggregateOutputType | null
    _avg: ChartToothAvgAggregateOutputType | null
    _sum: ChartToothSumAggregateOutputType | null
    _min: ChartToothMinAggregateOutputType | null
    _max: ChartToothMaxAggregateOutputType | null
  }

  export type ChartToothAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type ChartToothSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type ChartToothMinAggregateOutputType = {
    id: number | null
    toothCode: string | null
    toothGroup: string | null
    status: string | null
    notes: string | null
    encounterId: number | null
  }

  export type ChartToothMaxAggregateOutputType = {
    id: number | null
    toothCode: string | null
    toothGroup: string | null
    status: string | null
    notes: string | null
    encounterId: number | null
  }

  export type ChartToothCountAggregateOutputType = {
    id: number
    toothCode: number
    toothGroup: number
    status: number
    notes: number
    encounterId: number
    _all: number
  }


  export type ChartToothAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type ChartToothSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type ChartToothMinAggregateInputType = {
    id?: true
    toothCode?: true
    toothGroup?: true
    status?: true
    notes?: true
    encounterId?: true
  }

  export type ChartToothMaxAggregateInputType = {
    id?: true
    toothCode?: true
    toothGroup?: true
    status?: true
    notes?: true
    encounterId?: true
  }

  export type ChartToothCountAggregateInputType = {
    id?: true
    toothCode?: true
    toothGroup?: true
    status?: true
    notes?: true
    encounterId?: true
    _all?: true
  }

  export type ChartToothAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartTooth to aggregate.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartTooths
    **/
    _count?: true | ChartToothCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChartToothAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChartToothSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartToothMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartToothMaxAggregateInputType
  }

  export type GetChartToothAggregateType<T extends ChartToothAggregateArgs> = {
        [P in keyof T & keyof AggregateChartTooth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartTooth[P]>
      : GetScalarType<T[P], AggregateChartTooth[P]>
  }




  export type ChartToothGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartToothWhereInput
    orderBy?: ChartToothOrderByWithAggregationInput | ChartToothOrderByWithAggregationInput[]
    by: ChartToothScalarFieldEnum[] | ChartToothScalarFieldEnum
    having?: ChartToothScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartToothCountAggregateInputType | true
    _avg?: ChartToothAvgAggregateInputType
    _sum?: ChartToothSumAggregateInputType
    _min?: ChartToothMinAggregateInputType
    _max?: ChartToothMaxAggregateInputType
  }

  export type ChartToothGroupByOutputType = {
    id: number
    toothCode: string
    toothGroup: string | null
    status: string | null
    notes: string | null
    encounterId: number
    _count: ChartToothCountAggregateOutputType | null
    _avg: ChartToothAvgAggregateOutputType | null
    _sum: ChartToothSumAggregateOutputType | null
    _min: ChartToothMinAggregateOutputType | null
    _max: ChartToothMaxAggregateOutputType | null
  }

  type GetChartToothGroupByPayload<T extends ChartToothGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartToothGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartToothGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartToothGroupByOutputType[P]>
            : GetScalarType<T[P], ChartToothGroupByOutputType[P]>
        }
      >
    >


  export type ChartToothSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    toothCode?: boolean
    toothGroup?: boolean
    status?: boolean
    notes?: boolean
    encounterId?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    chartNotes?: boolean | ChartTooth$chartNotesArgs<ExtArgs>
    _count?: boolean | ChartToothCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartTooth"]>

  export type ChartToothSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    toothCode?: boolean
    toothGroup?: boolean
    status?: boolean
    notes?: boolean
    encounterId?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartTooth"]>

  export type ChartToothSelectScalar = {
    id?: boolean
    toothCode?: boolean
    toothGroup?: boolean
    status?: boolean
    notes?: boolean
    encounterId?: boolean
  }

  export type ChartToothInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    chartNotes?: boolean | ChartTooth$chartNotesArgs<ExtArgs>
    _count?: boolean | ChartToothCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChartToothIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $ChartToothPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartTooth"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      chartNotes: Prisma.$ChartNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      toothCode: string
      toothGroup: string | null
      status: string | null
      notes: string | null
      encounterId: number
    }, ExtArgs["result"]["chartTooth"]>
    composites: {}
  }

  type ChartToothGetPayload<S extends boolean | null | undefined | ChartToothDefaultArgs> = $Result.GetResult<Prisma.$ChartToothPayload, S>

  type ChartToothCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChartToothFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChartToothCountAggregateInputType | true
    }

  export interface ChartToothDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartTooth'], meta: { name: 'ChartTooth' } }
    /**
     * Find zero or one ChartTooth that matches the filter.
     * @param {ChartToothFindUniqueArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartToothFindUniqueArgs>(args: SelectSubset<T, ChartToothFindUniqueArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChartTooth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChartToothFindUniqueOrThrowArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartToothFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartToothFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChartTooth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothFindFirstArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartToothFindFirstArgs>(args?: SelectSubset<T, ChartToothFindFirstArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChartTooth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothFindFirstOrThrowArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartToothFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartToothFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChartTooths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartTooths
     * const chartTooths = await prisma.chartTooth.findMany()
     * 
     * // Get first 10 ChartTooths
     * const chartTooths = await prisma.chartTooth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartToothWithIdOnly = await prisma.chartTooth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartToothFindManyArgs>(args?: SelectSubset<T, ChartToothFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChartTooth.
     * @param {ChartToothCreateArgs} args - Arguments to create a ChartTooth.
     * @example
     * // Create one ChartTooth
     * const ChartTooth = await prisma.chartTooth.create({
     *   data: {
     *     // ... data to create a ChartTooth
     *   }
     * })
     * 
     */
    create<T extends ChartToothCreateArgs>(args: SelectSubset<T, ChartToothCreateArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChartTooths.
     * @param {ChartToothCreateManyArgs} args - Arguments to create many ChartTooths.
     * @example
     * // Create many ChartTooths
     * const chartTooth = await prisma.chartTooth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartToothCreateManyArgs>(args?: SelectSubset<T, ChartToothCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartTooths and returns the data saved in the database.
     * @param {ChartToothCreateManyAndReturnArgs} args - Arguments to create many ChartTooths.
     * @example
     * // Create many ChartTooths
     * const chartTooth = await prisma.chartTooth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartTooths and only return the `id`
     * const chartToothWithIdOnly = await prisma.chartTooth.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartToothCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartToothCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChartTooth.
     * @param {ChartToothDeleteArgs} args - Arguments to delete one ChartTooth.
     * @example
     * // Delete one ChartTooth
     * const ChartTooth = await prisma.chartTooth.delete({
     *   where: {
     *     // ... filter to delete one ChartTooth
     *   }
     * })
     * 
     */
    delete<T extends ChartToothDeleteArgs>(args: SelectSubset<T, ChartToothDeleteArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChartTooth.
     * @param {ChartToothUpdateArgs} args - Arguments to update one ChartTooth.
     * @example
     * // Update one ChartTooth
     * const chartTooth = await prisma.chartTooth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartToothUpdateArgs>(args: SelectSubset<T, ChartToothUpdateArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChartTooths.
     * @param {ChartToothDeleteManyArgs} args - Arguments to filter ChartTooths to delete.
     * @example
     * // Delete a few ChartTooths
     * const { count } = await prisma.chartTooth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartToothDeleteManyArgs>(args?: SelectSubset<T, ChartToothDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartTooths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartTooths
     * const chartTooth = await prisma.chartTooth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartToothUpdateManyArgs>(args: SelectSubset<T, ChartToothUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChartTooth.
     * @param {ChartToothUpsertArgs} args - Arguments to update or create a ChartTooth.
     * @example
     * // Update or create a ChartTooth
     * const chartTooth = await prisma.chartTooth.upsert({
     *   create: {
     *     // ... data to create a ChartTooth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartTooth we want to update
     *   }
     * })
     */
    upsert<T extends ChartToothUpsertArgs>(args: SelectSubset<T, ChartToothUpsertArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChartTooths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothCountArgs} args - Arguments to filter ChartTooths to count.
     * @example
     * // Count the number of ChartTooths
     * const count = await prisma.chartTooth.count({
     *   where: {
     *     // ... the filter for the ChartTooths we want to count
     *   }
     * })
    **/
    count<T extends ChartToothCountArgs>(
      args?: Subset<T, ChartToothCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartToothCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartTooth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartToothAggregateArgs>(args: Subset<T, ChartToothAggregateArgs>): Prisma.PrismaPromise<GetChartToothAggregateType<T>>

    /**
     * Group by ChartTooth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartToothGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartToothGroupByArgs['orderBy'] }
        : { orderBy?: ChartToothGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartToothGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartToothGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartTooth model
   */
  readonly fields: ChartToothFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartTooth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartToothClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chartNotes<T extends ChartTooth$chartNotesArgs<ExtArgs> = {}>(args?: Subset<T, ChartTooth$chartNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartTooth model
   */ 
  interface ChartToothFieldRefs {
    readonly id: FieldRef<"ChartTooth", 'Int'>
    readonly toothCode: FieldRef<"ChartTooth", 'String'>
    readonly toothGroup: FieldRef<"ChartTooth", 'String'>
    readonly status: FieldRef<"ChartTooth", 'String'>
    readonly notes: FieldRef<"ChartTooth", 'String'>
    readonly encounterId: FieldRef<"ChartTooth", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChartTooth findUnique
   */
  export type ChartToothFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth findUniqueOrThrow
   */
  export type ChartToothFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth findFirst
   */
  export type ChartToothFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartTooths.
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartTooths.
     */
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * ChartTooth findFirstOrThrow
   */
  export type ChartToothFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartTooths.
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartTooths.
     */
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * ChartTooth findMany
   */
  export type ChartToothFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooths to fetch.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartTooths.
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * ChartTooth create
   */
  export type ChartToothCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartTooth.
     */
    data: XOR<ChartToothCreateInput, ChartToothUncheckedCreateInput>
  }

  /**
   * ChartTooth createMany
   */
  export type ChartToothCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartTooths.
     */
    data: ChartToothCreateManyInput | ChartToothCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartTooth createManyAndReturn
   */
  export type ChartToothCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChartTooths.
     */
    data: ChartToothCreateManyInput | ChartToothCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartTooth update
   */
  export type ChartToothUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartTooth.
     */
    data: XOR<ChartToothUpdateInput, ChartToothUncheckedUpdateInput>
    /**
     * Choose, which ChartTooth to update.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth updateMany
   */
  export type ChartToothUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartTooths.
     */
    data: XOR<ChartToothUpdateManyMutationInput, ChartToothUncheckedUpdateManyInput>
    /**
     * Filter which ChartTooths to update
     */
    where?: ChartToothWhereInput
  }

  /**
   * ChartTooth upsert
   */
  export type ChartToothUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartTooth to update in case it exists.
     */
    where: ChartToothWhereUniqueInput
    /**
     * In case the ChartTooth found by the `where` argument doesn't exist, create a new ChartTooth with this data.
     */
    create: XOR<ChartToothCreateInput, ChartToothUncheckedCreateInput>
    /**
     * In case the ChartTooth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartToothUpdateInput, ChartToothUncheckedUpdateInput>
  }

  /**
   * ChartTooth delete
   */
  export type ChartToothDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter which ChartTooth to delete.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth deleteMany
   */
  export type ChartToothDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartTooths to delete
     */
    where?: ChartToothWhereInput
  }

  /**
   * ChartTooth.chartNotes
   */
  export type ChartTooth$chartNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    where?: ChartNoteWhereInput
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    cursor?: ChartNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartTooth without action
   */
  export type ChartToothDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
  }


  /**
   * Model ChartNote
   */

  export type AggregateChartNote = {
    _count: ChartNoteCountAggregateOutputType | null
    _avg: ChartNoteAvgAggregateOutputType | null
    _sum: ChartNoteSumAggregateOutputType | null
    _min: ChartNoteMinAggregateOutputType | null
    _max: ChartNoteMaxAggregateOutputType | null
  }

  export type ChartNoteAvgAggregateOutputType = {
    id: number | null
    chartToothId: number | null
  }

  export type ChartNoteSumAggregateOutputType = {
    id: number | null
    chartToothId: number | null
  }

  export type ChartNoteMinAggregateOutputType = {
    id: number | null
    chartToothId: number | null
    description: string | null
    createdAt: Date | null
  }

  export type ChartNoteMaxAggregateOutputType = {
    id: number | null
    chartToothId: number | null
    description: string | null
    createdAt: Date | null
  }

  export type ChartNoteCountAggregateOutputType = {
    id: number
    chartToothId: number
    description: number
    createdAt: number
    _all: number
  }


  export type ChartNoteAvgAggregateInputType = {
    id?: true
    chartToothId?: true
  }

  export type ChartNoteSumAggregateInputType = {
    id?: true
    chartToothId?: true
  }

  export type ChartNoteMinAggregateInputType = {
    id?: true
    chartToothId?: true
    description?: true
    createdAt?: true
  }

  export type ChartNoteMaxAggregateInputType = {
    id?: true
    chartToothId?: true
    description?: true
    createdAt?: true
  }

  export type ChartNoteCountAggregateInputType = {
    id?: true
    chartToothId?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ChartNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartNote to aggregate.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartNotes
    **/
    _count?: true | ChartNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChartNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChartNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartNoteMaxAggregateInputType
  }

  export type GetChartNoteAggregateType<T extends ChartNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateChartNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartNote[P]>
      : GetScalarType<T[P], AggregateChartNote[P]>
  }




  export type ChartNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartNoteWhereInput
    orderBy?: ChartNoteOrderByWithAggregationInput | ChartNoteOrderByWithAggregationInput[]
    by: ChartNoteScalarFieldEnum[] | ChartNoteScalarFieldEnum
    having?: ChartNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartNoteCountAggregateInputType | true
    _avg?: ChartNoteAvgAggregateInputType
    _sum?: ChartNoteSumAggregateInputType
    _min?: ChartNoteMinAggregateInputType
    _max?: ChartNoteMaxAggregateInputType
  }

  export type ChartNoteGroupByOutputType = {
    id: number
    chartToothId: number
    description: string
    createdAt: Date
    _count: ChartNoteCountAggregateOutputType | null
    _avg: ChartNoteAvgAggregateOutputType | null
    _sum: ChartNoteSumAggregateOutputType | null
    _min: ChartNoteMinAggregateOutputType | null
    _max: ChartNoteMaxAggregateOutputType | null
  }

  type GetChartNoteGroupByPayload<T extends ChartNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ChartNoteGroupByOutputType[P]>
        }
      >
    >


  export type ChartNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chartToothId?: boolean
    description?: boolean
    createdAt?: boolean
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartNote"]>

  export type ChartNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chartToothId?: boolean
    description?: boolean
    createdAt?: boolean
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartNote"]>

  export type ChartNoteSelectScalar = {
    id?: boolean
    chartToothId?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ChartNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }
  export type ChartNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }

  export type $ChartNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartNote"
    objects: {
      chartTooth: Prisma.$ChartToothPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chartToothId: number
      description: string
      createdAt: Date
    }, ExtArgs["result"]["chartNote"]>
    composites: {}
  }

  type ChartNoteGetPayload<S extends boolean | null | undefined | ChartNoteDefaultArgs> = $Result.GetResult<Prisma.$ChartNotePayload, S>

  type ChartNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChartNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChartNoteCountAggregateInputType | true
    }

  export interface ChartNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartNote'], meta: { name: 'ChartNote' } }
    /**
     * Find zero or one ChartNote that matches the filter.
     * @param {ChartNoteFindUniqueArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartNoteFindUniqueArgs>(args: SelectSubset<T, ChartNoteFindUniqueArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChartNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChartNoteFindUniqueOrThrowArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChartNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteFindFirstArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartNoteFindFirstArgs>(args?: SelectSubset<T, ChartNoteFindFirstArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChartNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteFindFirstOrThrowArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChartNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartNotes
     * const chartNotes = await prisma.chartNote.findMany()
     * 
     * // Get first 10 ChartNotes
     * const chartNotes = await prisma.chartNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartNoteWithIdOnly = await prisma.chartNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartNoteFindManyArgs>(args?: SelectSubset<T, ChartNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChartNote.
     * @param {ChartNoteCreateArgs} args - Arguments to create a ChartNote.
     * @example
     * // Create one ChartNote
     * const ChartNote = await prisma.chartNote.create({
     *   data: {
     *     // ... data to create a ChartNote
     *   }
     * })
     * 
     */
    create<T extends ChartNoteCreateArgs>(args: SelectSubset<T, ChartNoteCreateArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChartNotes.
     * @param {ChartNoteCreateManyArgs} args - Arguments to create many ChartNotes.
     * @example
     * // Create many ChartNotes
     * const chartNote = await prisma.chartNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartNoteCreateManyArgs>(args?: SelectSubset<T, ChartNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartNotes and returns the data saved in the database.
     * @param {ChartNoteCreateManyAndReturnArgs} args - Arguments to create many ChartNotes.
     * @example
     * // Create many ChartNotes
     * const chartNote = await prisma.chartNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartNotes and only return the `id`
     * const chartNoteWithIdOnly = await prisma.chartNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChartNote.
     * @param {ChartNoteDeleteArgs} args - Arguments to delete one ChartNote.
     * @example
     * // Delete one ChartNote
     * const ChartNote = await prisma.chartNote.delete({
     *   where: {
     *     // ... filter to delete one ChartNote
     *   }
     * })
     * 
     */
    delete<T extends ChartNoteDeleteArgs>(args: SelectSubset<T, ChartNoteDeleteArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChartNote.
     * @param {ChartNoteUpdateArgs} args - Arguments to update one ChartNote.
     * @example
     * // Update one ChartNote
     * const chartNote = await prisma.chartNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartNoteUpdateArgs>(args: SelectSubset<T, ChartNoteUpdateArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChartNotes.
     * @param {ChartNoteDeleteManyArgs} args - Arguments to filter ChartNotes to delete.
     * @example
     * // Delete a few ChartNotes
     * const { count } = await prisma.chartNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartNoteDeleteManyArgs>(args?: SelectSubset<T, ChartNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartNotes
     * const chartNote = await prisma.chartNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartNoteUpdateManyArgs>(args: SelectSubset<T, ChartNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChartNote.
     * @param {ChartNoteUpsertArgs} args - Arguments to update or create a ChartNote.
     * @example
     * // Update or create a ChartNote
     * const chartNote = await prisma.chartNote.upsert({
     *   create: {
     *     // ... data to create a ChartNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartNote we want to update
     *   }
     * })
     */
    upsert<T extends ChartNoteUpsertArgs>(args: SelectSubset<T, ChartNoteUpsertArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChartNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteCountArgs} args - Arguments to filter ChartNotes to count.
     * @example
     * // Count the number of ChartNotes
     * const count = await prisma.chartNote.count({
     *   where: {
     *     // ... the filter for the ChartNotes we want to count
     *   }
     * })
    **/
    count<T extends ChartNoteCountArgs>(
      args?: Subset<T, ChartNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartNoteAggregateArgs>(args: Subset<T, ChartNoteAggregateArgs>): Prisma.PrismaPromise<GetChartNoteAggregateType<T>>

    /**
     * Group by ChartNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartNoteGroupByArgs['orderBy'] }
        : { orderBy?: ChartNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartNote model
   */
  readonly fields: ChartNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chartTooth<T extends ChartToothDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartToothDefaultArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartNote model
   */ 
  interface ChartNoteFieldRefs {
    readonly id: FieldRef<"ChartNote", 'Int'>
    readonly chartToothId: FieldRef<"ChartNote", 'Int'>
    readonly description: FieldRef<"ChartNote", 'String'>
    readonly createdAt: FieldRef<"ChartNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChartNote findUnique
   */
  export type ChartNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote findUniqueOrThrow
   */
  export type ChartNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote findFirst
   */
  export type ChartNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartNotes.
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartNotes.
     */
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartNote findFirstOrThrow
   */
  export type ChartNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartNotes.
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartNotes.
     */
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartNote findMany
   */
  export type ChartNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNotes to fetch.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartNotes.
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartNote create
   */
  export type ChartNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartNote.
     */
    data: XOR<ChartNoteCreateInput, ChartNoteUncheckedCreateInput>
  }

  /**
   * ChartNote createMany
   */
  export type ChartNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartNotes.
     */
    data: ChartNoteCreateManyInput | ChartNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartNote createManyAndReturn
   */
  export type ChartNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChartNotes.
     */
    data: ChartNoteCreateManyInput | ChartNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartNote update
   */
  export type ChartNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartNote.
     */
    data: XOR<ChartNoteUpdateInput, ChartNoteUncheckedUpdateInput>
    /**
     * Choose, which ChartNote to update.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote updateMany
   */
  export type ChartNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartNotes.
     */
    data: XOR<ChartNoteUpdateManyMutationInput, ChartNoteUncheckedUpdateManyInput>
    /**
     * Filter which ChartNotes to update
     */
    where?: ChartNoteWhereInput
  }

  /**
   * ChartNote upsert
   */
  export type ChartNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartNote to update in case it exists.
     */
    where: ChartNoteWhereUniqueInput
    /**
     * In case the ChartNote found by the `where` argument doesn't exist, create a new ChartNote with this data.
     */
    create: XOR<ChartNoteCreateInput, ChartNoteUncheckedCreateInput>
    /**
     * In case the ChartNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartNoteUpdateInput, ChartNoteUncheckedUpdateInput>
  }

  /**
   * ChartNote delete
   */
  export type ChartNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter which ChartNote to delete.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote deleteMany
   */
  export type ChartNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartNotes to delete
     */
    where?: ChartNoteWhereInput
  }

  /**
   * ChartNote without action
   */
  export type ChartNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisAvgAggregateOutputType = {
    id: number | null
  }

  export type DiagnosisSumAggregateOutputType = {
    id: number | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiagnosisAvgAggregateInputType = {
    id?: true
  }

  export type DiagnosisSumAggregateInputType = {
    id?: true
  }

  export type DiagnosisMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _avg?: DiagnosisAvgAggregateInputType
    _sum?: DiagnosisSumAggregateInputType
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    problems?: boolean | Diagnosis$problemsArgs<ExtArgs>
    encounters?: boolean | Diagnosis$encountersArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems?: boolean | Diagnosis$problemsArgs<ExtArgs>
    encounters?: boolean | Diagnosis$encountersArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      problems: Prisma.$DiagnosisProblemPayload<ExtArgs>[]
      encounters: Prisma.$EncounterDiagnosisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }

  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisFindUniqueArgs>(args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisFindFirstArgs>(args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosisFindManyArgs>(args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
     */
    create<T extends DiagnosisCreateArgs>(args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisCreateManyArgs>(args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisDeleteArgs>(args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisUpdateArgs>(args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisDeleteManyArgs>(args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisUpdateManyArgs>(args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisUpsertArgs>(args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problems<T extends Diagnosis$problemsArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$problemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findMany"> | Null>
    encounters<T extends Diagnosis$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diagnosis model
   */ 
  interface DiagnosisFieldRefs {
    readonly id: FieldRef<"Diagnosis", 'Int'>
    readonly code: FieldRef<"Diagnosis", 'String'>
    readonly name: FieldRef<"Diagnosis", 'String'>
    readonly description: FieldRef<"Diagnosis", 'String'>
    readonly createdAt: FieldRef<"Diagnosis", 'DateTime'>
    readonly updatedAt: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis.problems
   */
  export type Diagnosis$problemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    where?: DiagnosisProblemWhereInput
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    cursor?: DiagnosisProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * Diagnosis.encounters
   */
  export type Diagnosis$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    where?: EncounterDiagnosisWhereInput
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    cursor?: EncounterDiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model DiagnosisProblem
   */

  export type AggregateDiagnosisProblem = {
    _count: DiagnosisProblemCountAggregateOutputType | null
    _avg: DiagnosisProblemAvgAggregateOutputType | null
    _sum: DiagnosisProblemSumAggregateOutputType | null
    _min: DiagnosisProblemMinAggregateOutputType | null
    _max: DiagnosisProblemMaxAggregateOutputType | null
  }

  export type DiagnosisProblemAvgAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    order: number | null
  }

  export type DiagnosisProblemSumAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    order: number | null
  }

  export type DiagnosisProblemMinAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    label: string | null
    order: number | null
    active: boolean | null
  }

  export type DiagnosisProblemMaxAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    label: string | null
    order: number | null
    active: boolean | null
  }

  export type DiagnosisProblemCountAggregateOutputType = {
    id: number
    diagnosisId: number
    label: number
    order: number
    active: number
    _all: number
  }


  export type DiagnosisProblemAvgAggregateInputType = {
    id?: true
    diagnosisId?: true
    order?: true
  }

  export type DiagnosisProblemSumAggregateInputType = {
    id?: true
    diagnosisId?: true
    order?: true
  }

  export type DiagnosisProblemMinAggregateInputType = {
    id?: true
    diagnosisId?: true
    label?: true
    order?: true
    active?: true
  }

  export type DiagnosisProblemMaxAggregateInputType = {
    id?: true
    diagnosisId?: true
    label?: true
    order?: true
    active?: true
  }

  export type DiagnosisProblemCountAggregateInputType = {
    id?: true
    diagnosisId?: true
    label?: true
    order?: true
    active?: true
    _all?: true
  }

  export type DiagnosisProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosisProblem to aggregate.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiagnosisProblems
    **/
    _count?: true | DiagnosisProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosisProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosisProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisProblemMaxAggregateInputType
  }

  export type GetDiagnosisProblemAggregateType<T extends DiagnosisProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosisProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosisProblem[P]>
      : GetScalarType<T[P], AggregateDiagnosisProblem[P]>
  }




  export type DiagnosisProblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisProblemWhereInput
    orderBy?: DiagnosisProblemOrderByWithAggregationInput | DiagnosisProblemOrderByWithAggregationInput[]
    by: DiagnosisProblemScalarFieldEnum[] | DiagnosisProblemScalarFieldEnum
    having?: DiagnosisProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisProblemCountAggregateInputType | true
    _avg?: DiagnosisProblemAvgAggregateInputType
    _sum?: DiagnosisProblemSumAggregateInputType
    _min?: DiagnosisProblemMinAggregateInputType
    _max?: DiagnosisProblemMaxAggregateInputType
  }

  export type DiagnosisProblemGroupByOutputType = {
    id: number
    diagnosisId: number
    label: string
    order: number
    active: boolean
    _count: DiagnosisProblemCountAggregateOutputType | null
    _avg: DiagnosisProblemAvgAggregateOutputType | null
    _sum: DiagnosisProblemSumAggregateOutputType | null
    _min: DiagnosisProblemMinAggregateOutputType | null
    _max: DiagnosisProblemMaxAggregateOutputType | null
  }

  type GetDiagnosisProblemGroupByPayload<T extends DiagnosisProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisProblemGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisProblemGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisProblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosisId?: boolean
    label?: boolean
    order?: boolean
    active?: boolean
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosisProblem"]>

  export type DiagnosisProblemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosisId?: boolean
    label?: boolean
    order?: boolean
    active?: boolean
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosisProblem"]>

  export type DiagnosisProblemSelectScalar = {
    id?: boolean
    diagnosisId?: boolean
    label?: boolean
    order?: boolean
    active?: boolean
  }

  export type DiagnosisProblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }
  export type DiagnosisProblemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }

  export type $DiagnosisProblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiagnosisProblem"
    objects: {
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      diagnosisId: number
      label: string
      order: number
      active: boolean
    }, ExtArgs["result"]["diagnosisProblem"]>
    composites: {}
  }

  type DiagnosisProblemGetPayload<S extends boolean | null | undefined | DiagnosisProblemDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisProblemPayload, S>

  type DiagnosisProblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisProblemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisProblemCountAggregateInputType | true
    }

  export interface DiagnosisProblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiagnosisProblem'], meta: { name: 'DiagnosisProblem' } }
    /**
     * Find zero or one DiagnosisProblem that matches the filter.
     * @param {DiagnosisProblemFindUniqueArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisProblemFindUniqueArgs>(args: SelectSubset<T, DiagnosisProblemFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DiagnosisProblem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisProblemFindUniqueOrThrowArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisProblemFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisProblemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DiagnosisProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemFindFirstArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisProblemFindFirstArgs>(args?: SelectSubset<T, DiagnosisProblemFindFirstArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DiagnosisProblem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemFindFirstOrThrowArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisProblemFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisProblemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DiagnosisProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiagnosisProblems
     * const diagnosisProblems = await prisma.diagnosisProblem.findMany()
     * 
     * // Get first 10 DiagnosisProblems
     * const diagnosisProblems = await prisma.diagnosisProblem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisProblemWithIdOnly = await prisma.diagnosisProblem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosisProblemFindManyArgs>(args?: SelectSubset<T, DiagnosisProblemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DiagnosisProblem.
     * @param {DiagnosisProblemCreateArgs} args - Arguments to create a DiagnosisProblem.
     * @example
     * // Create one DiagnosisProblem
     * const DiagnosisProblem = await prisma.diagnosisProblem.create({
     *   data: {
     *     // ... data to create a DiagnosisProblem
     *   }
     * })
     * 
     */
    create<T extends DiagnosisProblemCreateArgs>(args: SelectSubset<T, DiagnosisProblemCreateArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DiagnosisProblems.
     * @param {DiagnosisProblemCreateManyArgs} args - Arguments to create many DiagnosisProblems.
     * @example
     * // Create many DiagnosisProblems
     * const diagnosisProblem = await prisma.diagnosisProblem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisProblemCreateManyArgs>(args?: SelectSubset<T, DiagnosisProblemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiagnosisProblems and returns the data saved in the database.
     * @param {DiagnosisProblemCreateManyAndReturnArgs} args - Arguments to create many DiagnosisProblems.
     * @example
     * // Create many DiagnosisProblems
     * const diagnosisProblem = await prisma.diagnosisProblem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiagnosisProblems and only return the `id`
     * const diagnosisProblemWithIdOnly = await prisma.diagnosisProblem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisProblemCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisProblemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DiagnosisProblem.
     * @param {DiagnosisProblemDeleteArgs} args - Arguments to delete one DiagnosisProblem.
     * @example
     * // Delete one DiagnosisProblem
     * const DiagnosisProblem = await prisma.diagnosisProblem.delete({
     *   where: {
     *     // ... filter to delete one DiagnosisProblem
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisProblemDeleteArgs>(args: SelectSubset<T, DiagnosisProblemDeleteArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DiagnosisProblem.
     * @param {DiagnosisProblemUpdateArgs} args - Arguments to update one DiagnosisProblem.
     * @example
     * // Update one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisProblemUpdateArgs>(args: SelectSubset<T, DiagnosisProblemUpdateArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DiagnosisProblems.
     * @param {DiagnosisProblemDeleteManyArgs} args - Arguments to filter DiagnosisProblems to delete.
     * @example
     * // Delete a few DiagnosisProblems
     * const { count } = await prisma.diagnosisProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisProblemDeleteManyArgs>(args?: SelectSubset<T, DiagnosisProblemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiagnosisProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiagnosisProblems
     * const diagnosisProblem = await prisma.diagnosisProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisProblemUpdateManyArgs>(args: SelectSubset<T, DiagnosisProblemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiagnosisProblem.
     * @param {DiagnosisProblemUpsertArgs} args - Arguments to update or create a DiagnosisProblem.
     * @example
     * // Update or create a DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.upsert({
     *   create: {
     *     // ... data to create a DiagnosisProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiagnosisProblem we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisProblemUpsertArgs>(args: SelectSubset<T, DiagnosisProblemUpsertArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DiagnosisProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemCountArgs} args - Arguments to filter DiagnosisProblems to count.
     * @example
     * // Count the number of DiagnosisProblems
     * const count = await prisma.diagnosisProblem.count({
     *   where: {
     *     // ... the filter for the DiagnosisProblems we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisProblemCountArgs>(
      args?: Subset<T, DiagnosisProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiagnosisProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisProblemAggregateArgs>(args: Subset<T, DiagnosisProblemAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisProblemAggregateType<T>>

    /**
     * Group by DiagnosisProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisProblemGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiagnosisProblem model
   */
  readonly fields: DiagnosisProblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiagnosisProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisProblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diagnosis<T extends DiagnosisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiagnosisDefaultArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiagnosisProblem model
   */ 
  interface DiagnosisProblemFieldRefs {
    readonly id: FieldRef<"DiagnosisProblem", 'Int'>
    readonly diagnosisId: FieldRef<"DiagnosisProblem", 'Int'>
    readonly label: FieldRef<"DiagnosisProblem", 'String'>
    readonly order: FieldRef<"DiagnosisProblem", 'Int'>
    readonly active: FieldRef<"DiagnosisProblem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DiagnosisProblem findUnique
   */
  export type DiagnosisProblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem findUniqueOrThrow
   */
  export type DiagnosisProblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem findFirst
   */
  export type DiagnosisProblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosisProblems.
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosisProblems.
     */
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * DiagnosisProblem findFirstOrThrow
   */
  export type DiagnosisProblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosisProblems.
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosisProblems.
     */
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * DiagnosisProblem findMany
   */
  export type DiagnosisProblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblems to fetch.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiagnosisProblems.
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * DiagnosisProblem create
   */
  export type DiagnosisProblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * The data needed to create a DiagnosisProblem.
     */
    data: XOR<DiagnosisProblemCreateInput, DiagnosisProblemUncheckedCreateInput>
  }

  /**
   * DiagnosisProblem createMany
   */
  export type DiagnosisProblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiagnosisProblems.
     */
    data: DiagnosisProblemCreateManyInput | DiagnosisProblemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiagnosisProblem createManyAndReturn
   */
  export type DiagnosisProblemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DiagnosisProblems.
     */
    data: DiagnosisProblemCreateManyInput | DiagnosisProblemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiagnosisProblem update
   */
  export type DiagnosisProblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * The data needed to update a DiagnosisProblem.
     */
    data: XOR<DiagnosisProblemUpdateInput, DiagnosisProblemUncheckedUpdateInput>
    /**
     * Choose, which DiagnosisProblem to update.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem updateMany
   */
  export type DiagnosisProblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiagnosisProblems.
     */
    data: XOR<DiagnosisProblemUpdateManyMutationInput, DiagnosisProblemUncheckedUpdateManyInput>
    /**
     * Filter which DiagnosisProblems to update
     */
    where?: DiagnosisProblemWhereInput
  }

  /**
   * DiagnosisProblem upsert
   */
  export type DiagnosisProblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * The filter to search for the DiagnosisProblem to update in case it exists.
     */
    where: DiagnosisProblemWhereUniqueInput
    /**
     * In case the DiagnosisProblem found by the `where` argument doesn't exist, create a new DiagnosisProblem with this data.
     */
    create: XOR<DiagnosisProblemCreateInput, DiagnosisProblemUncheckedCreateInput>
    /**
     * In case the DiagnosisProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisProblemUpdateInput, DiagnosisProblemUncheckedUpdateInput>
  }

  /**
   * DiagnosisProblem delete
   */
  export type DiagnosisProblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter which DiagnosisProblem to delete.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem deleteMany
   */
  export type DiagnosisProblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosisProblems to delete
     */
    where?: DiagnosisProblemWhereInput
  }

  /**
   * DiagnosisProblem without action
   */
  export type DiagnosisProblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
  }


  /**
   * Model EncounterDiagnosis
   */

  export type AggregateEncounterDiagnosis = {
    _count: EncounterDiagnosisCountAggregateOutputType | null
    _avg: EncounterDiagnosisAvgAggregateOutputType | null
    _sum: EncounterDiagnosisSumAggregateOutputType | null
    _min: EncounterDiagnosisMinAggregateOutputType | null
    _max: EncounterDiagnosisMaxAggregateOutputType | null
  }

  export type EncounterDiagnosisAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
  }

  export type EncounterDiagnosisSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
  }

  export type EncounterDiagnosisMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
    toothCode: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EncounterDiagnosisMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
    toothCode: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EncounterDiagnosisCountAggregateOutputType = {
    id: number
    encounterId: number
    diagnosisId: number
    toothCode: number
    selectedProblemIds: number
    note: number
    createdAt: number
    _all: number
  }


  export type EncounterDiagnosisAvgAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
  }

  export type EncounterDiagnosisSumAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
  }

  export type EncounterDiagnosisMinAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
    toothCode?: true
    note?: true
    createdAt?: true
  }

  export type EncounterDiagnosisMaxAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
    toothCode?: true
    note?: true
    createdAt?: true
  }

  export type EncounterDiagnosisCountAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
    toothCode?: true
    selectedProblemIds?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type EncounterDiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterDiagnosis to aggregate.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterDiagnoses
    **/
    _count?: true | EncounterDiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterDiagnosisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterDiagnosisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterDiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterDiagnosisMaxAggregateInputType
  }

  export type GetEncounterDiagnosisAggregateType<T extends EncounterDiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterDiagnosis[P]>
      : GetScalarType<T[P], AggregateEncounterDiagnosis[P]>
  }




  export type EncounterDiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisWhereInput
    orderBy?: EncounterDiagnosisOrderByWithAggregationInput | EncounterDiagnosisOrderByWithAggregationInput[]
    by: EncounterDiagnosisScalarFieldEnum[] | EncounterDiagnosisScalarFieldEnum
    having?: EncounterDiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterDiagnosisCountAggregateInputType | true
    _avg?: EncounterDiagnosisAvgAggregateInputType
    _sum?: EncounterDiagnosisSumAggregateInputType
    _min?: EncounterDiagnosisMinAggregateInputType
    _max?: EncounterDiagnosisMaxAggregateInputType
  }

  export type EncounterDiagnosisGroupByOutputType = {
    id: number
    encounterId: number
    diagnosisId: number
    toothCode: string | null
    selectedProblemIds: JsonValue | null
    note: string | null
    createdAt: Date
    _count: EncounterDiagnosisCountAggregateOutputType | null
    _avg: EncounterDiagnosisAvgAggregateOutputType | null
    _sum: EncounterDiagnosisSumAggregateOutputType | null
    _min: EncounterDiagnosisMinAggregateOutputType | null
    _max: EncounterDiagnosisMaxAggregateOutputType | null
  }

  type GetEncounterDiagnosisGroupByPayload<T extends EncounterDiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterDiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterDiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterDiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterDiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type EncounterDiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    diagnosisId?: boolean
    toothCode?: boolean
    selectedProblemIds?: boolean
    note?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterDiagnosis"]>

  export type EncounterDiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    diagnosisId?: boolean
    toothCode?: boolean
    selectedProblemIds?: boolean
    note?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterDiagnosis"]>

  export type EncounterDiagnosisSelectScalar = {
    id?: boolean
    encounterId?: boolean
    diagnosisId?: boolean
    toothCode?: boolean
    selectedProblemIds?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type EncounterDiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }
  export type EncounterDiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }

  export type $EncounterDiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterDiagnosis"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      diagnosisId: number
      toothCode: string | null
      selectedProblemIds: Prisma.JsonValue | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["encounterDiagnosis"]>
    composites: {}
  }

  type EncounterDiagnosisGetPayload<S extends boolean | null | undefined | EncounterDiagnosisDefaultArgs> = $Result.GetResult<Prisma.$EncounterDiagnosisPayload, S>

  type EncounterDiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterDiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterDiagnosisCountAggregateInputType | true
    }

  export interface EncounterDiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterDiagnosis'], meta: { name: 'EncounterDiagnosis' } }
    /**
     * Find zero or one EncounterDiagnosis that matches the filter.
     * @param {EncounterDiagnosisFindUniqueArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterDiagnosisFindUniqueArgs>(args: SelectSubset<T, EncounterDiagnosisFindUniqueArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterDiagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterDiagnosisFindUniqueOrThrowArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterDiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterDiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterDiagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisFindFirstArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterDiagnosisFindFirstArgs>(args?: SelectSubset<T, EncounterDiagnosisFindFirstArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterDiagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisFindFirstOrThrowArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterDiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterDiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterDiagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterDiagnoses
     * const encounterDiagnoses = await prisma.encounterDiagnosis.findMany()
     * 
     * // Get first 10 EncounterDiagnoses
     * const encounterDiagnoses = await prisma.encounterDiagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterDiagnosisWithIdOnly = await prisma.encounterDiagnosis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterDiagnosisFindManyArgs>(args?: SelectSubset<T, EncounterDiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterDiagnosis.
     * @param {EncounterDiagnosisCreateArgs} args - Arguments to create a EncounterDiagnosis.
     * @example
     * // Create one EncounterDiagnosis
     * const EncounterDiagnosis = await prisma.encounterDiagnosis.create({
     *   data: {
     *     // ... data to create a EncounterDiagnosis
     *   }
     * })
     * 
     */
    create<T extends EncounterDiagnosisCreateArgs>(args: SelectSubset<T, EncounterDiagnosisCreateArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterDiagnoses.
     * @param {EncounterDiagnosisCreateManyArgs} args - Arguments to create many EncounterDiagnoses.
     * @example
     * // Create many EncounterDiagnoses
     * const encounterDiagnosis = await prisma.encounterDiagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterDiagnosisCreateManyArgs>(args?: SelectSubset<T, EncounterDiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterDiagnoses and returns the data saved in the database.
     * @param {EncounterDiagnosisCreateManyAndReturnArgs} args - Arguments to create many EncounterDiagnoses.
     * @example
     * // Create many EncounterDiagnoses
     * const encounterDiagnosis = await prisma.encounterDiagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterDiagnoses and only return the `id`
     * const encounterDiagnosisWithIdOnly = await prisma.encounterDiagnosis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterDiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterDiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterDiagnosis.
     * @param {EncounterDiagnosisDeleteArgs} args - Arguments to delete one EncounterDiagnosis.
     * @example
     * // Delete one EncounterDiagnosis
     * const EncounterDiagnosis = await prisma.encounterDiagnosis.delete({
     *   where: {
     *     // ... filter to delete one EncounterDiagnosis
     *   }
     * })
     * 
     */
    delete<T extends EncounterDiagnosisDeleteArgs>(args: SelectSubset<T, EncounterDiagnosisDeleteArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterDiagnosis.
     * @param {EncounterDiagnosisUpdateArgs} args - Arguments to update one EncounterDiagnosis.
     * @example
     * // Update one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterDiagnosisUpdateArgs>(args: SelectSubset<T, EncounterDiagnosisUpdateArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterDiagnoses.
     * @param {EncounterDiagnosisDeleteManyArgs} args - Arguments to filter EncounterDiagnoses to delete.
     * @example
     * // Delete a few EncounterDiagnoses
     * const { count } = await prisma.encounterDiagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDiagnosisDeleteManyArgs>(args?: SelectSubset<T, EncounterDiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterDiagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterDiagnoses
     * const encounterDiagnosis = await prisma.encounterDiagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterDiagnosisUpdateManyArgs>(args: SelectSubset<T, EncounterDiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterDiagnosis.
     * @param {EncounterDiagnosisUpsertArgs} args - Arguments to update or create a EncounterDiagnosis.
     * @example
     * // Update or create a EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.upsert({
     *   create: {
     *     // ... data to create a EncounterDiagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterDiagnosis we want to update
     *   }
     * })
     */
    upsert<T extends EncounterDiagnosisUpsertArgs>(args: SelectSubset<T, EncounterDiagnosisUpsertArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterDiagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisCountArgs} args - Arguments to filter EncounterDiagnoses to count.
     * @example
     * // Count the number of EncounterDiagnoses
     * const count = await prisma.encounterDiagnosis.count({
     *   where: {
     *     // ... the filter for the EncounterDiagnoses we want to count
     *   }
     * })
    **/
    count<T extends EncounterDiagnosisCountArgs>(
      args?: Subset<T, EncounterDiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterDiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterDiagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterDiagnosisAggregateArgs>(args: Subset<T, EncounterDiagnosisAggregateArgs>): Prisma.PrismaPromise<GetEncounterDiagnosisAggregateType<T>>

    /**
     * Group by EncounterDiagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterDiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterDiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: EncounterDiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterDiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterDiagnosis model
   */
  readonly fields: EncounterDiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterDiagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterDiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    diagnosis<T extends DiagnosisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiagnosisDefaultArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterDiagnosis model
   */ 
  interface EncounterDiagnosisFieldRefs {
    readonly id: FieldRef<"EncounterDiagnosis", 'Int'>
    readonly encounterId: FieldRef<"EncounterDiagnosis", 'Int'>
    readonly diagnosisId: FieldRef<"EncounterDiagnosis", 'Int'>
    readonly toothCode: FieldRef<"EncounterDiagnosis", 'String'>
    readonly selectedProblemIds: FieldRef<"EncounterDiagnosis", 'Json'>
    readonly note: FieldRef<"EncounterDiagnosis", 'String'>
    readonly createdAt: FieldRef<"EncounterDiagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterDiagnosis findUnique
   */
  export type EncounterDiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis findUniqueOrThrow
   */
  export type EncounterDiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis findFirst
   */
  export type EncounterDiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterDiagnoses.
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterDiagnoses.
     */
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis findFirstOrThrow
   */
  export type EncounterDiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterDiagnoses.
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterDiagnoses.
     */
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis findMany
   */
  export type EncounterDiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnoses to fetch.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterDiagnoses.
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis create
   */
  export type EncounterDiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterDiagnosis.
     */
    data: XOR<EncounterDiagnosisCreateInput, EncounterDiagnosisUncheckedCreateInput>
  }

  /**
   * EncounterDiagnosis createMany
   */
  export type EncounterDiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterDiagnoses.
     */
    data: EncounterDiagnosisCreateManyInput | EncounterDiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterDiagnosis createManyAndReturn
   */
  export type EncounterDiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterDiagnoses.
     */
    data: EncounterDiagnosisCreateManyInput | EncounterDiagnosisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterDiagnosis update
   */
  export type EncounterDiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterDiagnosis.
     */
    data: XOR<EncounterDiagnosisUpdateInput, EncounterDiagnosisUncheckedUpdateInput>
    /**
     * Choose, which EncounterDiagnosis to update.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis updateMany
   */
  export type EncounterDiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterDiagnoses.
     */
    data: XOR<EncounterDiagnosisUpdateManyMutationInput, EncounterDiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which EncounterDiagnoses to update
     */
    where?: EncounterDiagnosisWhereInput
  }

  /**
   * EncounterDiagnosis upsert
   */
  export type EncounterDiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterDiagnosis to update in case it exists.
     */
    where: EncounterDiagnosisWhereUniqueInput
    /**
     * In case the EncounterDiagnosis found by the `where` argument doesn't exist, create a new EncounterDiagnosis with this data.
     */
    create: XOR<EncounterDiagnosisCreateInput, EncounterDiagnosisUncheckedCreateInput>
    /**
     * In case the EncounterDiagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterDiagnosisUpdateInput, EncounterDiagnosisUncheckedUpdateInput>
  }

  /**
   * EncounterDiagnosis delete
   */
  export type EncounterDiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter which EncounterDiagnosis to delete.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis deleteMany
   */
  export type EncounterDiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterDiagnoses to delete
     */
    where?: EncounterDiagnosisWhereInput
  }

  /**
   * EncounterDiagnosis without action
   */
  export type EncounterDiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    code: string | null
    category: $Enums.ServiceCategory | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    code: string | null
    category: $Enums.ServiceCategory | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    code: number
    category: number
    name: number
    price: number
    isActive: number
    description: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    code?: true
    category?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    code?: true
    category?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    code?: true
    category?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    code: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive: boolean
    description: string | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    encounterServices?: boolean | Service$encounterServicesArgs<ExtArgs>
    serviceBranches?: boolean | Service$serviceBranchesArgs<ExtArgs>
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    code?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterServices?: boolean | Service$encounterServicesArgs<ExtArgs>
    serviceBranches?: boolean | Service$serviceBranchesArgs<ExtArgs>
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      encounterServices: Prisma.$EncounterServicePayload<ExtArgs>[]
      serviceBranches: Prisma.$ServiceBranchPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string | null
      category: $Enums.ServiceCategory
      name: string
      price: number
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounterServices<T extends Service$encounterServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$encounterServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findMany"> | Null>
    serviceBranches<T extends Service$serviceBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany"> | Null>
    invoiceItems<T extends Service$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly code: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'ServiceCategory'>
    readonly name: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly description: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.encounterServices
   */
  export type Service$encounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    where?: EncounterServiceWhereInput
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    cursor?: EncounterServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * Service.serviceBranches
   */
  export type Service$serviceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    cursor?: ServiceBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * Service.invoiceItems
   */
  export type Service$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceBranch
   */

  export type AggregateServiceBranch = {
    _count: ServiceBranchCountAggregateOutputType | null
    _avg: ServiceBranchAvgAggregateOutputType | null
    _sum: ServiceBranchSumAggregateOutputType | null
    _min: ServiceBranchMinAggregateOutputType | null
    _max: ServiceBranchMaxAggregateOutputType | null
  }

  export type ServiceBranchAvgAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchSumAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchMinAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchMaxAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchCountAggregateOutputType = {
    serviceId: number
    branchId: number
    _all: number
  }


  export type ServiceBranchAvgAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchSumAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchMinAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchMaxAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchCountAggregateInputType = {
    serviceId?: true
    branchId?: true
    _all?: true
  }

  export type ServiceBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBranch to aggregate.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceBranches
    **/
    _count?: true | ServiceBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceBranchMaxAggregateInputType
  }

  export type GetServiceBranchAggregateType<T extends ServiceBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceBranch[P]>
      : GetScalarType<T[P], AggregateServiceBranch[P]>
  }




  export type ServiceBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithAggregationInput | ServiceBranchOrderByWithAggregationInput[]
    by: ServiceBranchScalarFieldEnum[] | ServiceBranchScalarFieldEnum
    having?: ServiceBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceBranchCountAggregateInputType | true
    _avg?: ServiceBranchAvgAggregateInputType
    _sum?: ServiceBranchSumAggregateInputType
    _min?: ServiceBranchMinAggregateInputType
    _max?: ServiceBranchMaxAggregateInputType
  }

  export type ServiceBranchGroupByOutputType = {
    serviceId: number
    branchId: number
    _count: ServiceBranchCountAggregateOutputType | null
    _avg: ServiceBranchAvgAggregateOutputType | null
    _sum: ServiceBranchSumAggregateOutputType | null
    _min: ServiceBranchMinAggregateOutputType | null
    _max: ServiceBranchMaxAggregateOutputType | null
  }

  type GetServiceBranchGroupByPayload<T extends ServiceBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceBranchGroupByOutputType[P]>
        }
      >
    >


  export type ServiceBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    branchId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    branchId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectScalar = {
    serviceId?: boolean
    branchId?: boolean
  }

  export type ServiceBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ServiceBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ServiceBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceBranch"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      serviceId: number
      branchId: number
    }, ExtArgs["result"]["serviceBranch"]>
    composites: {}
  }

  type ServiceBranchGetPayload<S extends boolean | null | undefined | ServiceBranchDefaultArgs> = $Result.GetResult<Prisma.$ServiceBranchPayload, S>

  type ServiceBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceBranchCountAggregateInputType | true
    }

  export interface ServiceBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceBranch'], meta: { name: 'ServiceBranch' } }
    /**
     * Find zero or one ServiceBranch that matches the filter.
     * @param {ServiceBranchFindUniqueArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceBranchFindUniqueArgs>(args: SelectSubset<T, ServiceBranchFindUniqueArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceBranchFindUniqueOrThrowArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindFirstArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceBranchFindFirstArgs>(args?: SelectSubset<T, ServiceBranchFindFirstArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindFirstOrThrowArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceBranches
     * const serviceBranches = await prisma.serviceBranch.findMany()
     * 
     * // Get first 10 ServiceBranches
     * const serviceBranches = await prisma.serviceBranch.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const serviceBranchWithServiceIdOnly = await prisma.serviceBranch.findMany({ select: { serviceId: true } })
     * 
     */
    findMany<T extends ServiceBranchFindManyArgs>(args?: SelectSubset<T, ServiceBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceBranch.
     * @param {ServiceBranchCreateArgs} args - Arguments to create a ServiceBranch.
     * @example
     * // Create one ServiceBranch
     * const ServiceBranch = await prisma.serviceBranch.create({
     *   data: {
     *     // ... data to create a ServiceBranch
     *   }
     * })
     * 
     */
    create<T extends ServiceBranchCreateArgs>(args: SelectSubset<T, ServiceBranchCreateArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceBranches.
     * @param {ServiceBranchCreateManyArgs} args - Arguments to create many ServiceBranches.
     * @example
     * // Create many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceBranchCreateManyArgs>(args?: SelectSubset<T, ServiceBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceBranches and returns the data saved in the database.
     * @param {ServiceBranchCreateManyAndReturnArgs} args - Arguments to create many ServiceBranches.
     * @example
     * // Create many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceBranches and only return the `serviceId`
     * const serviceBranchWithServiceIdOnly = await prisma.serviceBranch.createManyAndReturn({ 
     *   select: { serviceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceBranch.
     * @param {ServiceBranchDeleteArgs} args - Arguments to delete one ServiceBranch.
     * @example
     * // Delete one ServiceBranch
     * const ServiceBranch = await prisma.serviceBranch.delete({
     *   where: {
     *     // ... filter to delete one ServiceBranch
     *   }
     * })
     * 
     */
    delete<T extends ServiceBranchDeleteArgs>(args: SelectSubset<T, ServiceBranchDeleteArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceBranch.
     * @param {ServiceBranchUpdateArgs} args - Arguments to update one ServiceBranch.
     * @example
     * // Update one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceBranchUpdateArgs>(args: SelectSubset<T, ServiceBranchUpdateArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceBranches.
     * @param {ServiceBranchDeleteManyArgs} args - Arguments to filter ServiceBranches to delete.
     * @example
     * // Delete a few ServiceBranches
     * const { count } = await prisma.serviceBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceBranchDeleteManyArgs>(args?: SelectSubset<T, ServiceBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceBranchUpdateManyArgs>(args: SelectSubset<T, ServiceBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceBranch.
     * @param {ServiceBranchUpsertArgs} args - Arguments to update or create a ServiceBranch.
     * @example
     * // Update or create a ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.upsert({
     *   create: {
     *     // ... data to create a ServiceBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceBranch we want to update
     *   }
     * })
     */
    upsert<T extends ServiceBranchUpsertArgs>(args: SelectSubset<T, ServiceBranchUpsertArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchCountArgs} args - Arguments to filter ServiceBranches to count.
     * @example
     * // Count the number of ServiceBranches
     * const count = await prisma.serviceBranch.count({
     *   where: {
     *     // ... the filter for the ServiceBranches we want to count
     *   }
     * })
    **/
    count<T extends ServiceBranchCountArgs>(
      args?: Subset<T, ServiceBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceBranchAggregateArgs>(args: Subset<T, ServiceBranchAggregateArgs>): Prisma.PrismaPromise<GetServiceBranchAggregateType<T>>

    /**
     * Group by ServiceBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceBranchGroupByArgs['orderBy'] }
        : { orderBy?: ServiceBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceBranch model
   */
  readonly fields: ServiceBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceBranch model
   */ 
  interface ServiceBranchFieldRefs {
    readonly serviceId: FieldRef<"ServiceBranch", 'Int'>
    readonly branchId: FieldRef<"ServiceBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceBranch findUnique
   */
  export type ServiceBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch findUniqueOrThrow
   */
  export type ServiceBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch findFirst
   */
  export type ServiceBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBranches.
     */
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch findFirstOrThrow
   */
  export type ServiceBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBranches.
     */
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch findMany
   */
  export type ServiceBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranches to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch create
   */
  export type ServiceBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceBranch.
     */
    data: XOR<ServiceBranchCreateInput, ServiceBranchUncheckedCreateInput>
  }

  /**
   * ServiceBranch createMany
   */
  export type ServiceBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceBranches.
     */
    data: ServiceBranchCreateManyInput | ServiceBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceBranch createManyAndReturn
   */
  export type ServiceBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceBranches.
     */
    data: ServiceBranchCreateManyInput | ServiceBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBranch update
   */
  export type ServiceBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceBranch.
     */
    data: XOR<ServiceBranchUpdateInput, ServiceBranchUncheckedUpdateInput>
    /**
     * Choose, which ServiceBranch to update.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch updateMany
   */
  export type ServiceBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceBranches.
     */
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBranches to update
     */
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceBranch upsert
   */
  export type ServiceBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceBranch to update in case it exists.
     */
    where: ServiceBranchWhereUniqueInput
    /**
     * In case the ServiceBranch found by the `where` argument doesn't exist, create a new ServiceBranch with this data.
     */
    create: XOR<ServiceBranchCreateInput, ServiceBranchUncheckedCreateInput>
    /**
     * In case the ServiceBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceBranchUpdateInput, ServiceBranchUncheckedUpdateInput>
  }

  /**
   * ServiceBranch delete
   */
  export type ServiceBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter which ServiceBranch to delete.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch deleteMany
   */
  export type ServiceBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBranches to delete
     */
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceBranch without action
   */
  export type ServiceBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
  }


  /**
   * Model EncounterService
   */

  export type AggregateEncounterService = {
    _count: EncounterServiceCountAggregateOutputType | null
    _avg: EncounterServiceAvgAggregateOutputType | null
    _sum: EncounterServiceSumAggregateOutputType | null
    _min: EncounterServiceMinAggregateOutputType | null
    _max: EncounterServiceMaxAggregateOutputType | null
  }

  export type EncounterServiceAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceCountAggregateOutputType = {
    id: number
    encounterId: number
    serviceId: number
    quantity: number
    price: number
    _all: number
  }


  export type EncounterServiceAvgAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceSumAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceMinAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceMaxAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceCountAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type EncounterServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterService to aggregate.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterServices
    **/
    _count?: true | EncounterServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterServiceMaxAggregateInputType
  }

  export type GetEncounterServiceAggregateType<T extends EncounterServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterService[P]>
      : GetScalarType<T[P], AggregateEncounterService[P]>
  }




  export type EncounterServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterServiceWhereInput
    orderBy?: EncounterServiceOrderByWithAggregationInput | EncounterServiceOrderByWithAggregationInput[]
    by: EncounterServiceScalarFieldEnum[] | EncounterServiceScalarFieldEnum
    having?: EncounterServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterServiceCountAggregateInputType | true
    _avg?: EncounterServiceAvgAggregateInputType
    _sum?: EncounterServiceSumAggregateInputType
    _min?: EncounterServiceMinAggregateInputType
    _max?: EncounterServiceMaxAggregateInputType
  }

  export type EncounterServiceGroupByOutputType = {
    id: number
    encounterId: number
    serviceId: number
    quantity: number
    price: number
    _count: EncounterServiceCountAggregateOutputType | null
    _avg: EncounterServiceAvgAggregateOutputType | null
    _sum: EncounterServiceSumAggregateOutputType | null
    _min: EncounterServiceMinAggregateOutputType | null
    _max: EncounterServiceMaxAggregateOutputType | null
  }

  type GetEncounterServiceGroupByPayload<T extends EncounterServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterServiceGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterServiceGroupByOutputType[P]>
        }
      >
    >


  export type EncounterServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterService"]>

  export type EncounterServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterService"]>

  export type EncounterServiceSelectScalar = {
    id?: boolean
    encounterId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type EncounterServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type EncounterServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $EncounterServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterService"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      serviceId: number
      quantity: number
      price: number
    }, ExtArgs["result"]["encounterService"]>
    composites: {}
  }

  type EncounterServiceGetPayload<S extends boolean | null | undefined | EncounterServiceDefaultArgs> = $Result.GetResult<Prisma.$EncounterServicePayload, S>

  type EncounterServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterServiceCountAggregateInputType | true
    }

  export interface EncounterServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterService'], meta: { name: 'EncounterService' } }
    /**
     * Find zero or one EncounterService that matches the filter.
     * @param {EncounterServiceFindUniqueArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterServiceFindUniqueArgs>(args: SelectSubset<T, EncounterServiceFindUniqueArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterServiceFindUniqueOrThrowArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceFindFirstArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterServiceFindFirstArgs>(args?: SelectSubset<T, EncounterServiceFindFirstArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceFindFirstOrThrowArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterServices
     * const encounterServices = await prisma.encounterService.findMany()
     * 
     * // Get first 10 EncounterServices
     * const encounterServices = await prisma.encounterService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterServiceWithIdOnly = await prisma.encounterService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterServiceFindManyArgs>(args?: SelectSubset<T, EncounterServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterService.
     * @param {EncounterServiceCreateArgs} args - Arguments to create a EncounterService.
     * @example
     * // Create one EncounterService
     * const EncounterService = await prisma.encounterService.create({
     *   data: {
     *     // ... data to create a EncounterService
     *   }
     * })
     * 
     */
    create<T extends EncounterServiceCreateArgs>(args: SelectSubset<T, EncounterServiceCreateArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterServices.
     * @param {EncounterServiceCreateManyArgs} args - Arguments to create many EncounterServices.
     * @example
     * // Create many EncounterServices
     * const encounterService = await prisma.encounterService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterServiceCreateManyArgs>(args?: SelectSubset<T, EncounterServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterServices and returns the data saved in the database.
     * @param {EncounterServiceCreateManyAndReturnArgs} args - Arguments to create many EncounterServices.
     * @example
     * // Create many EncounterServices
     * const encounterService = await prisma.encounterService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterServices and only return the `id`
     * const encounterServiceWithIdOnly = await prisma.encounterService.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterService.
     * @param {EncounterServiceDeleteArgs} args - Arguments to delete one EncounterService.
     * @example
     * // Delete one EncounterService
     * const EncounterService = await prisma.encounterService.delete({
     *   where: {
     *     // ... filter to delete one EncounterService
     *   }
     * })
     * 
     */
    delete<T extends EncounterServiceDeleteArgs>(args: SelectSubset<T, EncounterServiceDeleteArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterService.
     * @param {EncounterServiceUpdateArgs} args - Arguments to update one EncounterService.
     * @example
     * // Update one EncounterService
     * const encounterService = await prisma.encounterService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterServiceUpdateArgs>(args: SelectSubset<T, EncounterServiceUpdateArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterServices.
     * @param {EncounterServiceDeleteManyArgs} args - Arguments to filter EncounterServices to delete.
     * @example
     * // Delete a few EncounterServices
     * const { count } = await prisma.encounterService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterServiceDeleteManyArgs>(args?: SelectSubset<T, EncounterServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterServices
     * const encounterService = await prisma.encounterService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterServiceUpdateManyArgs>(args: SelectSubset<T, EncounterServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterService.
     * @param {EncounterServiceUpsertArgs} args - Arguments to update or create a EncounterService.
     * @example
     * // Update or create a EncounterService
     * const encounterService = await prisma.encounterService.upsert({
     *   create: {
     *     // ... data to create a EncounterService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterService we want to update
     *   }
     * })
     */
    upsert<T extends EncounterServiceUpsertArgs>(args: SelectSubset<T, EncounterServiceUpsertArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceCountArgs} args - Arguments to filter EncounterServices to count.
     * @example
     * // Count the number of EncounterServices
     * const count = await prisma.encounterService.count({
     *   where: {
     *     // ... the filter for the EncounterServices we want to count
     *   }
     * })
    **/
    count<T extends EncounterServiceCountArgs>(
      args?: Subset<T, EncounterServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterServiceAggregateArgs>(args: Subset<T, EncounterServiceAggregateArgs>): Prisma.PrismaPromise<GetEncounterServiceAggregateType<T>>

    /**
     * Group by EncounterService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterServiceGroupByArgs['orderBy'] }
        : { orderBy?: EncounterServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterService model
   */
  readonly fields: EncounterServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterService model
   */ 
  interface EncounterServiceFieldRefs {
    readonly id: FieldRef<"EncounterService", 'Int'>
    readonly encounterId: FieldRef<"EncounterService", 'Int'>
    readonly serviceId: FieldRef<"EncounterService", 'Int'>
    readonly quantity: FieldRef<"EncounterService", 'Int'>
    readonly price: FieldRef<"EncounterService", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * EncounterService findUnique
   */
  export type EncounterServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService findUniqueOrThrow
   */
  export type EncounterServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService findFirst
   */
  export type EncounterServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterServices.
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterServices.
     */
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * EncounterService findFirstOrThrow
   */
  export type EncounterServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterServices.
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterServices.
     */
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * EncounterService findMany
   */
  export type EncounterServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterServices to fetch.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterServices.
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * EncounterService create
   */
  export type EncounterServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterService.
     */
    data: XOR<EncounterServiceCreateInput, EncounterServiceUncheckedCreateInput>
  }

  /**
   * EncounterService createMany
   */
  export type EncounterServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterServices.
     */
    data: EncounterServiceCreateManyInput | EncounterServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterService createManyAndReturn
   */
  export type EncounterServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterServices.
     */
    data: EncounterServiceCreateManyInput | EncounterServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterService update
   */
  export type EncounterServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterService.
     */
    data: XOR<EncounterServiceUpdateInput, EncounterServiceUncheckedUpdateInput>
    /**
     * Choose, which EncounterService to update.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService updateMany
   */
  export type EncounterServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterServices.
     */
    data: XOR<EncounterServiceUpdateManyMutationInput, EncounterServiceUncheckedUpdateManyInput>
    /**
     * Filter which EncounterServices to update
     */
    where?: EncounterServiceWhereInput
  }

  /**
   * EncounterService upsert
   */
  export type EncounterServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterService to update in case it exists.
     */
    where: EncounterServiceWhereUniqueInput
    /**
     * In case the EncounterService found by the `where` argument doesn't exist, create a new EncounterService with this data.
     */
    create: XOR<EncounterServiceCreateInput, EncounterServiceUncheckedCreateInput>
    /**
     * In case the EncounterService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterServiceUpdateInput, EncounterServiceUncheckedUpdateInput>
  }

  /**
   * EncounterService delete
   */
  export type EncounterServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter which EncounterService to delete.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService deleteMany
   */
  export type EncounterServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterServices to delete
     */
    where?: EncounterServiceWhereInput
  }

  /**
   * EncounterService without action
   */
  export type EncounterServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
  }


  /**
   * Model Procedure
   */

  export type AggregateProcedure = {
    _count: ProcedureCountAggregateOutputType | null
    _avg: ProcedureAvgAggregateOutputType | null
    _sum: ProcedureSumAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  export type ProcedureAvgAggregateOutputType = {
    price: number | null
  }

  export type ProcedureSumAggregateOutputType = {
    price: number | null
  }

  export type ProcedureMinAggregateOutputType = {
    code: string | null
    name: string | null
    price: number | null
  }

  export type ProcedureMaxAggregateOutputType = {
    code: string | null
    name: string | null
    price: number | null
  }

  export type ProcedureCountAggregateOutputType = {
    code: number
    name: number
    price: number
    _all: number
  }


  export type ProcedureAvgAggregateInputType = {
    price?: true
  }

  export type ProcedureSumAggregateInputType = {
    price?: true
  }

  export type ProcedureMinAggregateInputType = {
    code?: true
    name?: true
    price?: true
  }

  export type ProcedureMaxAggregateInputType = {
    code?: true
    name?: true
    price?: true
  }

  export type ProcedureCountAggregateInputType = {
    code?: true
    name?: true
    price?: true
    _all?: true
  }

  export type ProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedure to aggregate.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedures
    **/
    _count?: true | ProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureMaxAggregateInputType
  }

  export type GetProcedureAggregateType<T extends ProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedure[P]>
      : GetScalarType<T[P], AggregateProcedure[P]>
  }




  export type ProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithAggregationInput | ProcedureOrderByWithAggregationInput[]
    by: ProcedureScalarFieldEnum[] | ProcedureScalarFieldEnum
    having?: ProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureCountAggregateInputType | true
    _avg?: ProcedureAvgAggregateInputType
    _sum?: ProcedureSumAggregateInputType
    _min?: ProcedureMinAggregateInputType
    _max?: ProcedureMaxAggregateInputType
  }

  export type ProcedureGroupByOutputType = {
    code: string
    name: string
    price: number
    _count: ProcedureCountAggregateOutputType | null
    _avg: ProcedureAvgAggregateOutputType | null
    _sum: ProcedureSumAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  type GetProcedureGroupByPayload<T extends ProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    price?: boolean
    invoiceItems?: boolean | Procedure$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectScalar = {
    code?: boolean
    name?: boolean
    price?: boolean
  }

  export type ProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | Procedure$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedure"
    objects: {
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      price: number
    }, ExtArgs["result"]["procedure"]>
    composites: {}
  }

  type ProcedureGetPayload<S extends boolean | null | undefined | ProcedureDefaultArgs> = $Result.GetResult<Prisma.$ProcedurePayload, S>

  type ProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcedureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedureCountAggregateInputType | true
    }

  export interface ProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedure'], meta: { name: 'Procedure' } }
    /**
     * Find zero or one Procedure that matches the filter.
     * @param {ProcedureFindUniqueArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureFindUniqueArgs>(args: SelectSubset<T, ProcedureFindUniqueArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Procedure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcedureFindUniqueOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Procedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureFindFirstArgs>(args?: SelectSubset<T, ProcedureFindFirstArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Procedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedures
     * const procedures = await prisma.procedure.findMany()
     * 
     * // Get first 10 Procedures
     * const procedures = await prisma.procedure.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const procedureWithCodeOnly = await prisma.procedure.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends ProcedureFindManyArgs>(args?: SelectSubset<T, ProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Procedure.
     * @param {ProcedureCreateArgs} args - Arguments to create a Procedure.
     * @example
     * // Create one Procedure
     * const Procedure = await prisma.procedure.create({
     *   data: {
     *     // ... data to create a Procedure
     *   }
     * })
     * 
     */
    create<T extends ProcedureCreateArgs>(args: SelectSubset<T, ProcedureCreateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procedures.
     * @param {ProcedureCreateManyArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureCreateManyArgs>(args?: SelectSubset<T, ProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procedures and returns the data saved in the database.
     * @param {ProcedureCreateManyAndReturnArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procedures and only return the `code`
     * const procedureWithCodeOnly = await prisma.procedure.createManyAndReturn({ 
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Procedure.
     * @param {ProcedureDeleteArgs} args - Arguments to delete one Procedure.
     * @example
     * // Delete one Procedure
     * const Procedure = await prisma.procedure.delete({
     *   where: {
     *     // ... filter to delete one Procedure
     *   }
     * })
     * 
     */
    delete<T extends ProcedureDeleteArgs>(args: SelectSubset<T, ProcedureDeleteArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Procedure.
     * @param {ProcedureUpdateArgs} args - Arguments to update one Procedure.
     * @example
     * // Update one Procedure
     * const procedure = await prisma.procedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureUpdateArgs>(args: SelectSubset<T, ProcedureUpdateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procedures.
     * @param {ProcedureDeleteManyArgs} args - Arguments to filter Procedures to delete.
     * @example
     * // Delete a few Procedures
     * const { count } = await prisma.procedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureDeleteManyArgs>(args?: SelectSubset<T, ProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureUpdateManyArgs>(args: SelectSubset<T, ProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procedure.
     * @param {ProcedureUpsertArgs} args - Arguments to update or create a Procedure.
     * @example
     * // Update or create a Procedure
     * const procedure = await prisma.procedure.upsert({
     *   create: {
     *     // ... data to create a Procedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedure we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureUpsertArgs>(args: SelectSubset<T, ProcedureUpsertArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureCountArgs} args - Arguments to filter Procedures to count.
     * @example
     * // Count the number of Procedures
     * const count = await prisma.procedure.count({
     *   where: {
     *     // ... the filter for the Procedures we want to count
     *   }
     * })
    **/
    count<T extends ProcedureCountArgs>(
      args?: Subset<T, ProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureAggregateArgs>(args: Subset<T, ProcedureAggregateArgs>): Prisma.PrismaPromise<GetProcedureAggregateType<T>>

    /**
     * Group by Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedure model
   */
  readonly fields: ProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoiceItems<T extends Procedure$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedure model
   */ 
  interface ProcedureFieldRefs {
    readonly code: FieldRef<"Procedure", 'String'>
    readonly name: FieldRef<"Procedure", 'String'>
    readonly price: FieldRef<"Procedure", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Procedure findUnique
   */
  export type ProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findUniqueOrThrow
   */
  export type ProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findFirst
   */
  export type ProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findFirstOrThrow
   */
  export type ProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findMany
   */
  export type ProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedures to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure create
   */
  export type ProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedure.
     */
    data: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
  }

  /**
   * Procedure createMany
   */
  export type ProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure createManyAndReturn
   */
  export type ProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure update
   */
  export type ProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedure.
     */
    data: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
    /**
     * Choose, which Procedure to update.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure updateMany
   */
  export type ProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
  }

  /**
   * Procedure upsert
   */
  export type ProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedure to update in case it exists.
     */
    where: ProcedureWhereUniqueInput
    /**
     * In case the Procedure found by the `where` argument doesn't exist, create a new Procedure with this data.
     */
    create: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
    /**
     * In case the Procedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
  }

  /**
   * Procedure delete
   */
  export type ProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter which Procedure to delete.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure deleteMany
   */
  export type ProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedures to delete
     */
    where?: ProcedureWhereInput
  }

  /**
   * Procedure.invoiceItems
   */
  export type Procedure$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Procedure without action
   */
  export type ProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    price: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    price: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    code: string | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    code: string | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    price: number
    isActive: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    branchId?: true
    price?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    branchId?: true
    price?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    branchId: number
    code: string | null
    name: string
    price: number
    isActive: boolean
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      code: string | null
      name: string
      price: number
      isActive: boolean
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoiceItems<T extends Product$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly branchId: FieldRef<"Product", 'Int'>
    readonly code: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly description: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.invoiceItems
   */
  export type Product$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorNameSnapshot: string | null
    patientNameSnapshot: string | null
    diagnosisSummary: string | null
    clinicNameSnapshot: string | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorNameSnapshot: string | null
    patientNameSnapshot: string | null
    diagnosisSummary: string | null
    clinicNameSnapshot: string | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    encounterId: number
    createdAt: number
    updatedAt: number
    doctorNameSnapshot: number
    patientNameSnapshot: number
    diagnosisSummary: number
    clinicNameSnapshot: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    encounterId?: true
    createdAt?: true
    updatedAt?: true
    doctorNameSnapshot?: true
    patientNameSnapshot?: true
    diagnosisSummary?: true
    clinicNameSnapshot?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    encounterId?: true
    createdAt?: true
    updatedAt?: true
    doctorNameSnapshot?: true
    patientNameSnapshot?: true
    diagnosisSummary?: true
    clinicNameSnapshot?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    encounterId?: true
    createdAt?: true
    updatedAt?: true
    doctorNameSnapshot?: true
    patientNameSnapshot?: true
    diagnosisSummary?: true
    clinicNameSnapshot?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: number
    encounterId: number
    createdAt: Date
    updatedAt: Date
    doctorNameSnapshot: string | null
    patientNameSnapshot: string | null
    diagnosisSummary: string | null
    clinicNameSnapshot: string | null
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorNameSnapshot?: boolean
    patientNameSnapshot?: boolean
    diagnosisSummary?: boolean
    clinicNameSnapshot?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    items?: boolean | Prescription$itemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorNameSnapshot?: boolean
    patientNameSnapshot?: boolean
    diagnosisSummary?: boolean
    clinicNameSnapshot?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    encounterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorNameSnapshot?: boolean
    patientNameSnapshot?: boolean
    diagnosisSummary?: boolean
    clinicNameSnapshot?: boolean
  }

  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    items?: boolean | Prescription$itemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      items: Prisma.$PrescriptionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      createdAt: Date
      updatedAt: Date
      doctorNameSnapshot: string | null
      patientNameSnapshot: string | null
      diagnosisSummary: string | null
      clinicNameSnapshot: string | null
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Prescription$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */ 
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'Int'>
    readonly encounterId: FieldRef<"Prescription", 'Int'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly updatedAt: FieldRef<"Prescription", 'DateTime'>
    readonly doctorNameSnapshot: FieldRef<"Prescription", 'String'>
    readonly patientNameSnapshot: FieldRef<"Prescription", 'String'>
    readonly diagnosisSummary: FieldRef<"Prescription", 'String'>
    readonly clinicNameSnapshot: FieldRef<"Prescription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription.items
   */
  export type Prescription$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionItem
   */

  export type AggregatePrescriptionItem = {
    _count: PrescriptionItemCountAggregateOutputType | null
    _avg: PrescriptionItemAvgAggregateOutputType | null
    _sum: PrescriptionItemSumAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  export type PrescriptionItemAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
  }

  export type PrescriptionItemSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
  }

  export type PrescriptionItemMinAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    drugName: string | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
    note: string | null
  }

  export type PrescriptionItemMaxAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    drugName: string | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
    note: string | null
  }

  export type PrescriptionItemCountAggregateOutputType = {
    id: number
    prescriptionId: number
    order: number
    drugName: number
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note: number
    _all: number
  }


  export type PrescriptionItemAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
  }

  export type PrescriptionItemSumAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
  }

  export type PrescriptionItemMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    drugName?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
    note?: true
  }

  export type PrescriptionItemMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    drugName?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
    note?: true
  }

  export type PrescriptionItemCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    drugName?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
    note?: true
    _all?: true
  }

  export type PrescriptionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItem to aggregate.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionItems
    **/
    _count?: true | PrescriptionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type GetPrescriptionItemAggregateType<T extends PrescriptionItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionItem[P]>
      : GetScalarType<T[P], AggregatePrescriptionItem[P]>
  }




  export type PrescriptionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithAggregationInput | PrescriptionItemOrderByWithAggregationInput[]
    by: PrescriptionItemScalarFieldEnum[] | PrescriptionItemScalarFieldEnum
    having?: PrescriptionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionItemCountAggregateInputType | true
    _avg?: PrescriptionItemAvgAggregateInputType
    _sum?: PrescriptionItemSumAggregateInputType
    _min?: PrescriptionItemMinAggregateInputType
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type PrescriptionItemGroupByOutputType = {
    id: number
    prescriptionId: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note: string | null
    _count: PrescriptionItemCountAggregateOutputType | null
    _avg: PrescriptionItemAvgAggregateOutputType | null
    _sum: PrescriptionItemSumAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  type GetPrescriptionItemGroupByPayload<T extends PrescriptionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    order?: boolean
    drugName?: boolean
    durationDays?: boolean
    quantityPerTake?: boolean
    frequencyPerDay?: boolean
    note?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    order?: boolean
    drugName?: boolean
    durationDays?: boolean
    quantityPerTake?: boolean
    frequencyPerDay?: boolean
    note?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    order?: boolean
    drugName?: boolean
    durationDays?: boolean
    quantityPerTake?: boolean
    frequencyPerDay?: boolean
    note?: boolean
  }

  export type PrescriptionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }

  export type $PrescriptionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionItem"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prescriptionId: number
      order: number
      drugName: string
      durationDays: number
      quantityPerTake: number
      frequencyPerDay: number
      note: string | null
    }, ExtArgs["result"]["prescriptionItem"]>
    composites: {}
  }

  type PrescriptionItemGetPayload<S extends boolean | null | undefined | PrescriptionItemDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionItemPayload, S>

  type PrescriptionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrescriptionItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrescriptionItemCountAggregateInputType | true
    }

  export interface PrescriptionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionItem'], meta: { name: 'PrescriptionItem' } }
    /**
     * Find zero or one PrescriptionItem that matches the filter.
     * @param {PrescriptionItemFindUniqueArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionItemFindUniqueArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrescriptionItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrescriptionItemFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrescriptionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionItemFindFirstArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrescriptionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrescriptionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany()
     * 
     * // Get first 10 PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionItemFindManyArgs>(args?: SelectSubset<T, PrescriptionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrescriptionItem.
     * @param {PrescriptionItemCreateArgs} args - Arguments to create a PrescriptionItem.
     * @example
     * // Create one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.create({
     *   data: {
     *     // ... data to create a PrescriptionItem
     *   }
     * })
     * 
     */
    create<T extends PrescriptionItemCreateArgs>(args: SelectSubset<T, PrescriptionItemCreateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrescriptionItems.
     * @param {PrescriptionItemCreateManyArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionItemCreateManyArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionItems and returns the data saved in the database.
     * @param {PrescriptionItemCreateManyAndReturnArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrescriptionItem.
     * @param {PrescriptionItemDeleteArgs} args - Arguments to delete one PrescriptionItem.
     * @example
     * // Delete one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionItem
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionItemDeleteArgs>(args: SelectSubset<T, PrescriptionItemDeleteArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrescriptionItem.
     * @param {PrescriptionItemUpdateArgs} args - Arguments to update one PrescriptionItem.
     * @example
     * // Update one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionItemUpdateArgs>(args: SelectSubset<T, PrescriptionItemUpdateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrescriptionItems.
     * @param {PrescriptionItemDeleteManyArgs} args - Arguments to filter PrescriptionItems to delete.
     * @example
     * // Delete a few PrescriptionItems
     * const { count } = await prisma.prescriptionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionItemDeleteManyArgs>(args?: SelectSubset<T, PrescriptionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionItemUpdateManyArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrescriptionItem.
     * @param {PrescriptionItemUpsertArgs} args - Arguments to update or create a PrescriptionItem.
     * @example
     * // Update or create a PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.upsert({
     *   create: {
     *     // ... data to create a PrescriptionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionItem we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionItemUpsertArgs>(args: SelectSubset<T, PrescriptionItemUpsertArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemCountArgs} args - Arguments to filter PrescriptionItems to count.
     * @example
     * // Count the number of PrescriptionItems
     * const count = await prisma.prescriptionItem.count({
     *   where: {
     *     // ... the filter for the PrescriptionItems we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionItemCountArgs>(
      args?: Subset<T, PrescriptionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionItemAggregateArgs>(args: Subset<T, PrescriptionItemAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionItemAggregateType<T>>

    /**
     * Group by PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionItemGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionItem model
   */
  readonly fields: PrescriptionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionItem model
   */ 
  interface PrescriptionItemFieldRefs {
    readonly id: FieldRef<"PrescriptionItem", 'Int'>
    readonly prescriptionId: FieldRef<"PrescriptionItem", 'Int'>
    readonly order: FieldRef<"PrescriptionItem", 'Int'>
    readonly drugName: FieldRef<"PrescriptionItem", 'String'>
    readonly durationDays: FieldRef<"PrescriptionItem", 'Int'>
    readonly quantityPerTake: FieldRef<"PrescriptionItem", 'Int'>
    readonly frequencyPerDay: FieldRef<"PrescriptionItem", 'Int'>
    readonly note: FieldRef<"PrescriptionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionItem findUnique
   */
  export type PrescriptionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findUniqueOrThrow
   */
  export type PrescriptionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findFirst
   */
  export type PrescriptionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findFirstOrThrow
   */
  export type PrescriptionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findMany
   */
  export type PrescriptionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItems to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem create
   */
  export type PrescriptionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionItem.
     */
    data: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
  }

  /**
   * PrescriptionItem createMany
   */
  export type PrescriptionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionItem createManyAndReturn
   */
  export type PrescriptionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem update
   */
  export type PrescriptionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionItem.
     */
    data: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionItem to update.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem updateMany
   */
  export type PrescriptionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
  }

  /**
   * PrescriptionItem upsert
   */
  export type PrescriptionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionItem to update in case it exists.
     */
    where: PrescriptionItemWhereUniqueInput
    /**
     * In case the PrescriptionItem found by the `where` argument doesn't exist, create a new PrescriptionItem with this data.
     */
    create: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
    /**
     * In case the PrescriptionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
  }

  /**
   * PrescriptionItem delete
   */
  export type PrescriptionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionItem to delete.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem deleteMany
   */
  export type PrescriptionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItems to delete
     */
    where?: PrescriptionItemWhereInput
  }

  /**
   * PrescriptionItem without action
   */
  export type PrescriptionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    finalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    finalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    discountPercent: $Enums.DiscountPercent | null
    finalAmount: number | null
    statusLegacy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    discountPercent: $Enums.DiscountPercent | null
    finalAmount: number | null
    statusLegacy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    branchId: number
    encounterId: number
    patientId: number
    totalAmount: number
    totalBeforeDiscount: number
    discountPercent: number
    finalAmount: number
    statusLegacy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    finalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    finalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    discountPercent?: true
    finalAmount?: true
    statusLegacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    discountPercent?: true
    finalAmount?: true
    statusLegacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    discountPercent?: true
    finalAmount?: true
    statusLegacy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    branchId: number | null
    encounterId: number
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    discountPercent: $Enums.DiscountPercent
    finalAmount: number | null
    statusLegacy: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    totalAmount?: boolean
    totalBeforeDiscount?: boolean
    discountPercent?: boolean
    finalAmount?: boolean
    statusLegacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    eBarimtReceipt?: boolean | Invoice$eBarimtReceiptArgs<ExtArgs>
    ledgerEntries?: boolean | Invoice$ledgerEntriesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Invoice$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    totalAmount?: boolean
    totalBeforeDiscount?: boolean
    discountPercent?: boolean
    finalAmount?: boolean
    statusLegacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    totalAmount?: boolean
    totalBeforeDiscount?: boolean
    discountPercent?: boolean
    finalAmount?: boolean
    statusLegacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    eBarimtReceipt?: boolean | Invoice$eBarimtReceiptArgs<ExtArgs>
    ledgerEntries?: boolean | Invoice$ledgerEntriesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Invoice$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      encounter: Prisma.$EncounterPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs> | null
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      eBarimtReceipt: Prisma.$EBarimtReceiptPayload<ExtArgs> | null
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      employeeBenefitUsages: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number | null
      encounterId: number
      patientId: number | null
      totalAmount: number | null
      totalBeforeDiscount: number | null
      discountPercent: $Enums.DiscountPercent
      finalAmount: number | null
      statusLegacy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Invoice$branchArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends Invoice$patientArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    eBarimtReceipt<T extends Invoice$eBarimtReceiptArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$eBarimtReceiptArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ledgerEntries<T extends Invoice$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    employeeBenefitUsages<T extends Invoice$employeeBenefitUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$employeeBenefitUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly branchId: FieldRef<"Invoice", 'Int'>
    readonly encounterId: FieldRef<"Invoice", 'Int'>
    readonly patientId: FieldRef<"Invoice", 'Int'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly totalBeforeDiscount: FieldRef<"Invoice", 'Float'>
    readonly discountPercent: FieldRef<"Invoice", 'DiscountPercent'>
    readonly finalAmount: FieldRef<"Invoice", 'Float'>
    readonly statusLegacy: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.branch
   */
  export type Invoice$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Invoice.patient
   */
  export type Invoice$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.eBarimtReceipt
   */
  export type Invoice$eBarimtReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    where?: EBarimtReceiptWhereInput
  }

  /**
   * Invoice.ledgerEntries
   */
  export type Invoice$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.employeeBenefitUsages
   */
  export type Invoice$employeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    serviceId: number | null
    productId: number | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    serviceId: number | null
    productId: number | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemType: $Enums.InvoiceItemType | null
    serviceId: number | null
    productId: number | null
    procedureCode: string | null
    name: string | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
    createdAt: Date | null
    source: $Enums.InvoiceItemSource | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemType: $Enums.InvoiceItemType | null
    serviceId: number | null
    productId: number | null
    procedureCode: string | null
    name: string | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
    createdAt: Date | null
    source: $Enums.InvoiceItemSource | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemType: number
    serviceId: number
    productId: number
    procedureCode: number
    name: number
    unitPrice: number
    quantity: number
    lineTotal: number
    createdAt: number
    source: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    productId?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    productId?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    serviceId?: true
    productId?: true
    procedureCode?: true
    name?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
    createdAt?: true
    source?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    serviceId?: true
    productId?: true
    procedureCode?: true
    name?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
    createdAt?: true
    source?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    serviceId?: true
    productId?: true
    procedureCode?: true
    name?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
    createdAt?: true
    source?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId: number | null
    productId: number | null
    procedureCode: string | null
    name: string
    unitPrice: number
    quantity: number
    lineTotal: number
    createdAt: Date
    source: $Enums.InvoiceItemSource
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    procedureCode?: boolean
    name?: boolean
    unitPrice?: boolean
    quantity?: boolean
    lineTotal?: boolean
    createdAt?: boolean
    source?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    procedureCode?: boolean
    name?: boolean
    unitPrice?: boolean
    quantity?: boolean
    lineTotal?: boolean
    createdAt?: boolean
    source?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    procedureCode?: boolean
    name?: boolean
    unitPrice?: boolean
    quantity?: boolean
    lineTotal?: boolean
    createdAt?: boolean
    source?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      procedure: Prisma.$ProcedurePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      itemType: $Enums.InvoiceItemType
      serviceId: number | null
      productId: number | null
      procedureCode: string | null
      name: string
      unitPrice: number
      quantity: number
      lineTotal: number
      createdAt: Date
      source: $Enums.InvoiceItemSource
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends InvoiceItem$serviceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product<T extends InvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    procedure<T extends InvoiceItem$procedureArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$procedureArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'Int'>
    readonly itemType: FieldRef<"InvoiceItem", 'InvoiceItemType'>
    readonly serviceId: FieldRef<"InvoiceItem", 'Int'>
    readonly productId: FieldRef<"InvoiceItem", 'Int'>
    readonly procedureCode: FieldRef<"InvoiceItem", 'String'>
    readonly name: FieldRef<"InvoiceItem", 'String'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Float'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly lineTotal: FieldRef<"InvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
    readonly source: FieldRef<"InvoiceItem", 'InvoiceItemSource'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem.service
   */
  export type InvoiceItem$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * InvoiceItem.product
   */
  export type InvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * InvoiceItem.procedure
   */
  export type InvoiceItem$procedureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
    method: string | null
    qpayTxnId: string | null
    timestamp: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
    method: string | null
    qpayTxnId: string | null
    timestamp: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    amount: number
    method: number
    qpayTxnId: number
    timestamp: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    method?: true
    qpayTxnId?: true
    timestamp?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    method?: true
    qpayTxnId?: true
    timestamp?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    method?: true
    qpayTxnId?: true
    timestamp?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    invoiceId: number
    amount: number
    method: string
    qpayTxnId: string | null
    timestamp: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    qpayTxnId?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    qpayTxnId?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    qpayTxnId?: boolean
    timestamp?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      amount: number
      method: string
      qpayTxnId: string | null
      timestamp: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly invoiceId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly qpayTxnId: FieldRef<"Payment", 'String'>
    readonly timestamp: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model EBarimtReceipt
   */

  export type AggregateEBarimtReceipt = {
    _count: EBarimtReceiptCountAggregateOutputType | null
    _avg: EBarimtReceiptAvgAggregateOutputType | null
    _sum: EBarimtReceiptSumAggregateOutputType | null
    _min: EBarimtReceiptMinAggregateOutputType | null
    _max: EBarimtReceiptMaxAggregateOutputType | null
  }

  export type EBarimtReceiptAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
  }

  export type EBarimtReceiptSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
  }

  export type EBarimtReceiptMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    receiptNumber: string | null
    timestamp: Date | null
  }

  export type EBarimtReceiptMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    receiptNumber: string | null
    timestamp: Date | null
  }

  export type EBarimtReceiptCountAggregateOutputType = {
    id: number
    invoiceId: number
    receiptNumber: number
    timestamp: number
    _all: number
  }


  export type EBarimtReceiptAvgAggregateInputType = {
    id?: true
    invoiceId?: true
  }

  export type EBarimtReceiptSumAggregateInputType = {
    id?: true
    invoiceId?: true
  }

  export type EBarimtReceiptMinAggregateInputType = {
    id?: true
    invoiceId?: true
    receiptNumber?: true
    timestamp?: true
  }

  export type EBarimtReceiptMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    receiptNumber?: true
    timestamp?: true
  }

  export type EBarimtReceiptCountAggregateInputType = {
    id?: true
    invoiceId?: true
    receiptNumber?: true
    timestamp?: true
    _all?: true
  }

  export type EBarimtReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBarimtReceipt to aggregate.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EBarimtReceipts
    **/
    _count?: true | EBarimtReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EBarimtReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EBarimtReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EBarimtReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EBarimtReceiptMaxAggregateInputType
  }

  export type GetEBarimtReceiptAggregateType<T extends EBarimtReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateEBarimtReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEBarimtReceipt[P]>
      : GetScalarType<T[P], AggregateEBarimtReceipt[P]>
  }




  export type EBarimtReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EBarimtReceiptWhereInput
    orderBy?: EBarimtReceiptOrderByWithAggregationInput | EBarimtReceiptOrderByWithAggregationInput[]
    by: EBarimtReceiptScalarFieldEnum[] | EBarimtReceiptScalarFieldEnum
    having?: EBarimtReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EBarimtReceiptCountAggregateInputType | true
    _avg?: EBarimtReceiptAvgAggregateInputType
    _sum?: EBarimtReceiptSumAggregateInputType
    _min?: EBarimtReceiptMinAggregateInputType
    _max?: EBarimtReceiptMaxAggregateInputType
  }

  export type EBarimtReceiptGroupByOutputType = {
    id: number
    invoiceId: number
    receiptNumber: string
    timestamp: Date
    _count: EBarimtReceiptCountAggregateOutputType | null
    _avg: EBarimtReceiptAvgAggregateOutputType | null
    _sum: EBarimtReceiptSumAggregateOutputType | null
    _min: EBarimtReceiptMinAggregateOutputType | null
    _max: EBarimtReceiptMaxAggregateOutputType | null
  }

  type GetEBarimtReceiptGroupByPayload<T extends EBarimtReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EBarimtReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EBarimtReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EBarimtReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], EBarimtReceiptGroupByOutputType[P]>
        }
      >
    >


  export type EBarimtReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    receiptNumber?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eBarimtReceipt"]>

  export type EBarimtReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    receiptNumber?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eBarimtReceipt"]>

  export type EBarimtReceiptSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    receiptNumber?: boolean
    timestamp?: boolean
  }

  export type EBarimtReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type EBarimtReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $EBarimtReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EBarimtReceipt"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      receiptNumber: string
      timestamp: Date
    }, ExtArgs["result"]["eBarimtReceipt"]>
    composites: {}
  }

  type EBarimtReceiptGetPayload<S extends boolean | null | undefined | EBarimtReceiptDefaultArgs> = $Result.GetResult<Prisma.$EBarimtReceiptPayload, S>

  type EBarimtReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EBarimtReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EBarimtReceiptCountAggregateInputType | true
    }

  export interface EBarimtReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EBarimtReceipt'], meta: { name: 'EBarimtReceipt' } }
    /**
     * Find zero or one EBarimtReceipt that matches the filter.
     * @param {EBarimtReceiptFindUniqueArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EBarimtReceiptFindUniqueArgs>(args: SelectSubset<T, EBarimtReceiptFindUniqueArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EBarimtReceipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EBarimtReceiptFindUniqueOrThrowArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EBarimtReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, EBarimtReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EBarimtReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptFindFirstArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EBarimtReceiptFindFirstArgs>(args?: SelectSubset<T, EBarimtReceiptFindFirstArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EBarimtReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptFindFirstOrThrowArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EBarimtReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, EBarimtReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EBarimtReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EBarimtReceipts
     * const eBarimtReceipts = await prisma.eBarimtReceipt.findMany()
     * 
     * // Get first 10 EBarimtReceipts
     * const eBarimtReceipts = await prisma.eBarimtReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eBarimtReceiptWithIdOnly = await prisma.eBarimtReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EBarimtReceiptFindManyArgs>(args?: SelectSubset<T, EBarimtReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EBarimtReceipt.
     * @param {EBarimtReceiptCreateArgs} args - Arguments to create a EBarimtReceipt.
     * @example
     * // Create one EBarimtReceipt
     * const EBarimtReceipt = await prisma.eBarimtReceipt.create({
     *   data: {
     *     // ... data to create a EBarimtReceipt
     *   }
     * })
     * 
     */
    create<T extends EBarimtReceiptCreateArgs>(args: SelectSubset<T, EBarimtReceiptCreateArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EBarimtReceipts.
     * @param {EBarimtReceiptCreateManyArgs} args - Arguments to create many EBarimtReceipts.
     * @example
     * // Create many EBarimtReceipts
     * const eBarimtReceipt = await prisma.eBarimtReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EBarimtReceiptCreateManyArgs>(args?: SelectSubset<T, EBarimtReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EBarimtReceipts and returns the data saved in the database.
     * @param {EBarimtReceiptCreateManyAndReturnArgs} args - Arguments to create many EBarimtReceipts.
     * @example
     * // Create many EBarimtReceipts
     * const eBarimtReceipt = await prisma.eBarimtReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EBarimtReceipts and only return the `id`
     * const eBarimtReceiptWithIdOnly = await prisma.eBarimtReceipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EBarimtReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, EBarimtReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EBarimtReceipt.
     * @param {EBarimtReceiptDeleteArgs} args - Arguments to delete one EBarimtReceipt.
     * @example
     * // Delete one EBarimtReceipt
     * const EBarimtReceipt = await prisma.eBarimtReceipt.delete({
     *   where: {
     *     // ... filter to delete one EBarimtReceipt
     *   }
     * })
     * 
     */
    delete<T extends EBarimtReceiptDeleteArgs>(args: SelectSubset<T, EBarimtReceiptDeleteArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EBarimtReceipt.
     * @param {EBarimtReceiptUpdateArgs} args - Arguments to update one EBarimtReceipt.
     * @example
     * // Update one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EBarimtReceiptUpdateArgs>(args: SelectSubset<T, EBarimtReceiptUpdateArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EBarimtReceipts.
     * @param {EBarimtReceiptDeleteManyArgs} args - Arguments to filter EBarimtReceipts to delete.
     * @example
     * // Delete a few EBarimtReceipts
     * const { count } = await prisma.eBarimtReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EBarimtReceiptDeleteManyArgs>(args?: SelectSubset<T, EBarimtReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EBarimtReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EBarimtReceipts
     * const eBarimtReceipt = await prisma.eBarimtReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EBarimtReceiptUpdateManyArgs>(args: SelectSubset<T, EBarimtReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EBarimtReceipt.
     * @param {EBarimtReceiptUpsertArgs} args - Arguments to update or create a EBarimtReceipt.
     * @example
     * // Update or create a EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.upsert({
     *   create: {
     *     // ... data to create a EBarimtReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EBarimtReceipt we want to update
     *   }
     * })
     */
    upsert<T extends EBarimtReceiptUpsertArgs>(args: SelectSubset<T, EBarimtReceiptUpsertArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EBarimtReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptCountArgs} args - Arguments to filter EBarimtReceipts to count.
     * @example
     * // Count the number of EBarimtReceipts
     * const count = await prisma.eBarimtReceipt.count({
     *   where: {
     *     // ... the filter for the EBarimtReceipts we want to count
     *   }
     * })
    **/
    count<T extends EBarimtReceiptCountArgs>(
      args?: Subset<T, EBarimtReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EBarimtReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EBarimtReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EBarimtReceiptAggregateArgs>(args: Subset<T, EBarimtReceiptAggregateArgs>): Prisma.PrismaPromise<GetEBarimtReceiptAggregateType<T>>

    /**
     * Group by EBarimtReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EBarimtReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EBarimtReceiptGroupByArgs['orderBy'] }
        : { orderBy?: EBarimtReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EBarimtReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEBarimtReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EBarimtReceipt model
   */
  readonly fields: EBarimtReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EBarimtReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EBarimtReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EBarimtReceipt model
   */ 
  interface EBarimtReceiptFieldRefs {
    readonly id: FieldRef<"EBarimtReceipt", 'Int'>
    readonly invoiceId: FieldRef<"EBarimtReceipt", 'Int'>
    readonly receiptNumber: FieldRef<"EBarimtReceipt", 'String'>
    readonly timestamp: FieldRef<"EBarimtReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EBarimtReceipt findUnique
   */
  export type EBarimtReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt findUniqueOrThrow
   */
  export type EBarimtReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt findFirst
   */
  export type EBarimtReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBarimtReceipts.
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBarimtReceipts.
     */
    distinct?: EBarimtReceiptScalarFieldEnum | EBarimtReceiptScalarFieldEnum[]
  }

  /**
   * EBarimtReceipt findFirstOrThrow
   */
  export type EBarimtReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBarimtReceipts.
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBarimtReceipts.
     */
    distinct?: EBarimtReceiptScalarFieldEnum | EBarimtReceiptScalarFieldEnum[]
  }

  /**
   * EBarimtReceipt findMany
   */
  export type EBarimtReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipts to fetch.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EBarimtReceipts.
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    distinct?: EBarimtReceiptScalarFieldEnum | EBarimtReceiptScalarFieldEnum[]
  }

  /**
   * EBarimtReceipt create
   */
  export type EBarimtReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a EBarimtReceipt.
     */
    data: XOR<EBarimtReceiptCreateInput, EBarimtReceiptUncheckedCreateInput>
  }

  /**
   * EBarimtReceipt createMany
   */
  export type EBarimtReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EBarimtReceipts.
     */
    data: EBarimtReceiptCreateManyInput | EBarimtReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EBarimtReceipt createManyAndReturn
   */
  export type EBarimtReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EBarimtReceipts.
     */
    data: EBarimtReceiptCreateManyInput | EBarimtReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EBarimtReceipt update
   */
  export type EBarimtReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a EBarimtReceipt.
     */
    data: XOR<EBarimtReceiptUpdateInput, EBarimtReceiptUncheckedUpdateInput>
    /**
     * Choose, which EBarimtReceipt to update.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt updateMany
   */
  export type EBarimtReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EBarimtReceipts.
     */
    data: XOR<EBarimtReceiptUpdateManyMutationInput, EBarimtReceiptUncheckedUpdateManyInput>
    /**
     * Filter which EBarimtReceipts to update
     */
    where?: EBarimtReceiptWhereInput
  }

  /**
   * EBarimtReceipt upsert
   */
  export type EBarimtReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the EBarimtReceipt to update in case it exists.
     */
    where: EBarimtReceiptWhereUniqueInput
    /**
     * In case the EBarimtReceipt found by the `where` argument doesn't exist, create a new EBarimtReceipt with this data.
     */
    create: XOR<EBarimtReceiptCreateInput, EBarimtReceiptUncheckedCreateInput>
    /**
     * In case the EBarimtReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EBarimtReceiptUpdateInput, EBarimtReceiptUncheckedUpdateInput>
  }

  /**
   * EBarimtReceipt delete
   */
  export type EBarimtReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter which EBarimtReceipt to delete.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt deleteMany
   */
  export type EBarimtReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBarimtReceipts to delete
     */
    where?: EBarimtReceiptWhereInput
  }

  /**
   * EBarimtReceipt without action
   */
  export type EBarimtReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    type: $Enums.LedgerEntryType | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
    createdAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    type: $Enums.LedgerEntryType | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
    createdAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    branchId: number
    patientId: number
    invoiceId: number
    type: number
    amount: number
    createdById: number
    approvedById: number
    approvalCodeId: number
    employeeVoucherId: number
    meta: number
    createdAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    type?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
    createdAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    type?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
    createdAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    type?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: number
    branchId: number
    patientId: number
    invoiceId: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
    meta: JsonValue | null
    createdAt: Date
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    invoiceId?: boolean
    type?: boolean
    amount?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvalCodeId?: boolean
    employeeVoucherId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    invoiceId?: boolean
    type?: boolean
    amount?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvalCodeId?: boolean
    employeeVoucherId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    invoiceId?: boolean
    type?: boolean
    amount?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvalCodeId?: boolean
    employeeVoucherId?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      approvalCode: Prisma.$AuthorizationCodePayload<ExtArgs> | null
      employeeVoucher: Prisma.$EmployeeVoucherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      patientId: number
      invoiceId: number | null
      type: $Enums.LedgerEntryType
      amount: number
      createdById: number
      approvedById: number | null
      approvalCodeId: number | null
      employeeVoucherId: number | null
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends LedgerEntry$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends LedgerEntry$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    approvalCode<T extends LedgerEntry$approvalCodeArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$approvalCodeArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employeeVoucher<T extends LedgerEntry$employeeVoucherArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$employeeVoucherArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */ 
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'Int'>
    readonly branchId: FieldRef<"LedgerEntry", 'Int'>
    readonly patientId: FieldRef<"LedgerEntry", 'Int'>
    readonly invoiceId: FieldRef<"LedgerEntry", 'Int'>
    readonly type: FieldRef<"LedgerEntry", 'LedgerEntryType'>
    readonly amount: FieldRef<"LedgerEntry", 'Float'>
    readonly createdById: FieldRef<"LedgerEntry", 'Int'>
    readonly approvedById: FieldRef<"LedgerEntry", 'Int'>
    readonly approvalCodeId: FieldRef<"LedgerEntry", 'Int'>
    readonly employeeVoucherId: FieldRef<"LedgerEntry", 'Int'>
    readonly meta: FieldRef<"LedgerEntry", 'Json'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry.invoice
   */
  export type LedgerEntry$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * LedgerEntry.approvedBy
   */
  export type LedgerEntry$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LedgerEntry.approvalCode
   */
  export type LedgerEntry$approvalCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    where?: AuthorizationCodeWhereInput
  }

  /**
   * LedgerEntry.employeeVoucher
   */
  export type LedgerEntry$employeeVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model AuthorizationCode
   */

  export type AggregateAuthorizationCode = {
    _count: AuthorizationCodeCountAggregateOutputType | null
    _avg: AuthorizationCodeAvgAggregateOutputType | null
    _sum: AuthorizationCodeSumAggregateOutputType | null
    _min: AuthorizationCodeMinAggregateOutputType | null
    _max: AuthorizationCodeMaxAggregateOutputType | null
  }

  export type AuthorizationCodeAvgAggregateOutputType = {
    id: number | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
  }

  export type AuthorizationCodeSumAggregateOutputType = {
    id: number | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
  }

  export type AuthorizationCodeMinAggregateOutputType = {
    id: number | null
    code: string | null
    purpose: string | null
    isEnabled: boolean | null
    expiresAt: Date | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorizationCodeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    purpose: string | null
    isEnabled: boolean | null
    expiresAt: Date | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorizationCodeCountAggregateOutputType = {
    id: number
    code: number
    purpose: number
    isEnabled: number
    expiresAt: number
    maxUses: number
    usedCount: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthorizationCodeAvgAggregateInputType = {
    id?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
  }

  export type AuthorizationCodeSumAggregateInputType = {
    id?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
  }

  export type AuthorizationCodeMinAggregateInputType = {
    id?: true
    code?: true
    purpose?: true
    isEnabled?: true
    expiresAt?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorizationCodeMaxAggregateInputType = {
    id?: true
    code?: true
    purpose?: true
    isEnabled?: true
    expiresAt?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorizationCodeCountAggregateInputType = {
    id?: true
    code?: true
    purpose?: true
    isEnabled?: true
    expiresAt?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorizationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthorizationCode to aggregate.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthorizationCodes
    **/
    _count?: true | AuthorizationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorizationCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorizationCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorizationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorizationCodeMaxAggregateInputType
  }

  export type GetAuthorizationCodeAggregateType<T extends AuthorizationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorizationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorizationCode[P]>
      : GetScalarType<T[P], AggregateAuthorizationCode[P]>
  }




  export type AuthorizationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorizationCodeWhereInput
    orderBy?: AuthorizationCodeOrderByWithAggregationInput | AuthorizationCodeOrderByWithAggregationInput[]
    by: AuthorizationCodeScalarFieldEnum[] | AuthorizationCodeScalarFieldEnum
    having?: AuthorizationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorizationCodeCountAggregateInputType | true
    _avg?: AuthorizationCodeAvgAggregateInputType
    _sum?: AuthorizationCodeSumAggregateInputType
    _min?: AuthorizationCodeMinAggregateInputType
    _max?: AuthorizationCodeMaxAggregateInputType
  }

  export type AuthorizationCodeGroupByOutputType = {
    id: number
    code: string
    purpose: string
    isEnabled: boolean
    expiresAt: Date | null
    maxUses: number | null
    usedCount: number
    createdById: number
    createdAt: Date
    updatedAt: Date
    _count: AuthorizationCodeCountAggregateOutputType | null
    _avg: AuthorizationCodeAvgAggregateOutputType | null
    _sum: AuthorizationCodeSumAggregateOutputType | null
    _min: AuthorizationCodeMinAggregateOutputType | null
    _max: AuthorizationCodeMaxAggregateOutputType | null
  }

  type GetAuthorizationCodeGroupByPayload<T extends AuthorizationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorizationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorizationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorizationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorizationCodeGroupByOutputType[P]>
        }
      >
    >


  export type AuthorizationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    purpose?: boolean
    isEnabled?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    usedCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | AuthorizationCode$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authorizationCode"]>

  export type AuthorizationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    purpose?: boolean
    isEnabled?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    usedCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authorizationCode"]>

  export type AuthorizationCodeSelectScalar = {
    id?: boolean
    code?: boolean
    purpose?: boolean
    isEnabled?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    usedCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthorizationCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | AuthorizationCode$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorizationCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthorizationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthorizationCode"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      purpose: string
      isEnabled: boolean
      expiresAt: Date | null
      maxUses: number | null
      usedCount: number
      createdById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authorizationCode"]>
    composites: {}
  }

  type AuthorizationCodeGetPayload<S extends boolean | null | undefined | AuthorizationCodeDefaultArgs> = $Result.GetResult<Prisma.$AuthorizationCodePayload, S>

  type AuthorizationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthorizationCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthorizationCodeCountAggregateInputType | true
    }

  export interface AuthorizationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthorizationCode'], meta: { name: 'AuthorizationCode' } }
    /**
     * Find zero or one AuthorizationCode that matches the filter.
     * @param {AuthorizationCodeFindUniqueArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorizationCodeFindUniqueArgs>(args: SelectSubset<T, AuthorizationCodeFindUniqueArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuthorizationCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthorizationCodeFindUniqueOrThrowArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorizationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuthorizationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeFindFirstArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorizationCodeFindFirstArgs>(args?: SelectSubset<T, AuthorizationCodeFindFirstArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuthorizationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeFindFirstOrThrowArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorizationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorizationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuthorizationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorizationCodes
     * const authorizationCodes = await prisma.authorizationCode.findMany()
     * 
     * // Get first 10 AuthorizationCodes
     * const authorizationCodes = await prisma.authorizationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorizationCodeWithIdOnly = await prisma.authorizationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorizationCodeFindManyArgs>(args?: SelectSubset<T, AuthorizationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuthorizationCode.
     * @param {AuthorizationCodeCreateArgs} args - Arguments to create a AuthorizationCode.
     * @example
     * // Create one AuthorizationCode
     * const AuthorizationCode = await prisma.authorizationCode.create({
     *   data: {
     *     // ... data to create a AuthorizationCode
     *   }
     * })
     * 
     */
    create<T extends AuthorizationCodeCreateArgs>(args: SelectSubset<T, AuthorizationCodeCreateArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuthorizationCodes.
     * @param {AuthorizationCodeCreateManyArgs} args - Arguments to create many AuthorizationCodes.
     * @example
     * // Create many AuthorizationCodes
     * const authorizationCode = await prisma.authorizationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorizationCodeCreateManyArgs>(args?: SelectSubset<T, AuthorizationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthorizationCodes and returns the data saved in the database.
     * @param {AuthorizationCodeCreateManyAndReturnArgs} args - Arguments to create many AuthorizationCodes.
     * @example
     * // Create many AuthorizationCodes
     * const authorizationCode = await prisma.authorizationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthorizationCodes and only return the `id`
     * const authorizationCodeWithIdOnly = await prisma.authorizationCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorizationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorizationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuthorizationCode.
     * @param {AuthorizationCodeDeleteArgs} args - Arguments to delete one AuthorizationCode.
     * @example
     * // Delete one AuthorizationCode
     * const AuthorizationCode = await prisma.authorizationCode.delete({
     *   where: {
     *     // ... filter to delete one AuthorizationCode
     *   }
     * })
     * 
     */
    delete<T extends AuthorizationCodeDeleteArgs>(args: SelectSubset<T, AuthorizationCodeDeleteArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuthorizationCode.
     * @param {AuthorizationCodeUpdateArgs} args - Arguments to update one AuthorizationCode.
     * @example
     * // Update one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorizationCodeUpdateArgs>(args: SelectSubset<T, AuthorizationCodeUpdateArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuthorizationCodes.
     * @param {AuthorizationCodeDeleteManyArgs} args - Arguments to filter AuthorizationCodes to delete.
     * @example
     * // Delete a few AuthorizationCodes
     * const { count } = await prisma.authorizationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorizationCodeDeleteManyArgs>(args?: SelectSubset<T, AuthorizationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorizationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorizationCodes
     * const authorizationCode = await prisma.authorizationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorizationCodeUpdateManyArgs>(args: SelectSubset<T, AuthorizationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorizationCode.
     * @param {AuthorizationCodeUpsertArgs} args - Arguments to update or create a AuthorizationCode.
     * @example
     * // Update or create a AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.upsert({
     *   create: {
     *     // ... data to create a AuthorizationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorizationCode we want to update
     *   }
     * })
     */
    upsert<T extends AuthorizationCodeUpsertArgs>(args: SelectSubset<T, AuthorizationCodeUpsertArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuthorizationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeCountArgs} args - Arguments to filter AuthorizationCodes to count.
     * @example
     * // Count the number of AuthorizationCodes
     * const count = await prisma.authorizationCode.count({
     *   where: {
     *     // ... the filter for the AuthorizationCodes we want to count
     *   }
     * })
    **/
    count<T extends AuthorizationCodeCountArgs>(
      args?: Subset<T, AuthorizationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorizationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorizationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorizationCodeAggregateArgs>(args: Subset<T, AuthorizationCodeAggregateArgs>): Prisma.PrismaPromise<GetAuthorizationCodeAggregateType<T>>

    /**
     * Group by AuthorizationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorizationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorizationCodeGroupByArgs['orderBy'] }
        : { orderBy?: AuthorizationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorizationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorizationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthorizationCode model
   */
  readonly fields: AuthorizationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthorizationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorizationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerEntries<T extends AuthorizationCode$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, AuthorizationCode$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthorizationCode model
   */ 
  interface AuthorizationCodeFieldRefs {
    readonly id: FieldRef<"AuthorizationCode", 'Int'>
    readonly code: FieldRef<"AuthorizationCode", 'String'>
    readonly purpose: FieldRef<"AuthorizationCode", 'String'>
    readonly isEnabled: FieldRef<"AuthorizationCode", 'Boolean'>
    readonly expiresAt: FieldRef<"AuthorizationCode", 'DateTime'>
    readonly maxUses: FieldRef<"AuthorizationCode", 'Int'>
    readonly usedCount: FieldRef<"AuthorizationCode", 'Int'>
    readonly createdById: FieldRef<"AuthorizationCode", 'Int'>
    readonly createdAt: FieldRef<"AuthorizationCode", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthorizationCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthorizationCode findUnique
   */
  export type AuthorizationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode findUniqueOrThrow
   */
  export type AuthorizationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode findFirst
   */
  export type AuthorizationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorizationCodes.
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorizationCodes.
     */
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * AuthorizationCode findFirstOrThrow
   */
  export type AuthorizationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorizationCodes.
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorizationCodes.
     */
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * AuthorizationCode findMany
   */
  export type AuthorizationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCodes to fetch.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthorizationCodes.
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * AuthorizationCode create
   */
  export type AuthorizationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthorizationCode.
     */
    data: XOR<AuthorizationCodeCreateInput, AuthorizationCodeUncheckedCreateInput>
  }

  /**
   * AuthorizationCode createMany
   */
  export type AuthorizationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthorizationCodes.
     */
    data: AuthorizationCodeCreateManyInput | AuthorizationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthorizationCode createManyAndReturn
   */
  export type AuthorizationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuthorizationCodes.
     */
    data: AuthorizationCodeCreateManyInput | AuthorizationCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthorizationCode update
   */
  export type AuthorizationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthorizationCode.
     */
    data: XOR<AuthorizationCodeUpdateInput, AuthorizationCodeUncheckedUpdateInput>
    /**
     * Choose, which AuthorizationCode to update.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode updateMany
   */
  export type AuthorizationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthorizationCodes.
     */
    data: XOR<AuthorizationCodeUpdateManyMutationInput, AuthorizationCodeUncheckedUpdateManyInput>
    /**
     * Filter which AuthorizationCodes to update
     */
    where?: AuthorizationCodeWhereInput
  }

  /**
   * AuthorizationCode upsert
   */
  export type AuthorizationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthorizationCode to update in case it exists.
     */
    where: AuthorizationCodeWhereUniqueInput
    /**
     * In case the AuthorizationCode found by the `where` argument doesn't exist, create a new AuthorizationCode with this data.
     */
    create: XOR<AuthorizationCodeCreateInput, AuthorizationCodeUncheckedCreateInput>
    /**
     * In case the AuthorizationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorizationCodeUpdateInput, AuthorizationCodeUncheckedUpdateInput>
  }

  /**
   * AuthorizationCode delete
   */
  export type AuthorizationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter which AuthorizationCode to delete.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode deleteMany
   */
  export type AuthorizationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthorizationCodes to delete
     */
    where?: AuthorizationCodeWhereInput
  }

  /**
   * AuthorizationCode.ledgerEntries
   */
  export type AuthorizationCode$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * AuthorizationCode without action
   */
  export type AuthorizationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeVoucher
   */

  export type AggregateEmployeeVoucher = {
    _count: EmployeeVoucherCountAggregateOutputType | null
    _avg: EmployeeVoucherAvgAggregateOutputType | null
    _sum: EmployeeVoucherSumAggregateOutputType | null
    _min: EmployeeVoucherMinAggregateOutputType | null
    _max: EmployeeVoucherMaxAggregateOutputType | null
  }

  export type EmployeeVoucherAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    balanceCap: number | null
    usedAmount: number | null
    createdById: number | null
  }

  export type EmployeeVoucherSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    balanceCap: number | null
    usedAmount: number | null
    createdById: number | null
  }

  export type EmployeeVoucherMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    code: string | null
    status: $Enums.EmployeeVoucherStatus | null
    balanceCap: number | null
    usedAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
  }

  export type EmployeeVoucherMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    code: string | null
    status: $Enums.EmployeeVoucherStatus | null
    balanceCap: number | null
    usedAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
  }

  export type EmployeeVoucherCountAggregateOutputType = {
    id: number
    branchId: number
    employeeId: number
    code: number
    status: number
    balanceCap: number
    usedAmount: number
    eligibility: number
    allowedPatientIds: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type EmployeeVoucherAvgAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    balanceCap?: true
    usedAmount?: true
    createdById?: true
  }

  export type EmployeeVoucherSumAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    balanceCap?: true
    usedAmount?: true
    createdById?: true
  }

  export type EmployeeVoucherMinAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    code?: true
    status?: true
    balanceCap?: true
    usedAmount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmployeeVoucherMaxAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    code?: true
    status?: true
    balanceCap?: true
    usedAmount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmployeeVoucherCountAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    code?: true
    status?: true
    balanceCap?: true
    usedAmount?: true
    eligibility?: true
    allowedPatientIds?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type EmployeeVoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeVoucher to aggregate.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeVouchers
    **/
    _count?: true | EmployeeVoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeVoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeVoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeVoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeVoucherMaxAggregateInputType
  }

  export type GetEmployeeVoucherAggregateType<T extends EmployeeVoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeVoucher[P]>
      : GetScalarType<T[P], AggregateEmployeeVoucher[P]>
  }




  export type EmployeeVoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithAggregationInput | EmployeeVoucherOrderByWithAggregationInput[]
    by: EmployeeVoucherScalarFieldEnum[] | EmployeeVoucherScalarFieldEnum
    having?: EmployeeVoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeVoucherCountAggregateInputType | true
    _avg?: EmployeeVoucherAvgAggregateInputType
    _sum?: EmployeeVoucherSumAggregateInputType
    _min?: EmployeeVoucherMinAggregateInputType
    _max?: EmployeeVoucherMaxAggregateInputType
  }

  export type EmployeeVoucherGroupByOutputType = {
    id: number
    branchId: number
    employeeId: number
    code: string
    status: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount: number
    eligibility: JsonValue
    allowedPatientIds: JsonValue
    createdAt: Date
    updatedAt: Date
    createdById: number
    _count: EmployeeVoucherCountAggregateOutputType | null
    _avg: EmployeeVoucherAvgAggregateOutputType | null
    _sum: EmployeeVoucherSumAggregateOutputType | null
    _min: EmployeeVoucherMinAggregateOutputType | null
    _max: EmployeeVoucherMaxAggregateOutputType | null
  }

  type GetEmployeeVoucherGroupByPayload<T extends EmployeeVoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeVoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeVoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeVoucherGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeVoucherGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeVoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    employeeId?: boolean
    code?: boolean
    status?: boolean
    balanceCap?: boolean
    usedAmount?: boolean
    eligibility?: boolean
    allowedPatientIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | EmployeeVoucher$ledgerEntriesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeVoucher"]>

  export type EmployeeVoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    employeeId?: boolean
    code?: boolean
    status?: boolean
    balanceCap?: boolean
    usedAmount?: boolean
    eligibility?: boolean
    allowedPatientIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeVoucher"]>

  export type EmployeeVoucherSelectScalar = {
    id?: boolean
    branchId?: boolean
    employeeId?: boolean
    code?: boolean
    status?: boolean
    balanceCap?: boolean
    usedAmount?: boolean
    eligibility?: boolean
    allowedPatientIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type EmployeeVoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | EmployeeVoucher$ledgerEntriesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeVoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeVoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeVoucher"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      employee: Prisma.$UserPayload<ExtArgs>
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      employeeId: number
      code: string
      status: $Enums.EmployeeVoucherStatus
      balanceCap: number
      usedAmount: number
      eligibility: Prisma.JsonValue
      allowedPatientIds: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdById: number
    }, ExtArgs["result"]["employeeVoucher"]>
    composites: {}
  }

  type EmployeeVoucherGetPayload<S extends boolean | null | undefined | EmployeeVoucherDefaultArgs> = $Result.GetResult<Prisma.$EmployeeVoucherPayload, S>

  type EmployeeVoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeVoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeVoucherCountAggregateInputType | true
    }

  export interface EmployeeVoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeVoucher'], meta: { name: 'EmployeeVoucher' } }
    /**
     * Find zero or one EmployeeVoucher that matches the filter.
     * @param {EmployeeVoucherFindUniqueArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeVoucherFindUniqueArgs>(args: SelectSubset<T, EmployeeVoucherFindUniqueArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeVoucher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeVoucherFindUniqueOrThrowArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeVoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeVoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeVoucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherFindFirstArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeVoucherFindFirstArgs>(args?: SelectSubset<T, EmployeeVoucherFindFirstArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeVoucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherFindFirstOrThrowArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeVoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeVoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeVouchers
     * const employeeVouchers = await prisma.employeeVoucher.findMany()
     * 
     * // Get first 10 EmployeeVouchers
     * const employeeVouchers = await prisma.employeeVoucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeVoucherWithIdOnly = await prisma.employeeVoucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeVoucherFindManyArgs>(args?: SelectSubset<T, EmployeeVoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeVoucher.
     * @param {EmployeeVoucherCreateArgs} args - Arguments to create a EmployeeVoucher.
     * @example
     * // Create one EmployeeVoucher
     * const EmployeeVoucher = await prisma.employeeVoucher.create({
     *   data: {
     *     // ... data to create a EmployeeVoucher
     *   }
     * })
     * 
     */
    create<T extends EmployeeVoucherCreateArgs>(args: SelectSubset<T, EmployeeVoucherCreateArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeVouchers.
     * @param {EmployeeVoucherCreateManyArgs} args - Arguments to create many EmployeeVouchers.
     * @example
     * // Create many EmployeeVouchers
     * const employeeVoucher = await prisma.employeeVoucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeVoucherCreateManyArgs>(args?: SelectSubset<T, EmployeeVoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeVouchers and returns the data saved in the database.
     * @param {EmployeeVoucherCreateManyAndReturnArgs} args - Arguments to create many EmployeeVouchers.
     * @example
     * // Create many EmployeeVouchers
     * const employeeVoucher = await prisma.employeeVoucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeVouchers and only return the `id`
     * const employeeVoucherWithIdOnly = await prisma.employeeVoucher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeVoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeVoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeVoucher.
     * @param {EmployeeVoucherDeleteArgs} args - Arguments to delete one EmployeeVoucher.
     * @example
     * // Delete one EmployeeVoucher
     * const EmployeeVoucher = await prisma.employeeVoucher.delete({
     *   where: {
     *     // ... filter to delete one EmployeeVoucher
     *   }
     * })
     * 
     */
    delete<T extends EmployeeVoucherDeleteArgs>(args: SelectSubset<T, EmployeeVoucherDeleteArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeVoucher.
     * @param {EmployeeVoucherUpdateArgs} args - Arguments to update one EmployeeVoucher.
     * @example
     * // Update one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeVoucherUpdateArgs>(args: SelectSubset<T, EmployeeVoucherUpdateArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeVouchers.
     * @param {EmployeeVoucherDeleteManyArgs} args - Arguments to filter EmployeeVouchers to delete.
     * @example
     * // Delete a few EmployeeVouchers
     * const { count } = await prisma.employeeVoucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeVoucherDeleteManyArgs>(args?: SelectSubset<T, EmployeeVoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeVouchers
     * const employeeVoucher = await prisma.employeeVoucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeVoucherUpdateManyArgs>(args: SelectSubset<T, EmployeeVoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeVoucher.
     * @param {EmployeeVoucherUpsertArgs} args - Arguments to update or create a EmployeeVoucher.
     * @example
     * // Update or create a EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.upsert({
     *   create: {
     *     // ... data to create a EmployeeVoucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeVoucher we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeVoucherUpsertArgs>(args: SelectSubset<T, EmployeeVoucherUpsertArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherCountArgs} args - Arguments to filter EmployeeVouchers to count.
     * @example
     * // Count the number of EmployeeVouchers
     * const count = await prisma.employeeVoucher.count({
     *   where: {
     *     // ... the filter for the EmployeeVouchers we want to count
     *   }
     * })
    **/
    count<T extends EmployeeVoucherCountArgs>(
      args?: Subset<T, EmployeeVoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeVoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeVoucherAggregateArgs>(args: Subset<T, EmployeeVoucherAggregateArgs>): Prisma.PrismaPromise<GetEmployeeVoucherAggregateType<T>>

    /**
     * Group by EmployeeVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeVoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeVoucherGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeVoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeVoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeVoucher model
   */
  readonly fields: EmployeeVoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeVoucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeVoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerEntries<T extends EmployeeVoucher$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeVoucher$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeVoucher model
   */ 
  interface EmployeeVoucherFieldRefs {
    readonly id: FieldRef<"EmployeeVoucher", 'Int'>
    readonly branchId: FieldRef<"EmployeeVoucher", 'Int'>
    readonly employeeId: FieldRef<"EmployeeVoucher", 'Int'>
    readonly code: FieldRef<"EmployeeVoucher", 'String'>
    readonly status: FieldRef<"EmployeeVoucher", 'EmployeeVoucherStatus'>
    readonly balanceCap: FieldRef<"EmployeeVoucher", 'Float'>
    readonly usedAmount: FieldRef<"EmployeeVoucher", 'Float'>
    readonly eligibility: FieldRef<"EmployeeVoucher", 'Json'>
    readonly allowedPatientIds: FieldRef<"EmployeeVoucher", 'Json'>
    readonly createdAt: FieldRef<"EmployeeVoucher", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeVoucher", 'DateTime'>
    readonly createdById: FieldRef<"EmployeeVoucher", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeVoucher findUnique
   */
  export type EmployeeVoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher findUniqueOrThrow
   */
  export type EmployeeVoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher findFirst
   */
  export type EmployeeVoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeVouchers.
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeVouchers.
     */
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher findFirstOrThrow
   */
  export type EmployeeVoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeVouchers.
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeVouchers.
     */
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher findMany
   */
  export type EmployeeVoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVouchers to fetch.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeVouchers.
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher create
   */
  export type EmployeeVoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeVoucher.
     */
    data: XOR<EmployeeVoucherCreateInput, EmployeeVoucherUncheckedCreateInput>
  }

  /**
   * EmployeeVoucher createMany
   */
  export type EmployeeVoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeVouchers.
     */
    data: EmployeeVoucherCreateManyInput | EmployeeVoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeVoucher createManyAndReturn
   */
  export type EmployeeVoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeVouchers.
     */
    data: EmployeeVoucherCreateManyInput | EmployeeVoucherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeVoucher update
   */
  export type EmployeeVoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeVoucher.
     */
    data: XOR<EmployeeVoucherUpdateInput, EmployeeVoucherUncheckedUpdateInput>
    /**
     * Choose, which EmployeeVoucher to update.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher updateMany
   */
  export type EmployeeVoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeVouchers.
     */
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeVouchers to update
     */
    where?: EmployeeVoucherWhereInput
  }

  /**
   * EmployeeVoucher upsert
   */
  export type EmployeeVoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeVoucher to update in case it exists.
     */
    where: EmployeeVoucherWhereUniqueInput
    /**
     * In case the EmployeeVoucher found by the `where` argument doesn't exist, create a new EmployeeVoucher with this data.
     */
    create: XOR<EmployeeVoucherCreateInput, EmployeeVoucherUncheckedCreateInput>
    /**
     * In case the EmployeeVoucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeVoucherUpdateInput, EmployeeVoucherUncheckedUpdateInput>
  }

  /**
   * EmployeeVoucher delete
   */
  export type EmployeeVoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter which EmployeeVoucher to delete.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher deleteMany
   */
  export type EmployeeVoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeVouchers to delete
     */
    where?: EmployeeVoucherWhereInput
  }

  /**
   * EmployeeVoucher.ledgerEntries
   */
  export type EmployeeVoucher$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher without action
   */
  export type EmployeeVoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    filePath: string | null
    toothCode: string | null
    type: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    filePath: string | null
    toothCode: string | null
    type: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    encounterId: number
    filePath: number
    toothCode: number
    type: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    encounterId?: true
    filePath?: true
    toothCode?: true
    type?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    encounterId?: true
    filePath?: true
    toothCode?: true
    type?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    encounterId?: true
    filePath?: true
    toothCode?: true
    type?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: number
    encounterId: number
    filePath: string
    toothCode: string | null
    type: string
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    filePath?: boolean
    toothCode?: boolean
    type?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    filePath?: boolean
    toothCode?: boolean
    type?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    encounterId?: boolean
    filePath?: boolean
    toothCode?: boolean
    type?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      filePath: string
      toothCode: string | null
      type: string
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'Int'>
    readonly encounterId: FieldRef<"Media", 'Int'>
    readonly filePath: FieldRef<"Media", 'String'>
    readonly toothCode: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model DoctorSchedule
   */

  export type AggregateDoctorSchedule = {
    _count: DoctorScheduleCountAggregateOutputType | null
    _avg: DoctorScheduleAvgAggregateOutputType | null
    _sum: DoctorScheduleSumAggregateOutputType | null
    _min: DoctorScheduleMinAggregateOutputType | null
    _max: DoctorScheduleMaxAggregateOutputType | null
  }

  export type DoctorScheduleAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorScheduleSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorScheduleMinAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type DoctorScheduleMaxAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type DoctorScheduleCountAggregateOutputType = {
    id: number
    doctorId: number
    branchId: number
    date: number
    startTime: number
    endTime: number
    note: number
    _all: number
  }


  export type DoctorScheduleAvgAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorScheduleSumAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorScheduleMinAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type DoctorScheduleMaxAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type DoctorScheduleCountAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
    _all?: true
  }

  export type DoctorScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSchedule to aggregate.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorSchedules
    **/
    _count?: true | DoctorScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorScheduleMaxAggregateInputType
  }

  export type GetDoctorScheduleAggregateType<T extends DoctorScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorSchedule[P]>
      : GetScalarType<T[P], AggregateDoctorSchedule[P]>
  }




  export type DoctorScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithAggregationInput | DoctorScheduleOrderByWithAggregationInput[]
    by: DoctorScheduleScalarFieldEnum[] | DoctorScheduleScalarFieldEnum
    having?: DoctorScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorScheduleCountAggregateInputType | true
    _avg?: DoctorScheduleAvgAggregateInputType
    _sum?: DoctorScheduleSumAggregateInputType
    _min?: DoctorScheduleMinAggregateInputType
    _max?: DoctorScheduleMaxAggregateInputType
  }

  export type DoctorScheduleGroupByOutputType = {
    id: number
    doctorId: number
    branchId: number
    date: Date
    startTime: string
    endTime: string
    note: string | null
    _count: DoctorScheduleCountAggregateOutputType | null
    _avg: DoctorScheduleAvgAggregateOutputType | null
    _sum: DoctorScheduleSumAggregateOutputType | null
    _min: DoctorScheduleMinAggregateOutputType | null
    _max: DoctorScheduleMaxAggregateOutputType | null
  }

  type GetDoctorScheduleGroupByPayload<T extends DoctorScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorScheduleGroupByOutputType[P]>
        }
      >
    >


  export type DoctorScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectScalar = {
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
  }

  export type DoctorScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type DoctorScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $DoctorSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorSchedule"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctorId: number
      branchId: number
      date: Date
      startTime: string
      endTime: string
      note: string | null
    }, ExtArgs["result"]["doctorSchedule"]>
    composites: {}
  }

  type DoctorScheduleGetPayload<S extends boolean | null | undefined | DoctorScheduleDefaultArgs> = $Result.GetResult<Prisma.$DoctorSchedulePayload, S>

  type DoctorScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorScheduleCountAggregateInputType | true
    }

  export interface DoctorScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorSchedule'], meta: { name: 'DoctorSchedule' } }
    /**
     * Find zero or one DoctorSchedule that matches the filter.
     * @param {DoctorScheduleFindUniqueArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorScheduleFindUniqueArgs>(args: SelectSubset<T, DoctorScheduleFindUniqueArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoctorSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorScheduleFindUniqueOrThrowArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoctorSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindFirstArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorScheduleFindFirstArgs>(args?: SelectSubset<T, DoctorScheduleFindFirstArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoctorSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindFirstOrThrowArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoctorSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorSchedules
     * const doctorSchedules = await prisma.doctorSchedule.findMany()
     * 
     * // Get first 10 DoctorSchedules
     * const doctorSchedules = await prisma.doctorSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorScheduleFindManyArgs>(args?: SelectSubset<T, DoctorScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoctorSchedule.
     * @param {DoctorScheduleCreateArgs} args - Arguments to create a DoctorSchedule.
     * @example
     * // Create one DoctorSchedule
     * const DoctorSchedule = await prisma.doctorSchedule.create({
     *   data: {
     *     // ... data to create a DoctorSchedule
     *   }
     * })
     * 
     */
    create<T extends DoctorScheduleCreateArgs>(args: SelectSubset<T, DoctorScheduleCreateArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoctorSchedules.
     * @param {DoctorScheduleCreateManyArgs} args - Arguments to create many DoctorSchedules.
     * @example
     * // Create many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorScheduleCreateManyArgs>(args?: SelectSubset<T, DoctorScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorSchedules and returns the data saved in the database.
     * @param {DoctorScheduleCreateManyAndReturnArgs} args - Arguments to create many DoctorSchedules.
     * @example
     * // Create many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorSchedules and only return the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoctorSchedule.
     * @param {DoctorScheduleDeleteArgs} args - Arguments to delete one DoctorSchedule.
     * @example
     * // Delete one DoctorSchedule
     * const DoctorSchedule = await prisma.doctorSchedule.delete({
     *   where: {
     *     // ... filter to delete one DoctorSchedule
     *   }
     * })
     * 
     */
    delete<T extends DoctorScheduleDeleteArgs>(args: SelectSubset<T, DoctorScheduleDeleteArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoctorSchedule.
     * @param {DoctorScheduleUpdateArgs} args - Arguments to update one DoctorSchedule.
     * @example
     * // Update one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorScheduleUpdateArgs>(args: SelectSubset<T, DoctorScheduleUpdateArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoctorSchedules.
     * @param {DoctorScheduleDeleteManyArgs} args - Arguments to filter DoctorSchedules to delete.
     * @example
     * // Delete a few DoctorSchedules
     * const { count } = await prisma.doctorSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorScheduleDeleteManyArgs>(args?: SelectSubset<T, DoctorScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorScheduleUpdateManyArgs>(args: SelectSubset<T, DoctorScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorSchedule.
     * @param {DoctorScheduleUpsertArgs} args - Arguments to update or create a DoctorSchedule.
     * @example
     * // Update or create a DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.upsert({
     *   create: {
     *     // ... data to create a DoctorSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorSchedule we want to update
     *   }
     * })
     */
    upsert<T extends DoctorScheduleUpsertArgs>(args: SelectSubset<T, DoctorScheduleUpsertArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoctorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleCountArgs} args - Arguments to filter DoctorSchedules to count.
     * @example
     * // Count the number of DoctorSchedules
     * const count = await prisma.doctorSchedule.count({
     *   where: {
     *     // ... the filter for the DoctorSchedules we want to count
     *   }
     * })
    **/
    count<T extends DoctorScheduleCountArgs>(
      args?: Subset<T, DoctorScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorScheduleAggregateArgs>(args: Subset<T, DoctorScheduleAggregateArgs>): Prisma.PrismaPromise<GetDoctorScheduleAggregateType<T>>

    /**
     * Group by DoctorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorScheduleGroupByArgs['orderBy'] }
        : { orderBy?: DoctorScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorSchedule model
   */
  readonly fields: DoctorScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorSchedule model
   */ 
  interface DoctorScheduleFieldRefs {
    readonly id: FieldRef<"DoctorSchedule", 'Int'>
    readonly doctorId: FieldRef<"DoctorSchedule", 'Int'>
    readonly branchId: FieldRef<"DoctorSchedule", 'Int'>
    readonly date: FieldRef<"DoctorSchedule", 'DateTime'>
    readonly startTime: FieldRef<"DoctorSchedule", 'String'>
    readonly endTime: FieldRef<"DoctorSchedule", 'String'>
    readonly note: FieldRef<"DoctorSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoctorSchedule findUnique
   */
  export type DoctorScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule findUniqueOrThrow
   */
  export type DoctorScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule findFirst
   */
  export type DoctorScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorSchedules.
     */
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule findFirstOrThrow
   */
  export type DoctorScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorSchedules.
     */
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule findMany
   */
  export type DoctorScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedules to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule create
   */
  export type DoctorScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorSchedule.
     */
    data: XOR<DoctorScheduleCreateInput, DoctorScheduleUncheckedCreateInput>
  }

  /**
   * DoctorSchedule createMany
   */
  export type DoctorScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorSchedules.
     */
    data: DoctorScheduleCreateManyInput | DoctorScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorSchedule createManyAndReturn
   */
  export type DoctorScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoctorSchedules.
     */
    data: DoctorScheduleCreateManyInput | DoctorScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorSchedule update
   */
  export type DoctorScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorSchedule.
     */
    data: XOR<DoctorScheduleUpdateInput, DoctorScheduleUncheckedUpdateInput>
    /**
     * Choose, which DoctorSchedule to update.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule updateMany
   */
  export type DoctorScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorSchedules.
     */
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyInput>
    /**
     * Filter which DoctorSchedules to update
     */
    where?: DoctorScheduleWhereInput
  }

  /**
   * DoctorSchedule upsert
   */
  export type DoctorScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorSchedule to update in case it exists.
     */
    where: DoctorScheduleWhereUniqueInput
    /**
     * In case the DoctorSchedule found by the `where` argument doesn't exist, create a new DoctorSchedule with this data.
     */
    create: XOR<DoctorScheduleCreateInput, DoctorScheduleUncheckedCreateInput>
    /**
     * In case the DoctorSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorScheduleUpdateInput, DoctorScheduleUncheckedUpdateInput>
  }

  /**
   * DoctorSchedule delete
   */
  export type DoctorScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter which DoctorSchedule to delete.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule deleteMany
   */
  export type DoctorScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSchedules to delete
     */
    where?: DoctorScheduleWhereInput
  }

  /**
   * DoctorSchedule without action
   */
  export type DoctorScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ReceptionSchedule
   */

  export type AggregateReceptionSchedule = {
    _count: ReceptionScheduleCountAggregateOutputType | null
    _avg: ReceptionScheduleAvgAggregateOutputType | null
    _sum: ReceptionScheduleSumAggregateOutputType | null
    _min: ReceptionScheduleMinAggregateOutputType | null
    _max: ReceptionScheduleMaxAggregateOutputType | null
  }

  export type ReceptionScheduleAvgAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionScheduleSumAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionScheduleMinAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type ReceptionScheduleMaxAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type ReceptionScheduleCountAggregateOutputType = {
    id: number
    receptionId: number
    branchId: number
    date: number
    startTime: number
    endTime: number
    note: number
    _all: number
  }


  export type ReceptionScheduleAvgAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionScheduleSumAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionScheduleMinAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type ReceptionScheduleMaxAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type ReceptionScheduleCountAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
    _all?: true
  }

  export type ReceptionScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionSchedule to aggregate.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceptionSchedules
    **/
    _count?: true | ReceptionScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceptionScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceptionScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceptionScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceptionScheduleMaxAggregateInputType
  }

  export type GetReceptionScheduleAggregateType<T extends ReceptionScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateReceptionSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceptionSchedule[P]>
      : GetScalarType<T[P], AggregateReceptionSchedule[P]>
  }




  export type ReceptionScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionScheduleWhereInput
    orderBy?: ReceptionScheduleOrderByWithAggregationInput | ReceptionScheduleOrderByWithAggregationInput[]
    by: ReceptionScheduleScalarFieldEnum[] | ReceptionScheduleScalarFieldEnum
    having?: ReceptionScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceptionScheduleCountAggregateInputType | true
    _avg?: ReceptionScheduleAvgAggregateInputType
    _sum?: ReceptionScheduleSumAggregateInputType
    _min?: ReceptionScheduleMinAggregateInputType
    _max?: ReceptionScheduleMaxAggregateInputType
  }

  export type ReceptionScheduleGroupByOutputType = {
    id: number
    receptionId: number
    branchId: number
    date: Date
    startTime: string
    endTime: string
    note: string | null
    _count: ReceptionScheduleCountAggregateOutputType | null
    _avg: ReceptionScheduleAvgAggregateOutputType | null
    _sum: ReceptionScheduleSumAggregateOutputType | null
    _min: ReceptionScheduleMinAggregateOutputType | null
    _max: ReceptionScheduleMaxAggregateOutputType | null
  }

  type GetReceptionScheduleGroupByPayload<T extends ReceptionScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceptionScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceptionScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceptionScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ReceptionScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ReceptionScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionSchedule"]>

  export type ReceptionScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionSchedule"]>

  export type ReceptionScheduleSelectScalar = {
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
  }

  export type ReceptionScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ReceptionScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ReceptionSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceptionSchedule"
    objects: {
      reception: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receptionId: number
      branchId: number
      date: Date
      startTime: string
      endTime: string
      note: string | null
    }, ExtArgs["result"]["receptionSchedule"]>
    composites: {}
  }

  type ReceptionScheduleGetPayload<S extends boolean | null | undefined | ReceptionScheduleDefaultArgs> = $Result.GetResult<Prisma.$ReceptionSchedulePayload, S>

  type ReceptionScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceptionScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceptionScheduleCountAggregateInputType | true
    }

  export interface ReceptionScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceptionSchedule'], meta: { name: 'ReceptionSchedule' } }
    /**
     * Find zero or one ReceptionSchedule that matches the filter.
     * @param {ReceptionScheduleFindUniqueArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceptionScheduleFindUniqueArgs>(args: SelectSubset<T, ReceptionScheduleFindUniqueArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReceptionSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceptionScheduleFindUniqueOrThrowArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceptionScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceptionScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReceptionSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleFindFirstArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceptionScheduleFindFirstArgs>(args?: SelectSubset<T, ReceptionScheduleFindFirstArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReceptionSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleFindFirstOrThrowArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceptionScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceptionScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReceptionSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceptionSchedules
     * const receptionSchedules = await prisma.receptionSchedule.findMany()
     * 
     * // Get first 10 ReceptionSchedules
     * const receptionSchedules = await prisma.receptionSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receptionScheduleWithIdOnly = await prisma.receptionSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceptionScheduleFindManyArgs>(args?: SelectSubset<T, ReceptionScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReceptionSchedule.
     * @param {ReceptionScheduleCreateArgs} args - Arguments to create a ReceptionSchedule.
     * @example
     * // Create one ReceptionSchedule
     * const ReceptionSchedule = await prisma.receptionSchedule.create({
     *   data: {
     *     // ... data to create a ReceptionSchedule
     *   }
     * })
     * 
     */
    create<T extends ReceptionScheduleCreateArgs>(args: SelectSubset<T, ReceptionScheduleCreateArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReceptionSchedules.
     * @param {ReceptionScheduleCreateManyArgs} args - Arguments to create many ReceptionSchedules.
     * @example
     * // Create many ReceptionSchedules
     * const receptionSchedule = await prisma.receptionSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceptionScheduleCreateManyArgs>(args?: SelectSubset<T, ReceptionScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceptionSchedules and returns the data saved in the database.
     * @param {ReceptionScheduleCreateManyAndReturnArgs} args - Arguments to create many ReceptionSchedules.
     * @example
     * // Create many ReceptionSchedules
     * const receptionSchedule = await prisma.receptionSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceptionSchedules and only return the `id`
     * const receptionScheduleWithIdOnly = await prisma.receptionSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceptionScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceptionScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReceptionSchedule.
     * @param {ReceptionScheduleDeleteArgs} args - Arguments to delete one ReceptionSchedule.
     * @example
     * // Delete one ReceptionSchedule
     * const ReceptionSchedule = await prisma.receptionSchedule.delete({
     *   where: {
     *     // ... filter to delete one ReceptionSchedule
     *   }
     * })
     * 
     */
    delete<T extends ReceptionScheduleDeleteArgs>(args: SelectSubset<T, ReceptionScheduleDeleteArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReceptionSchedule.
     * @param {ReceptionScheduleUpdateArgs} args - Arguments to update one ReceptionSchedule.
     * @example
     * // Update one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceptionScheduleUpdateArgs>(args: SelectSubset<T, ReceptionScheduleUpdateArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReceptionSchedules.
     * @param {ReceptionScheduleDeleteManyArgs} args - Arguments to filter ReceptionSchedules to delete.
     * @example
     * // Delete a few ReceptionSchedules
     * const { count } = await prisma.receptionSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceptionScheduleDeleteManyArgs>(args?: SelectSubset<T, ReceptionScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceptionSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceptionSchedules
     * const receptionSchedule = await prisma.receptionSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceptionScheduleUpdateManyArgs>(args: SelectSubset<T, ReceptionScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceptionSchedule.
     * @param {ReceptionScheduleUpsertArgs} args - Arguments to update or create a ReceptionSchedule.
     * @example
     * // Update or create a ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.upsert({
     *   create: {
     *     // ... data to create a ReceptionSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceptionSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ReceptionScheduleUpsertArgs>(args: SelectSubset<T, ReceptionScheduleUpsertArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReceptionSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleCountArgs} args - Arguments to filter ReceptionSchedules to count.
     * @example
     * // Count the number of ReceptionSchedules
     * const count = await prisma.receptionSchedule.count({
     *   where: {
     *     // ... the filter for the ReceptionSchedules we want to count
     *   }
     * })
    **/
    count<T extends ReceptionScheduleCountArgs>(
      args?: Subset<T, ReceptionScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceptionScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceptionSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceptionScheduleAggregateArgs>(args: Subset<T, ReceptionScheduleAggregateArgs>): Prisma.PrismaPromise<GetReceptionScheduleAggregateType<T>>

    /**
     * Group by ReceptionSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceptionScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceptionScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ReceptionScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceptionScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceptionScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceptionSchedule model
   */
  readonly fields: ReceptionScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceptionSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceptionScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reception<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceptionSchedule model
   */ 
  interface ReceptionScheduleFieldRefs {
    readonly id: FieldRef<"ReceptionSchedule", 'Int'>
    readonly receptionId: FieldRef<"ReceptionSchedule", 'Int'>
    readonly branchId: FieldRef<"ReceptionSchedule", 'Int'>
    readonly date: FieldRef<"ReceptionSchedule", 'DateTime'>
    readonly startTime: FieldRef<"ReceptionSchedule", 'String'>
    readonly endTime: FieldRef<"ReceptionSchedule", 'String'>
    readonly note: FieldRef<"ReceptionSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReceptionSchedule findUnique
   */
  export type ReceptionScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule findUniqueOrThrow
   */
  export type ReceptionScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule findFirst
   */
  export type ReceptionScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionSchedules.
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionSchedules.
     */
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * ReceptionSchedule findFirstOrThrow
   */
  export type ReceptionScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionSchedules.
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionSchedules.
     */
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * ReceptionSchedule findMany
   */
  export type ReceptionScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedules to fetch.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceptionSchedules.
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * ReceptionSchedule create
   */
  export type ReceptionScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceptionSchedule.
     */
    data: XOR<ReceptionScheduleCreateInput, ReceptionScheduleUncheckedCreateInput>
  }

  /**
   * ReceptionSchedule createMany
   */
  export type ReceptionScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceptionSchedules.
     */
    data: ReceptionScheduleCreateManyInput | ReceptionScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceptionSchedule createManyAndReturn
   */
  export type ReceptionScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReceptionSchedules.
     */
    data: ReceptionScheduleCreateManyInput | ReceptionScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceptionSchedule update
   */
  export type ReceptionScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceptionSchedule.
     */
    data: XOR<ReceptionScheduleUpdateInput, ReceptionScheduleUncheckedUpdateInput>
    /**
     * Choose, which ReceptionSchedule to update.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule updateMany
   */
  export type ReceptionScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceptionSchedules.
     */
    data: XOR<ReceptionScheduleUpdateManyMutationInput, ReceptionScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ReceptionSchedules to update
     */
    where?: ReceptionScheduleWhereInput
  }

  /**
   * ReceptionSchedule upsert
   */
  export type ReceptionScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceptionSchedule to update in case it exists.
     */
    where: ReceptionScheduleWhereUniqueInput
    /**
     * In case the ReceptionSchedule found by the `where` argument doesn't exist, create a new ReceptionSchedule with this data.
     */
    create: XOR<ReceptionScheduleCreateInput, ReceptionScheduleUncheckedCreateInput>
    /**
     * In case the ReceptionSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceptionScheduleUpdateInput, ReceptionScheduleUncheckedUpdateInput>
  }

  /**
   * ReceptionSchedule delete
   */
  export type ReceptionScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter which ReceptionSchedule to delete.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule deleteMany
   */
  export type ReceptionScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionSchedules to delete
     */
    where?: ReceptionScheduleWhereInput
  }

  /**
   * ReceptionSchedule without action
   */
  export type ReceptionScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
  }


  /**
   * Model DoctorBranch
   */

  export type AggregateDoctorBranch = {
    _count: DoctorBranchCountAggregateOutputType | null
    _avg: DoctorBranchAvgAggregateOutputType | null
    _sum: DoctorBranchSumAggregateOutputType | null
    _min: DoctorBranchMinAggregateOutputType | null
    _max: DoctorBranchMaxAggregateOutputType | null
  }

  export type DoctorBranchAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchMinAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchMaxAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchCountAggregateOutputType = {
    id: number
    doctorId: number
    branchId: number
    _all: number
  }


  export type DoctorBranchAvgAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchSumAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchMinAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchMaxAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchCountAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    _all?: true
  }

  export type DoctorBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorBranch to aggregate.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorBranches
    **/
    _count?: true | DoctorBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorBranchMaxAggregateInputType
  }

  export type GetDoctorBranchAggregateType<T extends DoctorBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorBranch[P]>
      : GetScalarType<T[P], AggregateDoctorBranch[P]>
  }




  export type DoctorBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorBranchWhereInput
    orderBy?: DoctorBranchOrderByWithAggregationInput | DoctorBranchOrderByWithAggregationInput[]
    by: DoctorBranchScalarFieldEnum[] | DoctorBranchScalarFieldEnum
    having?: DoctorBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorBranchCountAggregateInputType | true
    _avg?: DoctorBranchAvgAggregateInputType
    _sum?: DoctorBranchSumAggregateInputType
    _min?: DoctorBranchMinAggregateInputType
    _max?: DoctorBranchMaxAggregateInputType
  }

  export type DoctorBranchGroupByOutputType = {
    id: number
    doctorId: number
    branchId: number
    _count: DoctorBranchCountAggregateOutputType | null
    _avg: DoctorBranchAvgAggregateOutputType | null
    _sum: DoctorBranchSumAggregateOutputType | null
    _min: DoctorBranchMinAggregateOutputType | null
    _max: DoctorBranchMaxAggregateOutputType | null
  }

  type GetDoctorBranchGroupByPayload<T extends DoctorBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorBranchGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorBranchGroupByOutputType[P]>
        }
      >
    >


  export type DoctorBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorBranch"]>

  export type DoctorBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorBranch"]>

  export type DoctorBranchSelectScalar = {
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
  }

  export type DoctorBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type DoctorBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $DoctorBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorBranch"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctorId: number
      branchId: number
    }, ExtArgs["result"]["doctorBranch"]>
    composites: {}
  }

  type DoctorBranchGetPayload<S extends boolean | null | undefined | DoctorBranchDefaultArgs> = $Result.GetResult<Prisma.$DoctorBranchPayload, S>

  type DoctorBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorBranchCountAggregateInputType | true
    }

  export interface DoctorBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorBranch'], meta: { name: 'DoctorBranch' } }
    /**
     * Find zero or one DoctorBranch that matches the filter.
     * @param {DoctorBranchFindUniqueArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorBranchFindUniqueArgs>(args: SelectSubset<T, DoctorBranchFindUniqueArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoctorBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorBranchFindUniqueOrThrowArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoctorBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchFindFirstArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorBranchFindFirstArgs>(args?: SelectSubset<T, DoctorBranchFindFirstArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoctorBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchFindFirstOrThrowArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoctorBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorBranches
     * const doctorBranches = await prisma.doctorBranch.findMany()
     * 
     * // Get first 10 DoctorBranches
     * const doctorBranches = await prisma.doctorBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorBranchWithIdOnly = await prisma.doctorBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorBranchFindManyArgs>(args?: SelectSubset<T, DoctorBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoctorBranch.
     * @param {DoctorBranchCreateArgs} args - Arguments to create a DoctorBranch.
     * @example
     * // Create one DoctorBranch
     * const DoctorBranch = await prisma.doctorBranch.create({
     *   data: {
     *     // ... data to create a DoctorBranch
     *   }
     * })
     * 
     */
    create<T extends DoctorBranchCreateArgs>(args: SelectSubset<T, DoctorBranchCreateArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoctorBranches.
     * @param {DoctorBranchCreateManyArgs} args - Arguments to create many DoctorBranches.
     * @example
     * // Create many DoctorBranches
     * const doctorBranch = await prisma.doctorBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorBranchCreateManyArgs>(args?: SelectSubset<T, DoctorBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorBranches and returns the data saved in the database.
     * @param {DoctorBranchCreateManyAndReturnArgs} args - Arguments to create many DoctorBranches.
     * @example
     * // Create many DoctorBranches
     * const doctorBranch = await prisma.doctorBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorBranches and only return the `id`
     * const doctorBranchWithIdOnly = await prisma.doctorBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoctorBranch.
     * @param {DoctorBranchDeleteArgs} args - Arguments to delete one DoctorBranch.
     * @example
     * // Delete one DoctorBranch
     * const DoctorBranch = await prisma.doctorBranch.delete({
     *   where: {
     *     // ... filter to delete one DoctorBranch
     *   }
     * })
     * 
     */
    delete<T extends DoctorBranchDeleteArgs>(args: SelectSubset<T, DoctorBranchDeleteArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoctorBranch.
     * @param {DoctorBranchUpdateArgs} args - Arguments to update one DoctorBranch.
     * @example
     * // Update one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorBranchUpdateArgs>(args: SelectSubset<T, DoctorBranchUpdateArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoctorBranches.
     * @param {DoctorBranchDeleteManyArgs} args - Arguments to filter DoctorBranches to delete.
     * @example
     * // Delete a few DoctorBranches
     * const { count } = await prisma.doctorBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorBranchDeleteManyArgs>(args?: SelectSubset<T, DoctorBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorBranches
     * const doctorBranch = await prisma.doctorBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorBranchUpdateManyArgs>(args: SelectSubset<T, DoctorBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorBranch.
     * @param {DoctorBranchUpsertArgs} args - Arguments to update or create a DoctorBranch.
     * @example
     * // Update or create a DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.upsert({
     *   create: {
     *     // ... data to create a DoctorBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorBranch we want to update
     *   }
     * })
     */
    upsert<T extends DoctorBranchUpsertArgs>(args: SelectSubset<T, DoctorBranchUpsertArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoctorBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchCountArgs} args - Arguments to filter DoctorBranches to count.
     * @example
     * // Count the number of DoctorBranches
     * const count = await prisma.doctorBranch.count({
     *   where: {
     *     // ... the filter for the DoctorBranches we want to count
     *   }
     * })
    **/
    count<T extends DoctorBranchCountArgs>(
      args?: Subset<T, DoctorBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorBranchAggregateArgs>(args: Subset<T, DoctorBranchAggregateArgs>): Prisma.PrismaPromise<GetDoctorBranchAggregateType<T>>

    /**
     * Group by DoctorBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorBranchGroupByArgs['orderBy'] }
        : { orderBy?: DoctorBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorBranch model
   */
  readonly fields: DoctorBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorBranch model
   */ 
  interface DoctorBranchFieldRefs {
    readonly id: FieldRef<"DoctorBranch", 'Int'>
    readonly doctorId: FieldRef<"DoctorBranch", 'Int'>
    readonly branchId: FieldRef<"DoctorBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DoctorBranch findUnique
   */
  export type DoctorBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch findUniqueOrThrow
   */
  export type DoctorBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch findFirst
   */
  export type DoctorBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorBranches.
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorBranches.
     */
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * DoctorBranch findFirstOrThrow
   */
  export type DoctorBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorBranches.
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorBranches.
     */
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * DoctorBranch findMany
   */
  export type DoctorBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranches to fetch.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorBranches.
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * DoctorBranch create
   */
  export type DoctorBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorBranch.
     */
    data: XOR<DoctorBranchCreateInput, DoctorBranchUncheckedCreateInput>
  }

  /**
   * DoctorBranch createMany
   */
  export type DoctorBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorBranches.
     */
    data: DoctorBranchCreateManyInput | DoctorBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorBranch createManyAndReturn
   */
  export type DoctorBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoctorBranches.
     */
    data: DoctorBranchCreateManyInput | DoctorBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorBranch update
   */
  export type DoctorBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorBranch.
     */
    data: XOR<DoctorBranchUpdateInput, DoctorBranchUncheckedUpdateInput>
    /**
     * Choose, which DoctorBranch to update.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch updateMany
   */
  export type DoctorBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorBranches.
     */
    data: XOR<DoctorBranchUpdateManyMutationInput, DoctorBranchUncheckedUpdateManyInput>
    /**
     * Filter which DoctorBranches to update
     */
    where?: DoctorBranchWhereInput
  }

  /**
   * DoctorBranch upsert
   */
  export type DoctorBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorBranch to update in case it exists.
     */
    where: DoctorBranchWhereUniqueInput
    /**
     * In case the DoctorBranch found by the `where` argument doesn't exist, create a new DoctorBranch with this data.
     */
    create: XOR<DoctorBranchCreateInput, DoctorBranchUncheckedCreateInput>
    /**
     * In case the DoctorBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorBranchUpdateInput, DoctorBranchUncheckedUpdateInput>
  }

  /**
   * DoctorBranch delete
   */
  export type DoctorBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter which DoctorBranch to delete.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch deleteMany
   */
  export type DoctorBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorBranches to delete
     */
    where?: DoctorBranchWhereInput
  }

  /**
   * DoctorBranch without action
   */
  export type DoctorBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
  }


  /**
   * Model ReceptionBranch
   */

  export type AggregateReceptionBranch = {
    _count: ReceptionBranchCountAggregateOutputType | null
    _avg: ReceptionBranchAvgAggregateOutputType | null
    _sum: ReceptionBranchSumAggregateOutputType | null
    _min: ReceptionBranchMinAggregateOutputType | null
    _max: ReceptionBranchMaxAggregateOutputType | null
  }

  export type ReceptionBranchAvgAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchSumAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchMinAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchMaxAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchCountAggregateOutputType = {
    id: number
    receptionId: number
    branchId: number
    _all: number
  }


  export type ReceptionBranchAvgAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchSumAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchMinAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchMaxAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchCountAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    _all?: true
  }

  export type ReceptionBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionBranch to aggregate.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceptionBranches
    **/
    _count?: true | ReceptionBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceptionBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceptionBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceptionBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceptionBranchMaxAggregateInputType
  }

  export type GetReceptionBranchAggregateType<T extends ReceptionBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateReceptionBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceptionBranch[P]>
      : GetScalarType<T[P], AggregateReceptionBranch[P]>
  }




  export type ReceptionBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionBranchWhereInput
    orderBy?: ReceptionBranchOrderByWithAggregationInput | ReceptionBranchOrderByWithAggregationInput[]
    by: ReceptionBranchScalarFieldEnum[] | ReceptionBranchScalarFieldEnum
    having?: ReceptionBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceptionBranchCountAggregateInputType | true
    _avg?: ReceptionBranchAvgAggregateInputType
    _sum?: ReceptionBranchSumAggregateInputType
    _min?: ReceptionBranchMinAggregateInputType
    _max?: ReceptionBranchMaxAggregateInputType
  }

  export type ReceptionBranchGroupByOutputType = {
    id: number
    receptionId: number
    branchId: number
    _count: ReceptionBranchCountAggregateOutputType | null
    _avg: ReceptionBranchAvgAggregateOutputType | null
    _sum: ReceptionBranchSumAggregateOutputType | null
    _min: ReceptionBranchMinAggregateOutputType | null
    _max: ReceptionBranchMaxAggregateOutputType | null
  }

  type GetReceptionBranchGroupByPayload<T extends ReceptionBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceptionBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceptionBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceptionBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ReceptionBranchGroupByOutputType[P]>
        }
      >
    >


  export type ReceptionBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionBranch"]>

  export type ReceptionBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionBranch"]>

  export type ReceptionBranchSelectScalar = {
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
  }

  export type ReceptionBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ReceptionBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ReceptionBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceptionBranch"
    objects: {
      reception: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receptionId: number
      branchId: number
    }, ExtArgs["result"]["receptionBranch"]>
    composites: {}
  }

  type ReceptionBranchGetPayload<S extends boolean | null | undefined | ReceptionBranchDefaultArgs> = $Result.GetResult<Prisma.$ReceptionBranchPayload, S>

  type ReceptionBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceptionBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceptionBranchCountAggregateInputType | true
    }

  export interface ReceptionBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceptionBranch'], meta: { name: 'ReceptionBranch' } }
    /**
     * Find zero or one ReceptionBranch that matches the filter.
     * @param {ReceptionBranchFindUniqueArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceptionBranchFindUniqueArgs>(args: SelectSubset<T, ReceptionBranchFindUniqueArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReceptionBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceptionBranchFindUniqueOrThrowArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceptionBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceptionBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReceptionBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchFindFirstArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceptionBranchFindFirstArgs>(args?: SelectSubset<T, ReceptionBranchFindFirstArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReceptionBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchFindFirstOrThrowArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceptionBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceptionBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReceptionBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceptionBranches
     * const receptionBranches = await prisma.receptionBranch.findMany()
     * 
     * // Get first 10 ReceptionBranches
     * const receptionBranches = await prisma.receptionBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receptionBranchWithIdOnly = await prisma.receptionBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceptionBranchFindManyArgs>(args?: SelectSubset<T, ReceptionBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReceptionBranch.
     * @param {ReceptionBranchCreateArgs} args - Arguments to create a ReceptionBranch.
     * @example
     * // Create one ReceptionBranch
     * const ReceptionBranch = await prisma.receptionBranch.create({
     *   data: {
     *     // ... data to create a ReceptionBranch
     *   }
     * })
     * 
     */
    create<T extends ReceptionBranchCreateArgs>(args: SelectSubset<T, ReceptionBranchCreateArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReceptionBranches.
     * @param {ReceptionBranchCreateManyArgs} args - Arguments to create many ReceptionBranches.
     * @example
     * // Create many ReceptionBranches
     * const receptionBranch = await prisma.receptionBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceptionBranchCreateManyArgs>(args?: SelectSubset<T, ReceptionBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceptionBranches and returns the data saved in the database.
     * @param {ReceptionBranchCreateManyAndReturnArgs} args - Arguments to create many ReceptionBranches.
     * @example
     * // Create many ReceptionBranches
     * const receptionBranch = await prisma.receptionBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceptionBranches and only return the `id`
     * const receptionBranchWithIdOnly = await prisma.receptionBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceptionBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceptionBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReceptionBranch.
     * @param {ReceptionBranchDeleteArgs} args - Arguments to delete one ReceptionBranch.
     * @example
     * // Delete one ReceptionBranch
     * const ReceptionBranch = await prisma.receptionBranch.delete({
     *   where: {
     *     // ... filter to delete one ReceptionBranch
     *   }
     * })
     * 
     */
    delete<T extends ReceptionBranchDeleteArgs>(args: SelectSubset<T, ReceptionBranchDeleteArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReceptionBranch.
     * @param {ReceptionBranchUpdateArgs} args - Arguments to update one ReceptionBranch.
     * @example
     * // Update one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceptionBranchUpdateArgs>(args: SelectSubset<T, ReceptionBranchUpdateArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReceptionBranches.
     * @param {ReceptionBranchDeleteManyArgs} args - Arguments to filter ReceptionBranches to delete.
     * @example
     * // Delete a few ReceptionBranches
     * const { count } = await prisma.receptionBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceptionBranchDeleteManyArgs>(args?: SelectSubset<T, ReceptionBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceptionBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceptionBranches
     * const receptionBranch = await prisma.receptionBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceptionBranchUpdateManyArgs>(args: SelectSubset<T, ReceptionBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceptionBranch.
     * @param {ReceptionBranchUpsertArgs} args - Arguments to update or create a ReceptionBranch.
     * @example
     * // Update or create a ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.upsert({
     *   create: {
     *     // ... data to create a ReceptionBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceptionBranch we want to update
     *   }
     * })
     */
    upsert<T extends ReceptionBranchUpsertArgs>(args: SelectSubset<T, ReceptionBranchUpsertArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReceptionBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchCountArgs} args - Arguments to filter ReceptionBranches to count.
     * @example
     * // Count the number of ReceptionBranches
     * const count = await prisma.receptionBranch.count({
     *   where: {
     *     // ... the filter for the ReceptionBranches we want to count
     *   }
     * })
    **/
    count<T extends ReceptionBranchCountArgs>(
      args?: Subset<T, ReceptionBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceptionBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceptionBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceptionBranchAggregateArgs>(args: Subset<T, ReceptionBranchAggregateArgs>): Prisma.PrismaPromise<GetReceptionBranchAggregateType<T>>

    /**
     * Group by ReceptionBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceptionBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceptionBranchGroupByArgs['orderBy'] }
        : { orderBy?: ReceptionBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceptionBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceptionBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceptionBranch model
   */
  readonly fields: ReceptionBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceptionBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceptionBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reception<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceptionBranch model
   */ 
  interface ReceptionBranchFieldRefs {
    readonly id: FieldRef<"ReceptionBranch", 'Int'>
    readonly receptionId: FieldRef<"ReceptionBranch", 'Int'>
    readonly branchId: FieldRef<"ReceptionBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReceptionBranch findUnique
   */
  export type ReceptionBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch findUniqueOrThrow
   */
  export type ReceptionBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch findFirst
   */
  export type ReceptionBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionBranches.
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionBranches.
     */
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * ReceptionBranch findFirstOrThrow
   */
  export type ReceptionBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionBranches.
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionBranches.
     */
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * ReceptionBranch findMany
   */
  export type ReceptionBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranches to fetch.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceptionBranches.
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * ReceptionBranch create
   */
  export type ReceptionBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceptionBranch.
     */
    data: XOR<ReceptionBranchCreateInput, ReceptionBranchUncheckedCreateInput>
  }

  /**
   * ReceptionBranch createMany
   */
  export type ReceptionBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceptionBranches.
     */
    data: ReceptionBranchCreateManyInput | ReceptionBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceptionBranch createManyAndReturn
   */
  export type ReceptionBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReceptionBranches.
     */
    data: ReceptionBranchCreateManyInput | ReceptionBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceptionBranch update
   */
  export type ReceptionBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceptionBranch.
     */
    data: XOR<ReceptionBranchUpdateInput, ReceptionBranchUncheckedUpdateInput>
    /**
     * Choose, which ReceptionBranch to update.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch updateMany
   */
  export type ReceptionBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceptionBranches.
     */
    data: XOR<ReceptionBranchUpdateManyMutationInput, ReceptionBranchUncheckedUpdateManyInput>
    /**
     * Filter which ReceptionBranches to update
     */
    where?: ReceptionBranchWhereInput
  }

  /**
   * ReceptionBranch upsert
   */
  export type ReceptionBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceptionBranch to update in case it exists.
     */
    where: ReceptionBranchWhereUniqueInput
    /**
     * In case the ReceptionBranch found by the `where` argument doesn't exist, create a new ReceptionBranch with this data.
     */
    create: XOR<ReceptionBranchCreateInput, ReceptionBranchUncheckedCreateInput>
    /**
     * In case the ReceptionBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceptionBranchUpdateInput, ReceptionBranchUncheckedUpdateInput>
  }

  /**
   * ReceptionBranch delete
   */
  export type ReceptionBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter which ReceptionBranch to delete.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch deleteMany
   */
  export type ReceptionBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionBranches to delete
     */
    where?: ReceptionBranchWhereInput
  }

  /**
   * ReceptionBranch without action
   */
  export type ReceptionBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
  }


  /**
   * Model NurseBranch
   */

  export type AggregateNurseBranch = {
    _count: NurseBranchCountAggregateOutputType | null
    _avg: NurseBranchAvgAggregateOutputType | null
    _sum: NurseBranchSumAggregateOutputType | null
    _min: NurseBranchMinAggregateOutputType | null
    _max: NurseBranchMaxAggregateOutputType | null
  }

  export type NurseBranchAvgAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchSumAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchMinAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchMaxAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchCountAggregateOutputType = {
    id: number
    nurseId: number
    branchId: number
    _all: number
  }


  export type NurseBranchAvgAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchSumAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchMinAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchMaxAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchCountAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    _all?: true
  }

  export type NurseBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseBranch to aggregate.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NurseBranches
    **/
    _count?: true | NurseBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NurseBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NurseBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseBranchMaxAggregateInputType
  }

  export type GetNurseBranchAggregateType<T extends NurseBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateNurseBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurseBranch[P]>
      : GetScalarType<T[P], AggregateNurseBranch[P]>
  }




  export type NurseBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseBranchWhereInput
    orderBy?: NurseBranchOrderByWithAggregationInput | NurseBranchOrderByWithAggregationInput[]
    by: NurseBranchScalarFieldEnum[] | NurseBranchScalarFieldEnum
    having?: NurseBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseBranchCountAggregateInputType | true
    _avg?: NurseBranchAvgAggregateInputType
    _sum?: NurseBranchSumAggregateInputType
    _min?: NurseBranchMinAggregateInputType
    _max?: NurseBranchMaxAggregateInputType
  }

  export type NurseBranchGroupByOutputType = {
    id: number
    nurseId: number
    branchId: number
    _count: NurseBranchCountAggregateOutputType | null
    _avg: NurseBranchAvgAggregateOutputType | null
    _sum: NurseBranchSumAggregateOutputType | null
    _min: NurseBranchMinAggregateOutputType | null
    _max: NurseBranchMaxAggregateOutputType | null
  }

  type GetNurseBranchGroupByPayload<T extends NurseBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseBranchGroupByOutputType[P]>
            : GetScalarType<T[P], NurseBranchGroupByOutputType[P]>
        }
      >
    >


  export type NurseBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseBranch"]>

  export type NurseBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseBranch"]>

  export type NurseBranchSelectScalar = {
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
  }

  export type NurseBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type NurseBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $NurseBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NurseBranch"
    objects: {
      nurse: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nurseId: number
      branchId: number
    }, ExtArgs["result"]["nurseBranch"]>
    composites: {}
  }

  type NurseBranchGetPayload<S extends boolean | null | undefined | NurseBranchDefaultArgs> = $Result.GetResult<Prisma.$NurseBranchPayload, S>

  type NurseBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NurseBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NurseBranchCountAggregateInputType | true
    }

  export interface NurseBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NurseBranch'], meta: { name: 'NurseBranch' } }
    /**
     * Find zero or one NurseBranch that matches the filter.
     * @param {NurseBranchFindUniqueArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NurseBranchFindUniqueArgs>(args: SelectSubset<T, NurseBranchFindUniqueArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NurseBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NurseBranchFindUniqueOrThrowArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NurseBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, NurseBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NurseBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchFindFirstArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NurseBranchFindFirstArgs>(args?: SelectSubset<T, NurseBranchFindFirstArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NurseBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchFindFirstOrThrowArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NurseBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, NurseBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NurseBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NurseBranches
     * const nurseBranches = await prisma.nurseBranch.findMany()
     * 
     * // Get first 10 NurseBranches
     * const nurseBranches = await prisma.nurseBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nurseBranchWithIdOnly = await prisma.nurseBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NurseBranchFindManyArgs>(args?: SelectSubset<T, NurseBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NurseBranch.
     * @param {NurseBranchCreateArgs} args - Arguments to create a NurseBranch.
     * @example
     * // Create one NurseBranch
     * const NurseBranch = await prisma.nurseBranch.create({
     *   data: {
     *     // ... data to create a NurseBranch
     *   }
     * })
     * 
     */
    create<T extends NurseBranchCreateArgs>(args: SelectSubset<T, NurseBranchCreateArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NurseBranches.
     * @param {NurseBranchCreateManyArgs} args - Arguments to create many NurseBranches.
     * @example
     * // Create many NurseBranches
     * const nurseBranch = await prisma.nurseBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NurseBranchCreateManyArgs>(args?: SelectSubset<T, NurseBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NurseBranches and returns the data saved in the database.
     * @param {NurseBranchCreateManyAndReturnArgs} args - Arguments to create many NurseBranches.
     * @example
     * // Create many NurseBranches
     * const nurseBranch = await prisma.nurseBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NurseBranches and only return the `id`
     * const nurseBranchWithIdOnly = await prisma.nurseBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NurseBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, NurseBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NurseBranch.
     * @param {NurseBranchDeleteArgs} args - Arguments to delete one NurseBranch.
     * @example
     * // Delete one NurseBranch
     * const NurseBranch = await prisma.nurseBranch.delete({
     *   where: {
     *     // ... filter to delete one NurseBranch
     *   }
     * })
     * 
     */
    delete<T extends NurseBranchDeleteArgs>(args: SelectSubset<T, NurseBranchDeleteArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NurseBranch.
     * @param {NurseBranchUpdateArgs} args - Arguments to update one NurseBranch.
     * @example
     * // Update one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NurseBranchUpdateArgs>(args: SelectSubset<T, NurseBranchUpdateArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NurseBranches.
     * @param {NurseBranchDeleteManyArgs} args - Arguments to filter NurseBranches to delete.
     * @example
     * // Delete a few NurseBranches
     * const { count } = await prisma.nurseBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NurseBranchDeleteManyArgs>(args?: SelectSubset<T, NurseBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NurseBranches
     * const nurseBranch = await prisma.nurseBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NurseBranchUpdateManyArgs>(args: SelectSubset<T, NurseBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NurseBranch.
     * @param {NurseBranchUpsertArgs} args - Arguments to update or create a NurseBranch.
     * @example
     * // Update or create a NurseBranch
     * const nurseBranch = await prisma.nurseBranch.upsert({
     *   create: {
     *     // ... data to create a NurseBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NurseBranch we want to update
     *   }
     * })
     */
    upsert<T extends NurseBranchUpsertArgs>(args: SelectSubset<T, NurseBranchUpsertArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NurseBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchCountArgs} args - Arguments to filter NurseBranches to count.
     * @example
     * // Count the number of NurseBranches
     * const count = await prisma.nurseBranch.count({
     *   where: {
     *     // ... the filter for the NurseBranches we want to count
     *   }
     * })
    **/
    count<T extends NurseBranchCountArgs>(
      args?: Subset<T, NurseBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NurseBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseBranchAggregateArgs>(args: Subset<T, NurseBranchAggregateArgs>): Prisma.PrismaPromise<GetNurseBranchAggregateType<T>>

    /**
     * Group by NurseBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NurseBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NurseBranchGroupByArgs['orderBy'] }
        : { orderBy?: NurseBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NurseBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NurseBranch model
   */
  readonly fields: NurseBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NurseBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NurseBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nurse<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NurseBranch model
   */ 
  interface NurseBranchFieldRefs {
    readonly id: FieldRef<"NurseBranch", 'Int'>
    readonly nurseId: FieldRef<"NurseBranch", 'Int'>
    readonly branchId: FieldRef<"NurseBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NurseBranch findUnique
   */
  export type NurseBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch findUniqueOrThrow
   */
  export type NurseBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch findFirst
   */
  export type NurseBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseBranches.
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseBranches.
     */
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * NurseBranch findFirstOrThrow
   */
  export type NurseBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseBranches.
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseBranches.
     */
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * NurseBranch findMany
   */
  export type NurseBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranches to fetch.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NurseBranches.
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * NurseBranch create
   */
  export type NurseBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a NurseBranch.
     */
    data: XOR<NurseBranchCreateInput, NurseBranchUncheckedCreateInput>
  }

  /**
   * NurseBranch createMany
   */
  export type NurseBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NurseBranches.
     */
    data: NurseBranchCreateManyInput | NurseBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NurseBranch createManyAndReturn
   */
  export type NurseBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NurseBranches.
     */
    data: NurseBranchCreateManyInput | NurseBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NurseBranch update
   */
  export type NurseBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a NurseBranch.
     */
    data: XOR<NurseBranchUpdateInput, NurseBranchUncheckedUpdateInput>
    /**
     * Choose, which NurseBranch to update.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch updateMany
   */
  export type NurseBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NurseBranches.
     */
    data: XOR<NurseBranchUpdateManyMutationInput, NurseBranchUncheckedUpdateManyInput>
    /**
     * Filter which NurseBranches to update
     */
    where?: NurseBranchWhereInput
  }

  /**
   * NurseBranch upsert
   */
  export type NurseBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the NurseBranch to update in case it exists.
     */
    where: NurseBranchWhereUniqueInput
    /**
     * In case the NurseBranch found by the `where` argument doesn't exist, create a new NurseBranch with this data.
     */
    create: XOR<NurseBranchCreateInput, NurseBranchUncheckedCreateInput>
    /**
     * In case the NurseBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NurseBranchUpdateInput, NurseBranchUncheckedUpdateInput>
  }

  /**
   * NurseBranch delete
   */
  export type NurseBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter which NurseBranch to delete.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch deleteMany
   */
  export type NurseBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseBranches to delete
     */
    where?: NurseBranchWhereInput
  }

  /**
   * NurseBranch without action
   */
  export type NurseBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
  }


  /**
   * Model NurseSchedule
   */

  export type AggregateNurseSchedule = {
    _count: NurseScheduleCountAggregateOutputType | null
    _avg: NurseScheduleAvgAggregateOutputType | null
    _sum: NurseScheduleSumAggregateOutputType | null
    _min: NurseScheduleMinAggregateOutputType | null
    _max: NurseScheduleMaxAggregateOutputType | null
  }

  export type NurseScheduleAvgAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseScheduleSumAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseScheduleMinAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type NurseScheduleMaxAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type NurseScheduleCountAggregateOutputType = {
    id: number
    nurseId: number
    branchId: number
    date: number
    startTime: number
    endTime: number
    note: number
    _all: number
  }


  export type NurseScheduleAvgAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseScheduleSumAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseScheduleMinAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type NurseScheduleMaxAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type NurseScheduleCountAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
    _all?: true
  }

  export type NurseScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseSchedule to aggregate.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NurseSchedules
    **/
    _count?: true | NurseScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NurseScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NurseScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseScheduleMaxAggregateInputType
  }

  export type GetNurseScheduleAggregateType<T extends NurseScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateNurseSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurseSchedule[P]>
      : GetScalarType<T[P], AggregateNurseSchedule[P]>
  }




  export type NurseScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseScheduleWhereInput
    orderBy?: NurseScheduleOrderByWithAggregationInput | NurseScheduleOrderByWithAggregationInput[]
    by: NurseScheduleScalarFieldEnum[] | NurseScheduleScalarFieldEnum
    having?: NurseScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseScheduleCountAggregateInputType | true
    _avg?: NurseScheduleAvgAggregateInputType
    _sum?: NurseScheduleSumAggregateInputType
    _min?: NurseScheduleMinAggregateInputType
    _max?: NurseScheduleMaxAggregateInputType
  }

  export type NurseScheduleGroupByOutputType = {
    id: number
    nurseId: number
    branchId: number
    date: Date
    startTime: string
    endTime: string
    note: string | null
    _count: NurseScheduleCountAggregateOutputType | null
    _avg: NurseScheduleAvgAggregateOutputType | null
    _sum: NurseScheduleSumAggregateOutputType | null
    _min: NurseScheduleMinAggregateOutputType | null
    _max: NurseScheduleMaxAggregateOutputType | null
  }

  type GetNurseScheduleGroupByPayload<T extends NurseScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], NurseScheduleGroupByOutputType[P]>
        }
      >
    >


  export type NurseScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseSchedule"]>

  export type NurseScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseSchedule"]>

  export type NurseScheduleSelectScalar = {
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
  }

  export type NurseScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type NurseScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $NurseSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NurseSchedule"
    objects: {
      nurse: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nurseId: number
      branchId: number
      date: Date
      startTime: string
      endTime: string
      note: string | null
    }, ExtArgs["result"]["nurseSchedule"]>
    composites: {}
  }

  type NurseScheduleGetPayload<S extends boolean | null | undefined | NurseScheduleDefaultArgs> = $Result.GetResult<Prisma.$NurseSchedulePayload, S>

  type NurseScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NurseScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NurseScheduleCountAggregateInputType | true
    }

  export interface NurseScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NurseSchedule'], meta: { name: 'NurseSchedule' } }
    /**
     * Find zero or one NurseSchedule that matches the filter.
     * @param {NurseScheduleFindUniqueArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NurseScheduleFindUniqueArgs>(args: SelectSubset<T, NurseScheduleFindUniqueArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NurseSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NurseScheduleFindUniqueOrThrowArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NurseScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, NurseScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NurseSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleFindFirstArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NurseScheduleFindFirstArgs>(args?: SelectSubset<T, NurseScheduleFindFirstArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NurseSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleFindFirstOrThrowArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NurseScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, NurseScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NurseSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NurseSchedules
     * const nurseSchedules = await prisma.nurseSchedule.findMany()
     * 
     * // Get first 10 NurseSchedules
     * const nurseSchedules = await prisma.nurseSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nurseScheduleWithIdOnly = await prisma.nurseSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NurseScheduleFindManyArgs>(args?: SelectSubset<T, NurseScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NurseSchedule.
     * @param {NurseScheduleCreateArgs} args - Arguments to create a NurseSchedule.
     * @example
     * // Create one NurseSchedule
     * const NurseSchedule = await prisma.nurseSchedule.create({
     *   data: {
     *     // ... data to create a NurseSchedule
     *   }
     * })
     * 
     */
    create<T extends NurseScheduleCreateArgs>(args: SelectSubset<T, NurseScheduleCreateArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NurseSchedules.
     * @param {NurseScheduleCreateManyArgs} args - Arguments to create many NurseSchedules.
     * @example
     * // Create many NurseSchedules
     * const nurseSchedule = await prisma.nurseSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NurseScheduleCreateManyArgs>(args?: SelectSubset<T, NurseScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NurseSchedules and returns the data saved in the database.
     * @param {NurseScheduleCreateManyAndReturnArgs} args - Arguments to create many NurseSchedules.
     * @example
     * // Create many NurseSchedules
     * const nurseSchedule = await prisma.nurseSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NurseSchedules and only return the `id`
     * const nurseScheduleWithIdOnly = await prisma.nurseSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NurseScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, NurseScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NurseSchedule.
     * @param {NurseScheduleDeleteArgs} args - Arguments to delete one NurseSchedule.
     * @example
     * // Delete one NurseSchedule
     * const NurseSchedule = await prisma.nurseSchedule.delete({
     *   where: {
     *     // ... filter to delete one NurseSchedule
     *   }
     * })
     * 
     */
    delete<T extends NurseScheduleDeleteArgs>(args: SelectSubset<T, NurseScheduleDeleteArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NurseSchedule.
     * @param {NurseScheduleUpdateArgs} args - Arguments to update one NurseSchedule.
     * @example
     * // Update one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NurseScheduleUpdateArgs>(args: SelectSubset<T, NurseScheduleUpdateArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NurseSchedules.
     * @param {NurseScheduleDeleteManyArgs} args - Arguments to filter NurseSchedules to delete.
     * @example
     * // Delete a few NurseSchedules
     * const { count } = await prisma.nurseSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NurseScheduleDeleteManyArgs>(args?: SelectSubset<T, NurseScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NurseSchedules
     * const nurseSchedule = await prisma.nurseSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NurseScheduleUpdateManyArgs>(args: SelectSubset<T, NurseScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NurseSchedule.
     * @param {NurseScheduleUpsertArgs} args - Arguments to update or create a NurseSchedule.
     * @example
     * // Update or create a NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.upsert({
     *   create: {
     *     // ... data to create a NurseSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NurseSchedule we want to update
     *   }
     * })
     */
    upsert<T extends NurseScheduleUpsertArgs>(args: SelectSubset<T, NurseScheduleUpsertArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NurseSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleCountArgs} args - Arguments to filter NurseSchedules to count.
     * @example
     * // Count the number of NurseSchedules
     * const count = await prisma.nurseSchedule.count({
     *   where: {
     *     // ... the filter for the NurseSchedules we want to count
     *   }
     * })
    **/
    count<T extends NurseScheduleCountArgs>(
      args?: Subset<T, NurseScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NurseSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseScheduleAggregateArgs>(args: Subset<T, NurseScheduleAggregateArgs>): Prisma.PrismaPromise<GetNurseScheduleAggregateType<T>>

    /**
     * Group by NurseSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NurseScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NurseScheduleGroupByArgs['orderBy'] }
        : { orderBy?: NurseScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NurseScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NurseSchedule model
   */
  readonly fields: NurseScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NurseSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NurseScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nurse<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NurseSchedule model
   */ 
  interface NurseScheduleFieldRefs {
    readonly id: FieldRef<"NurseSchedule", 'Int'>
    readonly nurseId: FieldRef<"NurseSchedule", 'Int'>
    readonly branchId: FieldRef<"NurseSchedule", 'Int'>
    readonly date: FieldRef<"NurseSchedule", 'DateTime'>
    readonly startTime: FieldRef<"NurseSchedule", 'String'>
    readonly endTime: FieldRef<"NurseSchedule", 'String'>
    readonly note: FieldRef<"NurseSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NurseSchedule findUnique
   */
  export type NurseScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule findUniqueOrThrow
   */
  export type NurseScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule findFirst
   */
  export type NurseScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseSchedules.
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseSchedules.
     */
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * NurseSchedule findFirstOrThrow
   */
  export type NurseScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseSchedules.
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseSchedules.
     */
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * NurseSchedule findMany
   */
  export type NurseScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedules to fetch.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NurseSchedules.
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * NurseSchedule create
   */
  export type NurseScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a NurseSchedule.
     */
    data: XOR<NurseScheduleCreateInput, NurseScheduleUncheckedCreateInput>
  }

  /**
   * NurseSchedule createMany
   */
  export type NurseScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NurseSchedules.
     */
    data: NurseScheduleCreateManyInput | NurseScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NurseSchedule createManyAndReturn
   */
  export type NurseScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NurseSchedules.
     */
    data: NurseScheduleCreateManyInput | NurseScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NurseSchedule update
   */
  export type NurseScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a NurseSchedule.
     */
    data: XOR<NurseScheduleUpdateInput, NurseScheduleUncheckedUpdateInput>
    /**
     * Choose, which NurseSchedule to update.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule updateMany
   */
  export type NurseScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NurseSchedules.
     */
    data: XOR<NurseScheduleUpdateManyMutationInput, NurseScheduleUncheckedUpdateManyInput>
    /**
     * Filter which NurseSchedules to update
     */
    where?: NurseScheduleWhereInput
  }

  /**
   * NurseSchedule upsert
   */
  export type NurseScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the NurseSchedule to update in case it exists.
     */
    where: NurseScheduleWhereUniqueInput
    /**
     * In case the NurseSchedule found by the `where` argument doesn't exist, create a new NurseSchedule with this data.
     */
    create: XOR<NurseScheduleCreateInput, NurseScheduleUncheckedCreateInput>
    /**
     * In case the NurseSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NurseScheduleUpdateInput, NurseScheduleUncheckedUpdateInput>
  }

  /**
   * NurseSchedule delete
   */
  export type NurseScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter which NurseSchedule to delete.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule deleteMany
   */
  export type NurseScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseSchedules to delete
     */
    where?: NurseScheduleWhereInput
  }

  /**
   * NurseSchedule without action
   */
  export type NurseScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    createdAt: 'createdAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const EmployeeBenefitScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    code: 'code',
    branchId: 'branchId',
    initialAmount: 'initialAmount',
    remainingAmount: 'remainingAmount',
    fromDate: 'fromDate',
    toDate: 'toDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeBenefitScalarFieldEnum = (typeof EmployeeBenefitScalarFieldEnum)[keyof typeof EmployeeBenefitScalarFieldEnum]


  export const EmployeeBenefitUsageScalarFieldEnum: {
    id: 'id',
    employeeBenefitId: 'employeeBenefitId',
    invoiceId: 'invoiceId',
    encounterId: 'encounterId',
    amountUsed: 'amountUsed',
    patientId: 'patientId',
    createdAt: 'createdAt'
  };

  export type EmployeeBenefitUsageScalarFieldEnum = (typeof EmployeeBenefitUsageScalarFieldEnum)[keyof typeof EmployeeBenefitUsageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    ovog: 'ovog',
    name: 'name',
    role: 'role',
    branchId: 'branchId',
    createdAt: 'createdAt',
    phone: 'phone',
    regNo: 'regNo',
    licenseNumber: 'licenseNumber',
    licenseExpiryDate: 'licenseExpiryDate',
    signatureImagePath: 'signatureImagePath',
    stampImagePath: 'stampImagePath',
    idPhotoPath: 'idPhotoPath',
    calendarOrder: 'calendarOrder'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    regNo: 'regNo',
    ovog: 'ovog',
    name: 'name',
    gender: 'gender',
    birthDate: 'birthDate',
    phone: 'phone',
    address: 'address',
    bloodType: 'bloodType',
    citizenship: 'citizenship',
    emergencyPhone: 'emergencyPhone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    branchId: 'branchId'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const PatientBookScalarFieldEnum: {
    id: 'id',
    bookNumber: 'bookNumber',
    patientId: 'patientId'
  };

  export type PatientBookScalarFieldEnum = (typeof PatientBookScalarFieldEnum)[keyof typeof PatientBookScalarFieldEnum]


  export const VisitCardScalarFieldEnum: {
    id: 'id',
    patientBookId: 'patientBookId',
    type: 'type',
    answers: 'answers',
    patientSignaturePath: 'patientSignaturePath',
    signedAt: 'signedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitCardScalarFieldEnum = (typeof VisitCardScalarFieldEnum)[keyof typeof VisitCardScalarFieldEnum]


  export const OrthoCardScalarFieldEnum: {
    id: 'id',
    patientBookId: 'patientBookId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrthoCardScalarFieldEnum = (typeof OrthoCardScalarFieldEnum)[keyof typeof OrthoCardScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    branchId: 'branchId',
    scheduledAt: 'scheduledAt',
    endAt: 'endAt',
    status: 'status',
    notes: 'notes'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    branchId: 'branchId',
    patientId: 'patientId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    patientBookId: 'patientBookId',
    doctorId: 'doctorId',
    visitDate: 'visitDate',
    notes: 'notes',
    appointmentId: 'appointmentId',
    nurseId: 'nurseId',
    patientSignaturePath: 'patientSignaturePath',
    patientSignedAt: 'patientSignedAt',
    doctorSignaturePath: 'doctorSignaturePath',
    doctorSignedAt: 'doctorSignedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const EncounterConsentScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    type: 'type',
    answers: 'answers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncounterConsentScalarFieldEnum = (typeof EncounterConsentScalarFieldEnum)[keyof typeof EncounterConsentScalarFieldEnum]


  export const ChartToothScalarFieldEnum: {
    id: 'id',
    toothCode: 'toothCode',
    toothGroup: 'toothGroup',
    status: 'status',
    notes: 'notes',
    encounterId: 'encounterId'
  };

  export type ChartToothScalarFieldEnum = (typeof ChartToothScalarFieldEnum)[keyof typeof ChartToothScalarFieldEnum]


  export const ChartNoteScalarFieldEnum: {
    id: 'id',
    chartToothId: 'chartToothId',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ChartNoteScalarFieldEnum = (typeof ChartNoteScalarFieldEnum)[keyof typeof ChartNoteScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const DiagnosisProblemScalarFieldEnum: {
    id: 'id',
    diagnosisId: 'diagnosisId',
    label: 'label',
    order: 'order',
    active: 'active'
  };

  export type DiagnosisProblemScalarFieldEnum = (typeof DiagnosisProblemScalarFieldEnum)[keyof typeof DiagnosisProblemScalarFieldEnum]


  export const EncounterDiagnosisScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    diagnosisId: 'diagnosisId',
    toothCode: 'toothCode',
    selectedProblemIds: 'selectedProblemIds',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type EncounterDiagnosisScalarFieldEnum = (typeof EncounterDiagnosisScalarFieldEnum)[keyof typeof EncounterDiagnosisScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    category: 'category',
    name: 'name',
    price: 'price',
    isActive: 'isActive',
    description: 'description'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceBranchScalarFieldEnum: {
    serviceId: 'serviceId',
    branchId: 'branchId'
  };

  export type ServiceBranchScalarFieldEnum = (typeof ServiceBranchScalarFieldEnum)[keyof typeof ServiceBranchScalarFieldEnum]


  export const EncounterServiceScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    price: 'price'
  };

  export type EncounterServiceScalarFieldEnum = (typeof EncounterServiceScalarFieldEnum)[keyof typeof EncounterServiceScalarFieldEnum]


  export const ProcedureScalarFieldEnum: {
    code: 'code',
    name: 'name',
    price: 'price'
  };

  export type ProcedureScalarFieldEnum = (typeof ProcedureScalarFieldEnum)[keyof typeof ProcedureScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    price: 'price',
    isActive: 'isActive',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    doctorNameSnapshot: 'doctorNameSnapshot',
    patientNameSnapshot: 'patientNameSnapshot',
    diagnosisSummary: 'diagnosisSummary',
    clinicNameSnapshot: 'clinicNameSnapshot'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionItemScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    order: 'order',
    drugName: 'drugName',
    durationDays: 'durationDays',
    quantityPerTake: 'quantityPerTake',
    frequencyPerDay: 'frequencyPerDay',
    note: 'note'
  };

  export type PrescriptionItemScalarFieldEnum = (typeof PrescriptionItemScalarFieldEnum)[keyof typeof PrescriptionItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    encounterId: 'encounterId',
    patientId: 'patientId',
    totalAmount: 'totalAmount',
    totalBeforeDiscount: 'totalBeforeDiscount',
    discountPercent: 'discountPercent',
    finalAmount: 'finalAmount',
    statusLegacy: 'statusLegacy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemType: 'itemType',
    serviceId: 'serviceId',
    productId: 'productId',
    procedureCode: 'procedureCode',
    name: 'name',
    unitPrice: 'unitPrice',
    quantity: 'quantity',
    lineTotal: 'lineTotal',
    createdAt: 'createdAt',
    source: 'source'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    amount: 'amount',
    method: 'method',
    qpayTxnId: 'qpayTxnId',
    timestamp: 'timestamp'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const EBarimtReceiptScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    receiptNumber: 'receiptNumber',
    timestamp: 'timestamp'
  };

  export type EBarimtReceiptScalarFieldEnum = (typeof EBarimtReceiptScalarFieldEnum)[keyof typeof EBarimtReceiptScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    patientId: 'patientId',
    invoiceId: 'invoiceId',
    type: 'type',
    amount: 'amount',
    createdById: 'createdById',
    approvedById: 'approvedById',
    approvalCodeId: 'approvalCodeId',
    employeeVoucherId: 'employeeVoucherId',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const AuthorizationCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    purpose: 'purpose',
    isEnabled: 'isEnabled',
    expiresAt: 'expiresAt',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorizationCodeScalarFieldEnum = (typeof AuthorizationCodeScalarFieldEnum)[keyof typeof AuthorizationCodeScalarFieldEnum]


  export const EmployeeVoucherScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    employeeId: 'employeeId',
    code: 'code',
    status: 'status',
    balanceCap: 'balanceCap',
    usedAmount: 'usedAmount',
    eligibility: 'eligibility',
    allowedPatientIds: 'allowedPatientIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type EmployeeVoucherScalarFieldEnum = (typeof EmployeeVoucherScalarFieldEnum)[keyof typeof EmployeeVoucherScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    filePath: 'filePath',
    toothCode: 'toothCode',
    type: 'type'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const DoctorScheduleScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    branchId: 'branchId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note'
  };

  export type DoctorScheduleScalarFieldEnum = (typeof DoctorScheduleScalarFieldEnum)[keyof typeof DoctorScheduleScalarFieldEnum]


  export const ReceptionScheduleScalarFieldEnum: {
    id: 'id',
    receptionId: 'receptionId',
    branchId: 'branchId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note'
  };

  export type ReceptionScheduleScalarFieldEnum = (typeof ReceptionScheduleScalarFieldEnum)[keyof typeof ReceptionScheduleScalarFieldEnum]


  export const DoctorBranchScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    branchId: 'branchId'
  };

  export type DoctorBranchScalarFieldEnum = (typeof DoctorBranchScalarFieldEnum)[keyof typeof DoctorBranchScalarFieldEnum]


  export const ReceptionBranchScalarFieldEnum: {
    id: 'id',
    receptionId: 'receptionId',
    branchId: 'branchId'
  };

  export type ReceptionBranchScalarFieldEnum = (typeof ReceptionBranchScalarFieldEnum)[keyof typeof ReceptionBranchScalarFieldEnum]


  export const NurseBranchScalarFieldEnum: {
    id: 'id',
    nurseId: 'nurseId',
    branchId: 'branchId'
  };

  export type NurseBranchScalarFieldEnum = (typeof NurseBranchScalarFieldEnum)[keyof typeof NurseBranchScalarFieldEnum]


  export const NurseScheduleScalarFieldEnum: {
    id: 'id',
    nurseId: 'nurseId',
    branchId: 'branchId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note'
  };

  export type NurseScheduleScalarFieldEnum = (typeof NurseScheduleScalarFieldEnum)[keyof typeof NurseScheduleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'VisitCardType'
   */
  export type EnumVisitCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitCardType'>
    


  /**
   * Reference to a field of type 'VisitCardType[]'
   */
  export type ListEnumVisitCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitCardType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DiscountPercent'
   */
  export type EnumDiscountPercentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountPercent'>
    


  /**
   * Reference to a field of type 'DiscountPercent[]'
   */
  export type ListEnumDiscountPercentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountPercent[]'>
    


  /**
   * Reference to a field of type 'InvoiceItemType'
   */
  export type EnumInvoiceItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemType'>
    


  /**
   * Reference to a field of type 'InvoiceItemType[]'
   */
  export type ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemType[]'>
    


  /**
   * Reference to a field of type 'InvoiceItemSource'
   */
  export type EnumInvoiceItemSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemSource'>
    


  /**
   * Reference to a field of type 'InvoiceItemSource[]'
   */
  export type ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemSource[]'>
    


  /**
   * Reference to a field of type 'LedgerEntryType'
   */
  export type EnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType'>
    


  /**
   * Reference to a field of type 'LedgerEntryType[]'
   */
  export type ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType[]'>
    


  /**
   * Reference to a field of type 'EmployeeVoucherStatus'
   */
  export type EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeVoucherStatus'>
    


  /**
   * Reference to a field of type 'EmployeeVoucherStatus[]'
   */
  export type ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeVoucherStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    products?: ProductListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    doctorSchedules?: DoctorScheduleOrderByRelationAggregateInput
    serviceBranches?: ServiceBranchOrderByRelationAggregateInput
    doctorBranches?: DoctorBranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    receptionSchedules?: ReceptionScheduleOrderByRelationAggregateInput
    receptionBranches?: ReceptionBranchOrderByRelationAggregateInput
    nurseSchedules?: NurseScheduleOrderByRelationAggregateInput
    nurseBranches?: NurseBranchOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    employeeVouchers?: EmployeeVoucherOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    products?: ProductListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type EmployeeBenefitWhereInput = {
    AND?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    OR?: EmployeeBenefitWhereInput[]
    NOT?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    id?: IntFilter<"EmployeeBenefit"> | number
    employeeId?: IntFilter<"EmployeeBenefit"> | number
    code?: StringFilter<"EmployeeBenefit"> | string
    branchId?: IntNullableFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
    usages?: EmployeeBenefitUsageListRelationFilter
  }

  export type EmployeeBenefitOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrderInput | SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrderInput | SortOrder
    toDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    usages?: EmployeeBenefitUsageOrderByRelationAggregateInput
  }

  export type EmployeeBenefitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    OR?: EmployeeBenefitWhereInput[]
    NOT?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    employeeId?: IntFilter<"EmployeeBenefit"> | number
    branchId?: IntNullableFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
    usages?: EmployeeBenefitUsageListRelationFilter
  }, "id" | "code">

  export type EmployeeBenefitOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrderInput | SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrderInput | SortOrder
    toDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeBenefitCountOrderByAggregateInput
    _avg?: EmployeeBenefitAvgOrderByAggregateInput
    _max?: EmployeeBenefitMaxOrderByAggregateInput
    _min?: EmployeeBenefitMinOrderByAggregateInput
    _sum?: EmployeeBenefitSumOrderByAggregateInput
  }

  export type EmployeeBenefitScalarWhereWithAggregatesInput = {
    AND?: EmployeeBenefitScalarWhereWithAggregatesInput | EmployeeBenefitScalarWhereWithAggregatesInput[]
    OR?: EmployeeBenefitScalarWhereWithAggregatesInput[]
    NOT?: EmployeeBenefitScalarWhereWithAggregatesInput | EmployeeBenefitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    code?: StringWithAggregatesFilter<"EmployeeBenefit"> | string
    branchId?: IntNullableWithAggregatesFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableWithAggregatesFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableWithAggregatesFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeBenefit"> | Date | string
  }

  export type EmployeeBenefitUsageWhereInput = {
    AND?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    OR?: EmployeeBenefitUsageWhereInput[]
    NOT?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    id?: IntFilter<"EmployeeBenefitUsage"> | number
    employeeBenefitId?: IntFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntFilter<"EmployeeBenefitUsage"> | number
    createdAt?: DateTimeFilter<"EmployeeBenefitUsage"> | Date | string
    employeeBenefit?: XOR<EmployeeBenefitRelationFilter, EmployeeBenefitWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type EmployeeBenefitUsageOrderByWithRelationInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    employeeBenefit?: EmployeeBenefitOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type EmployeeBenefitUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    OR?: EmployeeBenefitUsageWhereInput[]
    NOT?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    employeeBenefitId?: IntFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntFilter<"EmployeeBenefitUsage"> | number
    createdAt?: DateTimeFilter<"EmployeeBenefitUsage"> | Date | string
    employeeBenefit?: XOR<EmployeeBenefitRelationFilter, EmployeeBenefitWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type EmployeeBenefitUsageOrderByWithAggregationInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    _count?: EmployeeBenefitUsageCountOrderByAggregateInput
    _avg?: EmployeeBenefitUsageAvgOrderByAggregateInput
    _max?: EmployeeBenefitUsageMaxOrderByAggregateInput
    _min?: EmployeeBenefitUsageMinOrderByAggregateInput
    _sum?: EmployeeBenefitUsageSumOrderByAggregateInput
  }

  export type EmployeeBenefitUsageScalarWhereWithAggregatesInput = {
    AND?: EmployeeBenefitUsageScalarWhereWithAggregatesInput | EmployeeBenefitUsageScalarWhereWithAggregatesInput[]
    OR?: EmployeeBenefitUsageScalarWhereWithAggregatesInput[]
    NOT?: EmployeeBenefitUsageScalarWhereWithAggregatesInput | EmployeeBenefitUsageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    employeeBenefitId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeBenefitUsage"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    ovog?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    regNo?: StringNullableFilter<"User"> | string | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableFilter<"User"> | string | null
    stampImagePath?: StringNullableFilter<"User"> | string | null
    idPhotoPath?: StringNullableFilter<"User"> | string | null
    calendarOrder?: IntNullableFilter<"User"> | number | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounters?: EncounterListRelationFilter
    nurseEncounters?: EncounterListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    employeeBenefits?: EmployeeBenefitListRelationFilter
    createdLedgerEntries?: LedgerEntryListRelationFilter
    approvedLedgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
    createdEmployeeVouchers?: EmployeeVoucherListRelationFilter
    authorizationCodes?: AuthorizationCodeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    regNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    signatureImagePath?: SortOrderInput | SortOrder
    stampImagePath?: SortOrderInput | SortOrder
    idPhotoPath?: SortOrderInput | SortOrder
    calendarOrder?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    nurseEncounters?: EncounterOrderByRelationAggregateInput
    doctorSchedules?: DoctorScheduleOrderByRelationAggregateInput
    doctorBranches?: DoctorBranchOrderByRelationAggregateInput
    receptionSchedules?: ReceptionScheduleOrderByRelationAggregateInput
    receptionBranches?: ReceptionBranchOrderByRelationAggregateInput
    nurseSchedules?: NurseScheduleOrderByRelationAggregateInput
    nurseBranches?: NurseBranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    employeeBenefits?: EmployeeBenefitOrderByRelationAggregateInput
    createdLedgerEntries?: LedgerEntryOrderByRelationAggregateInput
    approvedLedgerEntries?: LedgerEntryOrderByRelationAggregateInput
    employeeVouchers?: EmployeeVoucherOrderByRelationAggregateInput
    createdEmployeeVouchers?: EmployeeVoucherOrderByRelationAggregateInput
    authorizationCodes?: AuthorizationCodeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    regNo?: string
    licenseNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    ovog?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableFilter<"User"> | string | null
    stampImagePath?: StringNullableFilter<"User"> | string | null
    idPhotoPath?: StringNullableFilter<"User"> | string | null
    calendarOrder?: IntNullableFilter<"User"> | number | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounters?: EncounterListRelationFilter
    nurseEncounters?: EncounterListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    employeeBenefits?: EmployeeBenefitListRelationFilter
    createdLedgerEntries?: LedgerEntryListRelationFilter
    approvedLedgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
    createdEmployeeVouchers?: EmployeeVoucherListRelationFilter
    authorizationCodes?: AuthorizationCodeListRelationFilter
  }, "id" | "email" | "regNo" | "licenseNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    regNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    signatureImagePath?: SortOrderInput | SortOrder
    stampImagePath?: SortOrderInput | SortOrder
    idPhotoPath?: SortOrderInput | SortOrder
    calendarOrder?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    ovog?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    regNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    licenseNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableWithAggregatesFilter<"User"> | string | null
    stampImagePath?: StringNullableWithAggregatesFilter<"User"> | string | null
    idPhotoPath?: StringNullableWithAggregatesFilter<"User"> | string | null
    calendarOrder?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    regNo?: StringNullableFilter<"Patient"> | string | null
    ovog?: StringNullableFilter<"Patient"> | string | null
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    citizenship?: StringNullableFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branchId?: IntFilter<"Patient"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patientBook?: XOR<PatientBookNullableRelationFilter, PatientBookWhereInput> | null
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    regNo?: SortOrderInput | SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patientBook?: PatientBookOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    regNo?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    ovog?: StringNullableFilter<"Patient"> | string | null
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    citizenship?: StringNullableFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branchId?: IntFilter<"Patient"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patientBook?: XOR<PatientBookNullableRelationFilter, PatientBookWhereInput> | null
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
  }, "id" | "regNo">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    regNo?: SortOrderInput | SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    regNo?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    ovog?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    name?: StringWithAggregatesFilter<"Patient"> | string
    gender?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    bloodType?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    citizenship?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    branchId?: IntWithAggregatesFilter<"Patient"> | number
  }

  export type PatientBookWhereInput = {
    AND?: PatientBookWhereInput | PatientBookWhereInput[]
    OR?: PatientBookWhereInput[]
    NOT?: PatientBookWhereInput | PatientBookWhereInput[]
    id?: IntFilter<"PatientBook"> | number
    bookNumber?: StringFilter<"PatientBook"> | string
    patientId?: IntFilter<"PatientBook"> | number
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    encounters?: EncounterListRelationFilter
    visitCard?: XOR<VisitCardNullableRelationFilter, VisitCardWhereInput> | null
    orthoCard?: XOR<OrthoCardNullableRelationFilter, OrthoCardWhereInput> | null
  }

  export type PatientBookOrderByWithRelationInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    visitCard?: VisitCardOrderByWithRelationInput
    orthoCard?: OrthoCardOrderByWithRelationInput
  }

  export type PatientBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookNumber?: string
    patientId?: number
    AND?: PatientBookWhereInput | PatientBookWhereInput[]
    OR?: PatientBookWhereInput[]
    NOT?: PatientBookWhereInput | PatientBookWhereInput[]
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    encounters?: EncounterListRelationFilter
    visitCard?: XOR<VisitCardNullableRelationFilter, VisitCardWhereInput> | null
    orthoCard?: XOR<OrthoCardNullableRelationFilter, OrthoCardWhereInput> | null
  }, "id" | "bookNumber" | "patientId">

  export type PatientBookOrderByWithAggregationInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
    _count?: PatientBookCountOrderByAggregateInput
    _avg?: PatientBookAvgOrderByAggregateInput
    _max?: PatientBookMaxOrderByAggregateInput
    _min?: PatientBookMinOrderByAggregateInput
    _sum?: PatientBookSumOrderByAggregateInput
  }

  export type PatientBookScalarWhereWithAggregatesInput = {
    AND?: PatientBookScalarWhereWithAggregatesInput | PatientBookScalarWhereWithAggregatesInput[]
    OR?: PatientBookScalarWhereWithAggregatesInput[]
    NOT?: PatientBookScalarWhereWithAggregatesInput | PatientBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatientBook"> | number
    bookNumber?: StringWithAggregatesFilter<"PatientBook"> | string
    patientId?: IntWithAggregatesFilter<"PatientBook"> | number
  }

  export type VisitCardWhereInput = {
    AND?: VisitCardWhereInput | VisitCardWhereInput[]
    OR?: VisitCardWhereInput[]
    NOT?: VisitCardWhereInput | VisitCardWhereInput[]
    id?: IntFilter<"VisitCard"> | number
    patientBookId?: IntFilter<"VisitCard"> | number
    type?: EnumVisitCardTypeFilter<"VisitCard"> | $Enums.VisitCardType
    answers?: JsonFilter<"VisitCard">
    patientSignaturePath?: StringNullableFilter<"VisitCard"> | string | null
    signedAt?: DateTimeNullableFilter<"VisitCard"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitCard"> | Date | string
    updatedAt?: DateTimeFilter<"VisitCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }

  export type VisitCardOrderByWithRelationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientBook?: PatientBookOrderByWithRelationInput
  }

  export type VisitCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    patientBookId?: number
    AND?: VisitCardWhereInput | VisitCardWhereInput[]
    OR?: VisitCardWhereInput[]
    NOT?: VisitCardWhereInput | VisitCardWhereInput[]
    type?: EnumVisitCardTypeFilter<"VisitCard"> | $Enums.VisitCardType
    answers?: JsonFilter<"VisitCard">
    patientSignaturePath?: StringNullableFilter<"VisitCard"> | string | null
    signedAt?: DateTimeNullableFilter<"VisitCard"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitCard"> | Date | string
    updatedAt?: DateTimeFilter<"VisitCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }, "id" | "patientBookId">

  export type VisitCardOrderByWithAggregationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitCardCountOrderByAggregateInput
    _avg?: VisitCardAvgOrderByAggregateInput
    _max?: VisitCardMaxOrderByAggregateInput
    _min?: VisitCardMinOrderByAggregateInput
    _sum?: VisitCardSumOrderByAggregateInput
  }

  export type VisitCardScalarWhereWithAggregatesInput = {
    AND?: VisitCardScalarWhereWithAggregatesInput | VisitCardScalarWhereWithAggregatesInput[]
    OR?: VisitCardScalarWhereWithAggregatesInput[]
    NOT?: VisitCardScalarWhereWithAggregatesInput | VisitCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VisitCard"> | number
    patientBookId?: IntWithAggregatesFilter<"VisitCard"> | number
    type?: EnumVisitCardTypeWithAggregatesFilter<"VisitCard"> | $Enums.VisitCardType
    answers?: JsonWithAggregatesFilter<"VisitCard">
    patientSignaturePath?: StringNullableWithAggregatesFilter<"VisitCard"> | string | null
    signedAt?: DateTimeNullableWithAggregatesFilter<"VisitCard"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisitCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VisitCard"> | Date | string
  }

  export type OrthoCardWhereInput = {
    AND?: OrthoCardWhereInput | OrthoCardWhereInput[]
    OR?: OrthoCardWhereInput[]
    NOT?: OrthoCardWhereInput | OrthoCardWhereInput[]
    id?: IntFilter<"OrthoCard"> | number
    patientBookId?: IntFilter<"OrthoCard"> | number
    data?: JsonFilter<"OrthoCard">
    createdAt?: DateTimeFilter<"OrthoCard"> | Date | string
    updatedAt?: DateTimeFilter<"OrthoCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }

  export type OrthoCardOrderByWithRelationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientBook?: PatientBookOrderByWithRelationInput
  }

  export type OrthoCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    patientBookId?: number
    AND?: OrthoCardWhereInput | OrthoCardWhereInput[]
    OR?: OrthoCardWhereInput[]
    NOT?: OrthoCardWhereInput | OrthoCardWhereInput[]
    data?: JsonFilter<"OrthoCard">
    createdAt?: DateTimeFilter<"OrthoCard"> | Date | string
    updatedAt?: DateTimeFilter<"OrthoCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }, "id" | "patientBookId">

  export type OrthoCardOrderByWithAggregationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrthoCardCountOrderByAggregateInput
    _avg?: OrthoCardAvgOrderByAggregateInput
    _max?: OrthoCardMaxOrderByAggregateInput
    _min?: OrthoCardMinOrderByAggregateInput
    _sum?: OrthoCardSumOrderByAggregateInput
  }

  export type OrthoCardScalarWhereWithAggregatesInput = {
    AND?: OrthoCardScalarWhereWithAggregatesInput | OrthoCardScalarWhereWithAggregatesInput[]
    OR?: OrthoCardScalarWhereWithAggregatesInput[]
    NOT?: OrthoCardScalarWhereWithAggregatesInput | OrthoCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrthoCard"> | number
    patientBookId?: IntWithAggregatesFilter<"OrthoCard"> | number
    data?: JsonWithAggregatesFilter<"OrthoCard">
    createdAt?: DateTimeWithAggregatesFilter<"OrthoCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrthoCard"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntNullableFilter<"Appointment"> | number | null
    branchId?: IntFilter<"Appointment"> | number
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntNullableFilter<"Appointment"> | number | null
    branchId?: IntFilter<"Appointment"> | number
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    patientId?: IntWithAggregatesFilter<"Appointment"> | number
    doctorId?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    branchId?: IntWithAggregatesFilter<"Appointment"> | number
    scheduledAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    status?: StringWithAggregatesFilter<"Appointment"> | string
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    doctorId?: IntFilter<"Booking"> | number
    branchId?: IntFilter<"Booking"> | number
    patientId?: IntFilter<"Booking"> | number
    date?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    doctorId?: IntFilter<"Booking"> | number
    branchId?: IntFilter<"Booking"> | number
    patientId?: IntFilter<"Booking"> | number
    date?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    doctorId?: IntWithAggregatesFilter<"Booking"> | number
    branchId?: IntWithAggregatesFilter<"Booking"> | number
    patientId?: IntWithAggregatesFilter<"Booking"> | number
    date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    startTime?: StringWithAggregatesFilter<"Booking"> | string
    endTime?: StringWithAggregatesFilter<"Booking"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: IntFilter<"Encounter"> | number
    patientBookId?: IntFilter<"Encounter"> | number
    doctorId?: IntFilter<"Encounter"> | number
    visitDate?: DateTimeFilter<"Encounter"> | Date | string
    notes?: StringNullableFilter<"Encounter"> | string | null
    appointmentId?: IntNullableFilter<"Encounter"> | number | null
    nurseId?: IntNullableFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
    nurse?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    chartTeeth?: ChartToothListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    media?: MediaListRelationFilter
    encounterServices?: EncounterServiceListRelationFilter
    diagnoses?: EncounterDiagnosisListRelationFilter
    consents?: EncounterConsentListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    nurseId?: SortOrderInput | SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    patientSignedAt?: SortOrderInput | SortOrder
    doctorSignaturePath?: SortOrderInput | SortOrder
    doctorSignedAt?: SortOrderInput | SortOrder
    patientBook?: PatientBookOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    nurse?: UserOrderByWithRelationInput
    chartTeeth?: ChartToothOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    media?: MediaOrderByRelationAggregateInput
    encounterServices?: EncounterServiceOrderByRelationAggregateInput
    diagnoses?: EncounterDiagnosisOrderByRelationAggregateInput
    consents?: EncounterConsentOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    patientBookId?: IntFilter<"Encounter"> | number
    doctorId?: IntFilter<"Encounter"> | number
    visitDate?: DateTimeFilter<"Encounter"> | Date | string
    notes?: StringNullableFilter<"Encounter"> | string | null
    appointmentId?: IntNullableFilter<"Encounter"> | number | null
    nurseId?: IntNullableFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
    nurse?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    chartTeeth?: ChartToothListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    media?: MediaListRelationFilter
    encounterServices?: EncounterServiceListRelationFilter
    diagnoses?: EncounterDiagnosisListRelationFilter
    consents?: EncounterConsentListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    nurseId?: SortOrderInput | SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    patientSignedAt?: SortOrderInput | SortOrder
    doctorSignaturePath?: SortOrderInput | SortOrder
    doctorSignedAt?: SortOrderInput | SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _avg?: EncounterAvgOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
    _sum?: EncounterSumOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Encounter"> | number
    patientBookId?: IntWithAggregatesFilter<"Encounter"> | number
    doctorId?: IntWithAggregatesFilter<"Encounter"> | number
    visitDate?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    appointmentId?: IntNullableWithAggregatesFilter<"Encounter"> | number | null
    nurseId?: IntNullableWithAggregatesFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
  }

  export type EncounterConsentWhereInput = {
    AND?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    OR?: EncounterConsentWhereInput[]
    NOT?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    id?: IntFilter<"EncounterConsent"> | number
    encounterId?: IntFilter<"EncounterConsent"> | number
    type?: StringFilter<"EncounterConsent"> | string
    answers?: JsonFilter<"EncounterConsent">
    createdAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }

  export type EncounterConsentOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
  }

  export type EncounterConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encounterId_type?: EncounterConsentEncounterIdTypeCompoundUniqueInput
    AND?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    OR?: EncounterConsentWhereInput[]
    NOT?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    encounterId?: IntFilter<"EncounterConsent"> | number
    type?: StringFilter<"EncounterConsent"> | string
    answers?: JsonFilter<"EncounterConsent">
    createdAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }, "id" | "encounterId_type">

  export type EncounterConsentOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncounterConsentCountOrderByAggregateInput
    _avg?: EncounterConsentAvgOrderByAggregateInput
    _max?: EncounterConsentMaxOrderByAggregateInput
    _min?: EncounterConsentMinOrderByAggregateInput
    _sum?: EncounterConsentSumOrderByAggregateInput
  }

  export type EncounterConsentScalarWhereWithAggregatesInput = {
    AND?: EncounterConsentScalarWhereWithAggregatesInput | EncounterConsentScalarWhereWithAggregatesInput[]
    OR?: EncounterConsentScalarWhereWithAggregatesInput[]
    NOT?: EncounterConsentScalarWhereWithAggregatesInput | EncounterConsentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterConsent"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterConsent"> | number
    type?: StringWithAggregatesFilter<"EncounterConsent"> | string
    answers?: JsonWithAggregatesFilter<"EncounterConsent">
    createdAt?: DateTimeWithAggregatesFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EncounterConsent"> | Date | string
  }

  export type ChartToothWhereInput = {
    AND?: ChartToothWhereInput | ChartToothWhereInput[]
    OR?: ChartToothWhereInput[]
    NOT?: ChartToothWhereInput | ChartToothWhereInput[]
    id?: IntFilter<"ChartTooth"> | number
    toothCode?: StringFilter<"ChartTooth"> | string
    toothGroup?: StringNullableFilter<"ChartTooth"> | string | null
    status?: StringNullableFilter<"ChartTooth"> | string | null
    notes?: StringNullableFilter<"ChartTooth"> | string | null
    encounterId?: IntFilter<"ChartTooth"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    chartNotes?: ChartNoteListRelationFilter
  }

  export type ChartToothOrderByWithRelationInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    chartNotes?: ChartNoteOrderByRelationAggregateInput
  }

  export type ChartToothWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChartToothWhereInput | ChartToothWhereInput[]
    OR?: ChartToothWhereInput[]
    NOT?: ChartToothWhereInput | ChartToothWhereInput[]
    toothCode?: StringFilter<"ChartTooth"> | string
    toothGroup?: StringNullableFilter<"ChartTooth"> | string | null
    status?: StringNullableFilter<"ChartTooth"> | string | null
    notes?: StringNullableFilter<"ChartTooth"> | string | null
    encounterId?: IntFilter<"ChartTooth"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    chartNotes?: ChartNoteListRelationFilter
  }, "id">

  export type ChartToothOrderByWithAggregationInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    _count?: ChartToothCountOrderByAggregateInput
    _avg?: ChartToothAvgOrderByAggregateInput
    _max?: ChartToothMaxOrderByAggregateInput
    _min?: ChartToothMinOrderByAggregateInput
    _sum?: ChartToothSumOrderByAggregateInput
  }

  export type ChartToothScalarWhereWithAggregatesInput = {
    AND?: ChartToothScalarWhereWithAggregatesInput | ChartToothScalarWhereWithAggregatesInput[]
    OR?: ChartToothScalarWhereWithAggregatesInput[]
    NOT?: ChartToothScalarWhereWithAggregatesInput | ChartToothScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChartTooth"> | number
    toothCode?: StringWithAggregatesFilter<"ChartTooth"> | string
    toothGroup?: StringNullableWithAggregatesFilter<"ChartTooth"> | string | null
    status?: StringNullableWithAggregatesFilter<"ChartTooth"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ChartTooth"> | string | null
    encounterId?: IntWithAggregatesFilter<"ChartTooth"> | number
  }

  export type ChartNoteWhereInput = {
    AND?: ChartNoteWhereInput | ChartNoteWhereInput[]
    OR?: ChartNoteWhereInput[]
    NOT?: ChartNoteWhereInput | ChartNoteWhereInput[]
    id?: IntFilter<"ChartNote"> | number
    chartToothId?: IntFilter<"ChartNote"> | number
    description?: StringFilter<"ChartNote"> | string
    createdAt?: DateTimeFilter<"ChartNote"> | Date | string
    chartTooth?: XOR<ChartToothRelationFilter, ChartToothWhereInput>
  }

  export type ChartNoteOrderByWithRelationInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    chartTooth?: ChartToothOrderByWithRelationInput
  }

  export type ChartNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChartNoteWhereInput | ChartNoteWhereInput[]
    OR?: ChartNoteWhereInput[]
    NOT?: ChartNoteWhereInput | ChartNoteWhereInput[]
    chartToothId?: IntFilter<"ChartNote"> | number
    description?: StringFilter<"ChartNote"> | string
    createdAt?: DateTimeFilter<"ChartNote"> | Date | string
    chartTooth?: XOR<ChartToothRelationFilter, ChartToothWhereInput>
  }, "id">

  export type ChartNoteOrderByWithAggregationInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: ChartNoteCountOrderByAggregateInput
    _avg?: ChartNoteAvgOrderByAggregateInput
    _max?: ChartNoteMaxOrderByAggregateInput
    _min?: ChartNoteMinOrderByAggregateInput
    _sum?: ChartNoteSumOrderByAggregateInput
  }

  export type ChartNoteScalarWhereWithAggregatesInput = {
    AND?: ChartNoteScalarWhereWithAggregatesInput | ChartNoteScalarWhereWithAggregatesInput[]
    OR?: ChartNoteScalarWhereWithAggregatesInput[]
    NOT?: ChartNoteScalarWhereWithAggregatesInput | ChartNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChartNote"> | number
    chartToothId?: IntWithAggregatesFilter<"ChartNote"> | number
    description?: StringWithAggregatesFilter<"ChartNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChartNote"> | Date | string
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    id?: IntFilter<"Diagnosis"> | number
    code?: StringFilter<"Diagnosis"> | string
    name?: StringFilter<"Diagnosis"> | string
    description?: StringNullableFilter<"Diagnosis"> | string | null
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    problems?: DiagnosisProblemListRelationFilter
    encounters?: EncounterDiagnosisListRelationFilter
  }

  export type DiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    problems?: DiagnosisProblemOrderByRelationAggregateInput
    encounters?: EncounterDiagnosisOrderByRelationAggregateInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    name?: StringFilter<"Diagnosis"> | string
    description?: StringNullableFilter<"Diagnosis"> | string | null
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    problems?: DiagnosisProblemListRelationFilter
    encounters?: EncounterDiagnosisListRelationFilter
  }, "id" | "code">

  export type DiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _avg?: DiagnosisAvgOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
    _sum?: DiagnosisSumOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diagnosis"> | number
    code?: StringWithAggregatesFilter<"Diagnosis"> | string
    name?: StringWithAggregatesFilter<"Diagnosis"> | string
    description?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
  }

  export type DiagnosisProblemWhereInput = {
    AND?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    OR?: DiagnosisProblemWhereInput[]
    NOT?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    id?: IntFilter<"DiagnosisProblem"> | number
    diagnosisId?: IntFilter<"DiagnosisProblem"> | number
    label?: StringFilter<"DiagnosisProblem"> | string
    order?: IntFilter<"DiagnosisProblem"> | number
    active?: BoolFilter<"DiagnosisProblem"> | boolean
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
  }

  export type DiagnosisProblemOrderByWithRelationInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
    diagnosis?: DiagnosisOrderByWithRelationInput
  }

  export type DiagnosisProblemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    OR?: DiagnosisProblemWhereInput[]
    NOT?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    diagnosisId?: IntFilter<"DiagnosisProblem"> | number
    label?: StringFilter<"DiagnosisProblem"> | string
    order?: IntFilter<"DiagnosisProblem"> | number
    active?: BoolFilter<"DiagnosisProblem"> | boolean
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
  }, "id">

  export type DiagnosisProblemOrderByWithAggregationInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
    _count?: DiagnosisProblemCountOrderByAggregateInput
    _avg?: DiagnosisProblemAvgOrderByAggregateInput
    _max?: DiagnosisProblemMaxOrderByAggregateInput
    _min?: DiagnosisProblemMinOrderByAggregateInput
    _sum?: DiagnosisProblemSumOrderByAggregateInput
  }

  export type DiagnosisProblemScalarWhereWithAggregatesInput = {
    AND?: DiagnosisProblemScalarWhereWithAggregatesInput | DiagnosisProblemScalarWhereWithAggregatesInput[]
    OR?: DiagnosisProblemScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisProblemScalarWhereWithAggregatesInput | DiagnosisProblemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DiagnosisProblem"> | number
    diagnosisId?: IntWithAggregatesFilter<"DiagnosisProblem"> | number
    label?: StringWithAggregatesFilter<"DiagnosisProblem"> | string
    order?: IntWithAggregatesFilter<"DiagnosisProblem"> | number
    active?: BoolWithAggregatesFilter<"DiagnosisProblem"> | boolean
  }

  export type EncounterDiagnosisWhereInput = {
    AND?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    OR?: EncounterDiagnosisWhereInput[]
    NOT?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    id?: IntFilter<"EncounterDiagnosis"> | number
    encounterId?: IntFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableFilter<"EncounterDiagnosis">
    note?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeFilter<"EncounterDiagnosis"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
  }

  export type EncounterDiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    selectedProblemIds?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    diagnosis?: DiagnosisOrderByWithRelationInput
  }

  export type EncounterDiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    OR?: EncounterDiagnosisWhereInput[]
    NOT?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    encounterId?: IntFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableFilter<"EncounterDiagnosis">
    note?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeFilter<"EncounterDiagnosis"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
  }, "id">

  export type EncounterDiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    selectedProblemIds?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EncounterDiagnosisCountOrderByAggregateInput
    _avg?: EncounterDiagnosisAvgOrderByAggregateInput
    _max?: EncounterDiagnosisMaxOrderByAggregateInput
    _min?: EncounterDiagnosisMinOrderByAggregateInput
    _sum?: EncounterDiagnosisSumOrderByAggregateInput
  }

  export type EncounterDiagnosisScalarWhereWithAggregatesInput = {
    AND?: EncounterDiagnosisScalarWhereWithAggregatesInput | EncounterDiagnosisScalarWhereWithAggregatesInput[]
    OR?: EncounterDiagnosisScalarWhereWithAggregatesInput[]
    NOT?: EncounterDiagnosisScalarWhereWithAggregatesInput | EncounterDiagnosisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterDiagnosis"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntWithAggregatesFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableWithAggregatesFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableWithAggregatesFilter<"EncounterDiagnosis">
    note?: StringNullableWithAggregatesFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EncounterDiagnosis"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    code?: StringNullableFilter<"Service"> | string | null
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    description?: StringNullableFilter<"Service"> | string | null
    encounterServices?: EncounterServiceListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    encounterServices?: EncounterServiceOrderByRelationAggregateInput
    serviceBranches?: ServiceBranchOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    description?: StringNullableFilter<"Service"> | string | null
    encounterServices?: EncounterServiceListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id" | "code">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    code?: StringNullableWithAggregatesFilter<"Service"> | string | null
    category?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    name?: StringWithAggregatesFilter<"Service"> | string
    price?: FloatWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
  }

  export type ServiceBranchWhereInput = {
    AND?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    OR?: ServiceBranchWhereInput[]
    NOT?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    serviceId?: IntFilter<"ServiceBranch"> | number
    branchId?: IntFilter<"ServiceBranch"> | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ServiceBranchOrderByWithRelationInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ServiceBranchWhereUniqueInput = Prisma.AtLeast<{
    serviceId_branchId?: ServiceBranchServiceIdBranchIdCompoundUniqueInput
    AND?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    OR?: ServiceBranchWhereInput[]
    NOT?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    serviceId?: IntFilter<"ServiceBranch"> | number
    branchId?: IntFilter<"ServiceBranch"> | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "serviceId_branchId">

  export type ServiceBranchOrderByWithAggregationInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
    _count?: ServiceBranchCountOrderByAggregateInput
    _avg?: ServiceBranchAvgOrderByAggregateInput
    _max?: ServiceBranchMaxOrderByAggregateInput
    _min?: ServiceBranchMinOrderByAggregateInput
    _sum?: ServiceBranchSumOrderByAggregateInput
  }

  export type ServiceBranchScalarWhereWithAggregatesInput = {
    AND?: ServiceBranchScalarWhereWithAggregatesInput | ServiceBranchScalarWhereWithAggregatesInput[]
    OR?: ServiceBranchScalarWhereWithAggregatesInput[]
    NOT?: ServiceBranchScalarWhereWithAggregatesInput | ServiceBranchScalarWhereWithAggregatesInput[]
    serviceId?: IntWithAggregatesFilter<"ServiceBranch"> | number
    branchId?: IntWithAggregatesFilter<"ServiceBranch"> | number
  }

  export type EncounterServiceWhereInput = {
    AND?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    OR?: EncounterServiceWhereInput[]
    NOT?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    id?: IntFilter<"EncounterService"> | number
    encounterId?: IntFilter<"EncounterService"> | number
    serviceId?: IntFilter<"EncounterService"> | number
    quantity?: IntFilter<"EncounterService"> | number
    price?: FloatFilter<"EncounterService"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type EncounterServiceOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type EncounterServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    OR?: EncounterServiceWhereInput[]
    NOT?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    encounterId?: IntFilter<"EncounterService"> | number
    serviceId?: IntFilter<"EncounterService"> | number
    quantity?: IntFilter<"EncounterService"> | number
    price?: FloatFilter<"EncounterService"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id">

  export type EncounterServiceOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: EncounterServiceCountOrderByAggregateInput
    _avg?: EncounterServiceAvgOrderByAggregateInput
    _max?: EncounterServiceMaxOrderByAggregateInput
    _min?: EncounterServiceMinOrderByAggregateInput
    _sum?: EncounterServiceSumOrderByAggregateInput
  }

  export type EncounterServiceScalarWhereWithAggregatesInput = {
    AND?: EncounterServiceScalarWhereWithAggregatesInput | EncounterServiceScalarWhereWithAggregatesInput[]
    OR?: EncounterServiceScalarWhereWithAggregatesInput[]
    NOT?: EncounterServiceScalarWhereWithAggregatesInput | EncounterServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterService"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterService"> | number
    serviceId?: IntWithAggregatesFilter<"EncounterService"> | number
    quantity?: IntWithAggregatesFilter<"EncounterService"> | number
    price?: FloatWithAggregatesFilter<"EncounterService"> | number
  }

  export type ProcedureWhereInput = {
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    code?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    price?: FloatFilter<"Procedure"> | number
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ProcedureOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ProcedureWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    name?: StringFilter<"Procedure"> | string
    price?: FloatFilter<"Procedure"> | number
    invoiceItems?: InvoiceItemListRelationFilter
  }, "code">

  export type ProcedureOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: ProcedureCountOrderByAggregateInput
    _avg?: ProcedureAvgOrderByAggregateInput
    _max?: ProcedureMaxOrderByAggregateInput
    _min?: ProcedureMinOrderByAggregateInput
    _sum?: ProcedureSumOrderByAggregateInput
  }

  export type ProcedureScalarWhereWithAggregatesInput = {
    AND?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    OR?: ProcedureScalarWhereWithAggregatesInput[]
    NOT?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Procedure"> | string
    name?: StringWithAggregatesFilter<"Procedure"> | string
    price?: FloatWithAggregatesFilter<"Procedure"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    branchId?: IntFilter<"Product"> | number
    code?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    branchId?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    branchId?: IntWithAggregatesFilter<"Product"> | number
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: IntFilter<"Prescription"> | number
    encounterId?: IntFilter<"Prescription"> | number
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    doctorNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    patientNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    diagnosisSummary?: StringNullableFilter<"Prescription"> | string | null
    clinicNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    items?: PrescriptionItemListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrderInput | SortOrder
    patientNameSnapshot?: SortOrderInput | SortOrder
    diagnosisSummary?: SortOrderInput | SortOrder
    clinicNameSnapshot?: SortOrderInput | SortOrder
    encounter?: EncounterOrderByWithRelationInput
    items?: PrescriptionItemOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encounterId?: number
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    doctorNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    patientNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    diagnosisSummary?: StringNullableFilter<"Prescription"> | string | null
    clinicNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    items?: PrescriptionItemListRelationFilter
  }, "id" | "encounterId">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrderInput | SortOrder
    patientNameSnapshot?: SortOrderInput | SortOrder
    diagnosisSummary?: SortOrderInput | SortOrder
    clinicNameSnapshot?: SortOrderInput | SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prescription"> | number
    encounterId?: IntWithAggregatesFilter<"Prescription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    doctorNameSnapshot?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    patientNameSnapshot?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    diagnosisSummary?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    clinicNameSnapshot?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
  }

  export type PrescriptionItemWhereInput = {
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    id?: IntFilter<"PrescriptionItem"> | number
    prescriptionId?: IntFilter<"PrescriptionItem"> | number
    order?: IntFilter<"PrescriptionItem"> | number
    drugName?: StringFilter<"PrescriptionItem"> | string
    durationDays?: IntFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntFilter<"PrescriptionItem"> | number
    note?: StringNullableFilter<"PrescriptionItem"> | string | null
    prescription?: XOR<PrescriptionRelationFilter, PrescriptionWhereInput>
  }

  export type PrescriptionItemOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrderInput | SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type PrescriptionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    prescriptionId?: IntFilter<"PrescriptionItem"> | number
    order?: IntFilter<"PrescriptionItem"> | number
    drugName?: StringFilter<"PrescriptionItem"> | string
    durationDays?: IntFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntFilter<"PrescriptionItem"> | number
    note?: StringNullableFilter<"PrescriptionItem"> | string | null
    prescription?: XOR<PrescriptionRelationFilter, PrescriptionWhereInput>
  }, "id">

  export type PrescriptionItemOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: PrescriptionItemCountOrderByAggregateInput
    _avg?: PrescriptionItemAvgOrderByAggregateInput
    _max?: PrescriptionItemMaxOrderByAggregateInput
    _min?: PrescriptionItemMinOrderByAggregateInput
    _sum?: PrescriptionItemSumOrderByAggregateInput
  }

  export type PrescriptionItemScalarWhereWithAggregatesInput = {
    AND?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    OR?: PrescriptionItemScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    prescriptionId?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    order?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    drugName?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    durationDays?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    note?: StringNullableWithAggregatesFilter<"PrescriptionItem"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    branchId?: IntNullableFilter<"Invoice"> | number | null
    encounterId?: IntFilter<"Invoice"> | number
    patientId?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    items?: InvoiceItemListRelationFilter
    eBarimtReceipt?: XOR<EBarimtReceiptNullableRelationFilter, EBarimtReceiptWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
    payments?: PaymentListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    totalBeforeDiscount?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    statusLegacy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    eBarimtReceipt?: EBarimtReceiptOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    employeeBenefitUsages?: EmployeeBenefitUsageOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encounterId?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    branchId?: IntNullableFilter<"Invoice"> | number | null
    patientId?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    items?: InvoiceItemListRelationFilter
    eBarimtReceipt?: XOR<EBarimtReceiptNullableRelationFilter, EBarimtReceiptWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
    payments?: PaymentListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }, "id" | "encounterId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    totalBeforeDiscount?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    statusLegacy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    branchId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    encounterId?: IntWithAggregatesFilter<"Invoice"> | number
    patientId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentWithAggregatesFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableFilter<"InvoiceItem"> | number | null
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    lineTotal?: FloatFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    procedure?: XOR<ProcedureNullableRelationFilter, ProcedureWhereInput> | null
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    procedureCode?: SortOrderInput | SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    procedure?: ProcedureOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableFilter<"InvoiceItem"> | number | null
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    lineTotal?: FloatFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    procedure?: XOR<ProcedureNullableRelationFilter, ProcedureWhereInput> | null
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    procedureCode?: SortOrderInput | SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeWithAggregatesFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    productId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    name?: StringWithAggregatesFilter<"InvoiceItem"> | string
    unitPrice?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    lineTotal?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceWithAggregatesFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    qpayTxnId?: StringNullableFilter<"Payment"> | string | null
    timestamp?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    qpayTxnId?: StringNullableFilter<"Payment"> | string | null
    timestamp?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    invoiceId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    method?: StringWithAggregatesFilter<"Payment"> | string
    qpayTxnId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type EBarimtReceiptWhereInput = {
    AND?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    OR?: EBarimtReceiptWhereInput[]
    NOT?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    id?: IntFilter<"EBarimtReceipt"> | number
    invoiceId?: IntFilter<"EBarimtReceipt"> | number
    receiptNumber?: StringFilter<"EBarimtReceipt"> | string
    timestamp?: DateTimeFilter<"EBarimtReceipt"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type EBarimtReceiptOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type EBarimtReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoiceId?: number
    receiptNumber?: string
    AND?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    OR?: EBarimtReceiptWhereInput[]
    NOT?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    timestamp?: DateTimeFilter<"EBarimtReceipt"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id" | "invoiceId" | "receiptNumber">

  export type EBarimtReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
    _count?: EBarimtReceiptCountOrderByAggregateInput
    _avg?: EBarimtReceiptAvgOrderByAggregateInput
    _max?: EBarimtReceiptMaxOrderByAggregateInput
    _min?: EBarimtReceiptMinOrderByAggregateInput
    _sum?: EBarimtReceiptSumOrderByAggregateInput
  }

  export type EBarimtReceiptScalarWhereWithAggregatesInput = {
    AND?: EBarimtReceiptScalarWhereWithAggregatesInput | EBarimtReceiptScalarWhereWithAggregatesInput[]
    OR?: EBarimtReceiptScalarWhereWithAggregatesInput[]
    NOT?: EBarimtReceiptScalarWhereWithAggregatesInput | EBarimtReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EBarimtReceipt"> | number
    invoiceId?: IntWithAggregatesFilter<"EBarimtReceipt"> | number
    receiptNumber?: StringWithAggregatesFilter<"EBarimtReceipt"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EBarimtReceipt"> | Date | string
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: IntFilter<"LedgerEntry"> | number
    branchId?: IntFilter<"LedgerEntry"> | number
    patientId?: IntFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatFilter<"LedgerEntry"> | number
    createdById?: IntFilter<"LedgerEntry"> | number
    approvedById?: IntNullableFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approvalCode?: XOR<AuthorizationCodeNullableRelationFilter, AuthorizationCodeWhereInput> | null
    employeeVoucher?: XOR<EmployeeVoucherNullableRelationFilter, EmployeeVoucherWhereInput> | null
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvalCodeId?: SortOrderInput | SortOrder
    employeeVoucherId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    approvalCode?: AuthorizationCodeOrderByWithRelationInput
    employeeVoucher?: EmployeeVoucherOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    branchId?: IntFilter<"LedgerEntry"> | number
    patientId?: IntFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatFilter<"LedgerEntry"> | number
    createdById?: IntFilter<"LedgerEntry"> | number
    approvedById?: IntNullableFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approvalCode?: XOR<AuthorizationCodeNullableRelationFilter, AuthorizationCodeWhereInput> | null
    employeeVoucher?: XOR<EmployeeVoucherNullableRelationFilter, EmployeeVoucherWhereInput> | null
  }, "id">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvalCodeId?: SortOrderInput | SortOrder
    employeeVoucherId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LedgerEntry"> | number
    branchId?: IntWithAggregatesFilter<"LedgerEntry"> | number
    patientId?: IntWithAggregatesFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatWithAggregatesFilter<"LedgerEntry"> | number
    createdById?: IntWithAggregatesFilter<"LedgerEntry"> | number
    approvedById?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableWithAggregatesFilter<"LedgerEntry">
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
  }

  export type AuthorizationCodeWhereInput = {
    AND?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    OR?: AuthorizationCodeWhereInput[]
    NOT?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    id?: IntFilter<"AuthorizationCode"> | number
    code?: StringFilter<"AuthorizationCode"> | string
    purpose?: StringFilter<"AuthorizationCode"> | string
    isEnabled?: BoolFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableFilter<"AuthorizationCode"> | number | null
    usedCount?: IntFilter<"AuthorizationCode"> | number
    createdById?: IntFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
  }

  export type AuthorizationCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type AuthorizationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    OR?: AuthorizationCodeWhereInput[]
    NOT?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    purpose?: StringFilter<"AuthorizationCode"> | string
    isEnabled?: BoolFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableFilter<"AuthorizationCode"> | number | null
    usedCount?: IntFilter<"AuthorizationCode"> | number
    createdById?: IntFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
  }, "id" | "code">

  export type AuthorizationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthorizationCodeCountOrderByAggregateInput
    _avg?: AuthorizationCodeAvgOrderByAggregateInput
    _max?: AuthorizationCodeMaxOrderByAggregateInput
    _min?: AuthorizationCodeMinOrderByAggregateInput
    _sum?: AuthorizationCodeSumOrderByAggregateInput
  }

  export type AuthorizationCodeScalarWhereWithAggregatesInput = {
    AND?: AuthorizationCodeScalarWhereWithAggregatesInput | AuthorizationCodeScalarWhereWithAggregatesInput[]
    OR?: AuthorizationCodeScalarWhereWithAggregatesInput[]
    NOT?: AuthorizationCodeScalarWhereWithAggregatesInput | AuthorizationCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuthorizationCode"> | number
    code?: StringWithAggregatesFilter<"AuthorizationCode"> | string
    purpose?: StringWithAggregatesFilter<"AuthorizationCode"> | string
    isEnabled?: BoolWithAggregatesFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"AuthorizationCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"AuthorizationCode"> | number
    createdById?: IntWithAggregatesFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthorizationCode"> | Date | string
  }

  export type EmployeeVoucherWhereInput = {
    AND?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    OR?: EmployeeVoucherWhereInput[]
    NOT?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    id?: IntFilter<"EmployeeVoucher"> | number
    branchId?: IntFilter<"EmployeeVoucher"> | number
    employeeId?: IntFilter<"EmployeeVoucher"> | number
    code?: StringFilter<"EmployeeVoucher"> | string
    status?: EnumEmployeeVoucherStatusFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatFilter<"EmployeeVoucher"> | number
    eligibility?: JsonFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonFilter<"EmployeeVoucher">
    createdAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntFilter<"EmployeeVoucher"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    employee?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmployeeVoucherOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    eligibility?: SortOrder
    allowedPatientIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    branch?: BranchOrderByWithRelationInput
    employee?: UserOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type EmployeeVoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    OR?: EmployeeVoucherWhereInput[]
    NOT?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    branchId?: IntFilter<"EmployeeVoucher"> | number
    employeeId?: IntFilter<"EmployeeVoucher"> | number
    status?: EnumEmployeeVoucherStatusFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatFilter<"EmployeeVoucher"> | number
    eligibility?: JsonFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonFilter<"EmployeeVoucher">
    createdAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntFilter<"EmployeeVoucher"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    employee?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type EmployeeVoucherOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    eligibility?: SortOrder
    allowedPatientIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: EmployeeVoucherCountOrderByAggregateInput
    _avg?: EmployeeVoucherAvgOrderByAggregateInput
    _max?: EmployeeVoucherMaxOrderByAggregateInput
    _min?: EmployeeVoucherMinOrderByAggregateInput
    _sum?: EmployeeVoucherSumOrderByAggregateInput
  }

  export type EmployeeVoucherScalarWhereWithAggregatesInput = {
    AND?: EmployeeVoucherScalarWhereWithAggregatesInput | EmployeeVoucherScalarWhereWithAggregatesInput[]
    OR?: EmployeeVoucherScalarWhereWithAggregatesInput[]
    NOT?: EmployeeVoucherScalarWhereWithAggregatesInput | EmployeeVoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
    branchId?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
    code?: StringWithAggregatesFilter<"EmployeeVoucher"> | string
    status?: EnumEmployeeVoucherStatusWithAggregatesFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatWithAggregatesFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatWithAggregatesFilter<"EmployeeVoucher"> | number
    eligibility?: JsonWithAggregatesFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonWithAggregatesFilter<"EmployeeVoucher">
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: IntFilter<"Media"> | number
    encounterId?: IntFilter<"Media"> | number
    filePath?: StringFilter<"Media"> | string
    toothCode?: StringNullableFilter<"Media"> | string | null
    type?: StringFilter<"Media"> | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    type?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    encounterId?: IntFilter<"Media"> | number
    filePath?: StringFilter<"Media"> | string
    toothCode?: StringNullableFilter<"Media"> | string | null
    type?: StringFilter<"Media"> | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Media"> | number
    encounterId?: IntWithAggregatesFilter<"Media"> | number
    filePath?: StringWithAggregatesFilter<"Media"> | string
    toothCode?: StringNullableWithAggregatesFilter<"Media"> | string | null
    type?: StringWithAggregatesFilter<"Media"> | string
  }

  export type DoctorScheduleWhereInput = {
    AND?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    OR?: DoctorScheduleWhereInput[]
    NOT?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    id?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    branchId?: IntFilter<"DoctorSchedule"> | number
    date?: DateTimeFilter<"DoctorSchedule"> | Date | string
    startTime?: StringFilter<"DoctorSchedule"> | string
    endTime?: StringFilter<"DoctorSchedule"> | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type DoctorScheduleOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type DoctorScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    doctorId_branchId_date?: DoctorScheduleDoctorIdBranchIdDateCompoundUniqueInput
    AND?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    OR?: DoctorScheduleWhereInput[]
    NOT?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    doctorId?: IntFilter<"DoctorSchedule"> | number
    branchId?: IntFilter<"DoctorSchedule"> | number
    date?: DateTimeFilter<"DoctorSchedule"> | Date | string
    startTime?: StringFilter<"DoctorSchedule"> | string
    endTime?: StringFilter<"DoctorSchedule"> | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "doctorId_branchId_date">

  export type DoctorScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: DoctorScheduleCountOrderByAggregateInput
    _avg?: DoctorScheduleAvgOrderByAggregateInput
    _max?: DoctorScheduleMaxOrderByAggregateInput
    _min?: DoctorScheduleMinOrderByAggregateInput
    _sum?: DoctorScheduleSumOrderByAggregateInput
  }

  export type DoctorScheduleScalarWhereWithAggregatesInput = {
    AND?: DoctorScheduleScalarWhereWithAggregatesInput | DoctorScheduleScalarWhereWithAggregatesInput[]
    OR?: DoctorScheduleScalarWhereWithAggregatesInput[]
    NOT?: DoctorScheduleScalarWhereWithAggregatesInput | DoctorScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    doctorId?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    branchId?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"DoctorSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"DoctorSchedule"> | string
    endTime?: StringWithAggregatesFilter<"DoctorSchedule"> | string
    note?: StringNullableWithAggregatesFilter<"DoctorSchedule"> | string | null
  }

  export type ReceptionScheduleWhereInput = {
    AND?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    OR?: ReceptionScheduleWhereInput[]
    NOT?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    id?: IntFilter<"ReceptionSchedule"> | number
    receptionId?: IntFilter<"ReceptionSchedule"> | number
    branchId?: IntFilter<"ReceptionSchedule"> | number
    date?: DateTimeFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringFilter<"ReceptionSchedule"> | string
    endTime?: StringFilter<"ReceptionSchedule"> | string
    note?: StringNullableFilter<"ReceptionSchedule"> | string | null
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ReceptionScheduleOrderByWithRelationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    reception?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ReceptionScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receptionId_branchId_date?: ReceptionScheduleReceptionIdBranchIdDateCompoundUniqueInput
    AND?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    OR?: ReceptionScheduleWhereInput[]
    NOT?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    receptionId?: IntFilter<"ReceptionSchedule"> | number
    branchId?: IntFilter<"ReceptionSchedule"> | number
    date?: DateTimeFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringFilter<"ReceptionSchedule"> | string
    endTime?: StringFilter<"ReceptionSchedule"> | string
    note?: StringNullableFilter<"ReceptionSchedule"> | string | null
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "receptionId_branchId_date">

  export type ReceptionScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: ReceptionScheduleCountOrderByAggregateInput
    _avg?: ReceptionScheduleAvgOrderByAggregateInput
    _max?: ReceptionScheduleMaxOrderByAggregateInput
    _min?: ReceptionScheduleMinOrderByAggregateInput
    _sum?: ReceptionScheduleSumOrderByAggregateInput
  }

  export type ReceptionScheduleScalarWhereWithAggregatesInput = {
    AND?: ReceptionScheduleScalarWhereWithAggregatesInput | ReceptionScheduleScalarWhereWithAggregatesInput[]
    OR?: ReceptionScheduleScalarWhereWithAggregatesInput[]
    NOT?: ReceptionScheduleScalarWhereWithAggregatesInput | ReceptionScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceptionSchedule"> | number
    receptionId?: IntWithAggregatesFilter<"ReceptionSchedule"> | number
    branchId?: IntWithAggregatesFilter<"ReceptionSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"ReceptionSchedule"> | string
    endTime?: StringWithAggregatesFilter<"ReceptionSchedule"> | string
    note?: StringNullableWithAggregatesFilter<"ReceptionSchedule"> | string | null
  }

  export type DoctorBranchWhereInput = {
    AND?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    OR?: DoctorBranchWhereInput[]
    NOT?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    id?: IntFilter<"DoctorBranch"> | number
    doctorId?: IntFilter<"DoctorBranch"> | number
    branchId?: IntFilter<"DoctorBranch"> | number
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type DoctorBranchOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type DoctorBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    doctorId_branchId?: DoctorBranchDoctorIdBranchIdCompoundUniqueInput
    AND?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    OR?: DoctorBranchWhereInput[]
    NOT?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    doctorId?: IntFilter<"DoctorBranch"> | number
    branchId?: IntFilter<"DoctorBranch"> | number
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "doctorId_branchId">

  export type DoctorBranchOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    _count?: DoctorBranchCountOrderByAggregateInput
    _avg?: DoctorBranchAvgOrderByAggregateInput
    _max?: DoctorBranchMaxOrderByAggregateInput
    _min?: DoctorBranchMinOrderByAggregateInput
    _sum?: DoctorBranchSumOrderByAggregateInput
  }

  export type DoctorBranchScalarWhereWithAggregatesInput = {
    AND?: DoctorBranchScalarWhereWithAggregatesInput | DoctorBranchScalarWhereWithAggregatesInput[]
    OR?: DoctorBranchScalarWhereWithAggregatesInput[]
    NOT?: DoctorBranchScalarWhereWithAggregatesInput | DoctorBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DoctorBranch"> | number
    doctorId?: IntWithAggregatesFilter<"DoctorBranch"> | number
    branchId?: IntWithAggregatesFilter<"DoctorBranch"> | number
  }

  export type ReceptionBranchWhereInput = {
    AND?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    OR?: ReceptionBranchWhereInput[]
    NOT?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    id?: IntFilter<"ReceptionBranch"> | number
    receptionId?: IntFilter<"ReceptionBranch"> | number
    branchId?: IntFilter<"ReceptionBranch"> | number
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ReceptionBranchOrderByWithRelationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    reception?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ReceptionBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receptionId_branchId?: ReceptionBranchReceptionIdBranchIdCompoundUniqueInput
    AND?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    OR?: ReceptionBranchWhereInput[]
    NOT?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    receptionId?: IntFilter<"ReceptionBranch"> | number
    branchId?: IntFilter<"ReceptionBranch"> | number
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "receptionId_branchId">

  export type ReceptionBranchOrderByWithAggregationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    _count?: ReceptionBranchCountOrderByAggregateInput
    _avg?: ReceptionBranchAvgOrderByAggregateInput
    _max?: ReceptionBranchMaxOrderByAggregateInput
    _min?: ReceptionBranchMinOrderByAggregateInput
    _sum?: ReceptionBranchSumOrderByAggregateInput
  }

  export type ReceptionBranchScalarWhereWithAggregatesInput = {
    AND?: ReceptionBranchScalarWhereWithAggregatesInput | ReceptionBranchScalarWhereWithAggregatesInput[]
    OR?: ReceptionBranchScalarWhereWithAggregatesInput[]
    NOT?: ReceptionBranchScalarWhereWithAggregatesInput | ReceptionBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceptionBranch"> | number
    receptionId?: IntWithAggregatesFilter<"ReceptionBranch"> | number
    branchId?: IntWithAggregatesFilter<"ReceptionBranch"> | number
  }

  export type NurseBranchWhereInput = {
    AND?: NurseBranchWhereInput | NurseBranchWhereInput[]
    OR?: NurseBranchWhereInput[]
    NOT?: NurseBranchWhereInput | NurseBranchWhereInput[]
    id?: IntFilter<"NurseBranch"> | number
    nurseId?: IntFilter<"NurseBranch"> | number
    branchId?: IntFilter<"NurseBranch"> | number
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type NurseBranchOrderByWithRelationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    nurse?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type NurseBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nurseId_branchId?: NurseBranchNurseIdBranchIdCompoundUniqueInput
    AND?: NurseBranchWhereInput | NurseBranchWhereInput[]
    OR?: NurseBranchWhereInput[]
    NOT?: NurseBranchWhereInput | NurseBranchWhereInput[]
    nurseId?: IntFilter<"NurseBranch"> | number
    branchId?: IntFilter<"NurseBranch"> | number
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "nurseId_branchId">

  export type NurseBranchOrderByWithAggregationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    _count?: NurseBranchCountOrderByAggregateInput
    _avg?: NurseBranchAvgOrderByAggregateInput
    _max?: NurseBranchMaxOrderByAggregateInput
    _min?: NurseBranchMinOrderByAggregateInput
    _sum?: NurseBranchSumOrderByAggregateInput
  }

  export type NurseBranchScalarWhereWithAggregatesInput = {
    AND?: NurseBranchScalarWhereWithAggregatesInput | NurseBranchScalarWhereWithAggregatesInput[]
    OR?: NurseBranchScalarWhereWithAggregatesInput[]
    NOT?: NurseBranchScalarWhereWithAggregatesInput | NurseBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NurseBranch"> | number
    nurseId?: IntWithAggregatesFilter<"NurseBranch"> | number
    branchId?: IntWithAggregatesFilter<"NurseBranch"> | number
  }

  export type NurseScheduleWhereInput = {
    AND?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    OR?: NurseScheduleWhereInput[]
    NOT?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    id?: IntFilter<"NurseSchedule"> | number
    nurseId?: IntFilter<"NurseSchedule"> | number
    branchId?: IntFilter<"NurseSchedule"> | number
    date?: DateTimeFilter<"NurseSchedule"> | Date | string
    startTime?: StringFilter<"NurseSchedule"> | string
    endTime?: StringFilter<"NurseSchedule"> | string
    note?: StringNullableFilter<"NurseSchedule"> | string | null
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type NurseScheduleOrderByWithRelationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    nurse?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type NurseScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nurseId_branchId_date?: NurseScheduleNurseIdBranchIdDateCompoundUniqueInput
    AND?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    OR?: NurseScheduleWhereInput[]
    NOT?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    nurseId?: IntFilter<"NurseSchedule"> | number
    branchId?: IntFilter<"NurseSchedule"> | number
    date?: DateTimeFilter<"NurseSchedule"> | Date | string
    startTime?: StringFilter<"NurseSchedule"> | string
    endTime?: StringFilter<"NurseSchedule"> | string
    note?: StringNullableFilter<"NurseSchedule"> | string | null
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "nurseId_branchId_date">

  export type NurseScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: NurseScheduleCountOrderByAggregateInput
    _avg?: NurseScheduleAvgOrderByAggregateInput
    _max?: NurseScheduleMaxOrderByAggregateInput
    _min?: NurseScheduleMinOrderByAggregateInput
    _sum?: NurseScheduleSumOrderByAggregateInput
  }

  export type NurseScheduleScalarWhereWithAggregatesInput = {
    AND?: NurseScheduleScalarWhereWithAggregatesInput | NurseScheduleScalarWhereWithAggregatesInput[]
    OR?: NurseScheduleScalarWhereWithAggregatesInput[]
    NOT?: NurseScheduleScalarWhereWithAggregatesInput | NurseScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NurseSchedule"> | number
    nurseId?: IntWithAggregatesFilter<"NurseSchedule"> | number
    branchId?: IntWithAggregatesFilter<"NurseSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"NurseSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"NurseSchedule"> | string
    endTime?: StringWithAggregatesFilter<"NurseSchedule"> | string
    note?: StringNullableWithAggregatesFilter<"NurseSchedule"> | string | null
  }

  export type BranchCreateInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitCreateInput = {
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeBenefitsInput
    usages?: EmployeeBenefitUsageCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitUncheckedCreateInput = {
    id?: number
    employeeId: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeBenefitsNestedInput
    usages?: EmployeeBenefitUsageUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitCreateManyInput = {
    id?: number
    employeeId: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeBenefitUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageCreateInput = {
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
    employeeBenefit: EmployeeBenefitCreateNestedOneWithoutUsagesInput
    invoice: InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageUpdateInput = {
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeBenefit?: EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageCreateManyInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageUpdateManyMutationInput = {
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PatientCreateInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
  }

  export type PatientUpdateManyMutationInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type PatientBookCreateInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateInput = {
    id?: number
    bookNumber: string
    patientId: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUpdateInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookCreateManyInput = {
    id?: number
    bookNumber: string
    patientId: number
  }

  export type PatientBookUpdateManyMutationInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PatientBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
  }

  export type VisitCardCreateInput = {
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook: PatientBookCreateNestedOneWithoutVisitCardInput
  }

  export type VisitCardUncheckedCreateInput = {
    id?: number
    patientBookId: number
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardUpdateInput = {
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUpdateOneRequiredWithoutVisitCardNestedInput
  }

  export type VisitCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCardCreateManyInput = {
    id?: number
    patientBookId: number
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardUpdateManyMutationInput = {
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook: PatientBookCreateNestedOneWithoutOrthoCardInput
  }

  export type OrthoCardUncheckedCreateInput = {
    id?: number
    patientBookId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUpdateOneRequiredWithoutOrthoCardNestedInput
  }

  export type OrthoCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardCreateManyInput = {
    id?: number
    patientBookId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutBookingsInput
    branch: BranchCreateNestedOneWithoutBookingsInput
    patient: PatientCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    doctorId: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutBookingsNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: number
    doctorId: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterUpdateManyMutationInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterConsentCreateInput = {
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutConsentsInput
  }

  export type EncounterConsentUncheckedCreateInput = {
    id?: number
    encounterId: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type EncounterConsentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentCreateManyInput = {
    id?: number
    encounterId: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartToothCreateInput = {
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounter: EncounterCreateNestedOneWithoutChartTeethInput
    chartNotes?: ChartNoteCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothUncheckedCreateInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounterId: number
    chartNotes?: ChartNoteUncheckedCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothUpdateInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutChartTeethNestedInput
    chartNotes?: ChartNoteUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: IntFieldUpdateOperationsInput | number
    chartNotes?: ChartNoteUncheckedUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothCreateManyInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounterId: number
  }

  export type ChartToothUpdateManyMutationInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChartToothUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: IntFieldUpdateOperationsInput | number
  }

  export type ChartNoteCreateInput = {
    description: string
    createdAt?: Date | string
    chartTooth: ChartToothCreateNestedOneWithoutChartNotesInput
  }

  export type ChartNoteUncheckedCreateInput = {
    id?: number
    chartToothId: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartTooth?: ChartToothUpdateOneRequiredWithoutChartNotesNestedInput
  }

  export type ChartNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chartToothId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteCreateManyInput = {
    id?: number
    chartToothId: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chartToothId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemCreateNestedManyWithoutDiagnosisInput
    encounters?: EncounterDiagnosisCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemUncheckedCreateNestedManyWithoutDiagnosisInput
    encounters?: EncounterDiagnosisUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUpdateManyWithoutDiagnosisNestedInput
    encounters?: EncounterDiagnosisUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisNestedInput
    encounters?: EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisCreateManyInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisProblemCreateInput = {
    label: string
    order?: number
    active?: boolean
    diagnosis: DiagnosisCreateNestedOneWithoutProblemsInput
  }

  export type DiagnosisProblemUncheckedCreateInput = {
    id?: number
    diagnosisId: number
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    diagnosis?: DiagnosisUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type DiagnosisProblemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemCreateManyInput = {
    id?: number
    diagnosisId: number
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterDiagnosisCreateInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDiagnosesInput
    diagnosis: DiagnosisCreateNestedOneWithoutEncountersInput
  }

  export type EncounterDiagnosisUncheckedCreateInput = {
    id?: number
    encounterId: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisUpdateInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDiagnosesNestedInput
    diagnosis?: DiagnosisUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisCreateManyInput = {
    id?: number
    encounterId: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisUpdateManyMutationInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
  }

  export type ServiceUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchCreateInput = {
    service: ServiceCreateNestedOneWithoutServiceBranchesInput
    branch: BranchCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateInput = {
    serviceId: number
    branchId: number
  }

  export type ServiceBranchUpdateInput = {
    service?: ServiceUpdateOneRequiredWithoutServiceBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceBranchCreateManyInput = {
    serviceId: number
    branchId: number
  }

  export type ServiceBranchUpdateManyMutationInput = {

  }

  export type ServiceBranchUncheckedUpdateManyInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterServiceCreateInput = {
    quantity?: number
    price: number
    encounter: EncounterCreateNestedOneWithoutEncounterServicesInput
    service: ServiceCreateNestedOneWithoutEncounterServicesInput
  }

  export type EncounterServiceUncheckedCreateInput = {
    id?: number
    encounterId: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    encounter?: EncounterUpdateOneRequiredWithoutEncounterServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutEncounterServicesNestedInput
  }

  export type EncounterServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceCreateManyInput = {
    id?: number
    encounterId: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcedureCreateInput = {
    code: string
    name: string
    price: number
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateInput = {
    code: string
    name: string
    price: number
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    invoiceItems?: InvoiceItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureCreateManyInput = {
    code: string
    name: string
    price: number
  }

  export type ProcedureUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcedureUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    branchId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    branchId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    encounter: EncounterCreateNestedOneWithoutPrescriptionInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: number
    encounterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutPrescriptionNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: number
    encounterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
  }

  export type PrescriptionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemCreateInput = {
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
    prescription: PrescriptionCreateNestedOneWithoutItemsInput
  }

  export type PrescriptionItemUncheckedCreateInput = {
    id?: number
    prescriptionId: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemCreateManyInput = {
    id?: number
    prescriptionId: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateManyMutationInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type PaymentCreateInput = {
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    invoiceId: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    invoiceId: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptCreateInput = {
    receiptNumber: string
    timestamp?: Date | string
    invoice: InvoiceCreateNestedOneWithoutEBarimtReceiptInput
  }

  export type EBarimtReceiptUncheckedCreateInput = {
    id?: number
    invoiceId: number
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptUpdateInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutEBarimtReceiptNestedInput
  }

  export type EBarimtReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptCreateManyInput = {
    id?: number
    invoiceId: number
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptUpdateManyMutationInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateManyMutationInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorizationCodeCreateInput = {
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAuthorizationCodesInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeUncheckedCreateInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAuthorizationCodesNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeCreateManyInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorizationCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorizationCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherCreateInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherCreateManyInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type EmployeeVoucherUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type MediaCreateInput = {
    filePath: string
    toothCode?: string | null
    type: string
    encounter: EncounterCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: number
    encounterId: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaUpdateInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    encounter?: EncounterUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateManyInput = {
    id?: number
    encounterId: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaUpdateManyMutationInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorScheduleCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    doctor: UserCreateNestedOneWithoutDoctorSchedulesInput
    branch: BranchCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneRequiredWithoutDoctorSchedulesNestedInput
    branch?: BranchUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleCreateManyInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    reception: UserCreateNestedOneWithoutReceptionSchedulesInput
    branch: BranchCreateNestedOneWithoutReceptionSchedulesInput
  }

  export type ReceptionScheduleUncheckedCreateInput = {
    id?: number
    receptionId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reception?: UserUpdateOneRequiredWithoutReceptionSchedulesNestedInput
    branch?: BranchUpdateOneRequiredWithoutReceptionSchedulesNestedInput
  }

  export type ReceptionScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleCreateManyInput = {
    id?: number
    receptionId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorBranchCreateInput = {
    doctor: UserCreateNestedOneWithoutDoctorBranchesInput
    branch: BranchCreateNestedOneWithoutDoctorBranchesInput
  }

  export type DoctorBranchUncheckedCreateInput = {
    id?: number
    doctorId: number
    branchId: number
  }

  export type DoctorBranchUpdateInput = {
    doctor?: UserUpdateOneRequiredWithoutDoctorBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutDoctorBranchesNestedInput
  }

  export type DoctorBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchCreateManyInput = {
    id?: number
    doctorId: number
    branchId: number
  }

  export type DoctorBranchUpdateManyMutationInput = {

  }

  export type DoctorBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchCreateInput = {
    reception: UserCreateNestedOneWithoutReceptionBranchesInput
    branch: BranchCreateNestedOneWithoutReceptionBranchesInput
  }

  export type ReceptionBranchUncheckedCreateInput = {
    id?: number
    receptionId: number
    branchId: number
  }

  export type ReceptionBranchUpdateInput = {
    reception?: UserUpdateOneRequiredWithoutReceptionBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutReceptionBranchesNestedInput
  }

  export type ReceptionBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchCreateManyInput = {
    id?: number
    receptionId: number
    branchId: number
  }

  export type ReceptionBranchUpdateManyMutationInput = {

  }

  export type ReceptionBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchCreateInput = {
    nurse: UserCreateNestedOneWithoutNurseBranchesInput
    branch: BranchCreateNestedOneWithoutNurseBranchesInput
  }

  export type NurseBranchUncheckedCreateInput = {
    id?: number
    nurseId: number
    branchId: number
  }

  export type NurseBranchUpdateInput = {
    nurse?: UserUpdateOneRequiredWithoutNurseBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutNurseBranchesNestedInput
  }

  export type NurseBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchCreateManyInput = {
    id?: number
    nurseId: number
    branchId: number
  }

  export type NurseBranchUpdateManyMutationInput = {

  }

  export type NurseBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseScheduleCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    nurse: UserCreateNestedOneWithoutNurseSchedulesInput
    branch: BranchCreateNestedOneWithoutNurseSchedulesInput
  }

  export type NurseScheduleUncheckedCreateInput = {
    id?: number
    nurseId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nurse?: UserUpdateOneRequiredWithoutNurseSchedulesNestedInput
    branch?: BranchUpdateOneRequiredWithoutNurseSchedulesNestedInput
  }

  export type NurseScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleCreateManyInput = {
    id?: number
    nurseId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type DoctorScheduleListRelationFilter = {
    every?: DoctorScheduleWhereInput
    some?: DoctorScheduleWhereInput
    none?: DoctorScheduleWhereInput
  }

  export type ServiceBranchListRelationFilter = {
    every?: ServiceBranchWhereInput
    some?: ServiceBranchWhereInput
    none?: ServiceBranchWhereInput
  }

  export type DoctorBranchListRelationFilter = {
    every?: DoctorBranchWhereInput
    some?: DoctorBranchWhereInput
    none?: DoctorBranchWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReceptionScheduleListRelationFilter = {
    every?: ReceptionScheduleWhereInput
    some?: ReceptionScheduleWhereInput
    none?: ReceptionScheduleWhereInput
  }

  export type ReceptionBranchListRelationFilter = {
    every?: ReceptionBranchWhereInput
    some?: ReceptionBranchWhereInput
    none?: ReceptionBranchWhereInput
  }

  export type NurseScheduleListRelationFilter = {
    every?: NurseScheduleWhereInput
    some?: NurseScheduleWhereInput
    none?: NurseScheduleWhereInput
  }

  export type NurseBranchListRelationFilter = {
    every?: NurseBranchWhereInput
    some?: NurseBranchWhereInput
    none?: NurseBranchWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type EmployeeVoucherListRelationFilter = {
    every?: EmployeeVoucherWhereInput
    some?: EmployeeVoucherWhereInput
    none?: EmployeeVoucherWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceptionScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceptionBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NurseScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NurseBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeVoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeBenefitUsageListRelationFilter = {
    every?: EmployeeBenefitUsageWhereInput
    some?: EmployeeBenefitUsageWhereInput
    none?: EmployeeBenefitUsageWhereInput
  }

  export type EmployeeBenefitUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeBenefitCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeBenefitAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type EmployeeBenefitMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeBenefitMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeBenefitSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmployeeBenefitRelationFilter = {
    is?: EmployeeBenefitWhereInput
    isNot?: EmployeeBenefitWhereInput
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type EmployeeBenefitUsageCountOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeBenefitUsageAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
  }

  export type EmployeeBenefitUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeBenefitUsageMinOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeBenefitUsageSumOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type EmployeeBenefitListRelationFilter = {
    every?: EmployeeBenefitWhereInput
    some?: EmployeeBenefitWhereInput
    none?: EmployeeBenefitWhereInput
  }

  export type AuthorizationCodeListRelationFilter = {
    every?: AuthorizationCodeWhereInput
    some?: AuthorizationCodeWhereInput
    none?: AuthorizationCodeWhereInput
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeBenefitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorizationCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    regNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiryDate?: SortOrder
    signatureImagePath?: SortOrder
    stampImagePath?: SortOrder
    idPhotoPath?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    regNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiryDate?: SortOrder
    signatureImagePath?: SortOrder
    stampImagePath?: SortOrder
    idPhotoPath?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    regNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiryDate?: SortOrder
    signatureImagePath?: SortOrder
    stampImagePath?: SortOrder
    idPhotoPath?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    calendarOrder?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type PatientBookNullableRelationFilter = {
    is?: PatientBookWhereInput | null
    isNot?: PatientBookWhereInput | null
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bloodType?: SortOrder
    citizenship?: SortOrder
    emergencyPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bloodType?: SortOrder
    citizenship?: SortOrder
    emergencyPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bloodType?: SortOrder
    citizenship?: SortOrder
    emergencyPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type VisitCardNullableRelationFilter = {
    is?: VisitCardWhereInput | null
    isNot?: VisitCardWhereInput | null
  }

  export type OrthoCardNullableRelationFilter = {
    is?: OrthoCardWhereInput | null
    isNot?: OrthoCardWhereInput | null
  }

  export type PatientBookCountOrderByAggregateInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookMaxOrderByAggregateInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookMinOrderByAggregateInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
  }

  export type EnumVisitCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeFilter<$PrismaModel> | $Enums.VisitCardType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PatientBookRelationFilter = {
    is?: PatientBookWhereInput
    isNot?: PatientBookWhereInput
  }

  export type VisitCardCountOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    patientSignaturePath?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitCardAvgOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type VisitCardMaxOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    patientSignaturePath?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitCardMinOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    patientSignaturePath?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitCardSumOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type EnumVisitCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitCardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitCardTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitCardTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type OrthoCardCountOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrthoCardAvgOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type OrthoCardMaxOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrthoCardMinOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrthoCardSumOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type AppointmentNullableRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type ChartToothListRelationFilter = {
    every?: ChartToothWhereInput
    some?: ChartToothWhereInput
    none?: ChartToothWhereInput
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PrescriptionNullableRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type EncounterServiceListRelationFilter = {
    every?: EncounterServiceWhereInput
    some?: EncounterServiceWhereInput
    none?: EncounterServiceWhereInput
  }

  export type EncounterDiagnosisListRelationFilter = {
    every?: EncounterDiagnosisWhereInput
    some?: EncounterDiagnosisWhereInput
    none?: EncounterDiagnosisWhereInput
  }

  export type EncounterConsentListRelationFilter = {
    every?: EncounterConsentWhereInput
    some?: EncounterConsentWhereInput
    none?: EncounterConsentWhereInput
  }

  export type ChartToothOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterDiagnosisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
    patientSignaturePath?: SortOrder
    patientSignedAt?: SortOrder
    doctorSignaturePath?: SortOrder
    doctorSignedAt?: SortOrder
  }

  export type EncounterAvgOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
    patientSignaturePath?: SortOrder
    patientSignedAt?: SortOrder
    doctorSignaturePath?: SortOrder
    doctorSignedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
    patientSignaturePath?: SortOrder
    patientSignedAt?: SortOrder
    doctorSignaturePath?: SortOrder
    doctorSignedAt?: SortOrder
  }

  export type EncounterSumOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
  }

  export type EncounterRelationFilter = {
    is?: EncounterWhereInput
    isNot?: EncounterWhereInput
  }

  export type EncounterConsentEncounterIdTypeCompoundUniqueInput = {
    encounterId: number
    type: string
  }

  export type EncounterConsentCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterConsentAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type EncounterConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterConsentMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterConsentSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartNoteListRelationFilter = {
    every?: ChartNoteWhereInput
    some?: ChartNoteWhereInput
    none?: ChartNoteWhereInput
  }

  export type ChartNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChartToothCountOrderByAggregateInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothMaxOrderByAggregateInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothMinOrderByAggregateInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothRelationFilter = {
    is?: ChartToothWhereInput
    isNot?: ChartToothWhereInput
  }

  export type ChartNoteCountOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
  }

  export type ChartNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartNoteMinOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartNoteSumOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
  }

  export type DiagnosisProblemListRelationFilter = {
    every?: DiagnosisProblemWhereInput
    some?: DiagnosisProblemWhereInput
    none?: DiagnosisProblemWhereInput
  }

  export type DiagnosisProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiagnosisRelationFilter = {
    is?: DiagnosisWhereInput
    isNot?: DiagnosisWhereInput
  }

  export type DiagnosisProblemCountOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
  }

  export type DiagnosisProblemAvgOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    order?: SortOrder
  }

  export type DiagnosisProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
  }

  export type DiagnosisProblemMinOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
  }

  export type DiagnosisProblemSumOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    order?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EncounterDiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrder
    selectedProblemIds?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
  }

  export type EncounterDiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceBranchServiceIdBranchIdCompoundUniqueInput = {
    serviceId: number
    branchId: number
  }

  export type ServiceBranchCountOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchAvgOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchMaxOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchMinOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchSumOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type EncounterServiceCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ProcedureCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProcedureAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProcedureMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProcedureMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProcedureSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    price?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    price?: SortOrder
  }

  export type PrescriptionItemListRelationFilter = {
    every?: PrescriptionItemWhereInput
    some?: PrescriptionItemWhereInput
    none?: PrescriptionItemWhereInput
  }

  export type PrescriptionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrder
    patientNameSnapshot?: SortOrder
    diagnosisSummary?: SortOrder
    clinicNameSnapshot?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrder
    patientNameSnapshot?: SortOrder
    diagnosisSummary?: SortOrder
    clinicNameSnapshot?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrder
    patientNameSnapshot?: SortOrder
    diagnosisSummary?: SortOrder
    clinicNameSnapshot?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type PrescriptionRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type PrescriptionItemCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrder
  }

  export type PrescriptionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
  }

  export type PrescriptionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrder
  }

  export type PrescriptionItemMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrder
  }

  export type PrescriptionItemSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDiscountPercentFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentFilter<$PrismaModel> | $Enums.DiscountPercent
  }

  export type PatientNullableRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type EBarimtReceiptNullableRelationFilter = {
    is?: EBarimtReceiptWhereInput | null
    isNot?: EBarimtReceiptWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrder
    statusLegacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    finalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrder
    statusLegacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrder
    statusLegacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    finalAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDiscountPercentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentWithAggregatesFilter<$PrismaModel> | $Enums.DiscountPercent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountPercentFilter<$PrismaModel>
    _max?: NestedEnumDiscountPercentFilter<$PrismaModel>
  }

  export type EnumInvoiceItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeFilter<$PrismaModel> | $Enums.InvoiceItemType
  }

  export type EnumInvoiceItemSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceFilter<$PrismaModel> | $Enums.InvoiceItemSource
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProcedureNullableRelationFilter = {
    is?: ProcedureWhereInput | null
    isNot?: ProcedureWhereInput | null
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    procedureCode?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    procedureCode?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    procedureCode?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
  }

  export type EnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type EBarimtReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
  }

  export type EBarimtReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
  }

  export type EBarimtReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
  }

  export type EBarimtReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
  }

  export type EBarimtReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
  }

  export type EnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type AuthorizationCodeNullableRelationFilter = {
    is?: AuthorizationCodeWhereInput | null
    isNot?: AuthorizationCodeWhereInput | null
  }

  export type EmployeeVoucherNullableRelationFilter = {
    is?: EmployeeVoucherWhereInput | null
    isNot?: EmployeeVoucherWhereInput | null
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
  }

  export type EnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type AuthorizationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
  }

  export type AuthorizationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationCodeSumOrderByAggregateInput = {
    id?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
  }

  export type EnumEmployeeVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
  }

  export type EmployeeVoucherCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    eligibility?: SortOrder
    allowedPatientIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdById?: SortOrder
  }

  export type EnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrder
    type?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrder
    type?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrder
    type?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type DoctorScheduleDoctorIdBranchIdDateCompoundUniqueInput = {
    doctorId: number
    branchId: number
    date: Date | string
  }

  export type DoctorScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type DoctorScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type DoctorScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type DoctorScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionScheduleReceptionIdBranchIdDateCompoundUniqueInput = {
    receptionId: number
    branchId: number
    date: Date | string
  }

  export type ReceptionScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type ReceptionScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type ReceptionScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type ReceptionScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchDoctorIdBranchIdCompoundUniqueInput = {
    doctorId: number
    branchId: number
  }

  export type DoctorBranchCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchReceptionIdBranchIdCompoundUniqueInput = {
    receptionId: number
    branchId: number
  }

  export type ReceptionBranchCountOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchMinOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchSumOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchNurseIdBranchIdCompoundUniqueInput = {
    nurseId: number
    branchId: number
  }

  export type NurseBranchCountOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchMinOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchSumOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseScheduleNurseIdBranchIdDateCompoundUniqueInput = {
    nurseId: number
    branchId: number
    date: Date | string
  }

  export type NurseScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type NurseScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type NurseScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type NurseScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type DoctorScheduleCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ServiceBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type DoctorBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReceptionScheduleCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutBranchInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutBranchInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ServiceBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type DoctorBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type DoctorScheduleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput | DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput | DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutBranchInput | DoctorScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ServiceBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutBranchInput | ServiceBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutBranchInput | ServiceBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutBranchInput | ServiceBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type DoctorBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutBranchInput | DoctorBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutBranchInput | DoctorBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutBranchInput | DoctorBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutBranchInput | AppointmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutBranchInput | AppointmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutBranchInput | AppointmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBranchInput | BookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBranchInput | BookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBranchInput | BookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReceptionScheduleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutBranchInput | ReceptionScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput | ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput | ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutBranchInput | ReceptionBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutBranchInput | NurseScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutBranchInput | NurseScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutBranchInput | NurseScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutBranchInput | NurseBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutBranchInput | NurseBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutBranchInput | NurseBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBranchInput | ProductUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBranchInput | ProductUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBranchInput | ProductUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutBranchInput | InvoiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutBranchInput | InvoiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutBranchInput | InvoiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutBranchInput | LedgerEntryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutBranchInput | LedgerEntryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutBranchInput | LedgerEntryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutBranchInput | EmployeeVoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput | DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput | DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutBranchInput | DoctorScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutBranchInput | ServiceBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutBranchInput | ServiceBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutBranchInput | ServiceBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutBranchInput | DoctorBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutBranchInput | DoctorBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutBranchInput | DoctorBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutBranchInput | AppointmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutBranchInput | AppointmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutBranchInput | AppointmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBranchInput | BookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBranchInput | BookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBranchInput | BookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutBranchInput | ReceptionScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput | ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput | ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutBranchInput | ReceptionBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutBranchInput | NurseScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutBranchInput | NurseScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutBranchInput | NurseScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutBranchInput | NurseBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutBranchInput | NurseBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutBranchInput | NurseBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBranchInput | ProductUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBranchInput | ProductUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBranchInput | ProductUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutBranchInput | InvoiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutBranchInput | InvoiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutBranchInput | InvoiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutBranchInput | LedgerEntryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutBranchInput | LedgerEntryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutBranchInput | LedgerEntryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutBranchInput | EmployeeVoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeBenefitsInput = {
    create?: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeBenefitsInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeBenefitUsageCreateNestedManyWithoutEmployeeBenefitInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEmployeeBenefitInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutEmployeeBenefitsNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeBenefitsInput
    upsert?: UserUpsertWithoutEmployeeBenefitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeBenefitsInput, UserUpdateWithoutEmployeeBenefitsInput>, UserUncheckedUpdateWithoutEmployeeBenefitsInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithoutEmployeeBenefitNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type EmployeeBenefitCreateNestedOneWithoutUsagesInput = {
    create?: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutUsagesInput
    connect?: EmployeeBenefitWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput = {
    create?: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEmployeeBenefitUsagesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutUsagesInput
    upsert?: EmployeeBenefitUpsertWithoutUsagesInput
    connect?: EmployeeBenefitWhereUniqueInput
    update?: XOR<XOR<EmployeeBenefitUpdateToOneWithWhereWithoutUsagesInput, EmployeeBenefitUpdateWithoutUsagesInput>, EmployeeBenefitUncheckedUpdateWithoutUsagesInput>
  }

  export type InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput = {
    create?: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEmployeeBenefitUsagesInput
    upsert?: InvoiceUpsertWithoutEmployeeBenefitUsagesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput, InvoiceUpdateWithoutEmployeeBenefitUsagesInput>, InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutDoctorInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutNurseInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type DoctorScheduleCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type DoctorBranchCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type ReceptionScheduleCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutDoctorInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EmployeeBenefitCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type EmployeeVoucherCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type AuthorizationCodeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type EncounterUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutDoctorInput | EncounterUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutDoctorInput | EncounterUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutDoctorInput | EncounterUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutNurseNestedInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutNurseInput | EncounterUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutNurseInput | EncounterUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutNurseInput | EncounterUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type DoctorScheduleUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutDoctorInput | DoctorScheduleUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type DoctorBranchUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput | DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput | DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutDoctorInput | DoctorBranchUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type ReceptionScheduleUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput | ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutReceptionInput | ReceptionBranchUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutNurseInput | NurseScheduleUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutNurseInput | NurseScheduleUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutNurseInput | NurseScheduleUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutNurseInput | NurseBranchUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutNurseInput | NurseBranchUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutNurseInput | NurseBranchUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDoctorInput | BookingUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDoctorInput | BookingUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDoctorInput | BookingUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EmployeeBenefitUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    set?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    disconnect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    delete?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    update?: EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput | EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutCreatedByInput | LedgerEntryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovedByInput | LedgerEntryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput | EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type EmployeeVoucherUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput | EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type AuthorizationCodeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    set?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    disconnect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    delete?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    update?: AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput | AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutDoctorInput | EncounterUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutDoctorInput | EncounterUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutDoctorInput | EncounterUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutNurseInput | EncounterUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutNurseInput | EncounterUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutNurseInput | EncounterUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutDoctorInput | DoctorScheduleUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput | DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput | DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutDoctorInput | DoctorBranchUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput | ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutReceptionInput | ReceptionBranchUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutNurseInput | NurseScheduleUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutNurseInput | NurseScheduleUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutNurseInput | NurseScheduleUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutNurseInput | NurseBranchUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutNurseInput | NurseBranchUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutNurseInput | NurseBranchUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDoctorInput | BookingUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDoctorInput | BookingUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDoctorInput | BookingUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    set?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    disconnect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    delete?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    update?: EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput | EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutCreatedByInput | LedgerEntryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovedByInput | LedgerEntryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput | EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput | EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    set?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    disconnect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    delete?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    update?: AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput | AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutPatientsInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientBookCreateNestedOneWithoutPatientInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    connect?: PatientBookWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutPatientInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutPatientInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type PatientBookUncheckedCreateNestedOneWithoutPatientInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    connect?: PatientBookWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    upsert?: BranchUpsertWithoutPatientsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPatientsInput, BranchUpdateWithoutPatientsInput>, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type PatientBookUpdateOneWithoutPatientNestedInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    upsert?: PatientBookUpsertWithoutPatientInput
    disconnect?: PatientBookWhereInput | boolean
    delete?: PatientBookWhereInput | boolean
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutPatientInput, PatientBookUpdateWithoutPatientInput>, PatientBookUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPatientInput | BookingUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPatientInput | BookingUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPatientInput | BookingUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutPatientInput | LedgerEntryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutPatientInput | LedgerEntryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutPatientInput | LedgerEntryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PatientBookUncheckedUpdateOneWithoutPatientNestedInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    upsert?: PatientBookUpsertWithoutPatientInput
    disconnect?: PatientBookWhereInput | boolean
    delete?: PatientBookWhereInput | boolean
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutPatientInput, PatientBookUpdateWithoutPatientInput>, PatientBookUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPatientInput | BookingUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPatientInput | BookingUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPatientInput | BookingUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutPatientInput | LedgerEntryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutPatientInput | LedgerEntryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutPatientInput | LedgerEntryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientBookInput
    connect?: PatientWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutPatientBookInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type VisitCardCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    connect?: VisitCardWhereUniqueInput
  }

  export type OrthoCardCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    connect?: OrthoCardWhereUniqueInput
  }

  export type EncounterUncheckedCreateNestedManyWithoutPatientBookInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type VisitCardUncheckedCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    connect?: VisitCardWhereUniqueInput
  }

  export type OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    connect?: OrthoCardWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutPatientBookNestedInput = {
    create?: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientBookInput
    upsert?: PatientUpsertWithoutPatientBookInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPatientBookInput, PatientUpdateWithoutPatientBookInput>, PatientUncheckedUpdateWithoutPatientBookInput>
  }

  export type EncounterUpdateManyWithoutPatientBookNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientBookInput | EncounterUpsertWithWhereUniqueWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientBookInput | EncounterUpdateWithWhereUniqueWithoutPatientBookInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientBookInput | EncounterUpdateManyWithWhereWithoutPatientBookInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type VisitCardUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    upsert?: VisitCardUpsertWithoutPatientBookInput
    disconnect?: VisitCardWhereInput | boolean
    delete?: VisitCardWhereInput | boolean
    connect?: VisitCardWhereUniqueInput
    update?: XOR<XOR<VisitCardUpdateToOneWithWhereWithoutPatientBookInput, VisitCardUpdateWithoutPatientBookInput>, VisitCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type OrthoCardUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    upsert?: OrthoCardUpsertWithoutPatientBookInput
    disconnect?: OrthoCardWhereInput | boolean
    delete?: OrthoCardWhereInput | boolean
    connect?: OrthoCardWhereUniqueInput
    update?: XOR<XOR<OrthoCardUpdateToOneWithWhereWithoutPatientBookInput, OrthoCardUpdateWithoutPatientBookInput>, OrthoCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type EncounterUncheckedUpdateManyWithoutPatientBookNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientBookInput | EncounterUpsertWithWhereUniqueWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientBookInput | EncounterUpdateWithWhereUniqueWithoutPatientBookInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientBookInput | EncounterUpdateManyWithWhereWithoutPatientBookInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    upsert?: VisitCardUpsertWithoutPatientBookInput
    disconnect?: VisitCardWhereInput | boolean
    delete?: VisitCardWhereInput | boolean
    connect?: VisitCardWhereUniqueInput
    update?: XOR<XOR<VisitCardUpdateToOneWithWhereWithoutPatientBookInput, VisitCardUpdateWithoutPatientBookInput>, VisitCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    upsert?: OrthoCardUpsertWithoutPatientBookInput
    disconnect?: OrthoCardWhereInput | boolean
    delete?: OrthoCardWhereInput | boolean
    connect?: OrthoCardWhereUniqueInput
    update?: XOR<XOR<OrthoCardUpdateToOneWithWhereWithoutPatientBookInput, OrthoCardUpdateWithoutPatientBookInput>, OrthoCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type PatientBookCreateNestedOneWithoutVisitCardInput = {
    create?: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutVisitCardInput
    connect?: PatientBookWhereUniqueInput
  }

  export type EnumVisitCardTypeFieldUpdateOperationsInput = {
    set?: $Enums.VisitCardType
  }

  export type PatientBookUpdateOneRequiredWithoutVisitCardNestedInput = {
    create?: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutVisitCardInput
    upsert?: PatientBookUpsertWithoutVisitCardInput
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutVisitCardInput, PatientBookUpdateWithoutVisitCardInput>, PatientBookUncheckedUpdateWithoutVisitCardInput>
  }

  export type PatientBookCreateNestedOneWithoutOrthoCardInput = {
    create?: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutOrthoCardInput
    connect?: PatientBookWhereUniqueInput
  }

  export type PatientBookUpdateOneRequiredWithoutOrthoCardNestedInput = {
    create?: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutOrthoCardInput
    upsert?: PatientBookUpsertWithoutOrthoCardInput
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutOrthoCardInput, PatientBookUpdateWithoutOrthoCardInput>, PatientBookUncheckedUpdateWithoutOrthoCardInput>
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAppointmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BranchUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAppointmentsInput
    upsert?: BranchUpsertWithoutAppointmentsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAppointmentsInput, BranchUpdateWithoutAppointmentsInput>, BranchUncheckedUpdateWithoutAppointmentsInput>
  }

  export type EncounterUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutAppointmentInput | EncounterUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutAppointmentInput | EncounterUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutAppointmentInput | EncounterUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutAppointmentInput | EncounterUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutAppointmentInput | EncounterUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutAppointmentInput | EncounterUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutBookingsInput = {
    create?: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBookingsInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBookingsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type BranchUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBookingsInput
    upsert?: BranchUpsertWithoutBookingsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBookingsInput, BranchUpdateWithoutBookingsInput>, BranchUncheckedUpdateWithoutBookingsInput>
  }

  export type PatientUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBookingsInput
    upsert?: PatientUpsertWithoutBookingsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutBookingsInput, PatientUpdateWithoutBookingsInput>, PatientUncheckedUpdateWithoutBookingsInput>
  }

  export type PatientBookCreateNestedOneWithoutEncountersInput = {
    create?: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutEncountersInput
    connect?: PatientBookWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEncountersInput = {
    create?: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncountersInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutEncountersInput = {
    create?: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEncountersInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNurseEncountersInput = {
    create?: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseEncountersInput
    connect?: UserWhereUniqueInput
  }

  export type ChartToothCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutEncounterInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutEncounterInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutEncounterInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type EncounterServiceCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type EncounterDiagnosisCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type EncounterConsentCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
  }

  export type ChartToothUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutEncounterInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PrescriptionUncheckedCreateNestedOneWithoutEncounterInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
  }

  export type PatientBookUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutEncountersInput
    upsert?: PatientBookUpsertWithoutEncountersInput
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutEncountersInput, PatientBookUpdateWithoutEncountersInput>, PatientBookUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncountersInput
    upsert?: UserUpsertWithoutEncountersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEncountersInput, UserUpdateWithoutEncountersInput>, UserUncheckedUpdateWithoutEncountersInput>
  }

  export type AppointmentUpdateOneWithoutEncountersNestedInput = {
    create?: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEncountersInput
    upsert?: AppointmentUpsertWithoutEncountersInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutEncountersInput, AppointmentUpdateWithoutEncountersInput>, AppointmentUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateOneWithoutNurseEncountersNestedInput = {
    create?: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseEncountersInput
    upsert?: UserUpsertWithoutNurseEncountersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseEncountersInput, UserUpdateWithoutNurseEncountersInput>, UserUncheckedUpdateWithoutNurseEncountersInput>
  }

  export type ChartToothUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    upsert?: ChartToothUpsertWithWhereUniqueWithoutEncounterInput | ChartToothUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    set?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    disconnect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    delete?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    update?: ChartToothUpdateWithWhereUniqueWithoutEncounterInput | ChartToothUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ChartToothUpdateManyWithWhereWithoutEncounterInput | ChartToothUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    upsert?: InvoiceUpsertWithoutEncounterInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEncounterInput, InvoiceUpdateWithoutEncounterInput>, InvoiceUncheckedUpdateWithoutEncounterInput>
  }

  export type PrescriptionUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    upsert?: PrescriptionUpsertWithoutEncounterInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutEncounterInput, PrescriptionUpdateWithoutEncounterInput>, PrescriptionUncheckedUpdateWithoutEncounterInput>
  }

  export type MediaUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutEncounterInput | MediaUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutEncounterInput | MediaUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutEncounterInput | MediaUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type EncounterServiceUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput | EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput | EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutEncounterInput | EncounterServiceUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type EncounterDiagnosisUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput | EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type EncounterConsentUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput | EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    set?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    disconnect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    delete?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    update?: EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput | EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterConsentUpdateManyWithWhereWithoutEncounterInput | EncounterConsentUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
  }

  export type ChartToothUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    upsert?: ChartToothUpsertWithWhereUniqueWithoutEncounterInput | ChartToothUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    set?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    disconnect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    delete?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    update?: ChartToothUpdateWithWhereUniqueWithoutEncounterInput | ChartToothUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ChartToothUpdateManyWithWhereWithoutEncounterInput | ChartToothUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    upsert?: InvoiceUpsertWithoutEncounterInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEncounterInput, InvoiceUpdateWithoutEncounterInput>, InvoiceUncheckedUpdateWithoutEncounterInput>
  }

  export type PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    upsert?: PrescriptionUpsertWithoutEncounterInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutEncounterInput, PrescriptionUpdateWithoutEncounterInput>, PrescriptionUncheckedUpdateWithoutEncounterInput>
  }

  export type MediaUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutEncounterInput | MediaUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutEncounterInput | MediaUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutEncounterInput | MediaUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput | EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput | EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutEncounterInput | EncounterServiceUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput | EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput | EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    set?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    disconnect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    delete?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    update?: EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput | EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterConsentUpdateManyWithWhereWithoutEncounterInput | EncounterConsentUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutConsentsInput = {
    create?: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutConsentsInput
    connect?: EncounterWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutConsentsInput
    upsert?: EncounterUpsertWithoutConsentsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutConsentsInput, EncounterUpdateWithoutConsentsInput>, EncounterUncheckedUpdateWithoutConsentsInput>
  }

  export type EncounterCreateNestedOneWithoutChartTeethInput = {
    create?: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutChartTeethInput
    connect?: EncounterWhereUniqueInput
  }

  export type ChartNoteCreateNestedManyWithoutChartToothInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
  }

  export type ChartNoteUncheckedCreateNestedManyWithoutChartToothInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
  }

  export type EncounterUpdateOneRequiredWithoutChartTeethNestedInput = {
    create?: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutChartTeethInput
    upsert?: EncounterUpsertWithoutChartTeethInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutChartTeethInput, EncounterUpdateWithoutChartTeethInput>, EncounterUncheckedUpdateWithoutChartTeethInput>
  }

  export type ChartNoteUpdateManyWithoutChartToothNestedInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    upsert?: ChartNoteUpsertWithWhereUniqueWithoutChartToothInput | ChartNoteUpsertWithWhereUniqueWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    set?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    disconnect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    delete?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    update?: ChartNoteUpdateWithWhereUniqueWithoutChartToothInput | ChartNoteUpdateWithWhereUniqueWithoutChartToothInput[]
    updateMany?: ChartNoteUpdateManyWithWhereWithoutChartToothInput | ChartNoteUpdateManyWithWhereWithoutChartToothInput[]
    deleteMany?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
  }

  export type ChartNoteUncheckedUpdateManyWithoutChartToothNestedInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    upsert?: ChartNoteUpsertWithWhereUniqueWithoutChartToothInput | ChartNoteUpsertWithWhereUniqueWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    set?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    disconnect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    delete?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    update?: ChartNoteUpdateWithWhereUniqueWithoutChartToothInput | ChartNoteUpdateWithWhereUniqueWithoutChartToothInput[]
    updateMany?: ChartNoteUpdateManyWithWhereWithoutChartToothInput | ChartNoteUpdateManyWithWhereWithoutChartToothInput[]
    deleteMany?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
  }

  export type ChartToothCreateNestedOneWithoutChartNotesInput = {
    create?: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
    connectOrCreate?: ChartToothCreateOrConnectWithoutChartNotesInput
    connect?: ChartToothWhereUniqueInput
  }

  export type ChartToothUpdateOneRequiredWithoutChartNotesNestedInput = {
    create?: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
    connectOrCreate?: ChartToothCreateOrConnectWithoutChartNotesInput
    upsert?: ChartToothUpsertWithoutChartNotesInput
    connect?: ChartToothWhereUniqueInput
    update?: XOR<XOR<ChartToothUpdateToOneWithWhereWithoutChartNotesInput, ChartToothUpdateWithoutChartNotesInput>, ChartToothUncheckedUpdateWithoutChartNotesInput>
  }

  export type DiagnosisProblemCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
  }

  export type EncounterDiagnosisCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type DiagnosisProblemUncheckedCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
  }

  export type EncounterDiagnosisUncheckedCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type DiagnosisProblemUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    upsert?: DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    set?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    disconnect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    delete?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    update?: DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput | DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
  }

  export type EncounterDiagnosisUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput | EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    upsert?: DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    set?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    disconnect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    delete?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    update?: DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput | DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput | EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type DiagnosisCreateNestedOneWithoutProblemsInput = {
    create?: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutProblemsInput
    connect?: DiagnosisWhereUniqueInput
  }

  export type DiagnosisUpdateOneRequiredWithoutProblemsNestedInput = {
    create?: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutProblemsInput
    upsert?: DiagnosisUpsertWithoutProblemsInput
    connect?: DiagnosisWhereUniqueInput
    update?: XOR<XOR<DiagnosisUpdateToOneWithWhereWithoutProblemsInput, DiagnosisUpdateWithoutProblemsInput>, DiagnosisUncheckedUpdateWithoutProblemsInput>
  }

  export type EncounterCreateNestedOneWithoutDiagnosesInput = {
    create?: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutDiagnosesInput
    connect?: EncounterWhereUniqueInput
  }

  export type DiagnosisCreateNestedOneWithoutEncountersInput = {
    create?: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEncountersInput
    connect?: DiagnosisWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutDiagnosesNestedInput = {
    create?: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutDiagnosesInput
    upsert?: EncounterUpsertWithoutDiagnosesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutDiagnosesInput, EncounterUpdateWithoutDiagnosesInput>, EncounterUncheckedUpdateWithoutDiagnosesInput>
  }

  export type DiagnosisUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEncountersInput
    upsert?: DiagnosisUpsertWithoutEncountersInput
    connect?: DiagnosisWhereUniqueInput
    update?: XOR<XOR<DiagnosisUpdateToOneWithWhereWithoutEncountersInput, DiagnosisUpdateWithoutEncountersInput>, DiagnosisUncheckedUpdateWithoutEncountersInput>
  }

  export type EncounterServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type ServiceBranchCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EncounterServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type ServiceBranchUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EncounterServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutServiceInput | EncounterServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutServiceInput | EncounterServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutServiceInput | EncounterServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type ServiceBranchUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutServiceInput | ServiceBranchUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutServiceInput | ServiceBranchUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutServiceInput | ServiceBranchUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceInput | InvoiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutServiceInput | EncounterServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutServiceInput | EncounterServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutServiceInput | EncounterServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutServiceInput | ServiceBranchUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutServiceInput | ServiceBranchUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutServiceInput | ServiceBranchUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceInput | InvoiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutServiceBranchesInput = {
    create?: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceBranchesInput
    connect?: ServiceWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutServiceBranchesInput = {
    create?: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutServiceBranchesNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceBranchesInput
    upsert?: ServiceUpsertWithoutServiceBranchesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceBranchesInput, ServiceUpdateWithoutServiceBranchesInput>, ServiceUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutServiceBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceBranchesInput
    upsert?: BranchUpsertWithoutServiceBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServiceBranchesInput, BranchUpdateWithoutServiceBranchesInput>, BranchUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type EncounterCreateNestedOneWithoutEncounterServicesInput = {
    create?: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterServicesInput
    connect?: EncounterWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutEncounterServicesInput = {
    create?: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEncounterServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutEncounterServicesNestedInput = {
    create?: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterServicesInput
    upsert?: EncounterUpsertWithoutEncounterServicesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutEncounterServicesInput, EncounterUpdateWithoutEncounterServicesInput>, EncounterUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutEncounterServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEncounterServicesInput
    upsert?: ServiceUpsertWithoutEncounterServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutEncounterServicesInput, ServiceUpdateWithoutEncounterServicesInput>, ServiceUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type InvoiceItemCreateNestedManyWithoutProcedureInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProcedureInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput | InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput | InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProcedureInput | InvoiceItemUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput | InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput | InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProcedureInput | InvoiceItemUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutProductsInput = {
    create?: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductsInput
    connect?: BranchWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductsInput
    upsert?: BranchUpsertWithoutProductsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutProductsInput, BranchUpdateWithoutProductsInput>, BranchUncheckedUpdateWithoutProductsInput>
  }

  export type InvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutPrescriptionInput
    connect?: EncounterWhereUniqueInput
  }

  export type PrescriptionItemCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type EncounterUpdateOneRequiredWithoutPrescriptionNestedInput = {
    create?: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutPrescriptionInput
    upsert?: EncounterUpsertWithoutPrescriptionInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutPrescriptionInput, EncounterUpdateWithoutPrescriptionInput>, EncounterUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutItemsInput = {
    create?: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutItemsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutItemsInput
    upsert?: PrescriptionUpsertWithoutItemsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutItemsInput, PrescriptionUpdateWithoutItemsInput>, PrescriptionUncheckedUpdateWithoutItemsInput>
  }

  export type BranchCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInvoicesInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutInvoiceInput
    connect?: EncounterWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EBarimtReceiptCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    connect?: EBarimtReceiptWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    connect?: EBarimtReceiptWhereUniqueInput
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDiscountPercentFieldUpdateOperationsInput = {
    set?: $Enums.DiscountPercent
  }

  export type BranchUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInvoicesInput
    upsert?: BranchUpsertWithoutInvoicesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInvoicesInput, BranchUpdateWithoutInvoicesInput>, BranchUncheckedUpdateWithoutInvoicesInput>
  }

  export type EncounterUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutInvoiceInput
    upsert?: EncounterUpsertWithoutInvoiceInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutInvoiceInput, EncounterUpdateWithoutInvoiceInput>, EncounterUncheckedUpdateWithoutInvoiceInput>
  }

  export type PatientUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EBarimtReceiptUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    upsert?: EBarimtReceiptUpsertWithoutInvoiceInput
    disconnect?: EBarimtReceiptWhereInput | boolean
    delete?: EBarimtReceiptWhereInput | boolean
    connect?: EBarimtReceiptWhereUniqueInput
    update?: XOR<XOR<EBarimtReceiptUpdateToOneWithWhereWithoutInvoiceInput, EBarimtReceiptUpdateWithoutInvoiceInput>, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
  }

  export type LedgerEntryUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutInvoiceInput | LedgerEntryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    upsert?: EBarimtReceiptUpsertWithoutInvoiceInput
    disconnect?: EBarimtReceiptWhereInput | boolean
    delete?: EBarimtReceiptWhereInput | boolean
    connect?: EBarimtReceiptWhereUniqueInput
    update?: XOR<XOR<EBarimtReceiptUpdateToOneWithWhereWithoutInvoiceInput, EBarimtReceiptUpdateWithoutInvoiceInput>, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
  }

  export type LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutInvoiceInput | LedgerEntryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProcedureCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProcedureWhereUniqueInput
  }

  export type EnumInvoiceItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceItemType
  }

  export type EnumInvoiceItemSourceFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceItemSource
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ServiceUpsertWithoutInvoiceItemsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput, ServiceUpdateWithoutInvoiceItemsInput>, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProductUpsertWithoutInvoiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInvoiceItemsInput, ProductUpdateWithoutInvoiceItemsInput>, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProcedureUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProcedureUpsertWithoutInvoiceItemsInput
    disconnect?: ProcedureWhereInput | boolean
    delete?: ProcedureWhereInput | boolean
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutInvoiceItemsInput, ProcedureUpdateWithoutInvoiceItemsInput>, ProcedureUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceCreateNestedOneWithoutEBarimtReceiptInput = {
    create?: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEBarimtReceiptInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutEBarimtReceiptNestedInput = {
    create?: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEBarimtReceiptInput
    upsert?: InvoiceUpsertWithoutEBarimtReceiptInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEBarimtReceiptInput, InvoiceUpdateWithoutEBarimtReceiptInput>, InvoiceUncheckedUpdateWithoutEBarimtReceiptInput>
  }

  export type BranchCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLedgerEntriesInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLedgerEntriesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLedgerEntriesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedLedgerEntriesInput = {
    create?: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLedgerEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedLedgerEntriesInput = {
    create?: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLedgerEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutLedgerEntriesInput
    connect?: AuthorizationCodeWhereUniqueInput
  }

  export type EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutLedgerEntriesInput
    connect?: EmployeeVoucherWhereUniqueInput
  }

  export type EnumLedgerEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerEntryType
  }

  export type BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLedgerEntriesInput
    upsert?: BranchUpsertWithoutLedgerEntriesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutLedgerEntriesInput, BranchUpdateWithoutLedgerEntriesInput>, BranchUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLedgerEntriesInput
    upsert?: PatientUpsertWithoutLedgerEntriesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLedgerEntriesInput, PatientUpdateWithoutLedgerEntriesInput>, PatientUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type InvoiceUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLedgerEntriesInput
    upsert?: InvoiceUpsertWithoutLedgerEntriesInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLedgerEntriesInput, InvoiceUpdateWithoutLedgerEntriesInput>, InvoiceUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLedgerEntriesInput
    upsert?: UserUpsertWithoutCreatedLedgerEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLedgerEntriesInput, UserUpdateWithoutCreatedLedgerEntriesInput>, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
  }

  export type UserUpdateOneWithoutApprovedLedgerEntriesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLedgerEntriesInput
    upsert?: UserUpsertWithoutApprovedLedgerEntriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedLedgerEntriesInput, UserUpdateWithoutApprovedLedgerEntriesInput>, UserUncheckedUpdateWithoutApprovedLedgerEntriesInput>
  }

  export type AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutLedgerEntriesInput
    upsert?: AuthorizationCodeUpsertWithoutLedgerEntriesInput
    disconnect?: AuthorizationCodeWhereInput | boolean
    delete?: AuthorizationCodeWhereInput | boolean
    connect?: AuthorizationCodeWhereUniqueInput
    update?: XOR<XOR<AuthorizationCodeUpdateToOneWithWhereWithoutLedgerEntriesInput, AuthorizationCodeUpdateWithoutLedgerEntriesInput>, AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutLedgerEntriesInput
    upsert?: EmployeeVoucherUpsertWithoutLedgerEntriesInput
    disconnect?: EmployeeVoucherWhereInput | boolean
    delete?: EmployeeVoucherWhereInput | boolean
    connect?: EmployeeVoucherWhereUniqueInput
    update?: XOR<XOR<EmployeeVoucherUpdateToOneWithWhereWithoutLedgerEntriesInput, EmployeeVoucherUpdateWithoutLedgerEntriesInput>, EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type UserCreateNestedOneWithoutAuthorizationCodesInput = {
    create?: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorizationCodesInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutApprovalCodeInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutApprovalCodeInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAuthorizationCodesNestedInput = {
    create?: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorizationCodesInput
    upsert?: UserUpsertWithoutAuthorizationCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorizationCodesInput, UserUpdateWithoutAuthorizationCodesInput>, UserUncheckedUpdateWithoutAuthorizationCodesInput>
  }

  export type LedgerEntryUpdateManyWithoutApprovalCodeNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput | LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovalCodeNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput | LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEmployeeVouchersInput = {
    create?: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeeVouchersInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeVouchersInput = {
    create?: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedEmployeeVouchersInput = {
    create?: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedEmployeeVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EnumEmployeeVoucherStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeVoucherStatus
  }

  export type BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput = {
    create?: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeeVouchersInput
    upsert?: BranchUpsertWithoutEmployeeVouchersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEmployeeVouchersInput, BranchUpdateWithoutEmployeeVouchersInput>, BranchUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeVouchersInput
    upsert?: UserUpsertWithoutEmployeeVouchersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeVouchersInput, UserUpdateWithoutEmployeeVouchersInput>, UserUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput | LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedEmployeeVouchersInput
    upsert?: UserUpsertWithoutCreatedEmployeeVouchersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedEmployeeVouchersInput, UserUpdateWithoutCreatedEmployeeVouchersInput>, UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput>
  }

  export type LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput | LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutMediaInput = {
    create?: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutMediaInput
    connect?: EncounterWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutMediaInput
    upsert?: EncounterUpsertWithoutMediaInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutMediaInput, EncounterUpdateWithoutMediaInput>, EncounterUncheckedUpdateWithoutMediaInput>
  }

  export type UserCreateNestedOneWithoutDoctorSchedulesInput = {
    create?: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutDoctorSchedulesInput = {
    create?: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorSchedulesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDoctorSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorSchedulesInput
    upsert?: UserUpsertWithoutDoctorSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorSchedulesInput, UserUpdateWithoutDoctorSchedulesInput>, UserUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type BranchUpdateOneRequiredWithoutDoctorSchedulesNestedInput = {
    create?: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorSchedulesInput
    upsert?: BranchUpsertWithoutDoctorSchedulesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDoctorSchedulesInput, BranchUpdateWithoutDoctorSchedulesInput>, BranchUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type UserCreateNestedOneWithoutReceptionSchedulesInput = {
    create?: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutReceptionSchedulesInput = {
    create?: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionSchedulesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReceptionSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionSchedulesInput
    upsert?: UserUpsertWithoutReceptionSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceptionSchedulesInput, UserUpdateWithoutReceptionSchedulesInput>, UserUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type BranchUpdateOneRequiredWithoutReceptionSchedulesNestedInput = {
    create?: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionSchedulesInput
    upsert?: BranchUpsertWithoutReceptionSchedulesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutReceptionSchedulesInput, BranchUpdateWithoutReceptionSchedulesInput>, BranchUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type UserCreateNestedOneWithoutDoctorBranchesInput = {
    create?: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutDoctorBranchesInput = {
    create?: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDoctorBranchesNestedInput = {
    create?: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorBranchesInput
    upsert?: UserUpsertWithoutDoctorBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorBranchesInput, UserUpdateWithoutDoctorBranchesInput>, UserUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutDoctorBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorBranchesInput
    upsert?: BranchUpsertWithoutDoctorBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDoctorBranchesInput, BranchUpdateWithoutDoctorBranchesInput>, BranchUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type UserCreateNestedOneWithoutReceptionBranchesInput = {
    create?: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutReceptionBranchesInput = {
    create?: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReceptionBranchesNestedInput = {
    create?: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionBranchesInput
    upsert?: UserUpsertWithoutReceptionBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceptionBranchesInput, UserUpdateWithoutReceptionBranchesInput>, UserUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutReceptionBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionBranchesInput
    upsert?: BranchUpsertWithoutReceptionBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutReceptionBranchesInput, BranchUpdateWithoutReceptionBranchesInput>, BranchUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type UserCreateNestedOneWithoutNurseBranchesInput = {
    create?: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutNurseBranchesInput = {
    create?: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNurseBranchesNestedInput = {
    create?: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseBranchesInput
    upsert?: UserUpsertWithoutNurseBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseBranchesInput, UserUpdateWithoutNurseBranchesInput>, UserUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutNurseBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseBranchesInput
    upsert?: BranchUpsertWithoutNurseBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutNurseBranchesInput, BranchUpdateWithoutNurseBranchesInput>, BranchUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type UserCreateNestedOneWithoutNurseSchedulesInput = {
    create?: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutNurseSchedulesInput = {
    create?: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseSchedulesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNurseSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseSchedulesInput
    upsert?: UserUpsertWithoutNurseSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseSchedulesInput, UserUpdateWithoutNurseSchedulesInput>, UserUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type BranchUpdateOneRequiredWithoutNurseSchedulesNestedInput = {
    create?: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseSchedulesInput
    upsert?: BranchUpsertWithoutNurseSchedulesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutNurseSchedulesInput, BranchUpdateWithoutNurseSchedulesInput>, BranchUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumVisitCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeFilter<$PrismaModel> | $Enums.VisitCardType
  }

  export type NestedEnumVisitCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitCardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitCardTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitCardTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDiscountPercentFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentFilter<$PrismaModel> | $Enums.DiscountPercent
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDiscountPercentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentWithAggregatesFilter<$PrismaModel> | $Enums.DiscountPercent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountPercentFilter<$PrismaModel>
    _max?: NestedEnumDiscountPercentFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeFilter<$PrismaModel> | $Enums.InvoiceItemType
  }

  export type NestedEnumInvoiceItemSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceFilter<$PrismaModel> | $Enums.InvoiceItemSource
  }

  export type NestedEnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
  }

  export type NestedEnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
  }

  export type NestedEnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutBranchInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutBranchInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBranchInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBranchInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientCreateManyBranchInputEnvelope = {
    data: PatientCreateManyBranchInput | PatientCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DoctorScheduleCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    doctor: UserCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateWithoutBranchInput = {
    id?: number
    doctorId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleCreateOrConnectWithoutBranchInput = {
    where: DoctorScheduleWhereUniqueInput
    create: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput>
  }

  export type DoctorScheduleCreateManyBranchInputEnvelope = {
    data: DoctorScheduleCreateManyBranchInput | DoctorScheduleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBranchCreateWithoutBranchInput = {
    service: ServiceCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateWithoutBranchInput = {
    serviceId: number
  }

  export type ServiceBranchCreateOrConnectWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    create: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput>
  }

  export type ServiceBranchCreateManyBranchInputEnvelope = {
    data: ServiceBranchCreateManyBranchInput | ServiceBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DoctorBranchCreateWithoutBranchInput = {
    doctor: UserCreateNestedOneWithoutDoctorBranchesInput
  }

  export type DoctorBranchUncheckedCreateWithoutBranchInput = {
    id?: number
    doctorId: number
  }

  export type DoctorBranchCreateOrConnectWithoutBranchInput = {
    where: DoctorBranchWhereUniqueInput
    create: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput>
  }

  export type DoctorBranchCreateManyBranchInputEnvelope = {
    data: DoctorBranchCreateManyBranchInput | DoctorBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutBranchInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutBranchInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput>
  }

  export type AppointmentCreateManyBranchInputEnvelope = {
    data: AppointmentCreateManyBranchInput | AppointmentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutBookingsInput
    patient: PatientCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutBranchInput = {
    id?: number
    doctorId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutBranchInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput>
  }

  export type BookingCreateManyBranchInputEnvelope = {
    data: BookingCreateManyBranchInput | BookingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionScheduleCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    reception: UserCreateNestedOneWithoutReceptionSchedulesInput
  }

  export type ReceptionScheduleUncheckedCreateWithoutBranchInput = {
    id?: number
    receptionId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleCreateOrConnectWithoutBranchInput = {
    where: ReceptionScheduleWhereUniqueInput
    create: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionScheduleCreateManyBranchInputEnvelope = {
    data: ReceptionScheduleCreateManyBranchInput | ReceptionScheduleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionBranchCreateWithoutBranchInput = {
    reception: UserCreateNestedOneWithoutReceptionBranchesInput
  }

  export type ReceptionBranchUncheckedCreateWithoutBranchInput = {
    id?: number
    receptionId: number
  }

  export type ReceptionBranchCreateOrConnectWithoutBranchInput = {
    where: ReceptionBranchWhereUniqueInput
    create: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionBranchCreateManyBranchInputEnvelope = {
    data: ReceptionBranchCreateManyBranchInput | ReceptionBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type NurseScheduleCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    nurse: UserCreateNestedOneWithoutNurseSchedulesInput
  }

  export type NurseScheduleUncheckedCreateWithoutBranchInput = {
    id?: number
    nurseId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleCreateOrConnectWithoutBranchInput = {
    where: NurseScheduleWhereUniqueInput
    create: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput>
  }

  export type NurseScheduleCreateManyBranchInputEnvelope = {
    data: NurseScheduleCreateManyBranchInput | NurseScheduleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type NurseBranchCreateWithoutBranchInput = {
    nurse: UserCreateNestedOneWithoutNurseBranchesInput
  }

  export type NurseBranchUncheckedCreateWithoutBranchInput = {
    id?: number
    nurseId: number
  }

  export type NurseBranchCreateOrConnectWithoutBranchInput = {
    where: NurseBranchWhereUniqueInput
    create: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput>
  }

  export type NurseBranchCreateManyBranchInputEnvelope = {
    data: NurseBranchCreateManyBranchInput | NurseBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutBranchInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBranchInput = {
    id?: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBranchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput>
  }

  export type ProductCreateManyBranchInputEnvelope = {
    data: ProductCreateManyBranchInput | ProductCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutBranchInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutBranchInput = {
    id?: number
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput>
  }

  export type InvoiceCreateManyBranchInputEnvelope = {
    data: InvoiceCreateManyBranchInput | InvoiceCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutBranchInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutBranchInput = {
    id?: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutBranchInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput>
  }

  export type LedgerEntryCreateManyBranchInputEnvelope = {
    data: LedgerEntryCreateManyBranchInput | LedgerEntryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeVoucherCreateWithoutBranchInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutBranchInput = {
    id?: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherCreateOrConnectWithoutBranchInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeVoucherCreateManyBranchInputEnvelope = {
    data: EmployeeVoucherCreateManyBranchInput | EmployeeVoucherCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    ovog?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    regNo?: StringNullableFilter<"User"> | string | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableFilter<"User"> | string | null
    stampImagePath?: StringNullableFilter<"User"> | string | null
    idPhotoPath?: StringNullableFilter<"User"> | string | null
    calendarOrder?: IntNullableFilter<"User"> | number | null
  }

  export type PatientUpsertWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
  }

  export type PatientUpdateManyWithWhereWithoutBranchInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutBranchInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: IntFilter<"Patient"> | number
    regNo?: StringNullableFilter<"Patient"> | string | null
    ovog?: StringNullableFilter<"Patient"> | string | null
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    citizenship?: StringNullableFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branchId?: IntFilter<"Patient"> | number
  }

  export type DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput = {
    where: DoctorScheduleWhereUniqueInput
    update: XOR<DoctorScheduleUpdateWithoutBranchInput, DoctorScheduleUncheckedUpdateWithoutBranchInput>
    create: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput>
  }

  export type DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput = {
    where: DoctorScheduleWhereUniqueInput
    data: XOR<DoctorScheduleUpdateWithoutBranchInput, DoctorScheduleUncheckedUpdateWithoutBranchInput>
  }

  export type DoctorScheduleUpdateManyWithWhereWithoutBranchInput = {
    where: DoctorScheduleScalarWhereInput
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyWithoutBranchInput>
  }

  export type DoctorScheduleScalarWhereInput = {
    AND?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
    OR?: DoctorScheduleScalarWhereInput[]
    NOT?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
    id?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    branchId?: IntFilter<"DoctorSchedule"> | number
    date?: DateTimeFilter<"DoctorSchedule"> | Date | string
    startTime?: StringFilter<"DoctorSchedule"> | string
    endTime?: StringFilter<"DoctorSchedule"> | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
  }

  export type ServiceBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    update: XOR<ServiceBranchUpdateWithoutBranchInput, ServiceBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput>
  }

  export type ServiceBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    data: XOR<ServiceBranchUpdateWithoutBranchInput, ServiceBranchUncheckedUpdateWithoutBranchInput>
  }

  export type ServiceBranchUpdateManyWithWhereWithoutBranchInput = {
    where: ServiceBranchScalarWhereInput
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type ServiceBranchScalarWhereInput = {
    AND?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
    OR?: ServiceBranchScalarWhereInput[]
    NOT?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
    serviceId?: IntFilter<"ServiceBranch"> | number
    branchId?: IntFilter<"ServiceBranch"> | number
  }

  export type DoctorBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: DoctorBranchWhereUniqueInput
    update: XOR<DoctorBranchUpdateWithoutBranchInput, DoctorBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput>
  }

  export type DoctorBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: DoctorBranchWhereUniqueInput
    data: XOR<DoctorBranchUpdateWithoutBranchInput, DoctorBranchUncheckedUpdateWithoutBranchInput>
  }

  export type DoctorBranchUpdateManyWithWhereWithoutBranchInput = {
    where: DoctorBranchScalarWhereInput
    data: XOR<DoctorBranchUpdateManyMutationInput, DoctorBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type DoctorBranchScalarWhereInput = {
    AND?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
    OR?: DoctorBranchScalarWhereInput[]
    NOT?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
    id?: IntFilter<"DoctorBranch"> | number
    doctorId?: IntFilter<"DoctorBranch"> | number
    branchId?: IntFilter<"DoctorBranch"> | number
  }

  export type AppointmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutBranchInput, AppointmentUncheckedUpdateWithoutBranchInput>
    create: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutBranchInput, AppointmentUncheckedUpdateWithoutBranchInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutBranchInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntNullableFilter<"Appointment"> | number | null
    branchId?: IntFilter<"Appointment"> | number
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutBranchInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBranchInput, BookingUncheckedUpdateWithoutBranchInput>
    create: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBranchInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBranchInput, BookingUncheckedUpdateWithoutBranchInput>
  }

  export type BookingUpdateManyWithWhereWithoutBranchInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBranchInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    doctorId?: IntFilter<"Booking"> | number
    branchId?: IntFilter<"Booking"> | number
    patientId?: IntFilter<"Booking"> | number
    date?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput = {
    where: ReceptionScheduleWhereUniqueInput
    update: XOR<ReceptionScheduleUpdateWithoutBranchInput, ReceptionScheduleUncheckedUpdateWithoutBranchInput>
    create: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput = {
    where: ReceptionScheduleWhereUniqueInput
    data: XOR<ReceptionScheduleUpdateWithoutBranchInput, ReceptionScheduleUncheckedUpdateWithoutBranchInput>
  }

  export type ReceptionScheduleUpdateManyWithWhereWithoutBranchInput = {
    where: ReceptionScheduleScalarWhereInput
    data: XOR<ReceptionScheduleUpdateManyMutationInput, ReceptionScheduleUncheckedUpdateManyWithoutBranchInput>
  }

  export type ReceptionScheduleScalarWhereInput = {
    AND?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
    OR?: ReceptionScheduleScalarWhereInput[]
    NOT?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
    id?: IntFilter<"ReceptionSchedule"> | number
    receptionId?: IntFilter<"ReceptionSchedule"> | number
    branchId?: IntFilter<"ReceptionSchedule"> | number
    date?: DateTimeFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringFilter<"ReceptionSchedule"> | string
    endTime?: StringFilter<"ReceptionSchedule"> | string
    note?: StringNullableFilter<"ReceptionSchedule"> | string | null
  }

  export type ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: ReceptionBranchWhereUniqueInput
    update: XOR<ReceptionBranchUpdateWithoutBranchInput, ReceptionBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: ReceptionBranchWhereUniqueInput
    data: XOR<ReceptionBranchUpdateWithoutBranchInput, ReceptionBranchUncheckedUpdateWithoutBranchInput>
  }

  export type ReceptionBranchUpdateManyWithWhereWithoutBranchInput = {
    where: ReceptionBranchScalarWhereInput
    data: XOR<ReceptionBranchUpdateManyMutationInput, ReceptionBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type ReceptionBranchScalarWhereInput = {
    AND?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
    OR?: ReceptionBranchScalarWhereInput[]
    NOT?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
    id?: IntFilter<"ReceptionBranch"> | number
    receptionId?: IntFilter<"ReceptionBranch"> | number
    branchId?: IntFilter<"ReceptionBranch"> | number
  }

  export type NurseScheduleUpsertWithWhereUniqueWithoutBranchInput = {
    where: NurseScheduleWhereUniqueInput
    update: XOR<NurseScheduleUpdateWithoutBranchInput, NurseScheduleUncheckedUpdateWithoutBranchInput>
    create: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput>
  }

  export type NurseScheduleUpdateWithWhereUniqueWithoutBranchInput = {
    where: NurseScheduleWhereUniqueInput
    data: XOR<NurseScheduleUpdateWithoutBranchInput, NurseScheduleUncheckedUpdateWithoutBranchInput>
  }

  export type NurseScheduleUpdateManyWithWhereWithoutBranchInput = {
    where: NurseScheduleScalarWhereInput
    data: XOR<NurseScheduleUpdateManyMutationInput, NurseScheduleUncheckedUpdateManyWithoutBranchInput>
  }

  export type NurseScheduleScalarWhereInput = {
    AND?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
    OR?: NurseScheduleScalarWhereInput[]
    NOT?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
    id?: IntFilter<"NurseSchedule"> | number
    nurseId?: IntFilter<"NurseSchedule"> | number
    branchId?: IntFilter<"NurseSchedule"> | number
    date?: DateTimeFilter<"NurseSchedule"> | Date | string
    startTime?: StringFilter<"NurseSchedule"> | string
    endTime?: StringFilter<"NurseSchedule"> | string
    note?: StringNullableFilter<"NurseSchedule"> | string | null
  }

  export type NurseBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: NurseBranchWhereUniqueInput
    update: XOR<NurseBranchUpdateWithoutBranchInput, NurseBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput>
  }

  export type NurseBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: NurseBranchWhereUniqueInput
    data: XOR<NurseBranchUpdateWithoutBranchInput, NurseBranchUncheckedUpdateWithoutBranchInput>
  }

  export type NurseBranchUpdateManyWithWhereWithoutBranchInput = {
    where: NurseBranchScalarWhereInput
    data: XOR<NurseBranchUpdateManyMutationInput, NurseBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type NurseBranchScalarWhereInput = {
    AND?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
    OR?: NurseBranchScalarWhereInput[]
    NOT?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
    id?: IntFilter<"NurseBranch"> | number
    nurseId?: IntFilter<"NurseBranch"> | number
    branchId?: IntFilter<"NurseBranch"> | number
  }

  export type ProductUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBranchInput, ProductUncheckedUpdateWithoutBranchInput>
    create: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBranchInput, ProductUncheckedUpdateWithoutBranchInput>
  }

  export type ProductUpdateManyWithWhereWithoutBranchInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBranchInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    branchId?: IntFilter<"Product"> | number
    code?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutBranchInput, InvoiceUncheckedUpdateWithoutBranchInput>
    create: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutBranchInput, InvoiceUncheckedUpdateWithoutBranchInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutBranchInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutBranchInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    branchId?: IntNullableFilter<"Invoice"> | number | null
    encounterId?: IntFilter<"Invoice"> | number
    patientId?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutBranchInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutBranchInput, LedgerEntryUncheckedUpdateWithoutBranchInput>
    create: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutBranchInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutBranchInput, LedgerEntryUncheckedUpdateWithoutBranchInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutBranchInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutBranchInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: IntFilter<"LedgerEntry"> | number
    branchId?: IntFilter<"LedgerEntry"> | number
    patientId?: IntFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatFilter<"LedgerEntry"> | number
    createdById?: IntFilter<"LedgerEntry"> | number
    approvedById?: IntNullableFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
  }

  export type EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput = {
    where: EmployeeVoucherWhereUniqueInput
    update: XOR<EmployeeVoucherUpdateWithoutBranchInput, EmployeeVoucherUncheckedUpdateWithoutBranchInput>
    create: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput = {
    where: EmployeeVoucherWhereUniqueInput
    data: XOR<EmployeeVoucherUpdateWithoutBranchInput, EmployeeVoucherUncheckedUpdateWithoutBranchInput>
  }

  export type EmployeeVoucherUpdateManyWithWhereWithoutBranchInput = {
    where: EmployeeVoucherScalarWhereInput
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyWithoutBranchInput>
  }

  export type EmployeeVoucherScalarWhereInput = {
    AND?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
    OR?: EmployeeVoucherScalarWhereInput[]
    NOT?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
    id?: IntFilter<"EmployeeVoucher"> | number
    branchId?: IntFilter<"EmployeeVoucher"> | number
    employeeId?: IntFilter<"EmployeeVoucher"> | number
    code?: StringFilter<"EmployeeVoucher"> | string
    status?: EnumEmployeeVoucherStatusFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatFilter<"EmployeeVoucher"> | number
    eligibility?: JsonFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonFilter<"EmployeeVoucher">
    createdAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntFilter<"EmployeeVoucher"> | number
  }

  export type UserCreateWithoutEmployeeBenefitsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutEmployeeBenefitsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutEmployeeBenefitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
  }

  export type EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput = {
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput = {
    id?: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    create: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope = {
    data: EmployeeBenefitUsageCreateManyEmployeeBenefitInput | EmployeeBenefitUsageCreateManyEmployeeBenefitInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeBenefitsInput = {
    update: XOR<UserUpdateWithoutEmployeeBenefitsInput, UserUncheckedUpdateWithoutEmployeeBenefitsInput>
    create: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeBenefitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeBenefitsInput, UserUncheckedUpdateWithoutEmployeeBenefitsInput>
  }

  export type UserUpdateWithoutEmployeeBenefitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeBenefitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    update: XOR<EmployeeBenefitUsageUpdateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedUpdateWithoutEmployeeBenefitInput>
    create: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    data: XOR<EmployeeBenefitUsageUpdateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedUpdateWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageScalarWhereInput
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageScalarWhereInput = {
    AND?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
    OR?: EmployeeBenefitUsageScalarWhereInput[]
    NOT?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
    id?: IntFilter<"EmployeeBenefitUsage"> | number
    employeeBenefitId?: IntFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntFilter<"EmployeeBenefitUsage"> | number
    createdAt?: DateTimeFilter<"EmployeeBenefitUsage"> | Date | string
  }

  export type EmployeeBenefitCreateWithoutUsagesInput = {
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeBenefitsInput
  }

  export type EmployeeBenefitUncheckedCreateWithoutUsagesInput = {
    id?: number
    employeeId: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeBenefitCreateOrConnectWithoutUsagesInput = {
    where: EmployeeBenefitWhereUniqueInput
    create: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
  }

  export type InvoiceCreateWithoutEmployeeBenefitUsagesInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEmployeeBenefitUsagesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
  }

  export type EmployeeBenefitUpsertWithoutUsagesInput = {
    update: XOR<EmployeeBenefitUpdateWithoutUsagesInput, EmployeeBenefitUncheckedUpdateWithoutUsagesInput>
    create: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
    where?: EmployeeBenefitWhereInput
  }

  export type EmployeeBenefitUpdateToOneWithWhereWithoutUsagesInput = {
    where?: EmployeeBenefitWhereInput
    data: XOR<EmployeeBenefitUpdateWithoutUsagesInput, EmployeeBenefitUncheckedUpdateWithoutUsagesInput>
  }

  export type EmployeeBenefitUpdateWithoutUsagesInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeBenefitsNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateWithoutUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutEmployeeBenefitUsagesInput = {
    update: XOR<InvoiceUpdateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
    create: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type InvoiceUpdateWithoutEmployeeBenefitUsagesInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type BranchCreateWithoutUsersInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type EncounterCreateWithoutDoctorInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientBookId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutDoctorInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput>
  }

  export type EncounterCreateManyDoctorInputEnvelope = {
    data: EncounterCreateManyDoctorInput | EncounterCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutNurseInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutNurseInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutNurseInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput>
  }

  export type EncounterCreateManyNurseInputEnvelope = {
    data: EncounterCreateManyNurseInput | EncounterCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type DoctorScheduleCreateWithoutDoctorInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    branch: BranchCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateWithoutDoctorInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleCreateOrConnectWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    create: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorScheduleCreateManyDoctorInputEnvelope = {
    data: DoctorScheduleCreateManyDoctorInput | DoctorScheduleCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DoctorBranchCreateWithoutDoctorInput = {
    branch: BranchCreateNestedOneWithoutDoctorBranchesInput
  }

  export type DoctorBranchUncheckedCreateWithoutDoctorInput = {
    id?: number
    branchId: number
  }

  export type DoctorBranchCreateOrConnectWithoutDoctorInput = {
    where: DoctorBranchWhereUniqueInput
    create: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorBranchCreateManyDoctorInputEnvelope = {
    data: DoctorBranchCreateManyDoctorInput | DoctorBranchCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionScheduleCreateWithoutReceptionInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    branch: BranchCreateNestedOneWithoutReceptionSchedulesInput
  }

  export type ReceptionScheduleUncheckedCreateWithoutReceptionInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleCreateOrConnectWithoutReceptionInput = {
    where: ReceptionScheduleWhereUniqueInput
    create: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionScheduleCreateManyReceptionInputEnvelope = {
    data: ReceptionScheduleCreateManyReceptionInput | ReceptionScheduleCreateManyReceptionInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionBranchCreateWithoutReceptionInput = {
    branch: BranchCreateNestedOneWithoutReceptionBranchesInput
  }

  export type ReceptionBranchUncheckedCreateWithoutReceptionInput = {
    id?: number
    branchId: number
  }

  export type ReceptionBranchCreateOrConnectWithoutReceptionInput = {
    where: ReceptionBranchWhereUniqueInput
    create: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionBranchCreateManyReceptionInputEnvelope = {
    data: ReceptionBranchCreateManyReceptionInput | ReceptionBranchCreateManyReceptionInput[]
    skipDuplicates?: boolean
  }

  export type NurseScheduleCreateWithoutNurseInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    branch: BranchCreateNestedOneWithoutNurseSchedulesInput
  }

  export type NurseScheduleUncheckedCreateWithoutNurseInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleCreateOrConnectWithoutNurseInput = {
    where: NurseScheduleWhereUniqueInput
    create: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput>
  }

  export type NurseScheduleCreateManyNurseInputEnvelope = {
    data: NurseScheduleCreateManyNurseInput | NurseScheduleCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type NurseBranchCreateWithoutNurseInput = {
    branch: BranchCreateNestedOneWithoutNurseBranchesInput
  }

  export type NurseBranchUncheckedCreateWithoutNurseInput = {
    id?: number
    branchId: number
  }

  export type NurseBranchCreateOrConnectWithoutNurseInput = {
    where: NurseBranchWhereUniqueInput
    create: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput>
  }

  export type NurseBranchCreateManyNurseInputEnvelope = {
    data: NurseBranchCreateManyNurseInput | NurseBranchCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDoctorInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientId: number
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutDoctorInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBookingsInput
    patient: PatientCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutDoctorInput = {
    id?: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutDoctorInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput>
  }

  export type BookingCreateManyDoctorInputEnvelope = {
    data: BookingCreateManyDoctorInput | BookingCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeBenefitCreateWithoutEmployeeInput = {
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: EmployeeBenefitUsageCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitUncheckedCreateWithoutEmployeeInput = {
    id?: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeBenefitWhereUniqueInput
    create: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeBenefitCreateManyEmployeeInputEnvelope = {
    data: EmployeeBenefitCreateManyEmployeeInput | EmployeeBenefitCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutCreatedByInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutCreatedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutCreatedByInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput>
  }

  export type LedgerEntryCreateManyCreatedByInputEnvelope = {
    data: LedgerEntryCreateManyCreatedByInput | LedgerEntryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutApprovedByInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutApprovedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutApprovedByInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput>
  }

  export type LedgerEntryCreateManyApprovedByInputEnvelope = {
    data: LedgerEntryCreateManyApprovedByInput | LedgerEntryCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeVoucherCreateWithoutEmployeeInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutEmployeeInput = {
    id?: number
    branchId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeVoucherCreateManyEmployeeInputEnvelope = {
    data: EmployeeVoucherCreateManyEmployeeInput | EmployeeVoucherCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeVoucherCreateWithoutCreatedByInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutCreatedByInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherCreateOrConnectWithoutCreatedByInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput>
  }

  export type EmployeeVoucherCreateManyCreatedByInputEnvelope = {
    data: EmployeeVoucherCreateManyCreatedByInput | EmployeeVoucherCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuthorizationCodeCreateWithoutCreatedByInput = {
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeUncheckedCreateWithoutCreatedByInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeCreateOrConnectWithoutCreatedByInput = {
    where: AuthorizationCodeWhereUniqueInput
    create: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput>
  }

  export type AuthorizationCodeCreateManyCreatedByInputEnvelope = {
    data: AuthorizationCodeCreateManyCreatedByInput | AuthorizationCodeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutDoctorInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutDoctorInput, EncounterUncheckedUpdateWithoutDoctorInput>
    create: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutDoctorInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutDoctorInput, EncounterUncheckedUpdateWithoutDoctorInput>
  }

  export type EncounterUpdateManyWithWhereWithoutDoctorInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutDoctorInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: IntFilter<"Encounter"> | number
    patientBookId?: IntFilter<"Encounter"> | number
    doctorId?: IntFilter<"Encounter"> | number
    visitDate?: DateTimeFilter<"Encounter"> | Date | string
    notes?: StringNullableFilter<"Encounter"> | string | null
    appointmentId?: IntNullableFilter<"Encounter"> | number | null
    nurseId?: IntNullableFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
  }

  export type EncounterUpsertWithWhereUniqueWithoutNurseInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutNurseInput, EncounterUncheckedUpdateWithoutNurseInput>
    create: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutNurseInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutNurseInput, EncounterUncheckedUpdateWithoutNurseInput>
  }

  export type EncounterUpdateManyWithWhereWithoutNurseInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutNurseInput>
  }

  export type DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    update: XOR<DoctorScheduleUpdateWithoutDoctorInput, DoctorScheduleUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    data: XOR<DoctorScheduleUpdateWithoutDoctorInput, DoctorScheduleUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorScheduleUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorScheduleScalarWhereInput
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorBranchWhereUniqueInput
    update: XOR<DoctorBranchUpdateWithoutDoctorInput, DoctorBranchUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorBranchWhereUniqueInput
    data: XOR<DoctorBranchUpdateWithoutDoctorInput, DoctorBranchUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorBranchUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorBranchScalarWhereInput
    data: XOR<DoctorBranchUpdateManyMutationInput, DoctorBranchUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionScheduleWhereUniqueInput
    update: XOR<ReceptionScheduleUpdateWithoutReceptionInput, ReceptionScheduleUncheckedUpdateWithoutReceptionInput>
    create: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionScheduleWhereUniqueInput
    data: XOR<ReceptionScheduleUpdateWithoutReceptionInput, ReceptionScheduleUncheckedUpdateWithoutReceptionInput>
  }

  export type ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput = {
    where: ReceptionScheduleScalarWhereInput
    data: XOR<ReceptionScheduleUpdateManyMutationInput, ReceptionScheduleUncheckedUpdateManyWithoutReceptionInput>
  }

  export type ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionBranchWhereUniqueInput
    update: XOR<ReceptionBranchUpdateWithoutReceptionInput, ReceptionBranchUncheckedUpdateWithoutReceptionInput>
    create: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionBranchWhereUniqueInput
    data: XOR<ReceptionBranchUpdateWithoutReceptionInput, ReceptionBranchUncheckedUpdateWithoutReceptionInput>
  }

  export type ReceptionBranchUpdateManyWithWhereWithoutReceptionInput = {
    where: ReceptionBranchScalarWhereInput
    data: XOR<ReceptionBranchUpdateManyMutationInput, ReceptionBranchUncheckedUpdateManyWithoutReceptionInput>
  }

  export type NurseScheduleUpsertWithWhereUniqueWithoutNurseInput = {
    where: NurseScheduleWhereUniqueInput
    update: XOR<NurseScheduleUpdateWithoutNurseInput, NurseScheduleUncheckedUpdateWithoutNurseInput>
    create: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput>
  }

  export type NurseScheduleUpdateWithWhereUniqueWithoutNurseInput = {
    where: NurseScheduleWhereUniqueInput
    data: XOR<NurseScheduleUpdateWithoutNurseInput, NurseScheduleUncheckedUpdateWithoutNurseInput>
  }

  export type NurseScheduleUpdateManyWithWhereWithoutNurseInput = {
    where: NurseScheduleScalarWhereInput
    data: XOR<NurseScheduleUpdateManyMutationInput, NurseScheduleUncheckedUpdateManyWithoutNurseInput>
  }

  export type NurseBranchUpsertWithWhereUniqueWithoutNurseInput = {
    where: NurseBranchWhereUniqueInput
    update: XOR<NurseBranchUpdateWithoutNurseInput, NurseBranchUncheckedUpdateWithoutNurseInput>
    create: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput>
  }

  export type NurseBranchUpdateWithWhereUniqueWithoutNurseInput = {
    where: NurseBranchWhereUniqueInput
    data: XOR<NurseBranchUpdateWithoutNurseInput, NurseBranchUncheckedUpdateWithoutNurseInput>
  }

  export type NurseBranchUpdateManyWithWhereWithoutNurseInput = {
    where: NurseBranchScalarWhereInput
    data: XOR<NurseBranchUpdateManyMutationInput, NurseBranchUncheckedUpdateManyWithoutNurseInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutDoctorInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutDoctorInput, BookingUncheckedUpdateWithoutDoctorInput>
    create: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutDoctorInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutDoctorInput, BookingUncheckedUpdateWithoutDoctorInput>
  }

  export type BookingUpdateManyWithWhereWithoutDoctorInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutDoctorInput>
  }

  export type EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeBenefitWhereUniqueInput
    update: XOR<EmployeeBenefitUpdateWithoutEmployeeInput, EmployeeBenefitUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeBenefitWhereUniqueInput
    data: XOR<EmployeeBenefitUpdateWithoutEmployeeInput, EmployeeBenefitUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeBenefitScalarWhereInput
    data: XOR<EmployeeBenefitUpdateManyMutationInput, EmployeeBenefitUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeBenefitScalarWhereInput = {
    AND?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
    OR?: EmployeeBenefitScalarWhereInput[]
    NOT?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
    id?: IntFilter<"EmployeeBenefit"> | number
    employeeId?: IntFilter<"EmployeeBenefit"> | number
    code?: StringFilter<"EmployeeBenefit"> | string
    branchId?: IntNullableFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutCreatedByInput, LedgerEntryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutCreatedByInput, LedgerEntryUncheckedUpdateWithoutCreatedByInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutCreatedByInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutApprovedByInput, LedgerEntryUncheckedUpdateWithoutApprovedByInput>
    create: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutApprovedByInput, LedgerEntryUncheckedUpdateWithoutApprovedByInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutApprovedByInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeVoucherWhereUniqueInput
    update: XOR<EmployeeVoucherUpdateWithoutEmployeeInput, EmployeeVoucherUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeVoucherWhereUniqueInput
    data: XOR<EmployeeVoucherUpdateWithoutEmployeeInput, EmployeeVoucherUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeVoucherScalarWhereInput
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EmployeeVoucherWhereUniqueInput
    update: XOR<EmployeeVoucherUpdateWithoutCreatedByInput, EmployeeVoucherUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput>
  }

  export type EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EmployeeVoucherWhereUniqueInput
    data: XOR<EmployeeVoucherUpdateWithoutCreatedByInput, EmployeeVoucherUncheckedUpdateWithoutCreatedByInput>
  }

  export type EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput = {
    where: EmployeeVoucherScalarWhereInput
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AuthorizationCodeWhereUniqueInput
    update: XOR<AuthorizationCodeUpdateWithoutCreatedByInput, AuthorizationCodeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput>
  }

  export type AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AuthorizationCodeWhereUniqueInput
    data: XOR<AuthorizationCodeUpdateWithoutCreatedByInput, AuthorizationCodeUncheckedUpdateWithoutCreatedByInput>
  }

  export type AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput = {
    where: AuthorizationCodeScalarWhereInput
    data: XOR<AuthorizationCodeUpdateManyMutationInput, AuthorizationCodeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuthorizationCodeScalarWhereInput = {
    AND?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
    OR?: AuthorizationCodeScalarWhereInput[]
    NOT?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
    id?: IntFilter<"AuthorizationCode"> | number
    code?: StringFilter<"AuthorizationCode"> | string
    purpose?: StringFilter<"AuthorizationCode"> | string
    isEnabled?: BoolFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableFilter<"AuthorizationCode"> | number | null
    usedCount?: IntFilter<"AuthorizationCode"> | number
    createdById?: IntFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
  }

  export type BranchCreateWithoutPatientsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPatientsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPatientsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
  }

  export type PatientBookCreateWithoutPatientInput = {
    bookNumber: string
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutPatientInput = {
    id?: number
    bookNumber: string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutPatientInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateWithoutPatientInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutPatientInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutBookingsInput
    branch: BranchCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutPatientInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput>
  }

  export type BookingCreateManyPatientInputEnvelope = {
    data: BookingCreateManyPatientInput | BookingCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutPatientInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutPatientInput = {
    id?: number
    branchId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutPatientInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput>
  }

  export type LedgerEntryCreateManyPatientInputEnvelope = {
    data: LedgerEntryCreateManyPatientInput | LedgerEntryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutPatientsInput = {
    update: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPatientsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type BranchUpdateWithoutPatientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientBookUpsertWithoutPatientInput = {
    update: XOR<PatientBookUpdateWithoutPatientInput, PatientBookUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutPatientInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutPatientInput, PatientBookUncheckedUpdateWithoutPatientInput>
  }

  export type PatientBookUpdateWithoutPatientInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutPatientInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPatientInput, BookingUncheckedUpdateWithoutPatientInput>
    create: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPatientInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPatientInput, BookingUncheckedUpdateWithoutPatientInput>
  }

  export type BookingUpdateManyWithWhereWithoutPatientInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutPatientInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutPatientInput, LedgerEntryUncheckedUpdateWithoutPatientInput>
    create: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutPatientInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutPatientInput, LedgerEntryUncheckedUpdateWithoutPatientInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutPatientInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientCreateWithoutPatientBookInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPatientBookInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPatientBookInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
  }

  export type EncounterCreateWithoutPatientBookInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPatientBookInput = {
    id?: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPatientBookInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput>
  }

  export type EncounterCreateManyPatientBookInputEnvelope = {
    data: EncounterCreateManyPatientBookInput | EncounterCreateManyPatientBookInput[]
    skipDuplicates?: boolean
  }

  export type VisitCardCreateWithoutPatientBookInput = {
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardUncheckedCreateWithoutPatientBookInput = {
    id?: number
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardCreateOrConnectWithoutPatientBookInput = {
    where: VisitCardWhereUniqueInput
    create: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
  }

  export type OrthoCardCreateWithoutPatientBookInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardUncheckedCreateWithoutPatientBookInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardCreateOrConnectWithoutPatientBookInput = {
    where: OrthoCardWhereUniqueInput
    create: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
  }

  export type PatientUpsertWithoutPatientBookInput = {
    update: XOR<PatientUpdateWithoutPatientBookInput, PatientUncheckedUpdateWithoutPatientBookInput>
    create: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPatientBookInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPatientBookInput, PatientUncheckedUpdateWithoutPatientBookInput>
  }

  export type PatientUpdateWithoutPatientBookInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutPatientBookInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPatientBookInput, EncounterUncheckedUpdateWithoutPatientBookInput>
    create: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPatientBookInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPatientBookInput, EncounterUncheckedUpdateWithoutPatientBookInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPatientBookInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPatientBookInput>
  }

  export type VisitCardUpsertWithoutPatientBookInput = {
    update: XOR<VisitCardUpdateWithoutPatientBookInput, VisitCardUncheckedUpdateWithoutPatientBookInput>
    create: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    where?: VisitCardWhereInput
  }

  export type VisitCardUpdateToOneWithWhereWithoutPatientBookInput = {
    where?: VisitCardWhereInput
    data: XOR<VisitCardUpdateWithoutPatientBookInput, VisitCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type VisitCardUpdateWithoutPatientBookInput = {
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCardUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardUpsertWithoutPatientBookInput = {
    update: XOR<OrthoCardUpdateWithoutPatientBookInput, OrthoCardUncheckedUpdateWithoutPatientBookInput>
    create: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    where?: OrthoCardWhereInput
  }

  export type OrthoCardUpdateToOneWithWhereWithoutPatientBookInput = {
    where?: OrthoCardWhereInput
    data: XOR<OrthoCardUpdateWithoutPatientBookInput, OrthoCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type OrthoCardUpdateWithoutPatientBookInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBookCreateWithoutVisitCardInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutVisitCardInput = {
    id?: number
    bookNumber: string
    patientId: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutVisitCardInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
  }

  export type PatientBookUpsertWithoutVisitCardInput = {
    update: XOR<PatientBookUpdateWithoutVisitCardInput, PatientBookUncheckedUpdateWithoutVisitCardInput>
    create: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutVisitCardInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutVisitCardInput, PatientBookUncheckedUpdateWithoutVisitCardInput>
  }

  export type PatientBookUpdateWithoutVisitCardInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutVisitCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookCreateWithoutOrthoCardInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutOrthoCardInput = {
    id?: number
    bookNumber: string
    patientId: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutOrthoCardInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
  }

  export type PatientBookUpsertWithoutOrthoCardInput = {
    update: XOR<PatientBookUpdateWithoutOrthoCardInput, PatientBookUncheckedUpdateWithoutOrthoCardInput>
    create: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutOrthoCardInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutOrthoCardInput, PatientBookUncheckedUpdateWithoutOrthoCardInput>
  }

  export type PatientBookUpdateWithoutOrthoCardInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutOrthoCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientCreateWithoutAppointmentsInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type BranchCreateWithoutAppointmentsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAppointmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
  }

  export type EncounterCreateWithoutAppointmentInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutAppointmentInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
  }

  export type EncounterCreateManyAppointmentInputEnvelope = {
    data: EncounterCreateManyAppointmentInput | EncounterCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutAppointmentsInput = {
    update: XOR<BranchUpdateWithoutAppointmentsInput, BranchUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAppointmentsInput, BranchUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BranchUpdateWithoutAppointmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutAppointmentInput, EncounterUncheckedUpdateWithoutAppointmentInput>
    create: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutAppointmentInput, EncounterUncheckedUpdateWithoutAppointmentInput>
  }

  export type EncounterUpdateManyWithWhereWithoutAppointmentInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type UserCreateWithoutBookingsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type BranchCreateWithoutBookingsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBookingsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
  }

  export type PatientCreateWithoutBookingsInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBookingsInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBookingsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutBookingsInput = {
    update: XOR<BranchUpdateWithoutBookingsInput, BranchUncheckedUpdateWithoutBookingsInput>
    create: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBookingsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBookingsInput, BranchUncheckedUpdateWithoutBookingsInput>
  }

  export type BranchUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutBookingsInput = {
    update: XOR<PatientUpdateWithoutBookingsInput, PatientUncheckedUpdateWithoutBookingsInput>
    create: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutBookingsInput, PatientUncheckedUpdateWithoutBookingsInput>
  }

  export type PatientUpdateWithoutBookingsInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientBookCreateWithoutEncountersInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutEncountersInput = {
    id?: number
    bookNumber: string
    patientId: number
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutEncountersInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
  }

  export type UserCreateWithoutEncountersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutEncountersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutEncountersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
  }

  export type AppointmentCreateWithoutEncountersInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutEncountersInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type AppointmentCreateOrConnectWithoutEncountersInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
  }

  export type UserCreateWithoutNurseEncountersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNurseEncountersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNurseEncountersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
  }

  export type ChartToothCreateWithoutEncounterInput = {
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    chartNotes?: ChartNoteCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothUncheckedCreateWithoutEncounterInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    chartNotes?: ChartNoteUncheckedCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothCreateOrConnectWithoutEncounterInput = {
    where: ChartToothWhereUniqueInput
    create: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput>
  }

  export type ChartToothCreateManyEncounterInputEnvelope = {
    data: ChartToothCreateManyEncounterInput | ChartToothCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutEncounterInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEncounterInput = {
    id?: number
    branchId?: number | null
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEncounterInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
  }

  export type PrescriptionCreateWithoutEncounterInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutEncounterInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutEncounterInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
  }

  export type MediaCreateWithoutEncounterInput = {
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaUncheckedCreateWithoutEncounterInput = {
    id?: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaCreateOrConnectWithoutEncounterInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput>
  }

  export type MediaCreateManyEncounterInputEnvelope = {
    data: MediaCreateManyEncounterInput | MediaCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterServiceCreateWithoutEncounterInput = {
    quantity?: number
    price: number
    service: ServiceCreateNestedOneWithoutEncounterServicesInput
  }

  export type EncounterServiceUncheckedCreateWithoutEncounterInput = {
    id?: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceCreateOrConnectWithoutEncounterInput = {
    where: EncounterServiceWhereUniqueInput
    create: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterServiceCreateManyEncounterInputEnvelope = {
    data: EncounterServiceCreateManyEncounterInput | EncounterServiceCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterDiagnosisCreateWithoutEncounterInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    diagnosis: DiagnosisCreateNestedOneWithoutEncountersInput
  }

  export type EncounterDiagnosisUncheckedCreateWithoutEncounterInput = {
    id?: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisCreateOrConnectWithoutEncounterInput = {
    where: EncounterDiagnosisWhereUniqueInput
    create: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterDiagnosisCreateManyEncounterInputEnvelope = {
    data: EncounterDiagnosisCreateManyEncounterInput | EncounterDiagnosisCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterConsentCreateWithoutEncounterInput = {
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentUncheckedCreateWithoutEncounterInput = {
    id?: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentCreateOrConnectWithoutEncounterInput = {
    where: EncounterConsentWhereUniqueInput
    create: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterConsentCreateManyEncounterInputEnvelope = {
    data: EncounterConsentCreateManyEncounterInput | EncounterConsentCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type PatientBookUpsertWithoutEncountersInput = {
    update: XOR<PatientBookUpdateWithoutEncountersInput, PatientBookUncheckedUpdateWithoutEncountersInput>
    create: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutEncountersInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutEncountersInput, PatientBookUncheckedUpdateWithoutEncountersInput>
  }

  export type PatientBookUpdateWithoutEncountersInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type UserUpsertWithoutEncountersInput = {
    update: XOR<UserUpdateWithoutEncountersInput, UserUncheckedUpdateWithoutEncountersInput>
    create: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEncountersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEncountersInput, UserUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateWithoutEncountersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AppointmentUpsertWithoutEncountersInput = {
    update: XOR<AppointmentUpdateWithoutEncountersInput, AppointmentUncheckedUpdateWithoutEncountersInput>
    create: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutEncountersInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutEncountersInput, AppointmentUncheckedUpdateWithoutEncountersInput>
  }

  export type AppointmentUpdateWithoutEncountersInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutNurseEncountersInput = {
    update: XOR<UserUpdateWithoutNurseEncountersInput, UserUncheckedUpdateWithoutNurseEncountersInput>
    create: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseEncountersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseEncountersInput, UserUncheckedUpdateWithoutNurseEncountersInput>
  }

  export type UserUpdateWithoutNurseEncountersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ChartToothUpsertWithWhereUniqueWithoutEncounterInput = {
    where: ChartToothWhereUniqueInput
    update: XOR<ChartToothUpdateWithoutEncounterInput, ChartToothUncheckedUpdateWithoutEncounterInput>
    create: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput>
  }

  export type ChartToothUpdateWithWhereUniqueWithoutEncounterInput = {
    where: ChartToothWhereUniqueInput
    data: XOR<ChartToothUpdateWithoutEncounterInput, ChartToothUncheckedUpdateWithoutEncounterInput>
  }

  export type ChartToothUpdateManyWithWhereWithoutEncounterInput = {
    where: ChartToothScalarWhereInput
    data: XOR<ChartToothUpdateManyMutationInput, ChartToothUncheckedUpdateManyWithoutEncounterInput>
  }

  export type ChartToothScalarWhereInput = {
    AND?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
    OR?: ChartToothScalarWhereInput[]
    NOT?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
    id?: IntFilter<"ChartTooth"> | number
    toothCode?: StringFilter<"ChartTooth"> | string
    toothGroup?: StringNullableFilter<"ChartTooth"> | string | null
    status?: StringNullableFilter<"ChartTooth"> | string | null
    notes?: StringNullableFilter<"ChartTooth"> | string | null
    encounterId?: IntFilter<"ChartTooth"> | number
  }

  export type InvoiceUpsertWithoutEncounterInput = {
    update: XOR<InvoiceUpdateWithoutEncounterInput, InvoiceUncheckedUpdateWithoutEncounterInput>
    create: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEncounterInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEncounterInput, InvoiceUncheckedUpdateWithoutEncounterInput>
  }

  export type InvoiceUpdateWithoutEncounterInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PrescriptionUpsertWithoutEncounterInput = {
    update: XOR<PrescriptionUpdateWithoutEncounterInput, PrescriptionUncheckedUpdateWithoutEncounterInput>
    create: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutEncounterInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutEncounterInput, PrescriptionUncheckedUpdateWithoutEncounterInput>
  }

  export type PrescriptionUpdateWithoutEncounterInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutEncounterInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutEncounterInput, MediaUncheckedUpdateWithoutEncounterInput>
    create: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutEncounterInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutEncounterInput, MediaUncheckedUpdateWithoutEncounterInput>
  }

  export type MediaUpdateManyWithWhereWithoutEncounterInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutEncounterInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: IntFilter<"Media"> | number
    encounterId?: IntFilter<"Media"> | number
    filePath?: StringFilter<"Media"> | string
    toothCode?: StringNullableFilter<"Media"> | string | null
    type?: StringFilter<"Media"> | string
  }

  export type EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterServiceWhereUniqueInput
    update: XOR<EncounterServiceUpdateWithoutEncounterInput, EncounterServiceUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterServiceWhereUniqueInput
    data: XOR<EncounterServiceUpdateWithoutEncounterInput, EncounterServiceUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterServiceUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterServiceScalarWhereInput
    data: XOR<EncounterServiceUpdateManyMutationInput, EncounterServiceUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterServiceScalarWhereInput = {
    AND?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
    OR?: EncounterServiceScalarWhereInput[]
    NOT?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
    id?: IntFilter<"EncounterService"> | number
    encounterId?: IntFilter<"EncounterService"> | number
    serviceId?: IntFilter<"EncounterService"> | number
    quantity?: IntFilter<"EncounterService"> | number
    price?: FloatFilter<"EncounterService"> | number
  }

  export type EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterDiagnosisWhereUniqueInput
    update: XOR<EncounterDiagnosisUpdateWithoutEncounterInput, EncounterDiagnosisUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterDiagnosisWhereUniqueInput
    data: XOR<EncounterDiagnosisUpdateWithoutEncounterInput, EncounterDiagnosisUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterDiagnosisScalarWhereInput
    data: XOR<EncounterDiagnosisUpdateManyMutationInput, EncounterDiagnosisUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterDiagnosisScalarWhereInput = {
    AND?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
    OR?: EncounterDiagnosisScalarWhereInput[]
    NOT?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
    id?: IntFilter<"EncounterDiagnosis"> | number
    encounterId?: IntFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableFilter<"EncounterDiagnosis">
    note?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeFilter<"EncounterDiagnosis"> | Date | string
  }

  export type EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterConsentWhereUniqueInput
    update: XOR<EncounterConsentUpdateWithoutEncounterInput, EncounterConsentUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterConsentWhereUniqueInput
    data: XOR<EncounterConsentUpdateWithoutEncounterInput, EncounterConsentUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterConsentUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterConsentScalarWhereInput
    data: XOR<EncounterConsentUpdateManyMutationInput, EncounterConsentUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterConsentScalarWhereInput = {
    AND?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
    OR?: EncounterConsentScalarWhereInput[]
    NOT?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
    id?: IntFilter<"EncounterConsent"> | number
    encounterId?: IntFilter<"EncounterConsent"> | number
    type?: StringFilter<"EncounterConsent"> | string
    answers?: JsonFilter<"EncounterConsent">
    createdAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeFilter<"EncounterConsent"> | Date | string
  }

  export type EncounterCreateWithoutConsentsInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutConsentsInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutConsentsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
  }

  export type EncounterUpsertWithoutConsentsInput = {
    update: XOR<EncounterUpdateWithoutConsentsInput, EncounterUncheckedUpdateWithoutConsentsInput>
    create: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutConsentsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutConsentsInput, EncounterUncheckedUpdateWithoutConsentsInput>
  }

  export type EncounterUpdateWithoutConsentsInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutConsentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateWithoutChartTeethInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutChartTeethInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutChartTeethInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
  }

  export type ChartNoteCreateWithoutChartToothInput = {
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUncheckedCreateWithoutChartToothInput = {
    id?: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteCreateOrConnectWithoutChartToothInput = {
    where: ChartNoteWhereUniqueInput
    create: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput>
  }

  export type ChartNoteCreateManyChartToothInputEnvelope = {
    data: ChartNoteCreateManyChartToothInput | ChartNoteCreateManyChartToothInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutChartTeethInput = {
    update: XOR<EncounterUpdateWithoutChartTeethInput, EncounterUncheckedUpdateWithoutChartTeethInput>
    create: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutChartTeethInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutChartTeethInput, EncounterUncheckedUpdateWithoutChartTeethInput>
  }

  export type EncounterUpdateWithoutChartTeethInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutChartTeethInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type ChartNoteUpsertWithWhereUniqueWithoutChartToothInput = {
    where: ChartNoteWhereUniqueInput
    update: XOR<ChartNoteUpdateWithoutChartToothInput, ChartNoteUncheckedUpdateWithoutChartToothInput>
    create: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput>
  }

  export type ChartNoteUpdateWithWhereUniqueWithoutChartToothInput = {
    where: ChartNoteWhereUniqueInput
    data: XOR<ChartNoteUpdateWithoutChartToothInput, ChartNoteUncheckedUpdateWithoutChartToothInput>
  }

  export type ChartNoteUpdateManyWithWhereWithoutChartToothInput = {
    where: ChartNoteScalarWhereInput
    data: XOR<ChartNoteUpdateManyMutationInput, ChartNoteUncheckedUpdateManyWithoutChartToothInput>
  }

  export type ChartNoteScalarWhereInput = {
    AND?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
    OR?: ChartNoteScalarWhereInput[]
    NOT?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
    id?: IntFilter<"ChartNote"> | number
    chartToothId?: IntFilter<"ChartNote"> | number
    description?: StringFilter<"ChartNote"> | string
    createdAt?: DateTimeFilter<"ChartNote"> | Date | string
  }

  export type ChartToothCreateWithoutChartNotesInput = {
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounter: EncounterCreateNestedOneWithoutChartTeethInput
  }

  export type ChartToothUncheckedCreateWithoutChartNotesInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounterId: number
  }

  export type ChartToothCreateOrConnectWithoutChartNotesInput = {
    where: ChartToothWhereUniqueInput
    create: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
  }

  export type ChartToothUpsertWithoutChartNotesInput = {
    update: XOR<ChartToothUpdateWithoutChartNotesInput, ChartToothUncheckedUpdateWithoutChartNotesInput>
    create: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
    where?: ChartToothWhereInput
  }

  export type ChartToothUpdateToOneWithWhereWithoutChartNotesInput = {
    where?: ChartToothWhereInput
    data: XOR<ChartToothUpdateWithoutChartNotesInput, ChartToothUncheckedUpdateWithoutChartNotesInput>
  }

  export type ChartToothUpdateWithoutChartNotesInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutChartTeethNestedInput
  }

  export type ChartToothUncheckedUpdateWithoutChartNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: IntFieldUpdateOperationsInput | number
  }

  export type DiagnosisProblemCreateWithoutDiagnosisInput = {
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemUncheckedCreateWithoutDiagnosisInput = {
    id?: number
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemCreateOrConnectWithoutDiagnosisInput = {
    where: DiagnosisProblemWhereUniqueInput
    create: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput>
  }

  export type DiagnosisProblemCreateManyDiagnosisInputEnvelope = {
    data: DiagnosisProblemCreateManyDiagnosisInput | DiagnosisProblemCreateManyDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type EncounterDiagnosisCreateWithoutDiagnosisInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDiagnosesInput
  }

  export type EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput = {
    id?: number
    encounterId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput = {
    where: EncounterDiagnosisWhereUniqueInput
    create: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput>
  }

  export type EncounterDiagnosisCreateManyDiagnosisInputEnvelope = {
    data: EncounterDiagnosisCreateManyDiagnosisInput | EncounterDiagnosisCreateManyDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: DiagnosisProblemWhereUniqueInput
    update: XOR<DiagnosisProblemUpdateWithoutDiagnosisInput, DiagnosisProblemUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput>
  }

  export type DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: DiagnosisProblemWhereUniqueInput
    data: XOR<DiagnosisProblemUpdateWithoutDiagnosisInput, DiagnosisProblemUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput = {
    where: DiagnosisProblemScalarWhereInput
    data: XOR<DiagnosisProblemUpdateManyMutationInput, DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisInput>
  }

  export type DiagnosisProblemScalarWhereInput = {
    AND?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
    OR?: DiagnosisProblemScalarWhereInput[]
    NOT?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
    id?: IntFilter<"DiagnosisProblem"> | number
    diagnosisId?: IntFilter<"DiagnosisProblem"> | number
    label?: StringFilter<"DiagnosisProblem"> | string
    order?: IntFilter<"DiagnosisProblem"> | number
    active?: BoolFilter<"DiagnosisProblem"> | boolean
  }

  export type EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: EncounterDiagnosisWhereUniqueInput
    update: XOR<EncounterDiagnosisUpdateWithoutDiagnosisInput, EncounterDiagnosisUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput>
  }

  export type EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: EncounterDiagnosisWhereUniqueInput
    data: XOR<EncounterDiagnosisUpdateWithoutDiagnosisInput, EncounterDiagnosisUncheckedUpdateWithoutDiagnosisInput>
  }

  export type EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput = {
    where: EncounterDiagnosisScalarWhereInput
    data: XOR<EncounterDiagnosisUpdateManyMutationInput, EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisInput>
  }

  export type DiagnosisCreateWithoutProblemsInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterDiagnosisCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutProblemsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterDiagnosisUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisCreateOrConnectWithoutProblemsInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
  }

  export type DiagnosisUpsertWithoutProblemsInput = {
    update: XOR<DiagnosisUpdateWithoutProblemsInput, DiagnosisUncheckedUpdateWithoutProblemsInput>
    create: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
    where?: DiagnosisWhereInput
  }

  export type DiagnosisUpdateToOneWithWhereWithoutProblemsInput = {
    where?: DiagnosisWhereInput
    data: XOR<DiagnosisUpdateWithoutProblemsInput, DiagnosisUncheckedUpdateWithoutProblemsInput>
  }

  export type DiagnosisUpdateWithoutProblemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterDiagnosisUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutProblemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type EncounterCreateWithoutDiagnosesInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutDiagnosesInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutDiagnosesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
  }

  export type DiagnosisCreateWithoutEncountersInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutEncountersInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisCreateOrConnectWithoutEncountersInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
  }

  export type EncounterUpsertWithoutDiagnosesInput = {
    update: XOR<EncounterUpdateWithoutDiagnosesInput, EncounterUncheckedUpdateWithoutDiagnosesInput>
    create: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutDiagnosesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutDiagnosesInput, EncounterUncheckedUpdateWithoutDiagnosesInput>
  }

  export type EncounterUpdateWithoutDiagnosesInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutDiagnosesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type DiagnosisUpsertWithoutEncountersInput = {
    update: XOR<DiagnosisUpdateWithoutEncountersInput, DiagnosisUncheckedUpdateWithoutEncountersInput>
    create: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
    where?: DiagnosisWhereInput
  }

  export type DiagnosisUpdateToOneWithWhereWithoutEncountersInput = {
    where?: DiagnosisWhereInput
    data: XOR<DiagnosisUpdateWithoutEncountersInput, DiagnosisUncheckedUpdateWithoutEncountersInput>
  }

  export type DiagnosisUpdateWithoutEncountersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type EncounterServiceCreateWithoutServiceInput = {
    quantity?: number
    price: number
    encounter: EncounterCreateNestedOneWithoutEncounterServicesInput
  }

  export type EncounterServiceUncheckedCreateWithoutServiceInput = {
    id?: number
    encounterId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceCreateOrConnectWithoutServiceInput = {
    where: EncounterServiceWhereUniqueInput
    create: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput>
  }

  export type EncounterServiceCreateManyServiceInputEnvelope = {
    data: EncounterServiceCreateManyServiceInput | EncounterServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBranchCreateWithoutServiceInput = {
    branch: BranchCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateWithoutServiceInput = {
    branchId: number
  }

  export type ServiceBranchCreateOrConnectWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    create: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBranchCreateManyServiceInputEnvelope = {
    data: ServiceBranchCreateManyServiceInput | ServiceBranchCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutServiceInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutServiceInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceItemCreateManyServiceInputEnvelope = {
    data: InvoiceItemCreateManyServiceInput | InvoiceItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type EncounterServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: EncounterServiceWhereUniqueInput
    update: XOR<EncounterServiceUpdateWithoutServiceInput, EncounterServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput>
  }

  export type EncounterServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: EncounterServiceWhereUniqueInput
    data: XOR<EncounterServiceUpdateWithoutServiceInput, EncounterServiceUncheckedUpdateWithoutServiceInput>
  }

  export type EncounterServiceUpdateManyWithWhereWithoutServiceInput = {
    where: EncounterServiceScalarWhereInput
    data: XOR<EncounterServiceUpdateManyMutationInput, EncounterServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceBranchUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    update: XOR<ServiceBranchUpdateWithoutServiceInput, ServiceBranchUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBranchUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    data: XOR<ServiceBranchUpdateWithoutServiceInput, ServiceBranchUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceBranchUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceBranchScalarWhereInput
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>
    create: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutServiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableFilter<"InvoiceItem"> | number | null
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    lineTotal?: FloatFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
  }

  export type ServiceCreateWithoutServiceBranchesInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceBranchesInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceBranchesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
  }

  export type BranchCreateWithoutServiceBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServiceBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServiceBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
  }

  export type ServiceUpsertWithoutServiceBranchesInput = {
    update: XOR<ServiceUpdateWithoutServiceBranchesInput, ServiceUncheckedUpdateWithoutServiceBranchesInput>
    create: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceBranchesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceBranchesInput, ServiceUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type ServiceUpdateWithoutServiceBranchesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BranchUpsertWithoutServiceBranchesInput = {
    update: XOR<BranchUpdateWithoutServiceBranchesInput, BranchUncheckedUpdateWithoutServiceBranchesInput>
    create: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServiceBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServiceBranchesInput, BranchUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type BranchUpdateWithoutServiceBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServiceBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterCreateWithoutEncounterServicesInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutEncounterServicesInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutEncounterServicesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
  }

  export type ServiceCreateWithoutEncounterServicesInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    serviceBranches?: ServiceBranchCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutEncounterServicesInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutEncounterServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
  }

  export type EncounterUpsertWithoutEncounterServicesInput = {
    update: XOR<EncounterUpdateWithoutEncounterServicesInput, EncounterUncheckedUpdateWithoutEncounterServicesInput>
    create: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutEncounterServicesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutEncounterServicesInput, EncounterUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type EncounterUpdateWithoutEncounterServicesInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutEncounterServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type ServiceUpsertWithoutEncounterServicesInput = {
    update: XOR<ServiceUpdateWithoutEncounterServicesInput, ServiceUncheckedUpdateWithoutEncounterServicesInput>
    create: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutEncounterServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutEncounterServicesInput, ServiceUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type ServiceUpdateWithoutEncounterServicesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceBranches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutEncounterServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type InvoiceItemCreateWithoutProcedureInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutProcedureInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutProcedureInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput>
  }

  export type InvoiceItemCreateManyProcedureInputEnvelope = {
    data: InvoiceItemCreateManyProcedureInput | InvoiceItemCreateManyProcedureInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProcedureInput, InvoiceItemUncheckedUpdateWithoutProcedureInput>
    create: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProcedureInput, InvoiceItemUncheckedUpdateWithoutProcedureInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProcedureInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProcedureInput>
  }

  export type BranchCreateWithoutProductsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutProductsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
  }

  export type InvoiceItemCreateWithoutProductInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutProductInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemCreateManyProductInputEnvelope = {
    data: InvoiceItemCreateManyProductInput | InvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutProductsInput = {
    update: XOR<BranchUpdateWithoutProductsInput, BranchUncheckedUpdateWithoutProductsInput>
    create: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutProductsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutProductsInput, BranchUncheckedUpdateWithoutProductsInput>
  }

  export type BranchUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type EncounterCreateWithoutPrescriptionInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPrescriptionInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateWithoutPrescriptionInput = {
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionItemCreateManyPrescriptionInput | PrescriptionItemCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutPrescriptionInput = {
    update: XOR<EncounterUpdateWithoutPrescriptionInput, EncounterUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutPrescriptionInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutPrescriptionInput, EncounterUncheckedUpdateWithoutPrescriptionInput>
  }

  export type EncounterUpdateWithoutPrescriptionInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionItemScalarWhereInput = {
    AND?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    OR?: PrescriptionItemScalarWhereInput[]
    NOT?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    id?: IntFilter<"PrescriptionItem"> | number
    prescriptionId?: IntFilter<"PrescriptionItem"> | number
    order?: IntFilter<"PrescriptionItem"> | number
    drugName?: StringFilter<"PrescriptionItem"> | string
    durationDays?: IntFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntFilter<"PrescriptionItem"> | number
    note?: StringNullableFilter<"PrescriptionItem"> | string | null
  }

  export type PrescriptionCreateWithoutItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    encounter: EncounterCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutItemsInput = {
    id?: number
    encounterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
  }

  export type PrescriptionCreateOrConnectWithoutItemsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
  }

  export type PrescriptionUpsertWithoutItemsInput = {
    update: XOR<PrescriptionUpdateWithoutItemsInput, PrescriptionUncheckedUpdateWithoutItemsInput>
    create: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutItemsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutItemsInput, PrescriptionUncheckedUpdateWithoutItemsInput>
  }

  export type PrescriptionUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchCreateWithoutInvoicesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutInvoicesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
  }

  export type EncounterCreateWithoutInvoiceInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutInvoiceInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutInvoiceInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
  }

  export type PatientCreateWithoutInvoicesInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EBarimtReceiptCreateWithoutInvoiceInput = {
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptUncheckedCreateWithoutInvoiceInput = {
    id?: number
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptCreateOrConnectWithoutInvoiceInput = {
    where: EBarimtReceiptWhereUniqueInput
    create: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
  }

  export type LedgerEntryCreateWithoutInvoiceInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutInvoiceInput = {
    id?: number
    branchId: number
    patientId: number
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutInvoiceInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput>
  }

  export type LedgerEntryCreateManyInvoiceInputEnvelope = {
    data: LedgerEntryCreateManyInvoiceInput | LedgerEntryCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeBenefitUsageCreateWithoutInvoiceInput = {
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
    employeeBenefit: EmployeeBenefitCreateNestedOneWithoutUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput = {
    id?: number
    employeeBenefitId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    create: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput>
  }

  export type EmployeeBenefitUsageCreateManyInvoiceInputEnvelope = {
    data: EmployeeBenefitUsageCreateManyInvoiceInput | EmployeeBenefitUsageCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutInvoicesInput = {
    update: XOR<BranchUpdateWithoutInvoicesInput, BranchUncheckedUpdateWithoutInvoicesInput>
    create: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInvoicesInput, BranchUncheckedUpdateWithoutInvoicesInput>
  }

  export type BranchUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithoutInvoiceInput = {
    update: XOR<EncounterUpdateWithoutInvoiceInput, EncounterUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutInvoiceInput, EncounterUncheckedUpdateWithoutInvoiceInput>
  }

  export type EncounterUpdateWithoutInvoiceInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type EBarimtReceiptUpsertWithoutInvoiceInput = {
    update: XOR<EBarimtReceiptUpdateWithoutInvoiceInput, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    where?: EBarimtReceiptWhereInput
  }

  export type EBarimtReceiptUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: EBarimtReceiptWhereInput
    data: XOR<EBarimtReceiptUpdateWithoutInvoiceInput, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
  }

  export type EBarimtReceiptUpdateWithoutInvoiceInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutInvoiceInput, LedgerEntryUncheckedUpdateWithoutInvoiceInput>
    create: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutInvoiceInput, LedgerEntryUncheckedUpdateWithoutInvoiceInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutInvoiceInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    qpayTxnId?: StringNullableFilter<"Payment"> | string | null
    timestamp?: DateTimeFilter<"Payment"> | Date | string
  }

  export type EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    update: XOR<EmployeeBenefitUsageUpdateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput>
  }

  export type EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    data: XOR<EmployeeBenefitUsageUpdateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedUpdateWithoutInvoiceInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput = {
    where: EmployeeBenefitUsageScalarWhereInput
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCreateWithoutInvoiceItemsInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ProductCreateWithoutInvoiceItemsInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    branchId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ProcedureCreateWithoutInvoiceItemsInput = {
    code: string
    name: string
    price: number
  }

  export type ProcedureUncheckedCreateWithoutInvoiceItemsInput = {
    code: string
    name: string
    price: number
  }

  export type ProcedureCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<ServiceUpdateWithoutInvoiceItemsInput, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutInvoiceItemsInput, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ServiceUpdateWithoutInvoiceItemsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProductUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateWithoutInvoiceItemsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProcedureUpdateWithoutInvoiceItemsInput, ProcedureUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutInvoiceItemsInput, ProcedureUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProcedureUpdateWithoutInvoiceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcedureUncheckedUpdateWithoutInvoiceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutEBarimtReceiptInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEBarimtReceiptInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEBarimtReceiptInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
  }

  export type InvoiceUpsertWithoutEBarimtReceiptInput = {
    update: XOR<InvoiceUpdateWithoutEBarimtReceiptInput, InvoiceUncheckedUpdateWithoutEBarimtReceiptInput>
    create: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEBarimtReceiptInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEBarimtReceiptInput, InvoiceUncheckedUpdateWithoutEBarimtReceiptInput>
  }

  export type InvoiceUpdateWithoutEBarimtReceiptInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEBarimtReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type BranchCreateWithoutLedgerEntriesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutLedgerEntriesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type PatientCreateWithoutLedgerEntriesInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLedgerEntriesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type InvoiceCreateWithoutLedgerEntriesInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLedgerEntriesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type UserCreateWithoutCreatedLedgerEntriesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedLedgerEntriesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedLedgerEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
  }

  export type UserCreateWithoutApprovedLedgerEntriesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutApprovedLedgerEntriesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutApprovedLedgerEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
  }

  export type AuthorizationCodeCreateWithoutLedgerEntriesInput = {
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAuthorizationCodesInput
  }

  export type AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorizationCodeCreateOrConnectWithoutLedgerEntriesInput = {
    where: AuthorizationCodeWhereUniqueInput
    create: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type EmployeeVoucherCreateWithoutLedgerEntriesInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type EmployeeVoucherCreateOrConnectWithoutLedgerEntriesInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type BranchUpsertWithoutLedgerEntriesInput = {
    update: XOR<BranchUpdateWithoutLedgerEntriesInput, BranchUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutLedgerEntriesInput, BranchUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type BranchUpdateWithoutLedgerEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutLedgerEntriesInput = {
    update: XOR<PatientUpdateWithoutLedgerEntriesInput, PatientUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLedgerEntriesInput, PatientUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type PatientUpdateWithoutLedgerEntriesInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceUpsertWithoutLedgerEntriesInput = {
    update: XOR<InvoiceUpdateWithoutLedgerEntriesInput, InvoiceUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLedgerEntriesInput, InvoiceUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type InvoiceUpdateWithoutLedgerEntriesInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutCreatedLedgerEntriesInput = {
    update: XOR<UserUpdateWithoutCreatedLedgerEntriesInput, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
    create: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLedgerEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLedgerEntriesInput, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
  }

  export type UserUpdateWithoutCreatedLedgerEntriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithoutApprovedLedgerEntriesInput = {
    update: XOR<UserUpdateWithoutApprovedLedgerEntriesInput, UserUncheckedUpdateWithoutApprovedLedgerEntriesInput>
    create: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedLedgerEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedLedgerEntriesInput, UserUncheckedUpdateWithoutApprovedLedgerEntriesInput>
  }

  export type UserUpdateWithoutApprovedLedgerEntriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type AuthorizationCodeUpsertWithoutLedgerEntriesInput = {
    update: XOR<AuthorizationCodeUpdateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
    where?: AuthorizationCodeWhereInput
  }

  export type AuthorizationCodeUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: AuthorizationCodeWhereInput
    data: XOR<AuthorizationCodeUpdateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type AuthorizationCodeUpdateWithoutLedgerEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAuthorizationCodesNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUpsertWithoutLedgerEntriesInput = {
    update: XOR<EmployeeVoucherUpdateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
    where?: EmployeeVoucherWhereInput
  }

  export type EmployeeVoucherUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: EmployeeVoucherWhereInput
    data: XOR<EmployeeVoucherUpdateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type EmployeeVoucherUpdateWithoutLedgerEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutAuthorizationCodesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAuthorizationCodesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAuthorizationCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
  }

  export type LedgerEntryCreateWithoutApprovalCodeInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutApprovalCodeInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutApprovalCodeInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput>
  }

  export type LedgerEntryCreateManyApprovalCodeInputEnvelope = {
    data: LedgerEntryCreateManyApprovalCodeInput | LedgerEntryCreateManyApprovalCodeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAuthorizationCodesInput = {
    update: XOR<UserUpdateWithoutAuthorizationCodesInput, UserUncheckedUpdateWithoutAuthorizationCodesInput>
    create: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorizationCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorizationCodesInput, UserUncheckedUpdateWithoutAuthorizationCodesInput>
  }

  export type UserUpdateWithoutAuthorizationCodesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorizationCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutApprovalCodeInput, LedgerEntryUncheckedUpdateWithoutApprovalCodeInput>
    create: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutApprovalCodeInput, LedgerEntryUncheckedUpdateWithoutApprovalCodeInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutApprovalCodeInput>
  }

  export type BranchCreateWithoutEmployeeVouchersInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEmployeeVouchersInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEmployeeVouchersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
  }

  export type UserCreateWithoutEmployeeVouchersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutEmployeeVouchersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutEmployeeVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
  }

  export type LedgerEntryCreateWithoutEmployeeVoucherInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput>
  }

  export type LedgerEntryCreateManyEmployeeVoucherInputEnvelope = {
    data: LedgerEntryCreateManyEmployeeVoucherInput | LedgerEntryCreateManyEmployeeVoucherInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedEmployeeVouchersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedEmployeeVouchersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedEmployeeVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
  }

  export type BranchUpsertWithoutEmployeeVouchersInput = {
    update: XOR<BranchUpdateWithoutEmployeeVouchersInput, BranchUncheckedUpdateWithoutEmployeeVouchersInput>
    create: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEmployeeVouchersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEmployeeVouchersInput, BranchUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type BranchUpdateWithoutEmployeeVouchersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEmployeeVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutEmployeeVouchersInput = {
    update: XOR<UserUpdateWithoutEmployeeVouchersInput, UserUncheckedUpdateWithoutEmployeeVouchersInput>
    create: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeVouchersInput, UserUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type UserUpdateWithoutEmployeeVouchersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutEmployeeVoucherInput, LedgerEntryUncheckedUpdateWithoutEmployeeVoucherInput>
    create: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutEmployeeVoucherInput, LedgerEntryUncheckedUpdateWithoutEmployeeVoucherInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherInput>
  }

  export type UserUpsertWithoutCreatedEmployeeVouchersInput = {
    update: XOR<UserUpdateWithoutCreatedEmployeeVouchersInput, UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput>
    create: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedEmployeeVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedEmployeeVouchersInput, UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput>
  }

  export type UserUpdateWithoutCreatedEmployeeVouchersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type EncounterCreateWithoutMediaInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutMediaInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutMediaInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
  }

  export type EncounterUpsertWithoutMediaInput = {
    update: XOR<EncounterUpdateWithoutMediaInput, EncounterUncheckedUpdateWithoutMediaInput>
    create: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutMediaInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutMediaInput, EncounterUncheckedUpdateWithoutMediaInput>
  }

  export type EncounterUpdateWithoutMediaInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserCreateWithoutDoctorSchedulesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDoctorSchedulesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
  }

  export type BranchCreateWithoutDoctorSchedulesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDoctorSchedulesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDoctorSchedulesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
  }

  export type UserUpsertWithoutDoctorSchedulesInput = {
    update: XOR<UserUpdateWithoutDoctorSchedulesInput, UserUncheckedUpdateWithoutDoctorSchedulesInput>
    create: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorSchedulesInput, UserUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type UserUpdateWithoutDoctorSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutDoctorSchedulesInput = {
    update: XOR<BranchUpdateWithoutDoctorSchedulesInput, BranchUncheckedUpdateWithoutDoctorSchedulesInput>
    create: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDoctorSchedulesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDoctorSchedulesInput, BranchUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type BranchUpdateWithoutDoctorSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutReceptionSchedulesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReceptionSchedulesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReceptionSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
  }

  export type BranchCreateWithoutReceptionSchedulesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutReceptionSchedulesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutReceptionSchedulesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
  }

  export type UserUpsertWithoutReceptionSchedulesInput = {
    update: XOR<UserUpdateWithoutReceptionSchedulesInput, UserUncheckedUpdateWithoutReceptionSchedulesInput>
    create: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceptionSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceptionSchedulesInput, UserUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type UserUpdateWithoutReceptionSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceptionSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutReceptionSchedulesInput = {
    update: XOR<BranchUpdateWithoutReceptionSchedulesInput, BranchUncheckedUpdateWithoutReceptionSchedulesInput>
    create: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutReceptionSchedulesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutReceptionSchedulesInput, BranchUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type BranchUpdateWithoutReceptionSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutReceptionSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutDoctorBranchesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutDoctorBranchesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
  }

  export type BranchCreateWithoutDoctorBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDoctorBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDoctorBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
  }

  export type UserUpsertWithoutDoctorBranchesInput = {
    update: XOR<UserUpdateWithoutDoctorBranchesInput, UserUncheckedUpdateWithoutDoctorBranchesInput>
    create: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorBranchesInput, UserUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type UserUpdateWithoutDoctorBranchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutDoctorBranchesInput = {
    update: XOR<BranchUpdateWithoutDoctorBranchesInput, BranchUncheckedUpdateWithoutDoctorBranchesInput>
    create: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDoctorBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDoctorBranchesInput, BranchUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type BranchUpdateWithoutDoctorBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDoctorBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutReceptionBranchesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReceptionBranchesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReceptionBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
  }

  export type BranchCreateWithoutReceptionBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutReceptionBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutReceptionBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
  }

  export type UserUpsertWithoutReceptionBranchesInput = {
    update: XOR<UserUpdateWithoutReceptionBranchesInput, UserUncheckedUpdateWithoutReceptionBranchesInput>
    create: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceptionBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceptionBranchesInput, UserUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type UserUpdateWithoutReceptionBranchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceptionBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutReceptionBranchesInput = {
    update: XOR<BranchUpdateWithoutReceptionBranchesInput, BranchUncheckedUpdateWithoutReceptionBranchesInput>
    create: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutReceptionBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutReceptionBranchesInput, BranchUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type BranchUpdateWithoutReceptionBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutReceptionBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutNurseBranchesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNurseBranchesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNurseBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
  }

  export type BranchCreateWithoutNurseBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutNurseBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutNurseBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
  }

  export type UserUpsertWithoutNurseBranchesInput = {
    update: XOR<UserUpdateWithoutNurseBranchesInput, UserUncheckedUpdateWithoutNurseBranchesInput>
    create: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseBranchesInput, UserUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type UserUpdateWithoutNurseBranchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutNurseBranchesInput = {
    update: XOR<BranchUpdateWithoutNurseBranchesInput, BranchUncheckedUpdateWithoutNurseBranchesInput>
    create: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutNurseBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutNurseBranchesInput, BranchUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type BranchUpdateWithoutNurseBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutNurseBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutNurseSchedulesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutNurseSchedulesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutNurseSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
  }

  export type BranchCreateWithoutNurseSchedulesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutNurseSchedulesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutNurseSchedulesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
  }

  export type UserUpsertWithoutNurseSchedulesInput = {
    update: XOR<UserUpdateWithoutNurseSchedulesInput, UserUncheckedUpdateWithoutNurseSchedulesInput>
    create: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseSchedulesInput, UserUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type UserUpdateWithoutNurseSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type BranchUpsertWithoutNurseSchedulesInput = {
    update: XOR<BranchUpdateWithoutNurseSchedulesInput, BranchUncheckedUpdateWithoutNurseSchedulesInput>
    create: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutNurseSchedulesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutNurseSchedulesInput, BranchUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type BranchUpdateWithoutNurseSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutNurseSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateManyBranchInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
  }

  export type PatientCreateManyBranchInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorScheduleCreateManyBranchInput = {
    id?: number
    doctorId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ServiceBranchCreateManyBranchInput = {
    serviceId: number
  }

  export type DoctorBranchCreateManyBranchInput = {
    id?: number
    doctorId: number
  }

  export type AppointmentCreateManyBranchInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type BookingCreateManyBranchInput = {
    id?: number
    doctorId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceptionScheduleCreateManyBranchInput = {
    id?: number
    receptionId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionBranchCreateManyBranchInput = {
    id?: number
    receptionId: number
  }

  export type NurseScheduleCreateManyBranchInput = {
    id?: number
    nurseId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseBranchCreateManyBranchInput = {
    id?: number
    nurseId: number
  }

  export type ProductCreateManyBranchInput = {
    id?: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyBranchInput = {
    id?: number
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyBranchInput = {
    id?: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmployeeVoucherCreateManyBranchInput = {
    id?: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type UserUpdateWithoutBranchInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PatientUpdateWithoutBranchInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorScheduleUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchUpdateWithoutBranchInput = {
    service?: ServiceUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateWithoutBranchInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceBranchUncheckedUpdateManyWithoutBranchInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchUpdateWithoutBranchInput = {
    doctor?: UserUpdateOneRequiredWithoutDoctorBranchesNestedInput
  }

  export type DoctorBranchUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentUpdateWithoutBranchInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutBookingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceptionScheduleUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reception?: UserUpdateOneRequiredWithoutReceptionSchedulesNestedInput
  }

  export type ReceptionScheduleUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionBranchUpdateWithoutBranchInput = {
    reception?: UserUpdateOneRequiredWithoutReceptionBranchesNestedInput
  }

  export type ReceptionBranchUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseScheduleUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nurse?: UserUpdateOneRequiredWithoutNurseSchedulesNestedInput
  }

  export type NurseScheduleUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseBranchUpdateWithoutBranchInput = {
    nurse?: UserUpdateOneRequiredWithoutNurseBranchesNestedInput
  }

  export type NurseBranchUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutBranchInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutBranchInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutBranchInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUpdateWithoutBranchInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeBenefitUsageCreateManyEmployeeBenefitInput = {
    id?: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageUpdateWithoutEmployeeBenefitInput = {
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateWithoutEmployeeBenefitInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyDoctorInput = {
    id?: number
    patientBookId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterCreateManyNurseInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type DoctorScheduleCreateManyDoctorInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorBranchCreateManyDoctorInput = {
    id?: number
    branchId: number
  }

  export type ReceptionScheduleCreateManyReceptionInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionBranchCreateManyReceptionInput = {
    id?: number
    branchId: number
  }

  export type NurseScheduleCreateManyNurseInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseBranchCreateManyNurseInput = {
    id?: number
    branchId: number
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: number
    patientId: number
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type BookingCreateManyDoctorInput = {
    id?: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeBenefitCreateManyEmployeeInput = {
    id?: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyCreatedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateManyApprovedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmployeeVoucherCreateManyEmployeeInput = {
    id?: number
    branchId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type EmployeeVoucherCreateManyCreatedByInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorizationCodeCreateManyCreatedByInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateWithoutDoctorInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterUpdateWithoutNurseInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorScheduleUpdateWithoutDoctorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorBranchUpdateWithoutDoctorInput = {
    branch?: BranchUpdateOneRequiredWithoutDoctorBranchesNestedInput
  }

  export type DoctorBranchUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionScheduleUpdateWithoutReceptionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutReceptionSchedulesNestedInput
  }

  export type ReceptionScheduleUncheckedUpdateWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionBranchUpdateWithoutReceptionInput = {
    branch?: BranchUpdateOneRequiredWithoutReceptionBranchesNestedInput
  }

  export type ReceptionBranchUncheckedUpdateWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseScheduleUpdateWithoutNurseInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutNurseSchedulesNestedInput
  }

  export type NurseScheduleUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseBranchUpdateWithoutNurseInput = {
    branch?: BranchUpdateOneRequiredWithoutNurseBranchesNestedInput
  }

  export type NurseBranchUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutDoctorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBookingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUpdateWithoutEmployeeInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: EmployeeBenefitUsageUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutCreatedByInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutApprovedByInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUpdateWithoutEmployeeInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeVoucherUpdateWithoutCreatedByInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorizationCodeUpdateWithoutCreatedByInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type BookingCreateManyPatientInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyPatientInput = {
    id?: number
    branchId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutPatientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutBookingsNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutPatientInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyPatientBookInput = {
    id?: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterUpdateWithoutPatientBookInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterCreateManyAppointmentInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterUpdateWithoutAppointmentInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChartToothCreateManyEncounterInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
  }

  export type MediaCreateManyEncounterInput = {
    id?: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type EncounterServiceCreateManyEncounterInput = {
    id?: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterDiagnosisCreateManyEncounterInput = {
    id?: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterConsentCreateManyEncounterInput = {
    id?: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChartToothUpdateWithoutEncounterInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    chartNotes?: ChartNoteUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    chartNotes?: ChartNoteUncheckedUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaUpdateWithoutEncounterInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterServiceUpdateWithoutEncounterInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutEncounterServicesNestedInput
  }

  export type EncounterServiceUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterDiagnosisUpdateWithoutEncounterInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: DiagnosisUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUpdateWithoutEncounterInput = {
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteCreateManyChartToothInput = {
    id?: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUpdateWithoutChartToothInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteUncheckedUpdateWithoutChartToothInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteUncheckedUpdateManyWithoutChartToothInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisProblemCreateManyDiagnosisInput = {
    id?: number
    label: string
    order?: number
    active?: boolean
  }

  export type EncounterDiagnosisCreateManyDiagnosisInput = {
    id?: number
    encounterId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type DiagnosisProblemUpdateWithoutDiagnosisInput = {
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemUncheckedUpdateWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterDiagnosisUpdateWithoutDiagnosisInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDiagnosesNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterServiceCreateManyServiceInput = {
    id?: number
    encounterId: number
    quantity?: number
    price: number
  }

  export type ServiceBranchCreateManyServiceInput = {
    branchId: number
  }

  export type InvoiceItemCreateManyServiceInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type EncounterServiceUpdateWithoutServiceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    encounter?: EncounterUpdateOneRequiredWithoutEncounterServicesNestedInput
  }

  export type EncounterServiceUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceBranchUpdateWithoutServiceInput = {
    branch?: BranchUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateWithoutServiceInput = {
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceBranchUncheckedUpdateManyWithoutServiceInput = {
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUpdateWithoutServiceInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateManyProcedureInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateWithoutProcedureInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProcedureInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProcedureInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateManyProductInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateWithoutProductInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type PrescriptionItemCreateManyPrescriptionInput = {
    id?: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUpdateWithoutPrescriptionInput = {
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type LedgerEntryCreateManyInvoiceInput = {
    id?: number
    branchId: number
    patientId: number
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type EmployeeBenefitUsageCreateManyInvoiceInput = {
    id?: number
    employeeBenefitId: number
    encounterId: number
    amountUsed: number
    patientId: number
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type LedgerEntryUpdateWithoutInvoiceInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUpdateWithoutInvoiceInput = {
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeBenefit?: EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyApprovalCodeInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutApprovalCodeInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutApprovalCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovalCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyEmployeeVoucherInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutEmployeeVoucherInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutEmployeeVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeBenefitCountOutputTypeDefaultArgs instead
     */
    export type EmployeeBenefitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientBookCountOutputTypeDefaultArgs instead
     */
    export type PatientBookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientBookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentCountOutputTypeDefaultArgs instead
     */
    export type AppointmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterCountOutputTypeDefaultArgs instead
     */
    export type EncounterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartToothCountOutputTypeDefaultArgs instead
     */
    export type ChartToothCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartToothCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisCountOutputTypeDefaultArgs instead
     */
    export type DiagnosisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedureCountOutputTypeDefaultArgs instead
     */
    export type ProcedureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionCountOutputTypeDefaultArgs instead
     */
    export type PrescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthorizationCodeCountOutputTypeDefaultArgs instead
     */
    export type AuthorizationCodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeVoucherCountOutputTypeDefaultArgs instead
     */
    export type EmployeeVoucherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeBenefitDefaultArgs instead
     */
    export type EmployeeBenefitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeBenefitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeBenefitUsageDefaultArgs instead
     */
    export type EmployeeBenefitUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeBenefitUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientBookDefaultArgs instead
     */
    export type PatientBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitCardDefaultArgs instead
     */
    export type VisitCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrthoCardDefaultArgs instead
     */
    export type OrthoCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrthoCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDefaultArgs instead
     */
    export type EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterConsentDefaultArgs instead
     */
    export type EncounterConsentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterConsentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartToothDefaultArgs instead
     */
    export type ChartToothArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartToothDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartNoteDefaultArgs instead
     */
    export type ChartNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisDefaultArgs instead
     */
    export type DiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisProblemDefaultArgs instead
     */
    export type DiagnosisProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisProblemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDiagnosisDefaultArgs instead
     */
    export type EncounterDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceBranchDefaultArgs instead
     */
    export type ServiceBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterServiceDefaultArgs instead
     */
    export type EncounterServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedureDefaultArgs instead
     */
    export type ProcedureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionDefaultArgs instead
     */
    export type PrescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionItemDefaultArgs instead
     */
    export type PrescriptionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EBarimtReceiptDefaultArgs instead
     */
    export type EBarimtReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EBarimtReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerEntryDefaultArgs instead
     */
    export type LedgerEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthorizationCodeDefaultArgs instead
     */
    export type AuthorizationCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthorizationCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeVoucherDefaultArgs instead
     */
    export type EmployeeVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeVoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorScheduleDefaultArgs instead
     */
    export type DoctorScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceptionScheduleDefaultArgs instead
     */
    export type ReceptionScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceptionScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorBranchDefaultArgs instead
     */
    export type DoctorBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceptionBranchDefaultArgs instead
     */
    export type ReceptionBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceptionBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NurseBranchDefaultArgs instead
     */
    export type NurseBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NurseBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NurseScheduleDefaultArgs instead
     */
    export type NurseScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NurseScheduleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}