
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model EmployeeBenefit
 * 
 */
export type EmployeeBenefit = $Result.DefaultSelection<Prisma.$EmployeeBenefitPayload>
/**
 * Model EmployeeBenefitUsage
 * 
 */
export type EmployeeBenefitUsage = $Result.DefaultSelection<Prisma.$EmployeeBenefitUsagePayload>
/**
 * Model SterilizationCategory
 * 
 */
export type SterilizationCategory = $Result.DefaultSelection<Prisma.$SterilizationCategoryPayload>
/**
 * Model SterilizationItem
 * 
 */
export type SterilizationItem = $Result.DefaultSelection<Prisma.$SterilizationItemPayload>
/**
 * Model SterilizationIndicator
 * 
 */
export type SterilizationIndicator = $Result.DefaultSelection<Prisma.$SterilizationIndicatorPayload>
/**
 * Model SterilizationIndicatorItem
 * 
 */
export type SterilizationIndicatorItem = $Result.DefaultSelection<Prisma.$SterilizationIndicatorItemPayload>
/**
 * Model EncounterSterilizationPackageUse
 * 
 */
export type EncounterSterilizationPackageUse = $Result.DefaultSelection<Prisma.$EncounterSterilizationPackageUsePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model PatientBook
 * 
 */
export type PatientBook = $Result.DefaultSelection<Prisma.$PatientBookPayload>
/**
 * Model VisitCard
 * 
 */
export type VisitCard = $Result.DefaultSelection<Prisma.$VisitCardPayload>
/**
 * Model OrthoCard
 * 
 */
export type OrthoCard = $Result.DefaultSelection<Prisma.$OrthoCardPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model EncounterConsent
 * 
 */
export type EncounterConsent = $Result.DefaultSelection<Prisma.$EncounterConsentPayload>
/**
 * Model ChartTooth
 * 
 */
export type ChartTooth = $Result.DefaultSelection<Prisma.$ChartToothPayload>
/**
 * Model ChartNote
 * 
 */
export type ChartNote = $Result.DefaultSelection<Prisma.$ChartNotePayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model DiagnosisProblem
 * 
 */
export type DiagnosisProblem = $Result.DefaultSelection<Prisma.$DiagnosisProblemPayload>
/**
 * Model EncounterDiagnosis
 * 
 */
export type EncounterDiagnosis = $Result.DefaultSelection<Prisma.$EncounterDiagnosisPayload>
/**
 * Model EncounterDiagnosisSterilizationIndicator
 * 
 */
export type EncounterDiagnosisSterilizationIndicator = $Result.DefaultSelection<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceBranch
 * 
 */
export type ServiceBranch = $Result.DefaultSelection<Prisma.$ServiceBranchPayload>
/**
 * Model EncounterService
 * 
 */
export type EncounterService = $Result.DefaultSelection<Prisma.$EncounterServicePayload>
/**
 * Model Procedure
 * 
 */
export type Procedure = $Result.DefaultSelection<Prisma.$ProcedurePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductStockMovement
 * 
 */
export type ProductStockMovement = $Result.DefaultSelection<Prisma.$ProductStockMovementPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionItem
 * 
 */
export type PrescriptionItem = $Result.DefaultSelection<Prisma.$PrescriptionItemPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model EBarimtReceipt
 * 
 */
export type EBarimtReceipt = $Result.DefaultSelection<Prisma.$EBarimtReceiptPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model AuthorizationCode
 * 
 */
export type AuthorizationCode = $Result.DefaultSelection<Prisma.$AuthorizationCodePayload>
/**
 * Model EmployeeVoucher
 * 
 */
export type EmployeeVoucher = $Result.DefaultSelection<Prisma.$EmployeeVoucherPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model DoctorSchedule
 * 
 */
export type DoctorSchedule = $Result.DefaultSelection<Prisma.$DoctorSchedulePayload>
/**
 * Model ReceptionSchedule
 * 
 */
export type ReceptionSchedule = $Result.DefaultSelection<Prisma.$ReceptionSchedulePayload>
/**
 * Model DoctorBranch
 * 
 */
export type DoctorBranch = $Result.DefaultSelection<Prisma.$DoctorBranchPayload>
/**
 * Model ReceptionBranch
 * 
 */
export type ReceptionBranch = $Result.DefaultSelection<Prisma.$ReceptionBranchPayload>
/**
 * Model NurseBranch
 * 
 */
export type NurseBranch = $Result.DefaultSelection<Prisma.$NurseBranchPayload>
/**
 * Model NurseSchedule
 * 
 */
export type NurseSchedule = $Result.DefaultSelection<Prisma.$NurseSchedulePayload>
/**
 * Model PaymentMethodConfig
 * 
 */
export type PaymentMethodConfig = $Result.DefaultSelection<Prisma.$PaymentMethodConfigPayload>
/**
 * Model PaymentProviderConfig
 * 
 */
export type PaymentProviderConfig = $Result.DefaultSelection<Prisma.$PaymentProviderConfigPayload>
/**
 * Model QPayIntent
 * 
 */
export type QPayIntent = $Result.DefaultSelection<Prisma.$QPayIntentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  doctor: 'doctor',
  receptionist: 'receptionist',
  accountant: 'accountant',
  nurse: 'nurse',
  manager: 'manager'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const VisitCardType: {
  ADULT: 'ADULT',
  CHILD: 'CHILD'
};

export type VisitCardType = (typeof VisitCardType)[keyof typeof VisitCardType]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const ServiceCategory: {
  ORTHODONTIC_TREATMENT: 'ORTHODONTIC_TREATMENT',
  IMAGING: 'IMAGING',
  DEFECT_CORRECTION: 'DEFECT_CORRECTION',
  ADULT_TREATMENT: 'ADULT_TREATMENT',
  WHITENING: 'WHITENING',
  CHILD_TREATMENT: 'CHILD_TREATMENT',
  SURGERY: 'SURGERY'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const ProductStockMovementType: {
  ADJUSTMENT: 'ADJUSTMENT',
  SALE: 'SALE'
};

export type ProductStockMovementType = (typeof ProductStockMovementType)[keyof typeof ProductStockMovementType]


export const DiscountPercent: {
  ZERO: 'ZERO',
  FIVE: 'FIVE',
  TEN: 'TEN'
};

export type DiscountPercent = (typeof DiscountPercent)[keyof typeof DiscountPercent]


export const InvoiceItemType: {
  SERVICE: 'SERVICE',
  PRODUCT: 'PRODUCT'
};

export type InvoiceItemType = (typeof InvoiceItemType)[keyof typeof InvoiceItemType]


export const InvoiceItemSource: {
  ENCOUNTER: 'ENCOUNTER',
  MANUAL: 'MANUAL'
};

export type InvoiceItemSource = (typeof InvoiceItemSource)[keyof typeof InvoiceItemSource]


export const LedgerEntryType: {
  CASH: 'CASH',
  QPAY: 'QPAY',
  POS: 'POS',
  FIN_APP: 'FIN_APP',
  BOOKING_ADVANCE: 'BOOKING_ADVANCE',
  INSURANCE_PENDING: 'INSURANCE_PENDING',
  INSURANCE_SETTLED: 'INSURANCE_SETTLED',
  EMPLOYEE_VOUCHER: 'EMPLOYEE_VOUCHER',
  BARTER: 'BARTER',
  REFUND: 'REFUND'
};

export type LedgerEntryType = (typeof LedgerEntryType)[keyof typeof LedgerEntryType]


export const EmployeeVoucherStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED',
  EXPIRED: 'EXPIRED'
};

export type EmployeeVoucherStatus = (typeof EmployeeVoucherStatus)[keyof typeof EmployeeVoucherStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type VisitCardType = $Enums.VisitCardType

export const VisitCardType: typeof $Enums.VisitCardType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type ProductStockMovementType = $Enums.ProductStockMovementType

export const ProductStockMovementType: typeof $Enums.ProductStockMovementType

export type DiscountPercent = $Enums.DiscountPercent

export const DiscountPercent: typeof $Enums.DiscountPercent

export type InvoiceItemType = $Enums.InvoiceItemType

export const InvoiceItemType: typeof $Enums.InvoiceItemType

export type InvoiceItemSource = $Enums.InvoiceItemSource

export const InvoiceItemSource: typeof $Enums.InvoiceItemSource

export type LedgerEntryType = $Enums.LedgerEntryType

export const LedgerEntryType: typeof $Enums.LedgerEntryType

export type EmployeeVoucherStatus = $Enums.EmployeeVoucherStatus

export const EmployeeVoucherStatus: typeof $Enums.EmployeeVoucherStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Branches
 * const branches = await prisma.branch.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Branches
   * const branches = await prisma.branch.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.employeeBenefit`: Exposes CRUD operations for the **EmployeeBenefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeBenefits
    * const employeeBenefits = await prisma.employeeBenefit.findMany()
    * ```
    */
  get employeeBenefit(): Prisma.EmployeeBenefitDelegate<ExtArgs>;

  /**
   * `prisma.employeeBenefitUsage`: Exposes CRUD operations for the **EmployeeBenefitUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeBenefitUsages
    * const employeeBenefitUsages = await prisma.employeeBenefitUsage.findMany()
    * ```
    */
  get employeeBenefitUsage(): Prisma.EmployeeBenefitUsageDelegate<ExtArgs>;

  /**
   * `prisma.sterilizationCategory`: Exposes CRUD operations for the **SterilizationCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SterilizationCategories
    * const sterilizationCategories = await prisma.sterilizationCategory.findMany()
    * ```
    */
  get sterilizationCategory(): Prisma.SterilizationCategoryDelegate<ExtArgs>;

  /**
   * `prisma.sterilizationItem`: Exposes CRUD operations for the **SterilizationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SterilizationItems
    * const sterilizationItems = await prisma.sterilizationItem.findMany()
    * ```
    */
  get sterilizationItem(): Prisma.SterilizationItemDelegate<ExtArgs>;

  /**
   * `prisma.sterilizationIndicator`: Exposes CRUD operations for the **SterilizationIndicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SterilizationIndicators
    * const sterilizationIndicators = await prisma.sterilizationIndicator.findMany()
    * ```
    */
  get sterilizationIndicator(): Prisma.SterilizationIndicatorDelegate<ExtArgs>;

  /**
   * `prisma.sterilizationIndicatorItem`: Exposes CRUD operations for the **SterilizationIndicatorItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SterilizationIndicatorItems
    * const sterilizationIndicatorItems = await prisma.sterilizationIndicatorItem.findMany()
    * ```
    */
  get sterilizationIndicatorItem(): Prisma.SterilizationIndicatorItemDelegate<ExtArgs>;

  /**
   * `prisma.encounterSterilizationPackageUse`: Exposes CRUD operations for the **EncounterSterilizationPackageUse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterSterilizationPackageUses
    * const encounterSterilizationPackageUses = await prisma.encounterSterilizationPackageUse.findMany()
    * ```
    */
  get encounterSterilizationPackageUse(): Prisma.EncounterSterilizationPackageUseDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.patientBook`: Exposes CRUD operations for the **PatientBook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientBooks
    * const patientBooks = await prisma.patientBook.findMany()
    * ```
    */
  get patientBook(): Prisma.PatientBookDelegate<ExtArgs>;

  /**
   * `prisma.visitCard`: Exposes CRUD operations for the **VisitCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitCards
    * const visitCards = await prisma.visitCard.findMany()
    * ```
    */
  get visitCard(): Prisma.VisitCardDelegate<ExtArgs>;

  /**
   * `prisma.orthoCard`: Exposes CRUD operations for the **OrthoCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrthoCards
    * const orthoCards = await prisma.orthoCard.findMany()
    * ```
    */
  get orthoCard(): Prisma.OrthoCardDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs>;

  /**
   * `prisma.encounterConsent`: Exposes CRUD operations for the **EncounterConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterConsents
    * const encounterConsents = await prisma.encounterConsent.findMany()
    * ```
    */
  get encounterConsent(): Prisma.EncounterConsentDelegate<ExtArgs>;

  /**
   * `prisma.chartTooth`: Exposes CRUD operations for the **ChartTooth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartTooths
    * const chartTooths = await prisma.chartTooth.findMany()
    * ```
    */
  get chartTooth(): Prisma.ChartToothDelegate<ExtArgs>;

  /**
   * `prisma.chartNote`: Exposes CRUD operations for the **ChartNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartNotes
    * const chartNotes = await prisma.chartNote.findMany()
    * ```
    */
  get chartNote(): Prisma.ChartNoteDelegate<ExtArgs>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.diagnosisProblem`: Exposes CRUD operations for the **DiagnosisProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiagnosisProblems
    * const diagnosisProblems = await prisma.diagnosisProblem.findMany()
    * ```
    */
  get diagnosisProblem(): Prisma.DiagnosisProblemDelegate<ExtArgs>;

  /**
   * `prisma.encounterDiagnosis`: Exposes CRUD operations for the **EncounterDiagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterDiagnoses
    * const encounterDiagnoses = await prisma.encounterDiagnosis.findMany()
    * ```
    */
  get encounterDiagnosis(): Prisma.EncounterDiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.encounterDiagnosisSterilizationIndicator`: Exposes CRUD operations for the **EncounterDiagnosisSterilizationIndicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterDiagnosisSterilizationIndicators
    * const encounterDiagnosisSterilizationIndicators = await prisma.encounterDiagnosisSterilizationIndicator.findMany()
    * ```
    */
  get encounterDiagnosisSterilizationIndicator(): Prisma.EncounterDiagnosisSterilizationIndicatorDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.serviceBranch`: Exposes CRUD operations for the **ServiceBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceBranches
    * const serviceBranches = await prisma.serviceBranch.findMany()
    * ```
    */
  get serviceBranch(): Prisma.ServiceBranchDelegate<ExtArgs>;

  /**
   * `prisma.encounterService`: Exposes CRUD operations for the **EncounterService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterServices
    * const encounterServices = await prisma.encounterService.findMany()
    * ```
    */
  get encounterService(): Prisma.EncounterServiceDelegate<ExtArgs>;

  /**
   * `prisma.procedure`: Exposes CRUD operations for the **Procedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procedures
    * const procedures = await prisma.procedure.findMany()
    * ```
    */
  get procedure(): Prisma.ProcedureDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productStockMovement`: Exposes CRUD operations for the **ProductStockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStockMovements
    * const productStockMovements = await prisma.productStockMovement.findMany()
    * ```
    */
  get productStockMovement(): Prisma.ProductStockMovementDelegate<ExtArgs>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs>;

  /**
   * `prisma.prescriptionItem`: Exposes CRUD operations for the **PrescriptionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionItems
    * const prescriptionItems = await prisma.prescriptionItem.findMany()
    * ```
    */
  get prescriptionItem(): Prisma.PrescriptionItemDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.eBarimtReceipt`: Exposes CRUD operations for the **EBarimtReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EBarimtReceipts
    * const eBarimtReceipts = await prisma.eBarimtReceipt.findMany()
    * ```
    */
  get eBarimtReceipt(): Prisma.EBarimtReceiptDelegate<ExtArgs>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs>;

  /**
   * `prisma.authorizationCode`: Exposes CRUD operations for the **AuthorizationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthorizationCodes
    * const authorizationCodes = await prisma.authorizationCode.findMany()
    * ```
    */
  get authorizationCode(): Prisma.AuthorizationCodeDelegate<ExtArgs>;

  /**
   * `prisma.employeeVoucher`: Exposes CRUD operations for the **EmployeeVoucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeVouchers
    * const employeeVouchers = await prisma.employeeVoucher.findMany()
    * ```
    */
  get employeeVoucher(): Prisma.EmployeeVoucherDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.doctorSchedule`: Exposes CRUD operations for the **DoctorSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorSchedules
    * const doctorSchedules = await prisma.doctorSchedule.findMany()
    * ```
    */
  get doctorSchedule(): Prisma.DoctorScheduleDelegate<ExtArgs>;

  /**
   * `prisma.receptionSchedule`: Exposes CRUD operations for the **ReceptionSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceptionSchedules
    * const receptionSchedules = await prisma.receptionSchedule.findMany()
    * ```
    */
  get receptionSchedule(): Prisma.ReceptionScheduleDelegate<ExtArgs>;

  /**
   * `prisma.doctorBranch`: Exposes CRUD operations for the **DoctorBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorBranches
    * const doctorBranches = await prisma.doctorBranch.findMany()
    * ```
    */
  get doctorBranch(): Prisma.DoctorBranchDelegate<ExtArgs>;

  /**
   * `prisma.receptionBranch`: Exposes CRUD operations for the **ReceptionBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceptionBranches
    * const receptionBranches = await prisma.receptionBranch.findMany()
    * ```
    */
  get receptionBranch(): Prisma.ReceptionBranchDelegate<ExtArgs>;

  /**
   * `prisma.nurseBranch`: Exposes CRUD operations for the **NurseBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NurseBranches
    * const nurseBranches = await prisma.nurseBranch.findMany()
    * ```
    */
  get nurseBranch(): Prisma.NurseBranchDelegate<ExtArgs>;

  /**
   * `prisma.nurseSchedule`: Exposes CRUD operations for the **NurseSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NurseSchedules
    * const nurseSchedules = await prisma.nurseSchedule.findMany()
    * ```
    */
  get nurseSchedule(): Prisma.NurseScheduleDelegate<ExtArgs>;

  /**
   * `prisma.paymentMethodConfig`: Exposes CRUD operations for the **PaymentMethodConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethodConfigs
    * const paymentMethodConfigs = await prisma.paymentMethodConfig.findMany()
    * ```
    */
  get paymentMethodConfig(): Prisma.PaymentMethodConfigDelegate<ExtArgs>;

  /**
   * `prisma.paymentProviderConfig`: Exposes CRUD operations for the **PaymentProviderConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentProviderConfigs
    * const paymentProviderConfigs = await prisma.paymentProviderConfig.findMany()
    * ```
    */
  get paymentProviderConfig(): Prisma.PaymentProviderConfigDelegate<ExtArgs>;

  /**
   * `prisma.qPayIntent`: Exposes CRUD operations for the **QPayIntent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QPayIntents
    * const qPayIntents = await prisma.qPayIntent.findMany()
    * ```
    */
  get qPayIntent(): Prisma.QPayIntentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Branch: 'Branch',
    EmployeeBenefit: 'EmployeeBenefit',
    EmployeeBenefitUsage: 'EmployeeBenefitUsage',
    SterilizationCategory: 'SterilizationCategory',
    SterilizationItem: 'SterilizationItem',
    SterilizationIndicator: 'SterilizationIndicator',
    SterilizationIndicatorItem: 'SterilizationIndicatorItem',
    EncounterSterilizationPackageUse: 'EncounterSterilizationPackageUse',
    User: 'User',
    Patient: 'Patient',
    PatientBook: 'PatientBook',
    VisitCard: 'VisitCard',
    OrthoCard: 'OrthoCard',
    Appointment: 'Appointment',
    Booking: 'Booking',
    Encounter: 'Encounter',
    EncounterConsent: 'EncounterConsent',
    ChartTooth: 'ChartTooth',
    ChartNote: 'ChartNote',
    Diagnosis: 'Diagnosis',
    DiagnosisProblem: 'DiagnosisProblem',
    EncounterDiagnosis: 'EncounterDiagnosis',
    EncounterDiagnosisSterilizationIndicator: 'EncounterDiagnosisSterilizationIndicator',
    Service: 'Service',
    ServiceBranch: 'ServiceBranch',
    EncounterService: 'EncounterService',
    Procedure: 'Procedure',
    Product: 'Product',
    ProductStockMovement: 'ProductStockMovement',
    ProductCategory: 'ProductCategory',
    Prescription: 'Prescription',
    PrescriptionItem: 'PrescriptionItem',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    EBarimtReceipt: 'EBarimtReceipt',
    LedgerEntry: 'LedgerEntry',
    AuthorizationCode: 'AuthorizationCode',
    EmployeeVoucher: 'EmployeeVoucher',
    Media: 'Media',
    DoctorSchedule: 'DoctorSchedule',
    ReceptionSchedule: 'ReceptionSchedule',
    DoctorBranch: 'DoctorBranch',
    ReceptionBranch: 'ReceptionBranch',
    NurseBranch: 'NurseBranch',
    NurseSchedule: 'NurseSchedule',
    PaymentMethodConfig: 'PaymentMethodConfig',
    PaymentProviderConfig: 'PaymentProviderConfig',
    QPayIntent: 'QPayIntent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "branch" | "employeeBenefit" | "employeeBenefitUsage" | "sterilizationCategory" | "sterilizationItem" | "sterilizationIndicator" | "sterilizationIndicatorItem" | "encounterSterilizationPackageUse" | "user" | "patient" | "patientBook" | "visitCard" | "orthoCard" | "appointment" | "booking" | "encounter" | "encounterConsent" | "chartTooth" | "chartNote" | "diagnosis" | "diagnosisProblem" | "encounterDiagnosis" | "encounterDiagnosisSterilizationIndicator" | "service" | "serviceBranch" | "encounterService" | "procedure" | "product" | "productStockMovement" | "productCategory" | "prescription" | "prescriptionItem" | "invoice" | "invoiceItem" | "payment" | "eBarimtReceipt" | "ledgerEntry" | "authorizationCode" | "employeeVoucher" | "media" | "doctorSchedule" | "receptionSchedule" | "doctorBranch" | "receptionBranch" | "nurseBranch" | "nurseSchedule" | "paymentMethodConfig" | "paymentProviderConfig" | "qPayIntent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      EmployeeBenefit: {
        payload: Prisma.$EmployeeBenefitPayload<ExtArgs>
        fields: Prisma.EmployeeBenefitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeBenefitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeBenefitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          findFirst: {
            args: Prisma.EmployeeBenefitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeBenefitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          findMany: {
            args: Prisma.EmployeeBenefitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>[]
          }
          create: {
            args: Prisma.EmployeeBenefitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          createMany: {
            args: Prisma.EmployeeBenefitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeBenefitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>[]
          }
          delete: {
            args: Prisma.EmployeeBenefitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          update: {
            args: Prisma.EmployeeBenefitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeBenefitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeBenefitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeBenefitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitPayload>
          }
          aggregate: {
            args: Prisma.EmployeeBenefitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeBenefit>
          }
          groupBy: {
            args: Prisma.EmployeeBenefitGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeBenefitCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitCountAggregateOutputType> | number
          }
        }
      }
      EmployeeBenefitUsage: {
        payload: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>
        fields: Prisma.EmployeeBenefitUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeBenefitUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeBenefitUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          findFirst: {
            args: Prisma.EmployeeBenefitUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeBenefitUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          findMany: {
            args: Prisma.EmployeeBenefitUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>[]
          }
          create: {
            args: Prisma.EmployeeBenefitUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          createMany: {
            args: Prisma.EmployeeBenefitUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeBenefitUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>[]
          }
          delete: {
            args: Prisma.EmployeeBenefitUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          update: {
            args: Prisma.EmployeeBenefitUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeBenefitUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeBenefitUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeBenefitUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeBenefitUsagePayload>
          }
          aggregate: {
            args: Prisma.EmployeeBenefitUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeBenefitUsage>
          }
          groupBy: {
            args: Prisma.EmployeeBenefitUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeBenefitUsageCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeBenefitUsageCountAggregateOutputType> | number
          }
        }
      }
      SterilizationCategory: {
        payload: Prisma.$SterilizationCategoryPayload<ExtArgs>
        fields: Prisma.SterilizationCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SterilizationCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SterilizationCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>
          }
          findFirst: {
            args: Prisma.SterilizationCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SterilizationCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>
          }
          findMany: {
            args: Prisma.SterilizationCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>[]
          }
          create: {
            args: Prisma.SterilizationCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>
          }
          createMany: {
            args: Prisma.SterilizationCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SterilizationCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>[]
          }
          delete: {
            args: Prisma.SterilizationCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>
          }
          update: {
            args: Prisma.SterilizationCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SterilizationCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SterilizationCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SterilizationCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationCategoryPayload>
          }
          aggregate: {
            args: Prisma.SterilizationCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSterilizationCategory>
          }
          groupBy: {
            args: Prisma.SterilizationCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SterilizationCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SterilizationCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SterilizationCategoryCountAggregateOutputType> | number
          }
        }
      }
      SterilizationItem: {
        payload: Prisma.$SterilizationItemPayload<ExtArgs>
        fields: Prisma.SterilizationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SterilizationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SterilizationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>
          }
          findFirst: {
            args: Prisma.SterilizationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SterilizationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>
          }
          findMany: {
            args: Prisma.SterilizationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>[]
          }
          create: {
            args: Prisma.SterilizationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>
          }
          createMany: {
            args: Prisma.SterilizationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SterilizationItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>[]
          }
          delete: {
            args: Prisma.SterilizationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>
          }
          update: {
            args: Prisma.SterilizationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>
          }
          deleteMany: {
            args: Prisma.SterilizationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SterilizationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SterilizationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationItemPayload>
          }
          aggregate: {
            args: Prisma.SterilizationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSterilizationItem>
          }
          groupBy: {
            args: Prisma.SterilizationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SterilizationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SterilizationItemCountArgs<ExtArgs>
            result: $Utils.Optional<SterilizationItemCountAggregateOutputType> | number
          }
        }
      }
      SterilizationIndicator: {
        payload: Prisma.$SterilizationIndicatorPayload<ExtArgs>
        fields: Prisma.SterilizationIndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SterilizationIndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SterilizationIndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>
          }
          findFirst: {
            args: Prisma.SterilizationIndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SterilizationIndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>
          }
          findMany: {
            args: Prisma.SterilizationIndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>[]
          }
          create: {
            args: Prisma.SterilizationIndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>
          }
          createMany: {
            args: Prisma.SterilizationIndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SterilizationIndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>[]
          }
          delete: {
            args: Prisma.SterilizationIndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>
          }
          update: {
            args: Prisma.SterilizationIndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>
          }
          deleteMany: {
            args: Prisma.SterilizationIndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SterilizationIndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SterilizationIndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorPayload>
          }
          aggregate: {
            args: Prisma.SterilizationIndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSterilizationIndicator>
          }
          groupBy: {
            args: Prisma.SterilizationIndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SterilizationIndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SterilizationIndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<SterilizationIndicatorCountAggregateOutputType> | number
          }
        }
      }
      SterilizationIndicatorItem: {
        payload: Prisma.$SterilizationIndicatorItemPayload<ExtArgs>
        fields: Prisma.SterilizationIndicatorItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SterilizationIndicatorItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SterilizationIndicatorItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>
          }
          findFirst: {
            args: Prisma.SterilizationIndicatorItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SterilizationIndicatorItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>
          }
          findMany: {
            args: Prisma.SterilizationIndicatorItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>[]
          }
          create: {
            args: Prisma.SterilizationIndicatorItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>
          }
          createMany: {
            args: Prisma.SterilizationIndicatorItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SterilizationIndicatorItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>[]
          }
          delete: {
            args: Prisma.SterilizationIndicatorItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>
          }
          update: {
            args: Prisma.SterilizationIndicatorItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>
          }
          deleteMany: {
            args: Prisma.SterilizationIndicatorItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SterilizationIndicatorItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SterilizationIndicatorItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SterilizationIndicatorItemPayload>
          }
          aggregate: {
            args: Prisma.SterilizationIndicatorItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSterilizationIndicatorItem>
          }
          groupBy: {
            args: Prisma.SterilizationIndicatorItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SterilizationIndicatorItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SterilizationIndicatorItemCountArgs<ExtArgs>
            result: $Utils.Optional<SterilizationIndicatorItemCountAggregateOutputType> | number
          }
        }
      }
      EncounterSterilizationPackageUse: {
        payload: Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>
        fields: Prisma.EncounterSterilizationPackageUseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterSterilizationPackageUseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterSterilizationPackageUseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>
          }
          findFirst: {
            args: Prisma.EncounterSterilizationPackageUseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterSterilizationPackageUseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>
          }
          findMany: {
            args: Prisma.EncounterSterilizationPackageUseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>[]
          }
          create: {
            args: Prisma.EncounterSterilizationPackageUseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>
          }
          createMany: {
            args: Prisma.EncounterSterilizationPackageUseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterSterilizationPackageUseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>[]
          }
          delete: {
            args: Prisma.EncounterSterilizationPackageUseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>
          }
          update: {
            args: Prisma.EncounterSterilizationPackageUseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>
          }
          deleteMany: {
            args: Prisma.EncounterSterilizationPackageUseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterSterilizationPackageUseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterSterilizationPackageUseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSterilizationPackageUsePayload>
          }
          aggregate: {
            args: Prisma.EncounterSterilizationPackageUseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterSterilizationPackageUse>
          }
          groupBy: {
            args: Prisma.EncounterSterilizationPackageUseGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterSterilizationPackageUseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterSterilizationPackageUseCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterSterilizationPackageUseCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      PatientBook: {
        payload: Prisma.$PatientBookPayload<ExtArgs>
        fields: Prisma.PatientBookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientBookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientBookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          findFirst: {
            args: Prisma.PatientBookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientBookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          findMany: {
            args: Prisma.PatientBookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>[]
          }
          create: {
            args: Prisma.PatientBookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          createMany: {
            args: Prisma.PatientBookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientBookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>[]
          }
          delete: {
            args: Prisma.PatientBookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          update: {
            args: Prisma.PatientBookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          deleteMany: {
            args: Prisma.PatientBookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientBookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientBookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientBookPayload>
          }
          aggregate: {
            args: Prisma.PatientBookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientBook>
          }
          groupBy: {
            args: Prisma.PatientBookGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientBookGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientBookCountArgs<ExtArgs>
            result: $Utils.Optional<PatientBookCountAggregateOutputType> | number
          }
        }
      }
      VisitCard: {
        payload: Prisma.$VisitCardPayload<ExtArgs>
        fields: Prisma.VisitCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          findFirst: {
            args: Prisma.VisitCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          findMany: {
            args: Prisma.VisitCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>[]
          }
          create: {
            args: Prisma.VisitCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          createMany: {
            args: Prisma.VisitCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisitCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>[]
          }
          delete: {
            args: Prisma.VisitCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          update: {
            args: Prisma.VisitCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          deleteMany: {
            args: Prisma.VisitCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitCardPayload>
          }
          aggregate: {
            args: Prisma.VisitCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitCard>
          }
          groupBy: {
            args: Prisma.VisitCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitCardCountArgs<ExtArgs>
            result: $Utils.Optional<VisitCardCountAggregateOutputType> | number
          }
        }
      }
      OrthoCard: {
        payload: Prisma.$OrthoCardPayload<ExtArgs>
        fields: Prisma.OrthoCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrthoCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrthoCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          findFirst: {
            args: Prisma.OrthoCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrthoCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          findMany: {
            args: Prisma.OrthoCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>[]
          }
          create: {
            args: Prisma.OrthoCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          createMany: {
            args: Prisma.OrthoCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrthoCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>[]
          }
          delete: {
            args: Prisma.OrthoCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          update: {
            args: Prisma.OrthoCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          deleteMany: {
            args: Prisma.OrthoCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrthoCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrthoCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrthoCardPayload>
          }
          aggregate: {
            args: Prisma.OrthoCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrthoCard>
          }
          groupBy: {
            args: Prisma.OrthoCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrthoCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrthoCardCountArgs<ExtArgs>
            result: $Utils.Optional<OrthoCardCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      EncounterConsent: {
        payload: Prisma.$EncounterConsentPayload<ExtArgs>
        fields: Prisma.EncounterConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          findFirst: {
            args: Prisma.EncounterConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          findMany: {
            args: Prisma.EncounterConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>[]
          }
          create: {
            args: Prisma.EncounterConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          createMany: {
            args: Prisma.EncounterConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>[]
          }
          delete: {
            args: Prisma.EncounterConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          update: {
            args: Prisma.EncounterConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          deleteMany: {
            args: Prisma.EncounterConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConsentPayload>
          }
          aggregate: {
            args: Prisma.EncounterConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterConsent>
          }
          groupBy: {
            args: Prisma.EncounterConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterConsentCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterConsentCountAggregateOutputType> | number
          }
        }
      }
      ChartTooth: {
        payload: Prisma.$ChartToothPayload<ExtArgs>
        fields: Prisma.ChartToothFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartToothFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartToothFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          findFirst: {
            args: Prisma.ChartToothFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartToothFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          findMany: {
            args: Prisma.ChartToothFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>[]
          }
          create: {
            args: Prisma.ChartToothCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          createMany: {
            args: Prisma.ChartToothCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartToothCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>[]
          }
          delete: {
            args: Prisma.ChartToothDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          update: {
            args: Prisma.ChartToothUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          deleteMany: {
            args: Prisma.ChartToothDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartToothUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChartToothUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartToothPayload>
          }
          aggregate: {
            args: Prisma.ChartToothAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartTooth>
          }
          groupBy: {
            args: Prisma.ChartToothGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartToothGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartToothCountArgs<ExtArgs>
            result: $Utils.Optional<ChartToothCountAggregateOutputType> | number
          }
        }
      }
      ChartNote: {
        payload: Prisma.$ChartNotePayload<ExtArgs>
        fields: Prisma.ChartNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          findFirst: {
            args: Prisma.ChartNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          findMany: {
            args: Prisma.ChartNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>[]
          }
          create: {
            args: Prisma.ChartNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          createMany: {
            args: Prisma.ChartNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>[]
          }
          delete: {
            args: Prisma.ChartNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          update: {
            args: Prisma.ChartNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          deleteMany: {
            args: Prisma.ChartNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChartNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartNotePayload>
          }
          aggregate: {
            args: Prisma.ChartNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartNote>
          }
          groupBy: {
            args: Prisma.ChartNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ChartNoteCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      DiagnosisProblem: {
        payload: Prisma.$DiagnosisProblemPayload<ExtArgs>
        fields: Prisma.DiagnosisProblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisProblemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisProblemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisProblemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisProblemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          findMany: {
            args: Prisma.DiagnosisProblemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>[]
          }
          create: {
            args: Prisma.DiagnosisProblemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          createMany: {
            args: Prisma.DiagnosisProblemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisProblemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisProblemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          update: {
            args: Prisma.DiagnosisProblemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisProblemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisProblemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisProblemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisProblemPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisProblemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosisProblem>
          }
          groupBy: {
            args: Prisma.DiagnosisProblemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisProblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisProblemCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisProblemCountAggregateOutputType> | number
          }
        }
      }
      EncounterDiagnosis: {
        payload: Prisma.$EncounterDiagnosisPayload<ExtArgs>
        fields: Prisma.EncounterDiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterDiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterDiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          findFirst: {
            args: Prisma.EncounterDiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterDiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          findMany: {
            args: Prisma.EncounterDiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>[]
          }
          create: {
            args: Prisma.EncounterDiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          createMany: {
            args: Prisma.EncounterDiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterDiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>[]
          }
          delete: {
            args: Prisma.EncounterDiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          update: {
            args: Prisma.EncounterDiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterDiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterDiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisPayload>
          }
          aggregate: {
            args: Prisma.EncounterDiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterDiagnosis>
          }
          groupBy: {
            args: Prisma.EncounterDiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterDiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterDiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterDiagnosisCountAggregateOutputType> | number
          }
        }
      }
      EncounterDiagnosisSterilizationIndicator: {
        payload: Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>
        fields: Prisma.EncounterDiagnosisSterilizationIndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
          }
          findFirst: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
          }
          findMany: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>[]
          }
          create: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
          }
          createMany: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>[]
          }
          delete: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
          }
          update: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload>
          }
          aggregate: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterDiagnosisSterilizationIndicator>
          }
          groupBy: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterDiagnosisSterilizationIndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterDiagnosisSterilizationIndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterDiagnosisSterilizationIndicatorCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceBranch: {
        payload: Prisma.$ServiceBranchPayload<ExtArgs>
        fields: Prisma.ServiceBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          findFirst: {
            args: Prisma.ServiceBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          findMany: {
            args: Prisma.ServiceBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          create: {
            args: Prisma.ServiceBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          createMany: {
            args: Prisma.ServiceBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>[]
          }
          delete: {
            args: Prisma.ServiceBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          update: {
            args: Prisma.ServiceBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          deleteMany: {
            args: Prisma.ServiceBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceBranchPayload>
          }
          aggregate: {
            args: Prisma.ServiceBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceBranch>
          }
          groupBy: {
            args: Prisma.ServiceBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceBranchCountAggregateOutputType> | number
          }
        }
      }
      EncounterService: {
        payload: Prisma.$EncounterServicePayload<ExtArgs>
        fields: Prisma.EncounterServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          findFirst: {
            args: Prisma.EncounterServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          findMany: {
            args: Prisma.EncounterServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>[]
          }
          create: {
            args: Prisma.EncounterServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          createMany: {
            args: Prisma.EncounterServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>[]
          }
          delete: {
            args: Prisma.EncounterServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          update: {
            args: Prisma.EncounterServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          deleteMany: {
            args: Prisma.EncounterServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterServicePayload>
          }
          aggregate: {
            args: Prisma.EncounterServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterService>
          }
          groupBy: {
            args: Prisma.EncounterServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterServiceCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterServiceCountAggregateOutputType> | number
          }
        }
      }
      Procedure: {
        payload: Prisma.$ProcedurePayload<ExtArgs>
        fields: Prisma.ProcedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findFirst: {
            args: Prisma.ProcedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          findMany: {
            args: Prisma.ProcedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          create: {
            args: Prisma.ProcedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          createMany: {
            args: Prisma.ProcedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>[]
          }
          delete: {
            args: Prisma.ProcedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          update: {
            args: Prisma.ProcedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          deleteMany: {
            args: Prisma.ProcedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedurePayload>
          }
          aggregate: {
            args: Prisma.ProcedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedure>
          }
          groupBy: {
            args: Prisma.ProcedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductStockMovement: {
        payload: Prisma.$ProductStockMovementPayload<ExtArgs>
        fields: Prisma.ProductStockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>
          }
          findFirst: {
            args: Prisma.ProductStockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>
          }
          findMany: {
            args: Prisma.ProductStockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>[]
          }
          create: {
            args: Prisma.ProductStockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>
          }
          createMany: {
            args: Prisma.ProductStockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductStockMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>[]
          }
          delete: {
            args: Prisma.ProductStockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>
          }
          update: {
            args: Prisma.ProductStockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>
          }
          deleteMany: {
            args: Prisma.ProductStockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductStockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockMovementPayload>
          }
          aggregate: {
            args: Prisma.ProductStockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStockMovement>
          }
          groupBy: {
            args: Prisma.ProductStockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStockMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStockMovementCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionItem: {
        payload: Prisma.$PrescriptionItemPayload<ExtArgs>
        fields: Prisma.PrescriptionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findMany: {
            args: Prisma.PrescriptionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          create: {
            args: Prisma.PrescriptionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          createMany: {
            args: Prisma.PrescriptionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          update: {
            args: Prisma.PrescriptionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionItem>
          }
          groupBy: {
            args: Prisma.PrescriptionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionItemCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      EBarimtReceipt: {
        payload: Prisma.$EBarimtReceiptPayload<ExtArgs>
        fields: Prisma.EBarimtReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EBarimtReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EBarimtReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          findFirst: {
            args: Prisma.EBarimtReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EBarimtReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          findMany: {
            args: Prisma.EBarimtReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>[]
          }
          create: {
            args: Prisma.EBarimtReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          createMany: {
            args: Prisma.EBarimtReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EBarimtReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>[]
          }
          delete: {
            args: Prisma.EBarimtReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          update: {
            args: Prisma.EBarimtReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          deleteMany: {
            args: Prisma.EBarimtReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EBarimtReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EBarimtReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBarimtReceiptPayload>
          }
          aggregate: {
            args: Prisma.EBarimtReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEBarimtReceipt>
          }
          groupBy: {
            args: Prisma.EBarimtReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<EBarimtReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.EBarimtReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<EBarimtReceiptCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      AuthorizationCode: {
        payload: Prisma.$AuthorizationCodePayload<ExtArgs>
        fields: Prisma.AuthorizationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorizationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          findFirst: {
            args: Prisma.AuthorizationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorizationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          findMany: {
            args: Prisma.AuthorizationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>[]
          }
          create: {
            args: Prisma.AuthorizationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          createMany: {
            args: Prisma.AuthorizationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorizationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>[]
          }
          delete: {
            args: Prisma.AuthorizationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          update: {
            args: Prisma.AuthorizationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          deleteMany: {
            args: Prisma.AuthorizationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorizationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthorizationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationCodePayload>
          }
          aggregate: {
            args: Prisma.AuthorizationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthorizationCode>
          }
          groupBy: {
            args: Prisma.AuthorizationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorizationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorizationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorizationCodeCountAggregateOutputType> | number
          }
        }
      }
      EmployeeVoucher: {
        payload: Prisma.$EmployeeVoucherPayload<ExtArgs>
        fields: Prisma.EmployeeVoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeVoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeVoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          findFirst: {
            args: Prisma.EmployeeVoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeVoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          findMany: {
            args: Prisma.EmployeeVoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>[]
          }
          create: {
            args: Prisma.EmployeeVoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          createMany: {
            args: Prisma.EmployeeVoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeVoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>[]
          }
          delete: {
            args: Prisma.EmployeeVoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          update: {
            args: Prisma.EmployeeVoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeVoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeVoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeVoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeVoucherPayload>
          }
          aggregate: {
            args: Prisma.EmployeeVoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeVoucher>
          }
          groupBy: {
            args: Prisma.EmployeeVoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeVoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeVoucherCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeVoucherCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      DoctorSchedule: {
        payload: Prisma.$DoctorSchedulePayload<ExtArgs>
        fields: Prisma.DoctorScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          findFirst: {
            args: Prisma.DoctorScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          findMany: {
            args: Prisma.DoctorScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          create: {
            args: Prisma.DoctorScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          createMany: {
            args: Prisma.DoctorScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>[]
          }
          delete: {
            args: Prisma.DoctorScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          update: {
            args: Prisma.DoctorScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          deleteMany: {
            args: Prisma.DoctorScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorSchedulePayload>
          }
          aggregate: {
            args: Prisma.DoctorScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorSchedule>
          }
          groupBy: {
            args: Prisma.DoctorScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorScheduleCountAggregateOutputType> | number
          }
        }
      }
      ReceptionSchedule: {
        payload: Prisma.$ReceptionSchedulePayload<ExtArgs>
        fields: Prisma.ReceptionScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceptionScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceptionScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          findFirst: {
            args: Prisma.ReceptionScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceptionScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          findMany: {
            args: Prisma.ReceptionScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>[]
          }
          create: {
            args: Prisma.ReceptionScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          createMany: {
            args: Prisma.ReceptionScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceptionScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>[]
          }
          delete: {
            args: Prisma.ReceptionScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          update: {
            args: Prisma.ReceptionScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          deleteMany: {
            args: Prisma.ReceptionScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceptionScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceptionScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionSchedulePayload>
          }
          aggregate: {
            args: Prisma.ReceptionScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceptionSchedule>
          }
          groupBy: {
            args: Prisma.ReceptionScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceptionScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceptionScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ReceptionScheduleCountAggregateOutputType> | number
          }
        }
      }
      DoctorBranch: {
        payload: Prisma.$DoctorBranchPayload<ExtArgs>
        fields: Prisma.DoctorBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          findFirst: {
            args: Prisma.DoctorBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          findMany: {
            args: Prisma.DoctorBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>[]
          }
          create: {
            args: Prisma.DoctorBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          createMany: {
            args: Prisma.DoctorBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>[]
          }
          delete: {
            args: Prisma.DoctorBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          update: {
            args: Prisma.DoctorBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          deleteMany: {
            args: Prisma.DoctorBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorBranchPayload>
          }
          aggregate: {
            args: Prisma.DoctorBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorBranch>
          }
          groupBy: {
            args: Prisma.DoctorBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorBranchCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorBranchCountAggregateOutputType> | number
          }
        }
      }
      ReceptionBranch: {
        payload: Prisma.$ReceptionBranchPayload<ExtArgs>
        fields: Prisma.ReceptionBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceptionBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceptionBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          findFirst: {
            args: Prisma.ReceptionBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceptionBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          findMany: {
            args: Prisma.ReceptionBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>[]
          }
          create: {
            args: Prisma.ReceptionBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          createMany: {
            args: Prisma.ReceptionBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceptionBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>[]
          }
          delete: {
            args: Prisma.ReceptionBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          update: {
            args: Prisma.ReceptionBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          deleteMany: {
            args: Prisma.ReceptionBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceptionBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceptionBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceptionBranchPayload>
          }
          aggregate: {
            args: Prisma.ReceptionBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceptionBranch>
          }
          groupBy: {
            args: Prisma.ReceptionBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceptionBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceptionBranchCountArgs<ExtArgs>
            result: $Utils.Optional<ReceptionBranchCountAggregateOutputType> | number
          }
        }
      }
      NurseBranch: {
        payload: Prisma.$NurseBranchPayload<ExtArgs>
        fields: Prisma.NurseBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NurseBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NurseBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          findFirst: {
            args: Prisma.NurseBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NurseBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          findMany: {
            args: Prisma.NurseBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>[]
          }
          create: {
            args: Prisma.NurseBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          createMany: {
            args: Prisma.NurseBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NurseBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>[]
          }
          delete: {
            args: Prisma.NurseBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          update: {
            args: Prisma.NurseBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          deleteMany: {
            args: Prisma.NurseBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NurseBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NurseBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseBranchPayload>
          }
          aggregate: {
            args: Prisma.NurseBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurseBranch>
          }
          groupBy: {
            args: Prisma.NurseBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.NurseBranchCountArgs<ExtArgs>
            result: $Utils.Optional<NurseBranchCountAggregateOutputType> | number
          }
        }
      }
      NurseSchedule: {
        payload: Prisma.$NurseSchedulePayload<ExtArgs>
        fields: Prisma.NurseScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NurseScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NurseScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          findFirst: {
            args: Prisma.NurseScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NurseScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          findMany: {
            args: Prisma.NurseScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>[]
          }
          create: {
            args: Prisma.NurseScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          createMany: {
            args: Prisma.NurseScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NurseScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>[]
          }
          delete: {
            args: Prisma.NurseScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          update: {
            args: Prisma.NurseScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          deleteMany: {
            args: Prisma.NurseScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NurseScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NurseScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NurseSchedulePayload>
          }
          aggregate: {
            args: Prisma.NurseScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNurseSchedule>
          }
          groupBy: {
            args: Prisma.NurseScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NurseScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NurseScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<NurseScheduleCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethodConfig: {
        payload: Prisma.$PaymentMethodConfigPayload<ExtArgs>
        fields: Prisma.PaymentMethodConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>
          }
          update: {
            args: Prisma.PaymentMethodConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethodConfig>
          }
          groupBy: {
            args: Prisma.PaymentMethodConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodConfigCountAggregateOutputType> | number
          }
        }
      }
      PaymentProviderConfig: {
        payload: Prisma.$PaymentProviderConfigPayload<ExtArgs>
        fields: Prisma.PaymentProviderConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentProviderConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentProviderConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentProviderConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentProviderConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentProviderConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentProviderConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentProviderConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentProviderConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>[]
          }
          delete: {
            args: Prisma.PaymentProviderConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          update: {
            args: Prisma.PaymentProviderConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentProviderConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentProviderConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentProviderConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentProviderConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentProviderConfig>
          }
          groupBy: {
            args: Prisma.PaymentProviderConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentProviderConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentProviderConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentProviderConfigCountAggregateOutputType> | number
          }
        }
      }
      QPayIntent: {
        payload: Prisma.$QPayIntentPayload<ExtArgs>
        fields: Prisma.QPayIntentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QPayIntentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QPayIntentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>
          }
          findFirst: {
            args: Prisma.QPayIntentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QPayIntentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>
          }
          findMany: {
            args: Prisma.QPayIntentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>[]
          }
          create: {
            args: Prisma.QPayIntentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>
          }
          createMany: {
            args: Prisma.QPayIntentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QPayIntentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>[]
          }
          delete: {
            args: Prisma.QPayIntentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>
          }
          update: {
            args: Prisma.QPayIntentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>
          }
          deleteMany: {
            args: Prisma.QPayIntentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QPayIntentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QPayIntentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QPayIntentPayload>
          }
          aggregate: {
            args: Prisma.QPayIntentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQPayIntent>
          }
          groupBy: {
            args: Prisma.QPayIntentGroupByArgs<ExtArgs>
            result: $Utils.Optional<QPayIntentGroupByOutputType>[]
          }
          count: {
            args: Prisma.QPayIntentCountArgs<ExtArgs>
            result: $Utils.Optional<QPayIntentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    users: number
    patients: number
    doctorSchedules: number
    serviceBranches: number
    doctorBranches: number
    appointments: number
    bookings: number
    receptionSchedules: number
    receptionBranches: number
    nurseSchedules: number
    nurseBranches: number
    products: number
    productCategories: number
    productStockMovements: number
    invoices: number
    ledgerEntries: number
    employeeVouchers: number
    sterilizationIndicators: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    patients?: boolean | BranchCountOutputTypeCountPatientsArgs
    doctorSchedules?: boolean | BranchCountOutputTypeCountDoctorSchedulesArgs
    serviceBranches?: boolean | BranchCountOutputTypeCountServiceBranchesArgs
    doctorBranches?: boolean | BranchCountOutputTypeCountDoctorBranchesArgs
    appointments?: boolean | BranchCountOutputTypeCountAppointmentsArgs
    bookings?: boolean | BranchCountOutputTypeCountBookingsArgs
    receptionSchedules?: boolean | BranchCountOutputTypeCountReceptionSchedulesArgs
    receptionBranches?: boolean | BranchCountOutputTypeCountReceptionBranchesArgs
    nurseSchedules?: boolean | BranchCountOutputTypeCountNurseSchedulesArgs
    nurseBranches?: boolean | BranchCountOutputTypeCountNurseBranchesArgs
    products?: boolean | BranchCountOutputTypeCountProductsArgs
    productCategories?: boolean | BranchCountOutputTypeCountProductCategoriesArgs
    productStockMovements?: boolean | BranchCountOutputTypeCountProductStockMovementsArgs
    invoices?: boolean | BranchCountOutputTypeCountInvoicesArgs
    ledgerEntries?: boolean | BranchCountOutputTypeCountLedgerEntriesArgs
    employeeVouchers?: boolean | BranchCountOutputTypeCountEmployeeVouchersArgs
    sterilizationIndicators?: boolean | BranchCountOutputTypeCountSterilizationIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDoctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServiceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDoctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountReceptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionScheduleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountReceptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountNurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseScheduleWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountNurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountProductCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountProductStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockMovementWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSterilizationIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationIndicatorWhereInput
  }


  /**
   * Count Type EmployeeBenefitCountOutputType
   */

  export type EmployeeBenefitCountOutputType = {
    usages: number
  }

  export type EmployeeBenefitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | EmployeeBenefitCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeBenefitCountOutputType without action
   */
  export type EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitCountOutputType
     */
    select?: EmployeeBenefitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeBenefitCountOutputType without action
   */
  export type EmployeeBenefitCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
  }


  /**
   * Count Type SterilizationCategoryCountOutputType
   */

  export type SterilizationCategoryCountOutputType = {
    items: number
  }

  export type SterilizationCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SterilizationCategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SterilizationCategoryCountOutputType without action
   */
  export type SterilizationCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategoryCountOutputType
     */
    select?: SterilizationCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SterilizationCategoryCountOutputType without action
   */
  export type SterilizationCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationItemWhereInput
  }


  /**
   * Count Type SterilizationItemCountOutputType
   */

  export type SterilizationItemCountOutputType = {
    indicatorItems: number
  }

  export type SterilizationItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicatorItems?: boolean | SterilizationItemCountOutputTypeCountIndicatorItemsArgs
  }

  // Custom InputTypes
  /**
   * SterilizationItemCountOutputType without action
   */
  export type SterilizationItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItemCountOutputType
     */
    select?: SterilizationItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SterilizationItemCountOutputType without action
   */
  export type SterilizationItemCountOutputTypeCountIndicatorItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationIndicatorItemWhereInput
  }


  /**
   * Count Type SterilizationIndicatorCountOutputType
   */

  export type SterilizationIndicatorCountOutputType = {
    items: number
    uses: number
    encounterDiagnosisLinks: number
  }

  export type SterilizationIndicatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SterilizationIndicatorCountOutputTypeCountItemsArgs
    uses?: boolean | SterilizationIndicatorCountOutputTypeCountUsesArgs
    encounterDiagnosisLinks?: boolean | SterilizationIndicatorCountOutputTypeCountEncounterDiagnosisLinksArgs
  }

  // Custom InputTypes
  /**
   * SterilizationIndicatorCountOutputType without action
   */
  export type SterilizationIndicatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorCountOutputType
     */
    select?: SterilizationIndicatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SterilizationIndicatorCountOutputType without action
   */
  export type SterilizationIndicatorCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationIndicatorItemWhereInput
  }

  /**
   * SterilizationIndicatorCountOutputType without action
   */
  export type SterilizationIndicatorCountOutputTypeCountUsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSterilizationPackageUseWhereInput
  }

  /**
   * SterilizationIndicatorCountOutputType without action
   */
  export type SterilizationIndicatorCountOutputTypeCountEncounterDiagnosisLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    encounters: number
    nurseEncounters: number
    doctorSchedules: number
    doctorBranches: number
    receptionSchedules: number
    receptionBranches: number
    nurseSchedules: number
    nurseBranches: number
    appointments: number
    bookings: number
    employeeBenefits: number
    createdLedgerEntries: number
    approvedLedgerEntries: number
    employeeVouchers: number
    createdEmployeeVouchers: number
    authorizationCodes: number
    sterilizationIndicators: number
    openedSterilizationPackages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | UserCountOutputTypeCountEncountersArgs
    nurseEncounters?: boolean | UserCountOutputTypeCountNurseEncountersArgs
    doctorSchedules?: boolean | UserCountOutputTypeCountDoctorSchedulesArgs
    doctorBranches?: boolean | UserCountOutputTypeCountDoctorBranchesArgs
    receptionSchedules?: boolean | UserCountOutputTypeCountReceptionSchedulesArgs
    receptionBranches?: boolean | UserCountOutputTypeCountReceptionBranchesArgs
    nurseSchedules?: boolean | UserCountOutputTypeCountNurseSchedulesArgs
    nurseBranches?: boolean | UserCountOutputTypeCountNurseBranchesArgs
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    employeeBenefits?: boolean | UserCountOutputTypeCountEmployeeBenefitsArgs
    createdLedgerEntries?: boolean | UserCountOutputTypeCountCreatedLedgerEntriesArgs
    approvedLedgerEntries?: boolean | UserCountOutputTypeCountApprovedLedgerEntriesArgs
    employeeVouchers?: boolean | UserCountOutputTypeCountEmployeeVouchersArgs
    createdEmployeeVouchers?: boolean | UserCountOutputTypeCountCreatedEmployeeVouchersArgs
    authorizationCodes?: boolean | UserCountOutputTypeCountAuthorizationCodesArgs
    sterilizationIndicators?: boolean | UserCountOutputTypeCountSterilizationIndicatorsArgs
    openedSterilizationPackages?: boolean | UserCountOutputTypeCountOpenedSterilizationPackagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNurseEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorBranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionBranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseBranchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthorizationCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorizationCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSterilizationIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationIndicatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpenedSterilizationPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSterilizationPackageUseWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    bookings: number
    invoices: number
    ledgerEntries: number
    employeeBenefitUsages: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    bookings?: boolean | PatientCountOutputTypeCountBookingsArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    ledgerEntries?: boolean | PatientCountOutputTypeCountLedgerEntriesArgs
    employeeBenefitUsages?: boolean | PatientCountOutputTypeCountEmployeeBenefitUsagesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEmployeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
  }


  /**
   * Count Type PatientBookCountOutputType
   */

  export type PatientBookCountOutputType = {
    encounters: number
  }

  export type PatientBookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | PatientBookCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * PatientBookCountOutputType without action
   */
  export type PatientBookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBookCountOutputType
     */
    select?: PatientBookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientBookCountOutputType without action
   */
  export type PatientBookCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    encounters: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | AppointmentCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    chartTeeth: number
    media: number
    encounterServices: number
    diagnoses: number
    consents: number
    sterilizationPackageUses: number
    employeeBenefitUsages: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartTeeth?: boolean | EncounterCountOutputTypeCountChartTeethArgs
    media?: boolean | EncounterCountOutputTypeCountMediaArgs
    encounterServices?: boolean | EncounterCountOutputTypeCountEncounterServicesArgs
    diagnoses?: boolean | EncounterCountOutputTypeCountDiagnosesArgs
    consents?: boolean | EncounterCountOutputTypeCountConsentsArgs
    sterilizationPackageUses?: boolean | EncounterCountOutputTypeCountSterilizationPackageUsesArgs
    employeeBenefitUsages?: boolean | EncounterCountOutputTypeCountEmployeeBenefitUsagesArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountChartTeethArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartToothWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountEncounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterServiceWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountDiagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConsentWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountSterilizationPackageUsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSterilizationPackageUseWhereInput
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountEmployeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
  }


  /**
   * Count Type ChartToothCountOutputType
   */

  export type ChartToothCountOutputType = {
    chartNotes: number
  }

  export type ChartToothCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartNotes?: boolean | ChartToothCountOutputTypeCountChartNotesArgs
  }

  // Custom InputTypes
  /**
   * ChartToothCountOutputType without action
   */
  export type ChartToothCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartToothCountOutputType
     */
    select?: ChartToothCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChartToothCountOutputType without action
   */
  export type ChartToothCountOutputTypeCountChartNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartNoteWhereInput
  }


  /**
   * Count Type DiagnosisCountOutputType
   */

  export type DiagnosisCountOutputType = {
    problems: number
    encounters: number
  }

  export type DiagnosisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems?: boolean | DiagnosisCountOutputTypeCountProblemsArgs
    encounters?: boolean | DiagnosisCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisCountOutputType
     */
    select?: DiagnosisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeCountProblemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisProblemWhereInput
  }

  /**
   * DiagnosisCountOutputType without action
   */
  export type DiagnosisCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisWhereInput
  }


  /**
   * Count Type EncounterDiagnosisCountOutputType
   */

  export type EncounterDiagnosisCountOutputType = {
    sterilizationIndicators: number
  }

  export type EncounterDiagnosisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sterilizationIndicators?: boolean | EncounterDiagnosisCountOutputTypeCountSterilizationIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * EncounterDiagnosisCountOutputType without action
   */
  export type EncounterDiagnosisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisCountOutputType
     */
    select?: EncounterDiagnosisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterDiagnosisCountOutputType without action
   */
  export type EncounterDiagnosisCountOutputTypeCountSterilizationIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    encounterServices: number
    serviceBranches: number
    invoiceItems: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterServices?: boolean | ServiceCountOutputTypeCountEncounterServicesArgs
    serviceBranches?: boolean | ServiceCountOutputTypeCountServiceBranchesArgs
    invoiceItems?: boolean | ServiceCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountEncounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type ProcedureCountOutputType
   */

  export type ProcedureCountOutputType = {
    invoiceItems: number
  }

  export type ProcedureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | ProcedureCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureCountOutputType
     */
    select?: ProcedureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcedureCountOutputType without action
   */
  export type ProcedureCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    invoiceItems: number
    stockMovements: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | ProductCountOutputTypeCountInvoiceItemsArgs
    stockMovements?: boolean | ProductCountOutputTypeCountStockMovementsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockMovementWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    items: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PrescriptionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    ledgerEntries: number
    payments: number
    employeeBenefitUsages: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    ledgerEntries?: boolean | InvoiceCountOutputTypeCountLedgerEntriesArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    employeeBenefitUsages?: boolean | InvoiceCountOutputTypeCountEmployeeBenefitUsagesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountEmployeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
  }


  /**
   * Count Type AuthorizationCodeCountOutputType
   */

  export type AuthorizationCodeCountOutputType = {
    ledgerEntries: number
  }

  export type AuthorizationCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerEntries?: boolean | AuthorizationCodeCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * AuthorizationCodeCountOutputType without action
   */
  export type AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCodeCountOutputType
     */
    select?: AuthorizationCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorizationCodeCountOutputType without action
   */
  export type AuthorizationCodeCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type EmployeeVoucherCountOutputType
   */

  export type EmployeeVoucherCountOutputType = {
    ledgerEntries: number
  }

  export type EmployeeVoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledgerEntries?: boolean | EmployeeVoucherCountOutputTypeCountLedgerEntriesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeVoucherCountOutputType without action
   */
  export type EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucherCountOutputType
     */
    select?: EmployeeVoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeVoucherCountOutputType without action
   */
  export type EmployeeVoucherCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }


  /**
   * Count Type PaymentMethodConfigCountOutputType
   */

  export type PaymentMethodConfigCountOutputType = {
    providers: number
  }

  export type PaymentMethodConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | PaymentMethodConfigCountOutputTypeCountProvidersArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodConfigCountOutputType without action
   */
  export type PaymentMethodConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfigCountOutputType
     */
    select?: PaymentMethodConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodConfigCountOutputType without action
   */
  export type PaymentMethodConfigCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentProviderConfigWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    createdAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    createdAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    createdAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    name: string
    address: string | null
    createdAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    doctorSchedules?: boolean | Branch$doctorSchedulesArgs<ExtArgs>
    serviceBranches?: boolean | Branch$serviceBranchesArgs<ExtArgs>
    doctorBranches?: boolean | Branch$doctorBranchesArgs<ExtArgs>
    appointments?: boolean | Branch$appointmentsArgs<ExtArgs>
    bookings?: boolean | Branch$bookingsArgs<ExtArgs>
    receptionSchedules?: boolean | Branch$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | Branch$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | Branch$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | Branch$nurseBranchesArgs<ExtArgs>
    products?: boolean | Branch$productsArgs<ExtArgs>
    productCategories?: boolean | Branch$productCategoriesArgs<ExtArgs>
    productStockMovements?: boolean | Branch$productStockMovementsArgs<ExtArgs>
    invoices?: boolean | Branch$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Branch$ledgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | Branch$employeeVouchersArgs<ExtArgs>
    sterilizationIndicators?: boolean | Branch$sterilizationIndicatorsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    createdAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    doctorSchedules?: boolean | Branch$doctorSchedulesArgs<ExtArgs>
    serviceBranches?: boolean | Branch$serviceBranchesArgs<ExtArgs>
    doctorBranches?: boolean | Branch$doctorBranchesArgs<ExtArgs>
    appointments?: boolean | Branch$appointmentsArgs<ExtArgs>
    bookings?: boolean | Branch$bookingsArgs<ExtArgs>
    receptionSchedules?: boolean | Branch$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | Branch$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | Branch$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | Branch$nurseBranchesArgs<ExtArgs>
    products?: boolean | Branch$productsArgs<ExtArgs>
    productCategories?: boolean | Branch$productCategoriesArgs<ExtArgs>
    productStockMovements?: boolean | Branch$productStockMovementsArgs<ExtArgs>
    invoices?: boolean | Branch$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Branch$ledgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | Branch$employeeVouchersArgs<ExtArgs>
    sterilizationIndicators?: boolean | Branch$sterilizationIndicatorsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      doctorSchedules: Prisma.$DoctorSchedulePayload<ExtArgs>[]
      serviceBranches: Prisma.$ServiceBranchPayload<ExtArgs>[]
      doctorBranches: Prisma.$DoctorBranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      receptionSchedules: Prisma.$ReceptionSchedulePayload<ExtArgs>[]
      receptionBranches: Prisma.$ReceptionBranchPayload<ExtArgs>[]
      nurseSchedules: Prisma.$NurseSchedulePayload<ExtArgs>[]
      nurseBranches: Prisma.$NurseBranchPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      productCategories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      productStockMovements: Prisma.$ProductStockMovementPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      employeeVouchers: Prisma.$EmployeeVoucherPayload<ExtArgs>[]
      sterilizationIndicators: Prisma.$SterilizationIndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      createdAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    patients<T extends Branch$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany"> | Null>
    doctorSchedules<T extends Branch$doctorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$doctorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    serviceBranches<T extends Branch$serviceBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$serviceBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany"> | Null>
    doctorBranches<T extends Branch$doctorBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$doctorBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Branch$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Branch$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    receptionSchedules<T extends Branch$receptionSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$receptionSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    receptionBranches<T extends Branch$receptionBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$receptionBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findMany"> | Null>
    nurseSchedules<T extends Branch$nurseSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$nurseSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    nurseBranches<T extends Branch$nurseBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$nurseBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Branch$productsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    productCategories<T extends Branch$productCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$productCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    productStockMovements<T extends Branch$productStockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$productStockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Branch$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Branch$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    employeeVouchers<T extends Branch$employeeVouchersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$employeeVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    sterilizationIndicators<T extends Branch$sterilizationIndicatorsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$sterilizationIndicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.patients
   */
  export type Branch$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Branch.doctorSchedules
   */
  export type Branch$doctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    cursor?: DoctorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * Branch.serviceBranches
   */
  export type Branch$serviceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    cursor?: ServiceBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * Branch.doctorBranches
   */
  export type Branch$doctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    where?: DoctorBranchWhereInput
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    cursor?: DoctorBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * Branch.appointments
   */
  export type Branch$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Branch.bookings
   */
  export type Branch$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Branch.receptionSchedules
   */
  export type Branch$receptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    where?: ReceptionScheduleWhereInput
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    cursor?: ReceptionScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * Branch.receptionBranches
   */
  export type Branch$receptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    where?: ReceptionBranchWhereInput
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    cursor?: ReceptionBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * Branch.nurseSchedules
   */
  export type Branch$nurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    where?: NurseScheduleWhereInput
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    cursor?: NurseScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * Branch.nurseBranches
   */
  export type Branch$nurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    where?: NurseBranchWhereInput
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    cursor?: NurseBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * Branch.products
   */
  export type Branch$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Branch.productCategories
   */
  export type Branch$productCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Branch.productStockMovements
   */
  export type Branch$productStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    where?: ProductStockMovementWhereInput
    orderBy?: ProductStockMovementOrderByWithRelationInput | ProductStockMovementOrderByWithRelationInput[]
    cursor?: ProductStockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockMovementScalarFieldEnum | ProductStockMovementScalarFieldEnum[]
  }

  /**
   * Branch.invoices
   */
  export type Branch$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Branch.ledgerEntries
   */
  export type Branch$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Branch.employeeVouchers
   */
  export type Branch$employeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    cursor?: EmployeeVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * Branch.sterilizationIndicators
   */
  export type Branch$sterilizationIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    where?: SterilizationIndicatorWhereInput
    orderBy?: SterilizationIndicatorOrderByWithRelationInput | SterilizationIndicatorOrderByWithRelationInput[]
    cursor?: SterilizationIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SterilizationIndicatorScalarFieldEnum | SterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeBenefit
   */

  export type AggregateEmployeeBenefit = {
    _count: EmployeeBenefitCountAggregateOutputType | null
    _avg: EmployeeBenefitAvgAggregateOutputType | null
    _sum: EmployeeBenefitSumAggregateOutputType | null
    _min: EmployeeBenefitMinAggregateOutputType | null
    _max: EmployeeBenefitMaxAggregateOutputType | null
  }

  export type EmployeeBenefitAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
  }

  export type EmployeeBenefitSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
  }

  export type EmployeeBenefitMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    code: string | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
    fromDate: Date | null
    toDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeBenefitMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    code: string | null
    branchId: number | null
    initialAmount: number | null
    remainingAmount: number | null
    fromDate: Date | null
    toDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeBenefitCountAggregateOutputType = {
    id: number
    employeeId: number
    code: number
    branchId: number
    initialAmount: number
    remainingAmount: number
    fromDate: number
    toDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeBenefitAvgAggregateInputType = {
    id?: true
    employeeId?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
  }

  export type EmployeeBenefitSumAggregateInputType = {
    id?: true
    employeeId?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
  }

  export type EmployeeBenefitMinAggregateInputType = {
    id?: true
    employeeId?: true
    code?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
    fromDate?: true
    toDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeBenefitMaxAggregateInputType = {
    id?: true
    employeeId?: true
    code?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
    fromDate?: true
    toDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeBenefitCountAggregateInputType = {
    id?: true
    employeeId?: true
    code?: true
    branchId?: true
    initialAmount?: true
    remainingAmount?: true
    fromDate?: true
    toDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeBenefitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefit to aggregate.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeBenefits
    **/
    _count?: true | EmployeeBenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeBenefitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeBenefitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeBenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeBenefitMaxAggregateInputType
  }

  export type GetEmployeeBenefitAggregateType<T extends EmployeeBenefitAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeBenefit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeBenefit[P]>
      : GetScalarType<T[P], AggregateEmployeeBenefit[P]>
  }




  export type EmployeeBenefitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitWhereInput
    orderBy?: EmployeeBenefitOrderByWithAggregationInput | EmployeeBenefitOrderByWithAggregationInput[]
    by: EmployeeBenefitScalarFieldEnum[] | EmployeeBenefitScalarFieldEnum
    having?: EmployeeBenefitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeBenefitCountAggregateInputType | true
    _avg?: EmployeeBenefitAvgAggregateInputType
    _sum?: EmployeeBenefitSumAggregateInputType
    _min?: EmployeeBenefitMinAggregateInputType
    _max?: EmployeeBenefitMaxAggregateInputType
  }

  export type EmployeeBenefitGroupByOutputType = {
    id: number
    employeeId: number
    code: string
    branchId: number | null
    initialAmount: number
    remainingAmount: number
    fromDate: Date | null
    toDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeeBenefitCountAggregateOutputType | null
    _avg: EmployeeBenefitAvgAggregateOutputType | null
    _sum: EmployeeBenefitSumAggregateOutputType | null
    _min: EmployeeBenefitMinAggregateOutputType | null
    _max: EmployeeBenefitMaxAggregateOutputType | null
  }

  type GetEmployeeBenefitGroupByPayload<T extends EmployeeBenefitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeBenefitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeBenefitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeBenefitGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeBenefitGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeBenefitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    code?: boolean
    branchId?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    fromDate?: boolean
    toDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    usages?: boolean | EmployeeBenefit$usagesArgs<ExtArgs>
    _count?: boolean | EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefit"]>

  export type EmployeeBenefitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    code?: boolean
    branchId?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    fromDate?: boolean
    toDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefit"]>

  export type EmployeeBenefitSelectScalar = {
    id?: boolean
    employeeId?: boolean
    code?: boolean
    branchId?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    fromDate?: boolean
    toDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeBenefitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    usages?: boolean | EmployeeBenefit$usagesArgs<ExtArgs>
    _count?: boolean | EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeBenefitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeBenefitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeBenefit"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      usages: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      code: string
      branchId: number | null
      initialAmount: number
      remainingAmount: number
      fromDate: Date | null
      toDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeBenefit"]>
    composites: {}
  }

  type EmployeeBenefitGetPayload<S extends boolean | null | undefined | EmployeeBenefitDefaultArgs> = $Result.GetResult<Prisma.$EmployeeBenefitPayload, S>

  type EmployeeBenefitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeBenefitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeBenefitCountAggregateInputType | true
    }

  export interface EmployeeBenefitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeBenefit'], meta: { name: 'EmployeeBenefit' } }
    /**
     * Find zero or one EmployeeBenefit that matches the filter.
     * @param {EmployeeBenefitFindUniqueArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeBenefitFindUniqueArgs>(args: SelectSubset<T, EmployeeBenefitFindUniqueArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeBenefit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeBenefitFindUniqueOrThrowArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeBenefitFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeBenefitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeBenefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitFindFirstArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeBenefitFindFirstArgs>(args?: SelectSubset<T, EmployeeBenefitFindFirstArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeBenefit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitFindFirstOrThrowArgs} args - Arguments to find a EmployeeBenefit
     * @example
     * // Get one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeBenefitFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeBenefitFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeBenefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeBenefits
     * const employeeBenefits = await prisma.employeeBenefit.findMany()
     * 
     * // Get first 10 EmployeeBenefits
     * const employeeBenefits = await prisma.employeeBenefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeBenefitWithIdOnly = await prisma.employeeBenefit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeBenefitFindManyArgs>(args?: SelectSubset<T, EmployeeBenefitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeBenefit.
     * @param {EmployeeBenefitCreateArgs} args - Arguments to create a EmployeeBenefit.
     * @example
     * // Create one EmployeeBenefit
     * const EmployeeBenefit = await prisma.employeeBenefit.create({
     *   data: {
     *     // ... data to create a EmployeeBenefit
     *   }
     * })
     * 
     */
    create<T extends EmployeeBenefitCreateArgs>(args: SelectSubset<T, EmployeeBenefitCreateArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeBenefits.
     * @param {EmployeeBenefitCreateManyArgs} args - Arguments to create many EmployeeBenefits.
     * @example
     * // Create many EmployeeBenefits
     * const employeeBenefit = await prisma.employeeBenefit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeBenefitCreateManyArgs>(args?: SelectSubset<T, EmployeeBenefitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeBenefits and returns the data saved in the database.
     * @param {EmployeeBenefitCreateManyAndReturnArgs} args - Arguments to create many EmployeeBenefits.
     * @example
     * // Create many EmployeeBenefits
     * const employeeBenefit = await prisma.employeeBenefit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeBenefits and only return the `id`
     * const employeeBenefitWithIdOnly = await prisma.employeeBenefit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeBenefitCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeBenefitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeBenefit.
     * @param {EmployeeBenefitDeleteArgs} args - Arguments to delete one EmployeeBenefit.
     * @example
     * // Delete one EmployeeBenefit
     * const EmployeeBenefit = await prisma.employeeBenefit.delete({
     *   where: {
     *     // ... filter to delete one EmployeeBenefit
     *   }
     * })
     * 
     */
    delete<T extends EmployeeBenefitDeleteArgs>(args: SelectSubset<T, EmployeeBenefitDeleteArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeBenefit.
     * @param {EmployeeBenefitUpdateArgs} args - Arguments to update one EmployeeBenefit.
     * @example
     * // Update one EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeBenefitUpdateArgs>(args: SelectSubset<T, EmployeeBenefitUpdateArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeBenefits.
     * @param {EmployeeBenefitDeleteManyArgs} args - Arguments to filter EmployeeBenefits to delete.
     * @example
     * // Delete a few EmployeeBenefits
     * const { count } = await prisma.employeeBenefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeBenefitDeleteManyArgs>(args?: SelectSubset<T, EmployeeBenefitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeBenefits
     * const employeeBenefit = await prisma.employeeBenefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeBenefitUpdateManyArgs>(args: SelectSubset<T, EmployeeBenefitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeBenefit.
     * @param {EmployeeBenefitUpsertArgs} args - Arguments to update or create a EmployeeBenefit.
     * @example
     * // Update or create a EmployeeBenefit
     * const employeeBenefit = await prisma.employeeBenefit.upsert({
     *   create: {
     *     // ... data to create a EmployeeBenefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeBenefit we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeBenefitUpsertArgs>(args: SelectSubset<T, EmployeeBenefitUpsertArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitCountArgs} args - Arguments to filter EmployeeBenefits to count.
     * @example
     * // Count the number of EmployeeBenefits
     * const count = await prisma.employeeBenefit.count({
     *   where: {
     *     // ... the filter for the EmployeeBenefits we want to count
     *   }
     * })
    **/
    count<T extends EmployeeBenefitCountArgs>(
      args?: Subset<T, EmployeeBenefitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeBenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeBenefitAggregateArgs>(args: Subset<T, EmployeeBenefitAggregateArgs>): Prisma.PrismaPromise<GetEmployeeBenefitAggregateType<T>>

    /**
     * Group by EmployeeBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeBenefitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeBenefitGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeBenefitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeBenefitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeBenefitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeBenefit model
   */
  readonly fields: EmployeeBenefitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeBenefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeBenefitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usages<T extends EmployeeBenefit$usagesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeBenefit$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeBenefit model
   */ 
  interface EmployeeBenefitFieldRefs {
    readonly id: FieldRef<"EmployeeBenefit", 'Int'>
    readonly employeeId: FieldRef<"EmployeeBenefit", 'Int'>
    readonly code: FieldRef<"EmployeeBenefit", 'String'>
    readonly branchId: FieldRef<"EmployeeBenefit", 'Int'>
    readonly initialAmount: FieldRef<"EmployeeBenefit", 'Int'>
    readonly remainingAmount: FieldRef<"EmployeeBenefit", 'Int'>
    readonly fromDate: FieldRef<"EmployeeBenefit", 'DateTime'>
    readonly toDate: FieldRef<"EmployeeBenefit", 'DateTime'>
    readonly isActive: FieldRef<"EmployeeBenefit", 'Boolean'>
    readonly createdAt: FieldRef<"EmployeeBenefit", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeBenefit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeBenefit findUnique
   */
  export type EmployeeBenefitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit findUniqueOrThrow
   */
  export type EmployeeBenefitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit findFirst
   */
  export type EmployeeBenefitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefits.
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefits.
     */
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit findFirstOrThrow
   */
  export type EmployeeBenefitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefit to fetch.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefits.
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefits.
     */
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit findMany
   */
  export type EmployeeBenefitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefits to fetch.
     */
    where?: EmployeeBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefits to fetch.
     */
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeBenefits.
     */
    cursor?: EmployeeBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefits.
     */
    skip?: number
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit create
   */
  export type EmployeeBenefitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeBenefit.
     */
    data: XOR<EmployeeBenefitCreateInput, EmployeeBenefitUncheckedCreateInput>
  }

  /**
   * EmployeeBenefit createMany
   */
  export type EmployeeBenefitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeBenefits.
     */
    data: EmployeeBenefitCreateManyInput | EmployeeBenefitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeBenefit createManyAndReturn
   */
  export type EmployeeBenefitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeBenefits.
     */
    data: EmployeeBenefitCreateManyInput | EmployeeBenefitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeBenefit update
   */
  export type EmployeeBenefitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeBenefit.
     */
    data: XOR<EmployeeBenefitUpdateInput, EmployeeBenefitUncheckedUpdateInput>
    /**
     * Choose, which EmployeeBenefit to update.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit updateMany
   */
  export type EmployeeBenefitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeBenefits.
     */
    data: XOR<EmployeeBenefitUpdateManyMutationInput, EmployeeBenefitUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeBenefits to update
     */
    where?: EmployeeBenefitWhereInput
  }

  /**
   * EmployeeBenefit upsert
   */
  export type EmployeeBenefitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeBenefit to update in case it exists.
     */
    where: EmployeeBenefitWhereUniqueInput
    /**
     * In case the EmployeeBenefit found by the `where` argument doesn't exist, create a new EmployeeBenefit with this data.
     */
    create: XOR<EmployeeBenefitCreateInput, EmployeeBenefitUncheckedCreateInput>
    /**
     * In case the EmployeeBenefit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeBenefitUpdateInput, EmployeeBenefitUncheckedUpdateInput>
  }

  /**
   * EmployeeBenefit delete
   */
  export type EmployeeBenefitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    /**
     * Filter which EmployeeBenefit to delete.
     */
    where: EmployeeBenefitWhereUniqueInput
  }

  /**
   * EmployeeBenefit deleteMany
   */
  export type EmployeeBenefitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefits to delete
     */
    where?: EmployeeBenefitWhereInput
  }

  /**
   * EmployeeBenefit.usages
   */
  export type EmployeeBenefit$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefit without action
   */
  export type EmployeeBenefitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeBenefitUsage
   */

  export type AggregateEmployeeBenefitUsage = {
    _count: EmployeeBenefitUsageCountAggregateOutputType | null
    _avg: EmployeeBenefitUsageAvgAggregateOutputType | null
    _sum: EmployeeBenefitUsageSumAggregateOutputType | null
    _min: EmployeeBenefitUsageMinAggregateOutputType | null
    _max: EmployeeBenefitUsageMaxAggregateOutputType | null
  }

  export type EmployeeBenefitUsageAvgAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
  }

  export type EmployeeBenefitUsageSumAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
  }

  export type EmployeeBenefitUsageMinAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
    patientBookNumber: string | null
    createdAt: Date | null
  }

  export type EmployeeBenefitUsageMaxAggregateOutputType = {
    id: number | null
    employeeBenefitId: number | null
    invoiceId: number | null
    encounterId: number | null
    amountUsed: number | null
    patientId: number | null
    patientBookNumber: string | null
    createdAt: Date | null
  }

  export type EmployeeBenefitUsageCountAggregateOutputType = {
    id: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber: number
    createdAt: number
    _all: number
  }


  export type EmployeeBenefitUsageAvgAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
  }

  export type EmployeeBenefitUsageSumAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
  }

  export type EmployeeBenefitUsageMinAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
    patientBookNumber?: true
    createdAt?: true
  }

  export type EmployeeBenefitUsageMaxAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
    patientBookNumber?: true
    createdAt?: true
  }

  export type EmployeeBenefitUsageCountAggregateInputType = {
    id?: true
    employeeBenefitId?: true
    invoiceId?: true
    encounterId?: true
    amountUsed?: true
    patientId?: true
    patientBookNumber?: true
    createdAt?: true
    _all?: true
  }

  export type EmployeeBenefitUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefitUsage to aggregate.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeBenefitUsages
    **/
    _count?: true | EmployeeBenefitUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeBenefitUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeBenefitUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeBenefitUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeBenefitUsageMaxAggregateInputType
  }

  export type GetEmployeeBenefitUsageAggregateType<T extends EmployeeBenefitUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeBenefitUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeBenefitUsage[P]>
      : GetScalarType<T[P], AggregateEmployeeBenefitUsage[P]>
  }




  export type EmployeeBenefitUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithAggregationInput | EmployeeBenefitUsageOrderByWithAggregationInput[]
    by: EmployeeBenefitUsageScalarFieldEnum[] | EmployeeBenefitUsageScalarFieldEnum
    having?: EmployeeBenefitUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeBenefitUsageCountAggregateInputType | true
    _avg?: EmployeeBenefitUsageAvgAggregateInputType
    _sum?: EmployeeBenefitUsageSumAggregateInputType
    _min?: EmployeeBenefitUsageMinAggregateInputType
    _max?: EmployeeBenefitUsageMaxAggregateInputType
  }

  export type EmployeeBenefitUsageGroupByOutputType = {
    id: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber: string | null
    createdAt: Date
    _count: EmployeeBenefitUsageCountAggregateOutputType | null
    _avg: EmployeeBenefitUsageAvgAggregateOutputType | null
    _sum: EmployeeBenefitUsageSumAggregateOutputType | null
    _min: EmployeeBenefitUsageMinAggregateOutputType | null
    _max: EmployeeBenefitUsageMaxAggregateOutputType | null
  }

  type GetEmployeeBenefitUsageGroupByPayload<T extends EmployeeBenefitUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeBenefitUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeBenefitUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeBenefitUsageGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeBenefitUsageGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeBenefitUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeBenefitId?: boolean
    invoiceId?: boolean
    encounterId?: boolean
    amountUsed?: boolean
    patientId?: boolean
    patientBookNumber?: boolean
    createdAt?: boolean
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefitUsage"]>

  export type EmployeeBenefitUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeBenefitId?: boolean
    invoiceId?: boolean
    encounterId?: boolean
    amountUsed?: boolean
    patientId?: boolean
    patientBookNumber?: boolean
    createdAt?: boolean
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeBenefitUsage"]>

  export type EmployeeBenefitUsageSelectScalar = {
    id?: boolean
    employeeBenefitId?: boolean
    invoiceId?: boolean
    encounterId?: boolean
    amountUsed?: boolean
    patientId?: boolean
    patientBookNumber?: boolean
    createdAt?: boolean
  }

  export type EmployeeBenefitUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type EmployeeBenefitUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeBenefit?: boolean | EmployeeBenefitDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $EmployeeBenefitUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeBenefitUsage"
    objects: {
      employeeBenefit: Prisma.$EmployeeBenefitPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeBenefitId: number
      invoiceId: number
      encounterId: number
      amountUsed: number
      patientId: number
      patientBookNumber: string | null
      createdAt: Date
    }, ExtArgs["result"]["employeeBenefitUsage"]>
    composites: {}
  }

  type EmployeeBenefitUsageGetPayload<S extends boolean | null | undefined | EmployeeBenefitUsageDefaultArgs> = $Result.GetResult<Prisma.$EmployeeBenefitUsagePayload, S>

  type EmployeeBenefitUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeBenefitUsageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeBenefitUsageCountAggregateInputType | true
    }

  export interface EmployeeBenefitUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeBenefitUsage'], meta: { name: 'EmployeeBenefitUsage' } }
    /**
     * Find zero or one EmployeeBenefitUsage that matches the filter.
     * @param {EmployeeBenefitUsageFindUniqueArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeBenefitUsageFindUniqueArgs>(args: SelectSubset<T, EmployeeBenefitUsageFindUniqueArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeBenefitUsage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeBenefitUsageFindUniqueOrThrowArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeBenefitUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeBenefitUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeBenefitUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageFindFirstArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeBenefitUsageFindFirstArgs>(args?: SelectSubset<T, EmployeeBenefitUsageFindFirstArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeBenefitUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageFindFirstOrThrowArgs} args - Arguments to find a EmployeeBenefitUsage
     * @example
     * // Get one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeBenefitUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeBenefitUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeBenefitUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeBenefitUsages
     * const employeeBenefitUsages = await prisma.employeeBenefitUsage.findMany()
     * 
     * // Get first 10 EmployeeBenefitUsages
     * const employeeBenefitUsages = await prisma.employeeBenefitUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeBenefitUsageWithIdOnly = await prisma.employeeBenefitUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeBenefitUsageFindManyArgs>(args?: SelectSubset<T, EmployeeBenefitUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageCreateArgs} args - Arguments to create a EmployeeBenefitUsage.
     * @example
     * // Create one EmployeeBenefitUsage
     * const EmployeeBenefitUsage = await prisma.employeeBenefitUsage.create({
     *   data: {
     *     // ... data to create a EmployeeBenefitUsage
     *   }
     * })
     * 
     */
    create<T extends EmployeeBenefitUsageCreateArgs>(args: SelectSubset<T, EmployeeBenefitUsageCreateArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeBenefitUsages.
     * @param {EmployeeBenefitUsageCreateManyArgs} args - Arguments to create many EmployeeBenefitUsages.
     * @example
     * // Create many EmployeeBenefitUsages
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeBenefitUsageCreateManyArgs>(args?: SelectSubset<T, EmployeeBenefitUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeBenefitUsages and returns the data saved in the database.
     * @param {EmployeeBenefitUsageCreateManyAndReturnArgs} args - Arguments to create many EmployeeBenefitUsages.
     * @example
     * // Create many EmployeeBenefitUsages
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeBenefitUsages and only return the `id`
     * const employeeBenefitUsageWithIdOnly = await prisma.employeeBenefitUsage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeBenefitUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeBenefitUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageDeleteArgs} args - Arguments to delete one EmployeeBenefitUsage.
     * @example
     * // Delete one EmployeeBenefitUsage
     * const EmployeeBenefitUsage = await prisma.employeeBenefitUsage.delete({
     *   where: {
     *     // ... filter to delete one EmployeeBenefitUsage
     *   }
     * })
     * 
     */
    delete<T extends EmployeeBenefitUsageDeleteArgs>(args: SelectSubset<T, EmployeeBenefitUsageDeleteArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageUpdateArgs} args - Arguments to update one EmployeeBenefitUsage.
     * @example
     * // Update one EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeBenefitUsageUpdateArgs>(args: SelectSubset<T, EmployeeBenefitUsageUpdateArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeBenefitUsages.
     * @param {EmployeeBenefitUsageDeleteManyArgs} args - Arguments to filter EmployeeBenefitUsages to delete.
     * @example
     * // Delete a few EmployeeBenefitUsages
     * const { count } = await prisma.employeeBenefitUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeBenefitUsageDeleteManyArgs>(args?: SelectSubset<T, EmployeeBenefitUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeBenefitUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeBenefitUsages
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeBenefitUsageUpdateManyArgs>(args: SelectSubset<T, EmployeeBenefitUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeBenefitUsage.
     * @param {EmployeeBenefitUsageUpsertArgs} args - Arguments to update or create a EmployeeBenefitUsage.
     * @example
     * // Update or create a EmployeeBenefitUsage
     * const employeeBenefitUsage = await prisma.employeeBenefitUsage.upsert({
     *   create: {
     *     // ... data to create a EmployeeBenefitUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeBenefitUsage we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeBenefitUsageUpsertArgs>(args: SelectSubset<T, EmployeeBenefitUsageUpsertArgs<ExtArgs>>): Prisma__EmployeeBenefitUsageClient<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeBenefitUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageCountArgs} args - Arguments to filter EmployeeBenefitUsages to count.
     * @example
     * // Count the number of EmployeeBenefitUsages
     * const count = await prisma.employeeBenefitUsage.count({
     *   where: {
     *     // ... the filter for the EmployeeBenefitUsages we want to count
     *   }
     * })
    **/
    count<T extends EmployeeBenefitUsageCountArgs>(
      args?: Subset<T, EmployeeBenefitUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeBenefitUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeBenefitUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeBenefitUsageAggregateArgs>(args: Subset<T, EmployeeBenefitUsageAggregateArgs>): Prisma.PrismaPromise<GetEmployeeBenefitUsageAggregateType<T>>

    /**
     * Group by EmployeeBenefitUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeBenefitUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeBenefitUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeBenefitUsageGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeBenefitUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeBenefitUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeBenefitUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeBenefitUsage model
   */
  readonly fields: EmployeeBenefitUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeBenefitUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeBenefitUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeBenefit<T extends EmployeeBenefitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeBenefitDefaultArgs<ExtArgs>>): Prisma__EmployeeBenefitClient<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeBenefitUsage model
   */ 
  interface EmployeeBenefitUsageFieldRefs {
    readonly id: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly employeeBenefitId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly invoiceId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly encounterId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly amountUsed: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly patientId: FieldRef<"EmployeeBenefitUsage", 'Int'>
    readonly patientBookNumber: FieldRef<"EmployeeBenefitUsage", 'String'>
    readonly createdAt: FieldRef<"EmployeeBenefitUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeBenefitUsage findUnique
   */
  export type EmployeeBenefitUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage findUniqueOrThrow
   */
  export type EmployeeBenefitUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage findFirst
   */
  export type EmployeeBenefitUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefitUsages.
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefitUsages.
     */
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefitUsage findFirstOrThrow
   */
  export type EmployeeBenefitUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsage to fetch.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeBenefitUsages.
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeBenefitUsages.
     */
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefitUsage findMany
   */
  export type EmployeeBenefitUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeBenefitUsages to fetch.
     */
    where?: EmployeeBenefitUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeBenefitUsages to fetch.
     */
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeBenefitUsages.
     */
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeBenefitUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeBenefitUsages.
     */
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * EmployeeBenefitUsage create
   */
  export type EmployeeBenefitUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeBenefitUsage.
     */
    data: XOR<EmployeeBenefitUsageCreateInput, EmployeeBenefitUsageUncheckedCreateInput>
  }

  /**
   * EmployeeBenefitUsage createMany
   */
  export type EmployeeBenefitUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeBenefitUsages.
     */
    data: EmployeeBenefitUsageCreateManyInput | EmployeeBenefitUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeBenefitUsage createManyAndReturn
   */
  export type EmployeeBenefitUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeBenefitUsages.
     */
    data: EmployeeBenefitUsageCreateManyInput | EmployeeBenefitUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeBenefitUsage update
   */
  export type EmployeeBenefitUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeBenefitUsage.
     */
    data: XOR<EmployeeBenefitUsageUpdateInput, EmployeeBenefitUsageUncheckedUpdateInput>
    /**
     * Choose, which EmployeeBenefitUsage to update.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage updateMany
   */
  export type EmployeeBenefitUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeBenefitUsages.
     */
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeBenefitUsages to update
     */
    where?: EmployeeBenefitUsageWhereInput
  }

  /**
   * EmployeeBenefitUsage upsert
   */
  export type EmployeeBenefitUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeBenefitUsage to update in case it exists.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
    /**
     * In case the EmployeeBenefitUsage found by the `where` argument doesn't exist, create a new EmployeeBenefitUsage with this data.
     */
    create: XOR<EmployeeBenefitUsageCreateInput, EmployeeBenefitUsageUncheckedCreateInput>
    /**
     * In case the EmployeeBenefitUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeBenefitUsageUpdateInput, EmployeeBenefitUsageUncheckedUpdateInput>
  }

  /**
   * EmployeeBenefitUsage delete
   */
  export type EmployeeBenefitUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    /**
     * Filter which EmployeeBenefitUsage to delete.
     */
    where: EmployeeBenefitUsageWhereUniqueInput
  }

  /**
   * EmployeeBenefitUsage deleteMany
   */
  export type EmployeeBenefitUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeBenefitUsages to delete
     */
    where?: EmployeeBenefitUsageWhereInput
  }

  /**
   * EmployeeBenefitUsage without action
   */
  export type EmployeeBenefitUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
  }


  /**
   * Model SterilizationCategory
   */

  export type AggregateSterilizationCategory = {
    _count: SterilizationCategoryCountAggregateOutputType | null
    _avg: SterilizationCategoryAvgAggregateOutputType | null
    _sum: SterilizationCategorySumAggregateOutputType | null
    _min: SterilizationCategoryMinAggregateOutputType | null
    _max: SterilizationCategoryMaxAggregateOutputType | null
  }

  export type SterilizationCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type SterilizationCategorySumAggregateOutputType = {
    id: number | null
  }

  export type SterilizationCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SterilizationCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SterilizationCategoryCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SterilizationCategoryAvgAggregateInputType = {
    id?: true
  }

  export type SterilizationCategorySumAggregateInputType = {
    id?: true
  }

  export type SterilizationCategoryMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SterilizationCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SterilizationCategoryCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SterilizationCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationCategory to aggregate.
     */
    where?: SterilizationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationCategories to fetch.
     */
    orderBy?: SterilizationCategoryOrderByWithRelationInput | SterilizationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SterilizationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SterilizationCategories
    **/
    _count?: true | SterilizationCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SterilizationCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SterilizationCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SterilizationCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SterilizationCategoryMaxAggregateInputType
  }

  export type GetSterilizationCategoryAggregateType<T extends SterilizationCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSterilizationCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSterilizationCategory[P]>
      : GetScalarType<T[P], AggregateSterilizationCategory[P]>
  }




  export type SterilizationCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationCategoryWhereInput
    orderBy?: SterilizationCategoryOrderByWithAggregationInput | SterilizationCategoryOrderByWithAggregationInput[]
    by: SterilizationCategoryScalarFieldEnum[] | SterilizationCategoryScalarFieldEnum
    having?: SterilizationCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SterilizationCategoryCountAggregateInputType | true
    _avg?: SterilizationCategoryAvgAggregateInputType
    _sum?: SterilizationCategorySumAggregateInputType
    _min?: SterilizationCategoryMinAggregateInputType
    _max?: SterilizationCategoryMaxAggregateInputType
  }

  export type SterilizationCategoryGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: SterilizationCategoryCountAggregateOutputType | null
    _avg: SterilizationCategoryAvgAggregateOutputType | null
    _sum: SterilizationCategorySumAggregateOutputType | null
    _min: SterilizationCategoryMinAggregateOutputType | null
    _max: SterilizationCategoryMaxAggregateOutputType | null
  }

  type GetSterilizationCategoryGroupByPayload<T extends SterilizationCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SterilizationCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SterilizationCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SterilizationCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SterilizationCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SterilizationCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | SterilizationCategory$itemsArgs<ExtArgs>
    _count?: boolean | SterilizationCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationCategory"]>

  export type SterilizationCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sterilizationCategory"]>

  export type SterilizationCategorySelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SterilizationCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SterilizationCategory$itemsArgs<ExtArgs>
    _count?: boolean | SterilizationCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SterilizationCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SterilizationCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SterilizationCategory"
    objects: {
      items: Prisma.$SterilizationItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sterilizationCategory"]>
    composites: {}
  }

  type SterilizationCategoryGetPayload<S extends boolean | null | undefined | SterilizationCategoryDefaultArgs> = $Result.GetResult<Prisma.$SterilizationCategoryPayload, S>

  type SterilizationCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SterilizationCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SterilizationCategoryCountAggregateInputType | true
    }

  export interface SterilizationCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SterilizationCategory'], meta: { name: 'SterilizationCategory' } }
    /**
     * Find zero or one SterilizationCategory that matches the filter.
     * @param {SterilizationCategoryFindUniqueArgs} args - Arguments to find a SterilizationCategory
     * @example
     * // Get one SterilizationCategory
     * const sterilizationCategory = await prisma.sterilizationCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SterilizationCategoryFindUniqueArgs>(args: SelectSubset<T, SterilizationCategoryFindUniqueArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SterilizationCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SterilizationCategoryFindUniqueOrThrowArgs} args - Arguments to find a SterilizationCategory
     * @example
     * // Get one SterilizationCategory
     * const sterilizationCategory = await prisma.sterilizationCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SterilizationCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SterilizationCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SterilizationCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryFindFirstArgs} args - Arguments to find a SterilizationCategory
     * @example
     * // Get one SterilizationCategory
     * const sterilizationCategory = await prisma.sterilizationCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SterilizationCategoryFindFirstArgs>(args?: SelectSubset<T, SterilizationCategoryFindFirstArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SterilizationCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryFindFirstOrThrowArgs} args - Arguments to find a SterilizationCategory
     * @example
     * // Get one SterilizationCategory
     * const sterilizationCategory = await prisma.sterilizationCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SterilizationCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SterilizationCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SterilizationCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SterilizationCategories
     * const sterilizationCategories = await prisma.sterilizationCategory.findMany()
     * 
     * // Get first 10 SterilizationCategories
     * const sterilizationCategories = await prisma.sterilizationCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sterilizationCategoryWithIdOnly = await prisma.sterilizationCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SterilizationCategoryFindManyArgs>(args?: SelectSubset<T, SterilizationCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SterilizationCategory.
     * @param {SterilizationCategoryCreateArgs} args - Arguments to create a SterilizationCategory.
     * @example
     * // Create one SterilizationCategory
     * const SterilizationCategory = await prisma.sterilizationCategory.create({
     *   data: {
     *     // ... data to create a SterilizationCategory
     *   }
     * })
     * 
     */
    create<T extends SterilizationCategoryCreateArgs>(args: SelectSubset<T, SterilizationCategoryCreateArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SterilizationCategories.
     * @param {SterilizationCategoryCreateManyArgs} args - Arguments to create many SterilizationCategories.
     * @example
     * // Create many SterilizationCategories
     * const sterilizationCategory = await prisma.sterilizationCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SterilizationCategoryCreateManyArgs>(args?: SelectSubset<T, SterilizationCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SterilizationCategories and returns the data saved in the database.
     * @param {SterilizationCategoryCreateManyAndReturnArgs} args - Arguments to create many SterilizationCategories.
     * @example
     * // Create many SterilizationCategories
     * const sterilizationCategory = await prisma.sterilizationCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SterilizationCategories and only return the `id`
     * const sterilizationCategoryWithIdOnly = await prisma.sterilizationCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SterilizationCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SterilizationCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SterilizationCategory.
     * @param {SterilizationCategoryDeleteArgs} args - Arguments to delete one SterilizationCategory.
     * @example
     * // Delete one SterilizationCategory
     * const SterilizationCategory = await prisma.sterilizationCategory.delete({
     *   where: {
     *     // ... filter to delete one SterilizationCategory
     *   }
     * })
     * 
     */
    delete<T extends SterilizationCategoryDeleteArgs>(args: SelectSubset<T, SterilizationCategoryDeleteArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SterilizationCategory.
     * @param {SterilizationCategoryUpdateArgs} args - Arguments to update one SterilizationCategory.
     * @example
     * // Update one SterilizationCategory
     * const sterilizationCategory = await prisma.sterilizationCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SterilizationCategoryUpdateArgs>(args: SelectSubset<T, SterilizationCategoryUpdateArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SterilizationCategories.
     * @param {SterilizationCategoryDeleteManyArgs} args - Arguments to filter SterilizationCategories to delete.
     * @example
     * // Delete a few SterilizationCategories
     * const { count } = await prisma.sterilizationCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SterilizationCategoryDeleteManyArgs>(args?: SelectSubset<T, SterilizationCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SterilizationCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SterilizationCategories
     * const sterilizationCategory = await prisma.sterilizationCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SterilizationCategoryUpdateManyArgs>(args: SelectSubset<T, SterilizationCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SterilizationCategory.
     * @param {SterilizationCategoryUpsertArgs} args - Arguments to update or create a SterilizationCategory.
     * @example
     * // Update or create a SterilizationCategory
     * const sterilizationCategory = await prisma.sterilizationCategory.upsert({
     *   create: {
     *     // ... data to create a SterilizationCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SterilizationCategory we want to update
     *   }
     * })
     */
    upsert<T extends SterilizationCategoryUpsertArgs>(args: SelectSubset<T, SterilizationCategoryUpsertArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SterilizationCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryCountArgs} args - Arguments to filter SterilizationCategories to count.
     * @example
     * // Count the number of SterilizationCategories
     * const count = await prisma.sterilizationCategory.count({
     *   where: {
     *     // ... the filter for the SterilizationCategories we want to count
     *   }
     * })
    **/
    count<T extends SterilizationCategoryCountArgs>(
      args?: Subset<T, SterilizationCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SterilizationCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SterilizationCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SterilizationCategoryAggregateArgs>(args: Subset<T, SterilizationCategoryAggregateArgs>): Prisma.PrismaPromise<GetSterilizationCategoryAggregateType<T>>

    /**
     * Group by SterilizationCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SterilizationCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SterilizationCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SterilizationCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SterilizationCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSterilizationCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SterilizationCategory model
   */
  readonly fields: SterilizationCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SterilizationCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SterilizationCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends SterilizationCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SterilizationCategory model
   */ 
  interface SterilizationCategoryFieldRefs {
    readonly id: FieldRef<"SterilizationCategory", 'Int'>
    readonly name: FieldRef<"SterilizationCategory", 'String'>
    readonly createdAt: FieldRef<"SterilizationCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"SterilizationCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SterilizationCategory findUnique
   */
  export type SterilizationCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationCategory to fetch.
     */
    where: SterilizationCategoryWhereUniqueInput
  }

  /**
   * SterilizationCategory findUniqueOrThrow
   */
  export type SterilizationCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationCategory to fetch.
     */
    where: SterilizationCategoryWhereUniqueInput
  }

  /**
   * SterilizationCategory findFirst
   */
  export type SterilizationCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationCategory to fetch.
     */
    where?: SterilizationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationCategories to fetch.
     */
    orderBy?: SterilizationCategoryOrderByWithRelationInput | SterilizationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationCategories.
     */
    cursor?: SterilizationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationCategories.
     */
    distinct?: SterilizationCategoryScalarFieldEnum | SterilizationCategoryScalarFieldEnum[]
  }

  /**
   * SterilizationCategory findFirstOrThrow
   */
  export type SterilizationCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationCategory to fetch.
     */
    where?: SterilizationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationCategories to fetch.
     */
    orderBy?: SterilizationCategoryOrderByWithRelationInput | SterilizationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationCategories.
     */
    cursor?: SterilizationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationCategories.
     */
    distinct?: SterilizationCategoryScalarFieldEnum | SterilizationCategoryScalarFieldEnum[]
  }

  /**
   * SterilizationCategory findMany
   */
  export type SterilizationCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationCategories to fetch.
     */
    where?: SterilizationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationCategories to fetch.
     */
    orderBy?: SterilizationCategoryOrderByWithRelationInput | SterilizationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SterilizationCategories.
     */
    cursor?: SterilizationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationCategories.
     */
    skip?: number
    distinct?: SterilizationCategoryScalarFieldEnum | SterilizationCategoryScalarFieldEnum[]
  }

  /**
   * SterilizationCategory create
   */
  export type SterilizationCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SterilizationCategory.
     */
    data: XOR<SterilizationCategoryCreateInput, SterilizationCategoryUncheckedCreateInput>
  }

  /**
   * SterilizationCategory createMany
   */
  export type SterilizationCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SterilizationCategories.
     */
    data: SterilizationCategoryCreateManyInput | SterilizationCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SterilizationCategory createManyAndReturn
   */
  export type SterilizationCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SterilizationCategories.
     */
    data: SterilizationCategoryCreateManyInput | SterilizationCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SterilizationCategory update
   */
  export type SterilizationCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SterilizationCategory.
     */
    data: XOR<SterilizationCategoryUpdateInput, SterilizationCategoryUncheckedUpdateInput>
    /**
     * Choose, which SterilizationCategory to update.
     */
    where: SterilizationCategoryWhereUniqueInput
  }

  /**
   * SterilizationCategory updateMany
   */
  export type SterilizationCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SterilizationCategories.
     */
    data: XOR<SterilizationCategoryUpdateManyMutationInput, SterilizationCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SterilizationCategories to update
     */
    where?: SterilizationCategoryWhereInput
  }

  /**
   * SterilizationCategory upsert
   */
  export type SterilizationCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SterilizationCategory to update in case it exists.
     */
    where: SterilizationCategoryWhereUniqueInput
    /**
     * In case the SterilizationCategory found by the `where` argument doesn't exist, create a new SterilizationCategory with this data.
     */
    create: XOR<SterilizationCategoryCreateInput, SterilizationCategoryUncheckedCreateInput>
    /**
     * In case the SterilizationCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SterilizationCategoryUpdateInput, SterilizationCategoryUncheckedUpdateInput>
  }

  /**
   * SterilizationCategory delete
   */
  export type SterilizationCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
    /**
     * Filter which SterilizationCategory to delete.
     */
    where: SterilizationCategoryWhereUniqueInput
  }

  /**
   * SterilizationCategory deleteMany
   */
  export type SterilizationCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationCategories to delete
     */
    where?: SterilizationCategoryWhereInput
  }

  /**
   * SterilizationCategory.items
   */
  export type SterilizationCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    where?: SterilizationItemWhereInput
    orderBy?: SterilizationItemOrderByWithRelationInput | SterilizationItemOrderByWithRelationInput[]
    cursor?: SterilizationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SterilizationItemScalarFieldEnum | SterilizationItemScalarFieldEnum[]
  }

  /**
   * SterilizationCategory without action
   */
  export type SterilizationCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationCategory
     */
    select?: SterilizationCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationCategoryInclude<ExtArgs> | null
  }


  /**
   * Model SterilizationItem
   */

  export type AggregateSterilizationItem = {
    _count: SterilizationItemCountAggregateOutputType | null
    _avg: SterilizationItemAvgAggregateOutputType | null
    _sum: SterilizationItemSumAggregateOutputType | null
    _min: SterilizationItemMinAggregateOutputType | null
    _max: SterilizationItemMaxAggregateOutputType | null
  }

  export type SterilizationItemAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    quantity: number | null
  }

  export type SterilizationItemSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    quantity: number | null
  }

  export type SterilizationItemMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SterilizationItemMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    name: string | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SterilizationItemCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SterilizationItemAvgAggregateInputType = {
    id?: true
    categoryId?: true
    quantity?: true
  }

  export type SterilizationItemSumAggregateInputType = {
    id?: true
    categoryId?: true
    quantity?: true
  }

  export type SterilizationItemMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SterilizationItemMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SterilizationItemCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SterilizationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationItem to aggregate.
     */
    where?: SterilizationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationItems to fetch.
     */
    orderBy?: SterilizationItemOrderByWithRelationInput | SterilizationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SterilizationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SterilizationItems
    **/
    _count?: true | SterilizationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SterilizationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SterilizationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SterilizationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SterilizationItemMaxAggregateInputType
  }

  export type GetSterilizationItemAggregateType<T extends SterilizationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSterilizationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSterilizationItem[P]>
      : GetScalarType<T[P], AggregateSterilizationItem[P]>
  }




  export type SterilizationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationItemWhereInput
    orderBy?: SterilizationItemOrderByWithAggregationInput | SterilizationItemOrderByWithAggregationInput[]
    by: SterilizationItemScalarFieldEnum[] | SterilizationItemScalarFieldEnum
    having?: SterilizationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SterilizationItemCountAggregateInputType | true
    _avg?: SterilizationItemAvgAggregateInputType
    _sum?: SterilizationItemSumAggregateInputType
    _min?: SterilizationItemMinAggregateInputType
    _max?: SterilizationItemMaxAggregateInputType
  }

  export type SterilizationItemGroupByOutputType = {
    id: number
    categoryId: number
    name: string
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: SterilizationItemCountAggregateOutputType | null
    _avg: SterilizationItemAvgAggregateOutputType | null
    _sum: SterilizationItemSumAggregateOutputType | null
    _min: SterilizationItemMinAggregateOutputType | null
    _max: SterilizationItemMaxAggregateOutputType | null
  }

  type GetSterilizationItemGroupByPayload<T extends SterilizationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SterilizationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SterilizationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SterilizationItemGroupByOutputType[P]>
            : GetScalarType<T[P], SterilizationItemGroupByOutputType[P]>
        }
      >
    >


  export type SterilizationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | SterilizationCategoryDefaultArgs<ExtArgs>
    indicatorItems?: boolean | SterilizationItem$indicatorItemsArgs<ExtArgs>
    _count?: boolean | SterilizationItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationItem"]>

  export type SterilizationItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | SterilizationCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationItem"]>

  export type SterilizationItemSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SterilizationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | SterilizationCategoryDefaultArgs<ExtArgs>
    indicatorItems?: boolean | SterilizationItem$indicatorItemsArgs<ExtArgs>
    _count?: boolean | SterilizationItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SterilizationItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | SterilizationCategoryDefaultArgs<ExtArgs>
  }

  export type $SterilizationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SterilizationItem"
    objects: {
      category: Prisma.$SterilizationCategoryPayload<ExtArgs>
      indicatorItems: Prisma.$SterilizationIndicatorItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryId: number
      name: string
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sterilizationItem"]>
    composites: {}
  }

  type SterilizationItemGetPayload<S extends boolean | null | undefined | SterilizationItemDefaultArgs> = $Result.GetResult<Prisma.$SterilizationItemPayload, S>

  type SterilizationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SterilizationItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SterilizationItemCountAggregateInputType | true
    }

  export interface SterilizationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SterilizationItem'], meta: { name: 'SterilizationItem' } }
    /**
     * Find zero or one SterilizationItem that matches the filter.
     * @param {SterilizationItemFindUniqueArgs} args - Arguments to find a SterilizationItem
     * @example
     * // Get one SterilizationItem
     * const sterilizationItem = await prisma.sterilizationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SterilizationItemFindUniqueArgs>(args: SelectSubset<T, SterilizationItemFindUniqueArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SterilizationItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SterilizationItemFindUniqueOrThrowArgs} args - Arguments to find a SterilizationItem
     * @example
     * // Get one SterilizationItem
     * const sterilizationItem = await prisma.sterilizationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SterilizationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SterilizationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SterilizationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemFindFirstArgs} args - Arguments to find a SterilizationItem
     * @example
     * // Get one SterilizationItem
     * const sterilizationItem = await prisma.sterilizationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SterilizationItemFindFirstArgs>(args?: SelectSubset<T, SterilizationItemFindFirstArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SterilizationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemFindFirstOrThrowArgs} args - Arguments to find a SterilizationItem
     * @example
     * // Get one SterilizationItem
     * const sterilizationItem = await prisma.sterilizationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SterilizationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SterilizationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SterilizationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SterilizationItems
     * const sterilizationItems = await prisma.sterilizationItem.findMany()
     * 
     * // Get first 10 SterilizationItems
     * const sterilizationItems = await prisma.sterilizationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sterilizationItemWithIdOnly = await prisma.sterilizationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SterilizationItemFindManyArgs>(args?: SelectSubset<T, SterilizationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SterilizationItem.
     * @param {SterilizationItemCreateArgs} args - Arguments to create a SterilizationItem.
     * @example
     * // Create one SterilizationItem
     * const SterilizationItem = await prisma.sterilizationItem.create({
     *   data: {
     *     // ... data to create a SterilizationItem
     *   }
     * })
     * 
     */
    create<T extends SterilizationItemCreateArgs>(args: SelectSubset<T, SterilizationItemCreateArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SterilizationItems.
     * @param {SterilizationItemCreateManyArgs} args - Arguments to create many SterilizationItems.
     * @example
     * // Create many SterilizationItems
     * const sterilizationItem = await prisma.sterilizationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SterilizationItemCreateManyArgs>(args?: SelectSubset<T, SterilizationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SterilizationItems and returns the data saved in the database.
     * @param {SterilizationItemCreateManyAndReturnArgs} args - Arguments to create many SterilizationItems.
     * @example
     * // Create many SterilizationItems
     * const sterilizationItem = await prisma.sterilizationItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SterilizationItems and only return the `id`
     * const sterilizationItemWithIdOnly = await prisma.sterilizationItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SterilizationItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SterilizationItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SterilizationItem.
     * @param {SterilizationItemDeleteArgs} args - Arguments to delete one SterilizationItem.
     * @example
     * // Delete one SterilizationItem
     * const SterilizationItem = await prisma.sterilizationItem.delete({
     *   where: {
     *     // ... filter to delete one SterilizationItem
     *   }
     * })
     * 
     */
    delete<T extends SterilizationItemDeleteArgs>(args: SelectSubset<T, SterilizationItemDeleteArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SterilizationItem.
     * @param {SterilizationItemUpdateArgs} args - Arguments to update one SterilizationItem.
     * @example
     * // Update one SterilizationItem
     * const sterilizationItem = await prisma.sterilizationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SterilizationItemUpdateArgs>(args: SelectSubset<T, SterilizationItemUpdateArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SterilizationItems.
     * @param {SterilizationItemDeleteManyArgs} args - Arguments to filter SterilizationItems to delete.
     * @example
     * // Delete a few SterilizationItems
     * const { count } = await prisma.sterilizationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SterilizationItemDeleteManyArgs>(args?: SelectSubset<T, SterilizationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SterilizationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SterilizationItems
     * const sterilizationItem = await prisma.sterilizationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SterilizationItemUpdateManyArgs>(args: SelectSubset<T, SterilizationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SterilizationItem.
     * @param {SterilizationItemUpsertArgs} args - Arguments to update or create a SterilizationItem.
     * @example
     * // Update or create a SterilizationItem
     * const sterilizationItem = await prisma.sterilizationItem.upsert({
     *   create: {
     *     // ... data to create a SterilizationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SterilizationItem we want to update
     *   }
     * })
     */
    upsert<T extends SterilizationItemUpsertArgs>(args: SelectSubset<T, SterilizationItemUpsertArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SterilizationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemCountArgs} args - Arguments to filter SterilizationItems to count.
     * @example
     * // Count the number of SterilizationItems
     * const count = await prisma.sterilizationItem.count({
     *   where: {
     *     // ... the filter for the SterilizationItems we want to count
     *   }
     * })
    **/
    count<T extends SterilizationItemCountArgs>(
      args?: Subset<T, SterilizationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SterilizationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SterilizationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SterilizationItemAggregateArgs>(args: Subset<T, SterilizationItemAggregateArgs>): Prisma.PrismaPromise<GetSterilizationItemAggregateType<T>>

    /**
     * Group by SterilizationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SterilizationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SterilizationItemGroupByArgs['orderBy'] }
        : { orderBy?: SterilizationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SterilizationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSterilizationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SterilizationItem model
   */
  readonly fields: SterilizationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SterilizationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SterilizationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends SterilizationCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationCategoryDefaultArgs<ExtArgs>>): Prisma__SterilizationCategoryClient<$Result.GetResult<Prisma.$SterilizationCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicatorItems<T extends SterilizationItem$indicatorItemsArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationItem$indicatorItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SterilizationItem model
   */ 
  interface SterilizationItemFieldRefs {
    readonly id: FieldRef<"SterilizationItem", 'Int'>
    readonly categoryId: FieldRef<"SterilizationItem", 'Int'>
    readonly name: FieldRef<"SterilizationItem", 'String'>
    readonly quantity: FieldRef<"SterilizationItem", 'Int'>
    readonly createdAt: FieldRef<"SterilizationItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SterilizationItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SterilizationItem findUnique
   */
  export type SterilizationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationItem to fetch.
     */
    where: SterilizationItemWhereUniqueInput
  }

  /**
   * SterilizationItem findUniqueOrThrow
   */
  export type SterilizationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationItem to fetch.
     */
    where: SterilizationItemWhereUniqueInput
  }

  /**
   * SterilizationItem findFirst
   */
  export type SterilizationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationItem to fetch.
     */
    where?: SterilizationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationItems to fetch.
     */
    orderBy?: SterilizationItemOrderByWithRelationInput | SterilizationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationItems.
     */
    cursor?: SterilizationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationItems.
     */
    distinct?: SterilizationItemScalarFieldEnum | SterilizationItemScalarFieldEnum[]
  }

  /**
   * SterilizationItem findFirstOrThrow
   */
  export type SterilizationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationItem to fetch.
     */
    where?: SterilizationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationItems to fetch.
     */
    orderBy?: SterilizationItemOrderByWithRelationInput | SterilizationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationItems.
     */
    cursor?: SterilizationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationItems.
     */
    distinct?: SterilizationItemScalarFieldEnum | SterilizationItemScalarFieldEnum[]
  }

  /**
   * SterilizationItem findMany
   */
  export type SterilizationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationItems to fetch.
     */
    where?: SterilizationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationItems to fetch.
     */
    orderBy?: SterilizationItemOrderByWithRelationInput | SterilizationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SterilizationItems.
     */
    cursor?: SterilizationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationItems.
     */
    skip?: number
    distinct?: SterilizationItemScalarFieldEnum | SterilizationItemScalarFieldEnum[]
  }

  /**
   * SterilizationItem create
   */
  export type SterilizationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SterilizationItem.
     */
    data: XOR<SterilizationItemCreateInput, SterilizationItemUncheckedCreateInput>
  }

  /**
   * SterilizationItem createMany
   */
  export type SterilizationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SterilizationItems.
     */
    data: SterilizationItemCreateManyInput | SterilizationItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SterilizationItem createManyAndReturn
   */
  export type SterilizationItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SterilizationItems.
     */
    data: SterilizationItemCreateManyInput | SterilizationItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SterilizationItem update
   */
  export type SterilizationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SterilizationItem.
     */
    data: XOR<SterilizationItemUpdateInput, SterilizationItemUncheckedUpdateInput>
    /**
     * Choose, which SterilizationItem to update.
     */
    where: SterilizationItemWhereUniqueInput
  }

  /**
   * SterilizationItem updateMany
   */
  export type SterilizationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SterilizationItems.
     */
    data: XOR<SterilizationItemUpdateManyMutationInput, SterilizationItemUncheckedUpdateManyInput>
    /**
     * Filter which SterilizationItems to update
     */
    where?: SterilizationItemWhereInput
  }

  /**
   * SterilizationItem upsert
   */
  export type SterilizationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SterilizationItem to update in case it exists.
     */
    where: SterilizationItemWhereUniqueInput
    /**
     * In case the SterilizationItem found by the `where` argument doesn't exist, create a new SterilizationItem with this data.
     */
    create: XOR<SterilizationItemCreateInput, SterilizationItemUncheckedCreateInput>
    /**
     * In case the SterilizationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SterilizationItemUpdateInput, SterilizationItemUncheckedUpdateInput>
  }

  /**
   * SterilizationItem delete
   */
  export type SterilizationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
    /**
     * Filter which SterilizationItem to delete.
     */
    where: SterilizationItemWhereUniqueInput
  }

  /**
   * SterilizationItem deleteMany
   */
  export type SterilizationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationItems to delete
     */
    where?: SterilizationItemWhereInput
  }

  /**
   * SterilizationItem.indicatorItems
   */
  export type SterilizationItem$indicatorItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    where?: SterilizationIndicatorItemWhereInput
    orderBy?: SterilizationIndicatorItemOrderByWithRelationInput | SterilizationIndicatorItemOrderByWithRelationInput[]
    cursor?: SterilizationIndicatorItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SterilizationIndicatorItemScalarFieldEnum | SterilizationIndicatorItemScalarFieldEnum[]
  }

  /**
   * SterilizationItem without action
   */
  export type SterilizationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationItem
     */
    select?: SterilizationItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationItemInclude<ExtArgs> | null
  }


  /**
   * Model SterilizationIndicator
   */

  export type AggregateSterilizationIndicator = {
    _count: SterilizationIndicatorCountAggregateOutputType | null
    _avg: SterilizationIndicatorAvgAggregateOutputType | null
    _sum: SterilizationIndicatorSumAggregateOutputType | null
    _min: SterilizationIndicatorMinAggregateOutputType | null
    _max: SterilizationIndicatorMaxAggregateOutputType | null
  }

  export type SterilizationIndicatorAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    specialistUserId: number | null
    packageQuantity: number | null
  }

  export type SterilizationIndicatorSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    specialistUserId: number | null
    packageQuantity: number | null
  }

  export type SterilizationIndicatorMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    packageName: string | null
    code: string | null
    indicatorDate: Date | null
    specialistUserId: number | null
    packageQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SterilizationIndicatorMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    packageName: string | null
    code: string | null
    indicatorDate: Date | null
    specialistUserId: number | null
    packageQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SterilizationIndicatorCountAggregateOutputType = {
    id: number
    branchId: number
    packageName: number
    code: number
    indicatorDate: number
    specialistUserId: number
    packageQuantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SterilizationIndicatorAvgAggregateInputType = {
    id?: true
    branchId?: true
    specialistUserId?: true
    packageQuantity?: true
  }

  export type SterilizationIndicatorSumAggregateInputType = {
    id?: true
    branchId?: true
    specialistUserId?: true
    packageQuantity?: true
  }

  export type SterilizationIndicatorMinAggregateInputType = {
    id?: true
    branchId?: true
    packageName?: true
    code?: true
    indicatorDate?: true
    specialistUserId?: true
    packageQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SterilizationIndicatorMaxAggregateInputType = {
    id?: true
    branchId?: true
    packageName?: true
    code?: true
    indicatorDate?: true
    specialistUserId?: true
    packageQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SterilizationIndicatorCountAggregateInputType = {
    id?: true
    branchId?: true
    packageName?: true
    code?: true
    indicatorDate?: true
    specialistUserId?: true
    packageQuantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SterilizationIndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationIndicator to aggregate.
     */
    where?: SterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicators to fetch.
     */
    orderBy?: SterilizationIndicatorOrderByWithRelationInput | SterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SterilizationIndicators
    **/
    _count?: true | SterilizationIndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SterilizationIndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SterilizationIndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SterilizationIndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SterilizationIndicatorMaxAggregateInputType
  }

  export type GetSterilizationIndicatorAggregateType<T extends SterilizationIndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateSterilizationIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSterilizationIndicator[P]>
      : GetScalarType<T[P], AggregateSterilizationIndicator[P]>
  }




  export type SterilizationIndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationIndicatorWhereInput
    orderBy?: SterilizationIndicatorOrderByWithAggregationInput | SterilizationIndicatorOrderByWithAggregationInput[]
    by: SterilizationIndicatorScalarFieldEnum[] | SterilizationIndicatorScalarFieldEnum
    having?: SterilizationIndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SterilizationIndicatorCountAggregateInputType | true
    _avg?: SterilizationIndicatorAvgAggregateInputType
    _sum?: SterilizationIndicatorSumAggregateInputType
    _min?: SterilizationIndicatorMinAggregateInputType
    _max?: SterilizationIndicatorMaxAggregateInputType
  }

  export type SterilizationIndicatorGroupByOutputType = {
    id: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date
    specialistUserId: number
    packageQuantity: number
    createdAt: Date
    updatedAt: Date
    _count: SterilizationIndicatorCountAggregateOutputType | null
    _avg: SterilizationIndicatorAvgAggregateOutputType | null
    _sum: SterilizationIndicatorSumAggregateOutputType | null
    _min: SterilizationIndicatorMinAggregateOutputType | null
    _max: SterilizationIndicatorMaxAggregateOutputType | null
  }

  type GetSterilizationIndicatorGroupByPayload<T extends SterilizationIndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SterilizationIndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SterilizationIndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SterilizationIndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], SterilizationIndicatorGroupByOutputType[P]>
        }
      >
    >


  export type SterilizationIndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    packageName?: boolean
    code?: boolean
    indicatorDate?: boolean
    specialistUserId?: boolean
    packageQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    specialist?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | SterilizationIndicator$itemsArgs<ExtArgs>
    uses?: boolean | SterilizationIndicator$usesArgs<ExtArgs>
    encounterDiagnosisLinks?: boolean | SterilizationIndicator$encounterDiagnosisLinksArgs<ExtArgs>
    _count?: boolean | SterilizationIndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationIndicator"]>

  export type SterilizationIndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    packageName?: boolean
    code?: boolean
    indicatorDate?: boolean
    specialistUserId?: boolean
    packageQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    specialist?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationIndicator"]>

  export type SterilizationIndicatorSelectScalar = {
    id?: boolean
    branchId?: boolean
    packageName?: boolean
    code?: boolean
    indicatorDate?: boolean
    specialistUserId?: boolean
    packageQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SterilizationIndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    specialist?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | SterilizationIndicator$itemsArgs<ExtArgs>
    uses?: boolean | SterilizationIndicator$usesArgs<ExtArgs>
    encounterDiagnosisLinks?: boolean | SterilizationIndicator$encounterDiagnosisLinksArgs<ExtArgs>
    _count?: boolean | SterilizationIndicatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SterilizationIndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    specialist?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SterilizationIndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SterilizationIndicator"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      specialist: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$SterilizationIndicatorItemPayload<ExtArgs>[]
      uses: Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>[]
      encounterDiagnosisLinks: Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      packageName: string
      code: string
      indicatorDate: Date
      specialistUserId: number
      packageQuantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sterilizationIndicator"]>
    composites: {}
  }

  type SterilizationIndicatorGetPayload<S extends boolean | null | undefined | SterilizationIndicatorDefaultArgs> = $Result.GetResult<Prisma.$SterilizationIndicatorPayload, S>

  type SterilizationIndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SterilizationIndicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SterilizationIndicatorCountAggregateInputType | true
    }

  export interface SterilizationIndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SterilizationIndicator'], meta: { name: 'SterilizationIndicator' } }
    /**
     * Find zero or one SterilizationIndicator that matches the filter.
     * @param {SterilizationIndicatorFindUniqueArgs} args - Arguments to find a SterilizationIndicator
     * @example
     * // Get one SterilizationIndicator
     * const sterilizationIndicator = await prisma.sterilizationIndicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SterilizationIndicatorFindUniqueArgs>(args: SelectSubset<T, SterilizationIndicatorFindUniqueArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SterilizationIndicator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SterilizationIndicatorFindUniqueOrThrowArgs} args - Arguments to find a SterilizationIndicator
     * @example
     * // Get one SterilizationIndicator
     * const sterilizationIndicator = await prisma.sterilizationIndicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SterilizationIndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, SterilizationIndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SterilizationIndicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorFindFirstArgs} args - Arguments to find a SterilizationIndicator
     * @example
     * // Get one SterilizationIndicator
     * const sterilizationIndicator = await prisma.sterilizationIndicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SterilizationIndicatorFindFirstArgs>(args?: SelectSubset<T, SterilizationIndicatorFindFirstArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SterilizationIndicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorFindFirstOrThrowArgs} args - Arguments to find a SterilizationIndicator
     * @example
     * // Get one SterilizationIndicator
     * const sterilizationIndicator = await prisma.sterilizationIndicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SterilizationIndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, SterilizationIndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SterilizationIndicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SterilizationIndicators
     * const sterilizationIndicators = await prisma.sterilizationIndicator.findMany()
     * 
     * // Get first 10 SterilizationIndicators
     * const sterilizationIndicators = await prisma.sterilizationIndicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sterilizationIndicatorWithIdOnly = await prisma.sterilizationIndicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SterilizationIndicatorFindManyArgs>(args?: SelectSubset<T, SterilizationIndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SterilizationIndicator.
     * @param {SterilizationIndicatorCreateArgs} args - Arguments to create a SterilizationIndicator.
     * @example
     * // Create one SterilizationIndicator
     * const SterilizationIndicator = await prisma.sterilizationIndicator.create({
     *   data: {
     *     // ... data to create a SterilizationIndicator
     *   }
     * })
     * 
     */
    create<T extends SterilizationIndicatorCreateArgs>(args: SelectSubset<T, SterilizationIndicatorCreateArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SterilizationIndicators.
     * @param {SterilizationIndicatorCreateManyArgs} args - Arguments to create many SterilizationIndicators.
     * @example
     * // Create many SterilizationIndicators
     * const sterilizationIndicator = await prisma.sterilizationIndicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SterilizationIndicatorCreateManyArgs>(args?: SelectSubset<T, SterilizationIndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SterilizationIndicators and returns the data saved in the database.
     * @param {SterilizationIndicatorCreateManyAndReturnArgs} args - Arguments to create many SterilizationIndicators.
     * @example
     * // Create many SterilizationIndicators
     * const sterilizationIndicator = await prisma.sterilizationIndicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SterilizationIndicators and only return the `id`
     * const sterilizationIndicatorWithIdOnly = await prisma.sterilizationIndicator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SterilizationIndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, SterilizationIndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SterilizationIndicator.
     * @param {SterilizationIndicatorDeleteArgs} args - Arguments to delete one SterilizationIndicator.
     * @example
     * // Delete one SterilizationIndicator
     * const SterilizationIndicator = await prisma.sterilizationIndicator.delete({
     *   where: {
     *     // ... filter to delete one SterilizationIndicator
     *   }
     * })
     * 
     */
    delete<T extends SterilizationIndicatorDeleteArgs>(args: SelectSubset<T, SterilizationIndicatorDeleteArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SterilizationIndicator.
     * @param {SterilizationIndicatorUpdateArgs} args - Arguments to update one SterilizationIndicator.
     * @example
     * // Update one SterilizationIndicator
     * const sterilizationIndicator = await prisma.sterilizationIndicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SterilizationIndicatorUpdateArgs>(args: SelectSubset<T, SterilizationIndicatorUpdateArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SterilizationIndicators.
     * @param {SterilizationIndicatorDeleteManyArgs} args - Arguments to filter SterilizationIndicators to delete.
     * @example
     * // Delete a few SterilizationIndicators
     * const { count } = await prisma.sterilizationIndicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SterilizationIndicatorDeleteManyArgs>(args?: SelectSubset<T, SterilizationIndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SterilizationIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SterilizationIndicators
     * const sterilizationIndicator = await prisma.sterilizationIndicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SterilizationIndicatorUpdateManyArgs>(args: SelectSubset<T, SterilizationIndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SterilizationIndicator.
     * @param {SterilizationIndicatorUpsertArgs} args - Arguments to update or create a SterilizationIndicator.
     * @example
     * // Update or create a SterilizationIndicator
     * const sterilizationIndicator = await prisma.sterilizationIndicator.upsert({
     *   create: {
     *     // ... data to create a SterilizationIndicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SterilizationIndicator we want to update
     *   }
     * })
     */
    upsert<T extends SterilizationIndicatorUpsertArgs>(args: SelectSubset<T, SterilizationIndicatorUpsertArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SterilizationIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorCountArgs} args - Arguments to filter SterilizationIndicators to count.
     * @example
     * // Count the number of SterilizationIndicators
     * const count = await prisma.sterilizationIndicator.count({
     *   where: {
     *     // ... the filter for the SterilizationIndicators we want to count
     *   }
     * })
    **/
    count<T extends SterilizationIndicatorCountArgs>(
      args?: Subset<T, SterilizationIndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SterilizationIndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SterilizationIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SterilizationIndicatorAggregateArgs>(args: Subset<T, SterilizationIndicatorAggregateArgs>): Prisma.PrismaPromise<GetSterilizationIndicatorAggregateType<T>>

    /**
     * Group by SterilizationIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SterilizationIndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SterilizationIndicatorGroupByArgs['orderBy'] }
        : { orderBy?: SterilizationIndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SterilizationIndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSterilizationIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SterilizationIndicator model
   */
  readonly fields: SterilizationIndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SterilizationIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SterilizationIndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    specialist<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends SterilizationIndicator$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationIndicator$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findMany"> | Null>
    uses<T extends SterilizationIndicator$usesArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationIndicator$usesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findMany"> | Null>
    encounterDiagnosisLinks<T extends SterilizationIndicator$encounterDiagnosisLinksArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationIndicator$encounterDiagnosisLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SterilizationIndicator model
   */ 
  interface SterilizationIndicatorFieldRefs {
    readonly id: FieldRef<"SterilizationIndicator", 'Int'>
    readonly branchId: FieldRef<"SterilizationIndicator", 'Int'>
    readonly packageName: FieldRef<"SterilizationIndicator", 'String'>
    readonly code: FieldRef<"SterilizationIndicator", 'String'>
    readonly indicatorDate: FieldRef<"SterilizationIndicator", 'DateTime'>
    readonly specialistUserId: FieldRef<"SterilizationIndicator", 'Int'>
    readonly packageQuantity: FieldRef<"SterilizationIndicator", 'Int'>
    readonly createdAt: FieldRef<"SterilizationIndicator", 'DateTime'>
    readonly updatedAt: FieldRef<"SterilizationIndicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SterilizationIndicator findUnique
   */
  export type SterilizationIndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicator to fetch.
     */
    where: SterilizationIndicatorWhereUniqueInput
  }

  /**
   * SterilizationIndicator findUniqueOrThrow
   */
  export type SterilizationIndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicator to fetch.
     */
    where: SterilizationIndicatorWhereUniqueInput
  }

  /**
   * SterilizationIndicator findFirst
   */
  export type SterilizationIndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicator to fetch.
     */
    where?: SterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicators to fetch.
     */
    orderBy?: SterilizationIndicatorOrderByWithRelationInput | SterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationIndicators.
     */
    cursor?: SterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationIndicators.
     */
    distinct?: SterilizationIndicatorScalarFieldEnum | SterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * SterilizationIndicator findFirstOrThrow
   */
  export type SterilizationIndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicator to fetch.
     */
    where?: SterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicators to fetch.
     */
    orderBy?: SterilizationIndicatorOrderByWithRelationInput | SterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationIndicators.
     */
    cursor?: SterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationIndicators.
     */
    distinct?: SterilizationIndicatorScalarFieldEnum | SterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * SterilizationIndicator findMany
   */
  export type SterilizationIndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicators to fetch.
     */
    where?: SterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicators to fetch.
     */
    orderBy?: SterilizationIndicatorOrderByWithRelationInput | SterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SterilizationIndicators.
     */
    cursor?: SterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicators.
     */
    skip?: number
    distinct?: SterilizationIndicatorScalarFieldEnum | SterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * SterilizationIndicator create
   */
  export type SterilizationIndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a SterilizationIndicator.
     */
    data: XOR<SterilizationIndicatorCreateInput, SterilizationIndicatorUncheckedCreateInput>
  }

  /**
   * SterilizationIndicator createMany
   */
  export type SterilizationIndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SterilizationIndicators.
     */
    data: SterilizationIndicatorCreateManyInput | SterilizationIndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SterilizationIndicator createManyAndReturn
   */
  export type SterilizationIndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SterilizationIndicators.
     */
    data: SterilizationIndicatorCreateManyInput | SterilizationIndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SterilizationIndicator update
   */
  export type SterilizationIndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a SterilizationIndicator.
     */
    data: XOR<SterilizationIndicatorUpdateInput, SterilizationIndicatorUncheckedUpdateInput>
    /**
     * Choose, which SterilizationIndicator to update.
     */
    where: SterilizationIndicatorWhereUniqueInput
  }

  /**
   * SterilizationIndicator updateMany
   */
  export type SterilizationIndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SterilizationIndicators.
     */
    data: XOR<SterilizationIndicatorUpdateManyMutationInput, SterilizationIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which SterilizationIndicators to update
     */
    where?: SterilizationIndicatorWhereInput
  }

  /**
   * SterilizationIndicator upsert
   */
  export type SterilizationIndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the SterilizationIndicator to update in case it exists.
     */
    where: SterilizationIndicatorWhereUniqueInput
    /**
     * In case the SterilizationIndicator found by the `where` argument doesn't exist, create a new SterilizationIndicator with this data.
     */
    create: XOR<SterilizationIndicatorCreateInput, SterilizationIndicatorUncheckedCreateInput>
    /**
     * In case the SterilizationIndicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SterilizationIndicatorUpdateInput, SterilizationIndicatorUncheckedUpdateInput>
  }

  /**
   * SterilizationIndicator delete
   */
  export type SterilizationIndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter which SterilizationIndicator to delete.
     */
    where: SterilizationIndicatorWhereUniqueInput
  }

  /**
   * SterilizationIndicator deleteMany
   */
  export type SterilizationIndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationIndicators to delete
     */
    where?: SterilizationIndicatorWhereInput
  }

  /**
   * SterilizationIndicator.items
   */
  export type SterilizationIndicator$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    where?: SterilizationIndicatorItemWhereInput
    orderBy?: SterilizationIndicatorItemOrderByWithRelationInput | SterilizationIndicatorItemOrderByWithRelationInput[]
    cursor?: SterilizationIndicatorItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SterilizationIndicatorItemScalarFieldEnum | SterilizationIndicatorItemScalarFieldEnum[]
  }

  /**
   * SterilizationIndicator.uses
   */
  export type SterilizationIndicator$usesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    where?: EncounterSterilizationPackageUseWhereInput
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterSterilizationPackageUseScalarFieldEnum | EncounterSterilizationPackageUseScalarFieldEnum[]
  }

  /**
   * SterilizationIndicator.encounterDiagnosisLinks
   */
  export type SterilizationIndicator$encounterDiagnosisLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput[]
    cursor?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterDiagnosisSterilizationIndicatorScalarFieldEnum | EncounterDiagnosisSterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * SterilizationIndicator without action
   */
  export type SterilizationIndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
  }


  /**
   * Model SterilizationIndicatorItem
   */

  export type AggregateSterilizationIndicatorItem = {
    _count: SterilizationIndicatorItemCountAggregateOutputType | null
    _avg: SterilizationIndicatorItemAvgAggregateOutputType | null
    _sum: SterilizationIndicatorItemSumAggregateOutputType | null
    _min: SterilizationIndicatorItemMinAggregateOutputType | null
    _max: SterilizationIndicatorItemMaxAggregateOutputType | null
  }

  export type SterilizationIndicatorItemAvgAggregateOutputType = {
    id: number | null
    indicatorId: number | null
    itemId: number | null
  }

  export type SterilizationIndicatorItemSumAggregateOutputType = {
    id: number | null
    indicatorId: number | null
    itemId: number | null
  }

  export type SterilizationIndicatorItemMinAggregateOutputType = {
    id: number | null
    indicatorId: number | null
    itemId: number | null
  }

  export type SterilizationIndicatorItemMaxAggregateOutputType = {
    id: number | null
    indicatorId: number | null
    itemId: number | null
  }

  export type SterilizationIndicatorItemCountAggregateOutputType = {
    id: number
    indicatorId: number
    itemId: number
    _all: number
  }


  export type SterilizationIndicatorItemAvgAggregateInputType = {
    id?: true
    indicatorId?: true
    itemId?: true
  }

  export type SterilizationIndicatorItemSumAggregateInputType = {
    id?: true
    indicatorId?: true
    itemId?: true
  }

  export type SterilizationIndicatorItemMinAggregateInputType = {
    id?: true
    indicatorId?: true
    itemId?: true
  }

  export type SterilizationIndicatorItemMaxAggregateInputType = {
    id?: true
    indicatorId?: true
    itemId?: true
  }

  export type SterilizationIndicatorItemCountAggregateInputType = {
    id?: true
    indicatorId?: true
    itemId?: true
    _all?: true
  }

  export type SterilizationIndicatorItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationIndicatorItem to aggregate.
     */
    where?: SterilizationIndicatorItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicatorItems to fetch.
     */
    orderBy?: SterilizationIndicatorItemOrderByWithRelationInput | SterilizationIndicatorItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SterilizationIndicatorItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicatorItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicatorItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SterilizationIndicatorItems
    **/
    _count?: true | SterilizationIndicatorItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SterilizationIndicatorItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SterilizationIndicatorItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SterilizationIndicatorItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SterilizationIndicatorItemMaxAggregateInputType
  }

  export type GetSterilizationIndicatorItemAggregateType<T extends SterilizationIndicatorItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSterilizationIndicatorItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSterilizationIndicatorItem[P]>
      : GetScalarType<T[P], AggregateSterilizationIndicatorItem[P]>
  }




  export type SterilizationIndicatorItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SterilizationIndicatorItemWhereInput
    orderBy?: SterilizationIndicatorItemOrderByWithAggregationInput | SterilizationIndicatorItemOrderByWithAggregationInput[]
    by: SterilizationIndicatorItemScalarFieldEnum[] | SterilizationIndicatorItemScalarFieldEnum
    having?: SterilizationIndicatorItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SterilizationIndicatorItemCountAggregateInputType | true
    _avg?: SterilizationIndicatorItemAvgAggregateInputType
    _sum?: SterilizationIndicatorItemSumAggregateInputType
    _min?: SterilizationIndicatorItemMinAggregateInputType
    _max?: SterilizationIndicatorItemMaxAggregateInputType
  }

  export type SterilizationIndicatorItemGroupByOutputType = {
    id: number
    indicatorId: number
    itemId: number
    _count: SterilizationIndicatorItemCountAggregateOutputType | null
    _avg: SterilizationIndicatorItemAvgAggregateOutputType | null
    _sum: SterilizationIndicatorItemSumAggregateOutputType | null
    _min: SterilizationIndicatorItemMinAggregateOutputType | null
    _max: SterilizationIndicatorItemMaxAggregateOutputType | null
  }

  type GetSterilizationIndicatorItemGroupByPayload<T extends SterilizationIndicatorItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SterilizationIndicatorItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SterilizationIndicatorItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SterilizationIndicatorItemGroupByOutputType[P]>
            : GetScalarType<T[P], SterilizationIndicatorItemGroupByOutputType[P]>
        }
      >
    >


  export type SterilizationIndicatorItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicatorId?: boolean
    itemId?: boolean
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    item?: boolean | SterilizationItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationIndicatorItem"]>

  export type SterilizationIndicatorItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    indicatorId?: boolean
    itemId?: boolean
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    item?: boolean | SterilizationItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sterilizationIndicatorItem"]>

  export type SterilizationIndicatorItemSelectScalar = {
    id?: boolean
    indicatorId?: boolean
    itemId?: boolean
  }

  export type SterilizationIndicatorItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    item?: boolean | SterilizationItemDefaultArgs<ExtArgs>
  }
  export type SterilizationIndicatorItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    item?: boolean | SterilizationItemDefaultArgs<ExtArgs>
  }

  export type $SterilizationIndicatorItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SterilizationIndicatorItem"
    objects: {
      indicator: Prisma.$SterilizationIndicatorPayload<ExtArgs>
      item: Prisma.$SterilizationItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      indicatorId: number
      itemId: number
    }, ExtArgs["result"]["sterilizationIndicatorItem"]>
    composites: {}
  }

  type SterilizationIndicatorItemGetPayload<S extends boolean | null | undefined | SterilizationIndicatorItemDefaultArgs> = $Result.GetResult<Prisma.$SterilizationIndicatorItemPayload, S>

  type SterilizationIndicatorItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SterilizationIndicatorItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SterilizationIndicatorItemCountAggregateInputType | true
    }

  export interface SterilizationIndicatorItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SterilizationIndicatorItem'], meta: { name: 'SterilizationIndicatorItem' } }
    /**
     * Find zero or one SterilizationIndicatorItem that matches the filter.
     * @param {SterilizationIndicatorItemFindUniqueArgs} args - Arguments to find a SterilizationIndicatorItem
     * @example
     * // Get one SterilizationIndicatorItem
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SterilizationIndicatorItemFindUniqueArgs>(args: SelectSubset<T, SterilizationIndicatorItemFindUniqueArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SterilizationIndicatorItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SterilizationIndicatorItemFindUniqueOrThrowArgs} args - Arguments to find a SterilizationIndicatorItem
     * @example
     * // Get one SterilizationIndicatorItem
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SterilizationIndicatorItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SterilizationIndicatorItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SterilizationIndicatorItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemFindFirstArgs} args - Arguments to find a SterilizationIndicatorItem
     * @example
     * // Get one SterilizationIndicatorItem
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SterilizationIndicatorItemFindFirstArgs>(args?: SelectSubset<T, SterilizationIndicatorItemFindFirstArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SterilizationIndicatorItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemFindFirstOrThrowArgs} args - Arguments to find a SterilizationIndicatorItem
     * @example
     * // Get one SterilizationIndicatorItem
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SterilizationIndicatorItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SterilizationIndicatorItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SterilizationIndicatorItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SterilizationIndicatorItems
     * const sterilizationIndicatorItems = await prisma.sterilizationIndicatorItem.findMany()
     * 
     * // Get first 10 SterilizationIndicatorItems
     * const sterilizationIndicatorItems = await prisma.sterilizationIndicatorItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sterilizationIndicatorItemWithIdOnly = await prisma.sterilizationIndicatorItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SterilizationIndicatorItemFindManyArgs>(args?: SelectSubset<T, SterilizationIndicatorItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SterilizationIndicatorItem.
     * @param {SterilizationIndicatorItemCreateArgs} args - Arguments to create a SterilizationIndicatorItem.
     * @example
     * // Create one SterilizationIndicatorItem
     * const SterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.create({
     *   data: {
     *     // ... data to create a SterilizationIndicatorItem
     *   }
     * })
     * 
     */
    create<T extends SterilizationIndicatorItemCreateArgs>(args: SelectSubset<T, SterilizationIndicatorItemCreateArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SterilizationIndicatorItems.
     * @param {SterilizationIndicatorItemCreateManyArgs} args - Arguments to create many SterilizationIndicatorItems.
     * @example
     * // Create many SterilizationIndicatorItems
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SterilizationIndicatorItemCreateManyArgs>(args?: SelectSubset<T, SterilizationIndicatorItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SterilizationIndicatorItems and returns the data saved in the database.
     * @param {SterilizationIndicatorItemCreateManyAndReturnArgs} args - Arguments to create many SterilizationIndicatorItems.
     * @example
     * // Create many SterilizationIndicatorItems
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SterilizationIndicatorItems and only return the `id`
     * const sterilizationIndicatorItemWithIdOnly = await prisma.sterilizationIndicatorItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SterilizationIndicatorItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SterilizationIndicatorItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SterilizationIndicatorItem.
     * @param {SterilizationIndicatorItemDeleteArgs} args - Arguments to delete one SterilizationIndicatorItem.
     * @example
     * // Delete one SterilizationIndicatorItem
     * const SterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.delete({
     *   where: {
     *     // ... filter to delete one SterilizationIndicatorItem
     *   }
     * })
     * 
     */
    delete<T extends SterilizationIndicatorItemDeleteArgs>(args: SelectSubset<T, SterilizationIndicatorItemDeleteArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SterilizationIndicatorItem.
     * @param {SterilizationIndicatorItemUpdateArgs} args - Arguments to update one SterilizationIndicatorItem.
     * @example
     * // Update one SterilizationIndicatorItem
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SterilizationIndicatorItemUpdateArgs>(args: SelectSubset<T, SterilizationIndicatorItemUpdateArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SterilizationIndicatorItems.
     * @param {SterilizationIndicatorItemDeleteManyArgs} args - Arguments to filter SterilizationIndicatorItems to delete.
     * @example
     * // Delete a few SterilizationIndicatorItems
     * const { count } = await prisma.sterilizationIndicatorItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SterilizationIndicatorItemDeleteManyArgs>(args?: SelectSubset<T, SterilizationIndicatorItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SterilizationIndicatorItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SterilizationIndicatorItems
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SterilizationIndicatorItemUpdateManyArgs>(args: SelectSubset<T, SterilizationIndicatorItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SterilizationIndicatorItem.
     * @param {SterilizationIndicatorItemUpsertArgs} args - Arguments to update or create a SterilizationIndicatorItem.
     * @example
     * // Update or create a SterilizationIndicatorItem
     * const sterilizationIndicatorItem = await prisma.sterilizationIndicatorItem.upsert({
     *   create: {
     *     // ... data to create a SterilizationIndicatorItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SterilizationIndicatorItem we want to update
     *   }
     * })
     */
    upsert<T extends SterilizationIndicatorItemUpsertArgs>(args: SelectSubset<T, SterilizationIndicatorItemUpsertArgs<ExtArgs>>): Prisma__SterilizationIndicatorItemClient<$Result.GetResult<Prisma.$SterilizationIndicatorItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SterilizationIndicatorItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemCountArgs} args - Arguments to filter SterilizationIndicatorItems to count.
     * @example
     * // Count the number of SterilizationIndicatorItems
     * const count = await prisma.sterilizationIndicatorItem.count({
     *   where: {
     *     // ... the filter for the SterilizationIndicatorItems we want to count
     *   }
     * })
    **/
    count<T extends SterilizationIndicatorItemCountArgs>(
      args?: Subset<T, SterilizationIndicatorItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SterilizationIndicatorItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SterilizationIndicatorItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SterilizationIndicatorItemAggregateArgs>(args: Subset<T, SterilizationIndicatorItemAggregateArgs>): Prisma.PrismaPromise<GetSterilizationIndicatorItemAggregateType<T>>

    /**
     * Group by SterilizationIndicatorItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SterilizationIndicatorItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SterilizationIndicatorItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SterilizationIndicatorItemGroupByArgs['orderBy'] }
        : { orderBy?: SterilizationIndicatorItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SterilizationIndicatorItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSterilizationIndicatorItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SterilizationIndicatorItem model
   */
  readonly fields: SterilizationIndicatorItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SterilizationIndicatorItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SterilizationIndicatorItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicator<T extends SterilizationIndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationIndicatorDefaultArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends SterilizationItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationItemDefaultArgs<ExtArgs>>): Prisma__SterilizationItemClient<$Result.GetResult<Prisma.$SterilizationItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SterilizationIndicatorItem model
   */ 
  interface SterilizationIndicatorItemFieldRefs {
    readonly id: FieldRef<"SterilizationIndicatorItem", 'Int'>
    readonly indicatorId: FieldRef<"SterilizationIndicatorItem", 'Int'>
    readonly itemId: FieldRef<"SterilizationIndicatorItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SterilizationIndicatorItem findUnique
   */
  export type SterilizationIndicatorItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicatorItem to fetch.
     */
    where: SterilizationIndicatorItemWhereUniqueInput
  }

  /**
   * SterilizationIndicatorItem findUniqueOrThrow
   */
  export type SterilizationIndicatorItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicatorItem to fetch.
     */
    where: SterilizationIndicatorItemWhereUniqueInput
  }

  /**
   * SterilizationIndicatorItem findFirst
   */
  export type SterilizationIndicatorItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicatorItem to fetch.
     */
    where?: SterilizationIndicatorItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicatorItems to fetch.
     */
    orderBy?: SterilizationIndicatorItemOrderByWithRelationInput | SterilizationIndicatorItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationIndicatorItems.
     */
    cursor?: SterilizationIndicatorItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicatorItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicatorItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationIndicatorItems.
     */
    distinct?: SterilizationIndicatorItemScalarFieldEnum | SterilizationIndicatorItemScalarFieldEnum[]
  }

  /**
   * SterilizationIndicatorItem findFirstOrThrow
   */
  export type SterilizationIndicatorItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicatorItem to fetch.
     */
    where?: SterilizationIndicatorItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicatorItems to fetch.
     */
    orderBy?: SterilizationIndicatorItemOrderByWithRelationInput | SterilizationIndicatorItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SterilizationIndicatorItems.
     */
    cursor?: SterilizationIndicatorItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicatorItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicatorItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SterilizationIndicatorItems.
     */
    distinct?: SterilizationIndicatorItemScalarFieldEnum | SterilizationIndicatorItemScalarFieldEnum[]
  }

  /**
   * SterilizationIndicatorItem findMany
   */
  export type SterilizationIndicatorItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * Filter, which SterilizationIndicatorItems to fetch.
     */
    where?: SterilizationIndicatorItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SterilizationIndicatorItems to fetch.
     */
    orderBy?: SterilizationIndicatorItemOrderByWithRelationInput | SterilizationIndicatorItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SterilizationIndicatorItems.
     */
    cursor?: SterilizationIndicatorItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SterilizationIndicatorItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SterilizationIndicatorItems.
     */
    skip?: number
    distinct?: SterilizationIndicatorItemScalarFieldEnum | SterilizationIndicatorItemScalarFieldEnum[]
  }

  /**
   * SterilizationIndicatorItem create
   */
  export type SterilizationIndicatorItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SterilizationIndicatorItem.
     */
    data: XOR<SterilizationIndicatorItemCreateInput, SterilizationIndicatorItemUncheckedCreateInput>
  }

  /**
   * SterilizationIndicatorItem createMany
   */
  export type SterilizationIndicatorItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SterilizationIndicatorItems.
     */
    data: SterilizationIndicatorItemCreateManyInput | SterilizationIndicatorItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SterilizationIndicatorItem createManyAndReturn
   */
  export type SterilizationIndicatorItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SterilizationIndicatorItems.
     */
    data: SterilizationIndicatorItemCreateManyInput | SterilizationIndicatorItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SterilizationIndicatorItem update
   */
  export type SterilizationIndicatorItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SterilizationIndicatorItem.
     */
    data: XOR<SterilizationIndicatorItemUpdateInput, SterilizationIndicatorItemUncheckedUpdateInput>
    /**
     * Choose, which SterilizationIndicatorItem to update.
     */
    where: SterilizationIndicatorItemWhereUniqueInput
  }

  /**
   * SterilizationIndicatorItem updateMany
   */
  export type SterilizationIndicatorItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SterilizationIndicatorItems.
     */
    data: XOR<SterilizationIndicatorItemUpdateManyMutationInput, SterilizationIndicatorItemUncheckedUpdateManyInput>
    /**
     * Filter which SterilizationIndicatorItems to update
     */
    where?: SterilizationIndicatorItemWhereInput
  }

  /**
   * SterilizationIndicatorItem upsert
   */
  export type SterilizationIndicatorItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SterilizationIndicatorItem to update in case it exists.
     */
    where: SterilizationIndicatorItemWhereUniqueInput
    /**
     * In case the SterilizationIndicatorItem found by the `where` argument doesn't exist, create a new SterilizationIndicatorItem with this data.
     */
    create: XOR<SterilizationIndicatorItemCreateInput, SterilizationIndicatorItemUncheckedCreateInput>
    /**
     * In case the SterilizationIndicatorItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SterilizationIndicatorItemUpdateInput, SterilizationIndicatorItemUncheckedUpdateInput>
  }

  /**
   * SterilizationIndicatorItem delete
   */
  export type SterilizationIndicatorItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
    /**
     * Filter which SterilizationIndicatorItem to delete.
     */
    where: SterilizationIndicatorItemWhereUniqueInput
  }

  /**
   * SterilizationIndicatorItem deleteMany
   */
  export type SterilizationIndicatorItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SterilizationIndicatorItems to delete
     */
    where?: SterilizationIndicatorItemWhereInput
  }

  /**
   * SterilizationIndicatorItem without action
   */
  export type SterilizationIndicatorItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicatorItem
     */
    select?: SterilizationIndicatorItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorItemInclude<ExtArgs> | null
  }


  /**
   * Model EncounterSterilizationPackageUse
   */

  export type AggregateEncounterSterilizationPackageUse = {
    _count: EncounterSterilizationPackageUseCountAggregateOutputType | null
    _avg: EncounterSterilizationPackageUseAvgAggregateOutputType | null
    _sum: EncounterSterilizationPackageUseSumAggregateOutputType | null
    _min: EncounterSterilizationPackageUseMinAggregateOutputType | null
    _max: EncounterSterilizationPackageUseMaxAggregateOutputType | null
  }

  export type EncounterSterilizationPackageUseAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
    indicatorId: number | null
    usedQuantity: number | null
    openedByUserId: number | null
  }

  export type EncounterSterilizationPackageUseSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
    indicatorId: number | null
    usedQuantity: number | null
    openedByUserId: number | null
  }

  export type EncounterSterilizationPackageUseMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    indicatorId: number | null
    usedQuantity: number | null
    openedByUserId: number | null
    createdAt: Date | null
  }

  export type EncounterSterilizationPackageUseMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    indicatorId: number | null
    usedQuantity: number | null
    openedByUserId: number | null
    createdAt: Date | null
  }

  export type EncounterSterilizationPackageUseCountAggregateOutputType = {
    id: number
    encounterId: number
    indicatorId: number
    usedQuantity: number
    openedByUserId: number
    createdAt: number
    _all: number
  }


  export type EncounterSterilizationPackageUseAvgAggregateInputType = {
    id?: true
    encounterId?: true
    indicatorId?: true
    usedQuantity?: true
    openedByUserId?: true
  }

  export type EncounterSterilizationPackageUseSumAggregateInputType = {
    id?: true
    encounterId?: true
    indicatorId?: true
    usedQuantity?: true
    openedByUserId?: true
  }

  export type EncounterSterilizationPackageUseMinAggregateInputType = {
    id?: true
    encounterId?: true
    indicatorId?: true
    usedQuantity?: true
    openedByUserId?: true
    createdAt?: true
  }

  export type EncounterSterilizationPackageUseMaxAggregateInputType = {
    id?: true
    encounterId?: true
    indicatorId?: true
    usedQuantity?: true
    openedByUserId?: true
    createdAt?: true
  }

  export type EncounterSterilizationPackageUseCountAggregateInputType = {
    id?: true
    encounterId?: true
    indicatorId?: true
    usedQuantity?: true
    openedByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type EncounterSterilizationPackageUseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterSterilizationPackageUse to aggregate.
     */
    where?: EncounterSterilizationPackageUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSterilizationPackageUses to fetch.
     */
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSterilizationPackageUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSterilizationPackageUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterSterilizationPackageUses
    **/
    _count?: true | EncounterSterilizationPackageUseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterSterilizationPackageUseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSterilizationPackageUseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterSterilizationPackageUseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterSterilizationPackageUseMaxAggregateInputType
  }

  export type GetEncounterSterilizationPackageUseAggregateType<T extends EncounterSterilizationPackageUseAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterSterilizationPackageUse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterSterilizationPackageUse[P]>
      : GetScalarType<T[P], AggregateEncounterSterilizationPackageUse[P]>
  }




  export type EncounterSterilizationPackageUseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSterilizationPackageUseWhereInput
    orderBy?: EncounterSterilizationPackageUseOrderByWithAggregationInput | EncounterSterilizationPackageUseOrderByWithAggregationInput[]
    by: EncounterSterilizationPackageUseScalarFieldEnum[] | EncounterSterilizationPackageUseScalarFieldEnum
    having?: EncounterSterilizationPackageUseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterSterilizationPackageUseCountAggregateInputType | true
    _avg?: EncounterSterilizationPackageUseAvgAggregateInputType
    _sum?: EncounterSterilizationPackageUseSumAggregateInputType
    _min?: EncounterSterilizationPackageUseMinAggregateInputType
    _max?: EncounterSterilizationPackageUseMaxAggregateInputType
  }

  export type EncounterSterilizationPackageUseGroupByOutputType = {
    id: number
    encounterId: number
    indicatorId: number
    usedQuantity: number
    openedByUserId: number | null
    createdAt: Date
    _count: EncounterSterilizationPackageUseCountAggregateOutputType | null
    _avg: EncounterSterilizationPackageUseAvgAggregateOutputType | null
    _sum: EncounterSterilizationPackageUseSumAggregateOutputType | null
    _min: EncounterSterilizationPackageUseMinAggregateOutputType | null
    _max: EncounterSterilizationPackageUseMaxAggregateOutputType | null
  }

  type GetEncounterSterilizationPackageUseGroupByPayload<T extends EncounterSterilizationPackageUseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterSterilizationPackageUseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterSterilizationPackageUseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterSterilizationPackageUseGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterSterilizationPackageUseGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSterilizationPackageUseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    indicatorId?: boolean
    usedQuantity?: boolean
    openedByUserId?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    openedBy?: boolean | EncounterSterilizationPackageUse$openedByArgs<ExtArgs>
  }, ExtArgs["result"]["encounterSterilizationPackageUse"]>

  export type EncounterSterilizationPackageUseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    indicatorId?: boolean
    usedQuantity?: boolean
    openedByUserId?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    openedBy?: boolean | EncounterSterilizationPackageUse$openedByArgs<ExtArgs>
  }, ExtArgs["result"]["encounterSterilizationPackageUse"]>

  export type EncounterSterilizationPackageUseSelectScalar = {
    id?: boolean
    encounterId?: boolean
    indicatorId?: boolean
    usedQuantity?: boolean
    openedByUserId?: boolean
    createdAt?: boolean
  }

  export type EncounterSterilizationPackageUseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    openedBy?: boolean | EncounterSterilizationPackageUse$openedByArgs<ExtArgs>
  }
  export type EncounterSterilizationPackageUseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
    openedBy?: boolean | EncounterSterilizationPackageUse$openedByArgs<ExtArgs>
  }

  export type $EncounterSterilizationPackageUsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterSterilizationPackageUse"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      indicator: Prisma.$SterilizationIndicatorPayload<ExtArgs>
      openedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      indicatorId: number
      usedQuantity: number
      openedByUserId: number | null
      createdAt: Date
    }, ExtArgs["result"]["encounterSterilizationPackageUse"]>
    composites: {}
  }

  type EncounterSterilizationPackageUseGetPayload<S extends boolean | null | undefined | EncounterSterilizationPackageUseDefaultArgs> = $Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload, S>

  type EncounterSterilizationPackageUseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterSterilizationPackageUseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterSterilizationPackageUseCountAggregateInputType | true
    }

  export interface EncounterSterilizationPackageUseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterSterilizationPackageUse'], meta: { name: 'EncounterSterilizationPackageUse' } }
    /**
     * Find zero or one EncounterSterilizationPackageUse that matches the filter.
     * @param {EncounterSterilizationPackageUseFindUniqueArgs} args - Arguments to find a EncounterSterilizationPackageUse
     * @example
     * // Get one EncounterSterilizationPackageUse
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterSterilizationPackageUseFindUniqueArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseFindUniqueArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterSterilizationPackageUse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterSterilizationPackageUseFindUniqueOrThrowArgs} args - Arguments to find a EncounterSterilizationPackageUse
     * @example
     * // Get one EncounterSterilizationPackageUse
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterSterilizationPackageUseFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterSterilizationPackageUse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseFindFirstArgs} args - Arguments to find a EncounterSterilizationPackageUse
     * @example
     * // Get one EncounterSterilizationPackageUse
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterSterilizationPackageUseFindFirstArgs>(args?: SelectSubset<T, EncounterSterilizationPackageUseFindFirstArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterSterilizationPackageUse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseFindFirstOrThrowArgs} args - Arguments to find a EncounterSterilizationPackageUse
     * @example
     * // Get one EncounterSterilizationPackageUse
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterSterilizationPackageUseFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterSterilizationPackageUseFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterSterilizationPackageUses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterSterilizationPackageUses
     * const encounterSterilizationPackageUses = await prisma.encounterSterilizationPackageUse.findMany()
     * 
     * // Get first 10 EncounterSterilizationPackageUses
     * const encounterSterilizationPackageUses = await prisma.encounterSterilizationPackageUse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterSterilizationPackageUseWithIdOnly = await prisma.encounterSterilizationPackageUse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterSterilizationPackageUseFindManyArgs>(args?: SelectSubset<T, EncounterSterilizationPackageUseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterSterilizationPackageUse.
     * @param {EncounterSterilizationPackageUseCreateArgs} args - Arguments to create a EncounterSterilizationPackageUse.
     * @example
     * // Create one EncounterSterilizationPackageUse
     * const EncounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.create({
     *   data: {
     *     // ... data to create a EncounterSterilizationPackageUse
     *   }
     * })
     * 
     */
    create<T extends EncounterSterilizationPackageUseCreateArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseCreateArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterSterilizationPackageUses.
     * @param {EncounterSterilizationPackageUseCreateManyArgs} args - Arguments to create many EncounterSterilizationPackageUses.
     * @example
     * // Create many EncounterSterilizationPackageUses
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterSterilizationPackageUseCreateManyArgs>(args?: SelectSubset<T, EncounterSterilizationPackageUseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterSterilizationPackageUses and returns the data saved in the database.
     * @param {EncounterSterilizationPackageUseCreateManyAndReturnArgs} args - Arguments to create many EncounterSterilizationPackageUses.
     * @example
     * // Create many EncounterSterilizationPackageUses
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterSterilizationPackageUses and only return the `id`
     * const encounterSterilizationPackageUseWithIdOnly = await prisma.encounterSterilizationPackageUse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterSterilizationPackageUseCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterSterilizationPackageUseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterSterilizationPackageUse.
     * @param {EncounterSterilizationPackageUseDeleteArgs} args - Arguments to delete one EncounterSterilizationPackageUse.
     * @example
     * // Delete one EncounterSterilizationPackageUse
     * const EncounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.delete({
     *   where: {
     *     // ... filter to delete one EncounterSterilizationPackageUse
     *   }
     * })
     * 
     */
    delete<T extends EncounterSterilizationPackageUseDeleteArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseDeleteArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterSterilizationPackageUse.
     * @param {EncounterSterilizationPackageUseUpdateArgs} args - Arguments to update one EncounterSterilizationPackageUse.
     * @example
     * // Update one EncounterSterilizationPackageUse
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterSterilizationPackageUseUpdateArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseUpdateArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterSterilizationPackageUses.
     * @param {EncounterSterilizationPackageUseDeleteManyArgs} args - Arguments to filter EncounterSterilizationPackageUses to delete.
     * @example
     * // Delete a few EncounterSterilizationPackageUses
     * const { count } = await prisma.encounterSterilizationPackageUse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterSterilizationPackageUseDeleteManyArgs>(args?: SelectSubset<T, EncounterSterilizationPackageUseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterSterilizationPackageUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterSterilizationPackageUses
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterSterilizationPackageUseUpdateManyArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterSterilizationPackageUse.
     * @param {EncounterSterilizationPackageUseUpsertArgs} args - Arguments to update or create a EncounterSterilizationPackageUse.
     * @example
     * // Update or create a EncounterSterilizationPackageUse
     * const encounterSterilizationPackageUse = await prisma.encounterSterilizationPackageUse.upsert({
     *   create: {
     *     // ... data to create a EncounterSterilizationPackageUse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterSterilizationPackageUse we want to update
     *   }
     * })
     */
    upsert<T extends EncounterSterilizationPackageUseUpsertArgs>(args: SelectSubset<T, EncounterSterilizationPackageUseUpsertArgs<ExtArgs>>): Prisma__EncounterSterilizationPackageUseClient<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterSterilizationPackageUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseCountArgs} args - Arguments to filter EncounterSterilizationPackageUses to count.
     * @example
     * // Count the number of EncounterSterilizationPackageUses
     * const count = await prisma.encounterSterilizationPackageUse.count({
     *   where: {
     *     // ... the filter for the EncounterSterilizationPackageUses we want to count
     *   }
     * })
    **/
    count<T extends EncounterSterilizationPackageUseCountArgs>(
      args?: Subset<T, EncounterSterilizationPackageUseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterSterilizationPackageUseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterSterilizationPackageUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterSterilizationPackageUseAggregateArgs>(args: Subset<T, EncounterSterilizationPackageUseAggregateArgs>): Prisma.PrismaPromise<GetEncounterSterilizationPackageUseAggregateType<T>>

    /**
     * Group by EncounterSterilizationPackageUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSterilizationPackageUseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterSterilizationPackageUseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterSterilizationPackageUseGroupByArgs['orderBy'] }
        : { orderBy?: EncounterSterilizationPackageUseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterSterilizationPackageUseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterSterilizationPackageUseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterSterilizationPackageUse model
   */
  readonly fields: EncounterSterilizationPackageUseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterSterilizationPackageUse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterSterilizationPackageUseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicator<T extends SterilizationIndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationIndicatorDefaultArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    openedBy<T extends EncounterSterilizationPackageUse$openedByArgs<ExtArgs> = {}>(args?: Subset<T, EncounterSterilizationPackageUse$openedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterSterilizationPackageUse model
   */ 
  interface EncounterSterilizationPackageUseFieldRefs {
    readonly id: FieldRef<"EncounterSterilizationPackageUse", 'Int'>
    readonly encounterId: FieldRef<"EncounterSterilizationPackageUse", 'Int'>
    readonly indicatorId: FieldRef<"EncounterSterilizationPackageUse", 'Int'>
    readonly usedQuantity: FieldRef<"EncounterSterilizationPackageUse", 'Int'>
    readonly openedByUserId: FieldRef<"EncounterSterilizationPackageUse", 'Int'>
    readonly createdAt: FieldRef<"EncounterSterilizationPackageUse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterSterilizationPackageUse findUnique
   */
  export type EncounterSterilizationPackageUseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSterilizationPackageUse to fetch.
     */
    where: EncounterSterilizationPackageUseWhereUniqueInput
  }

  /**
   * EncounterSterilizationPackageUse findUniqueOrThrow
   */
  export type EncounterSterilizationPackageUseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSterilizationPackageUse to fetch.
     */
    where: EncounterSterilizationPackageUseWhereUniqueInput
  }

  /**
   * EncounterSterilizationPackageUse findFirst
   */
  export type EncounterSterilizationPackageUseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSterilizationPackageUse to fetch.
     */
    where?: EncounterSterilizationPackageUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSterilizationPackageUses to fetch.
     */
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterSterilizationPackageUses.
     */
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSterilizationPackageUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSterilizationPackageUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterSterilizationPackageUses.
     */
    distinct?: EncounterSterilizationPackageUseScalarFieldEnum | EncounterSterilizationPackageUseScalarFieldEnum[]
  }

  /**
   * EncounterSterilizationPackageUse findFirstOrThrow
   */
  export type EncounterSterilizationPackageUseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSterilizationPackageUse to fetch.
     */
    where?: EncounterSterilizationPackageUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSterilizationPackageUses to fetch.
     */
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterSterilizationPackageUses.
     */
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSterilizationPackageUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSterilizationPackageUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterSterilizationPackageUses.
     */
    distinct?: EncounterSterilizationPackageUseScalarFieldEnum | EncounterSterilizationPackageUseScalarFieldEnum[]
  }

  /**
   * EncounterSterilizationPackageUse findMany
   */
  export type EncounterSterilizationPackageUseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSterilizationPackageUses to fetch.
     */
    where?: EncounterSterilizationPackageUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSterilizationPackageUses to fetch.
     */
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterSterilizationPackageUses.
     */
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSterilizationPackageUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSterilizationPackageUses.
     */
    skip?: number
    distinct?: EncounterSterilizationPackageUseScalarFieldEnum | EncounterSterilizationPackageUseScalarFieldEnum[]
  }

  /**
   * EncounterSterilizationPackageUse create
   */
  export type EncounterSterilizationPackageUseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterSterilizationPackageUse.
     */
    data: XOR<EncounterSterilizationPackageUseCreateInput, EncounterSterilizationPackageUseUncheckedCreateInput>
  }

  /**
   * EncounterSterilizationPackageUse createMany
   */
  export type EncounterSterilizationPackageUseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterSterilizationPackageUses.
     */
    data: EncounterSterilizationPackageUseCreateManyInput | EncounterSterilizationPackageUseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterSterilizationPackageUse createManyAndReturn
   */
  export type EncounterSterilizationPackageUseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterSterilizationPackageUses.
     */
    data: EncounterSterilizationPackageUseCreateManyInput | EncounterSterilizationPackageUseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterSterilizationPackageUse update
   */
  export type EncounterSterilizationPackageUseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterSterilizationPackageUse.
     */
    data: XOR<EncounterSterilizationPackageUseUpdateInput, EncounterSterilizationPackageUseUncheckedUpdateInput>
    /**
     * Choose, which EncounterSterilizationPackageUse to update.
     */
    where: EncounterSterilizationPackageUseWhereUniqueInput
  }

  /**
   * EncounterSterilizationPackageUse updateMany
   */
  export type EncounterSterilizationPackageUseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterSterilizationPackageUses.
     */
    data: XOR<EncounterSterilizationPackageUseUpdateManyMutationInput, EncounterSterilizationPackageUseUncheckedUpdateManyInput>
    /**
     * Filter which EncounterSterilizationPackageUses to update
     */
    where?: EncounterSterilizationPackageUseWhereInput
  }

  /**
   * EncounterSterilizationPackageUse upsert
   */
  export type EncounterSterilizationPackageUseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterSterilizationPackageUse to update in case it exists.
     */
    where: EncounterSterilizationPackageUseWhereUniqueInput
    /**
     * In case the EncounterSterilizationPackageUse found by the `where` argument doesn't exist, create a new EncounterSterilizationPackageUse with this data.
     */
    create: XOR<EncounterSterilizationPackageUseCreateInput, EncounterSterilizationPackageUseUncheckedCreateInput>
    /**
     * In case the EncounterSterilizationPackageUse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterSterilizationPackageUseUpdateInput, EncounterSterilizationPackageUseUncheckedUpdateInput>
  }

  /**
   * EncounterSterilizationPackageUse delete
   */
  export type EncounterSterilizationPackageUseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    /**
     * Filter which EncounterSterilizationPackageUse to delete.
     */
    where: EncounterSterilizationPackageUseWhereUniqueInput
  }

  /**
   * EncounterSterilizationPackageUse deleteMany
   */
  export type EncounterSterilizationPackageUseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterSterilizationPackageUses to delete
     */
    where?: EncounterSterilizationPackageUseWhereInput
  }

  /**
   * EncounterSterilizationPackageUse.openedBy
   */
  export type EncounterSterilizationPackageUse$openedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EncounterSterilizationPackageUse without action
   */
  export type EncounterSterilizationPackageUseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    calendarOrder: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    calendarOrder: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    ovog: string | null
    name: string | null
    role: $Enums.UserRole | null
    branchId: number | null
    createdAt: Date | null
    phone: string | null
    regNo: string | null
    licenseNumber: string | null
    licenseExpiryDate: Date | null
    signatureImagePath: string | null
    stampImagePath: string | null
    idPhotoPath: string | null
    calendarOrder: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    ovog: string | null
    name: string | null
    role: $Enums.UserRole | null
    branchId: number | null
    createdAt: Date | null
    phone: string | null
    regNo: string | null
    licenseNumber: string | null
    licenseExpiryDate: Date | null
    signatureImagePath: string | null
    stampImagePath: string | null
    idPhotoPath: string | null
    calendarOrder: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    ovog: number
    name: number
    role: number
    branchId: number
    createdAt: number
    phone: number
    regNo: number
    licenseNumber: number
    licenseExpiryDate: number
    signatureImagePath: number
    stampImagePath: number
    idPhotoPath: number
    calendarOrder: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    branchId?: true
    calendarOrder?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    branchId?: true
    calendarOrder?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    ovog?: true
    name?: true
    role?: true
    branchId?: true
    createdAt?: true
    phone?: true
    regNo?: true
    licenseNumber?: true
    licenseExpiryDate?: true
    signatureImagePath?: true
    stampImagePath?: true
    idPhotoPath?: true
    calendarOrder?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    ovog?: true
    name?: true
    role?: true
    branchId?: true
    createdAt?: true
    phone?: true
    regNo?: true
    licenseNumber?: true
    licenseExpiryDate?: true
    signatureImagePath?: true
    stampImagePath?: true
    idPhotoPath?: true
    calendarOrder?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    ovog?: true
    name?: true
    role?: true
    branchId?: true
    createdAt?: true
    phone?: true
    regNo?: true
    licenseNumber?: true
    licenseExpiryDate?: true
    signatureImagePath?: true
    stampImagePath?: true
    idPhotoPath?: true
    calendarOrder?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    ovog: string | null
    name: string | null
    role: $Enums.UserRole
    branchId: number | null
    createdAt: Date
    phone: string | null
    regNo: string | null
    licenseNumber: string | null
    licenseExpiryDate: Date | null
    signatureImagePath: string | null
    stampImagePath: string | null
    idPhotoPath: string | null
    calendarOrder: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    ovog?: boolean
    name?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    phone?: boolean
    regNo?: boolean
    licenseNumber?: boolean
    licenseExpiryDate?: boolean
    signatureImagePath?: boolean
    stampImagePath?: boolean
    idPhotoPath?: boolean
    calendarOrder?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    encounters?: boolean | User$encountersArgs<ExtArgs>
    nurseEncounters?: boolean | User$nurseEncountersArgs<ExtArgs>
    doctorSchedules?: boolean | User$doctorSchedulesArgs<ExtArgs>
    doctorBranches?: boolean | User$doctorBranchesArgs<ExtArgs>
    receptionSchedules?: boolean | User$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | User$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | User$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | User$nurseBranchesArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    employeeBenefits?: boolean | User$employeeBenefitsArgs<ExtArgs>
    createdLedgerEntries?: boolean | User$createdLedgerEntriesArgs<ExtArgs>
    approvedLedgerEntries?: boolean | User$approvedLedgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | User$employeeVouchersArgs<ExtArgs>
    createdEmployeeVouchers?: boolean | User$createdEmployeeVouchersArgs<ExtArgs>
    authorizationCodes?: boolean | User$authorizationCodesArgs<ExtArgs>
    sterilizationIndicators?: boolean | User$sterilizationIndicatorsArgs<ExtArgs>
    openedSterilizationPackages?: boolean | User$openedSterilizationPackagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    ovog?: boolean
    name?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    phone?: boolean
    regNo?: boolean
    licenseNumber?: boolean
    licenseExpiryDate?: boolean
    signatureImagePath?: boolean
    stampImagePath?: boolean
    idPhotoPath?: boolean
    calendarOrder?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    ovog?: boolean
    name?: boolean
    role?: boolean
    branchId?: boolean
    createdAt?: boolean
    phone?: boolean
    regNo?: boolean
    licenseNumber?: boolean
    licenseExpiryDate?: boolean
    signatureImagePath?: boolean
    stampImagePath?: boolean
    idPhotoPath?: boolean
    calendarOrder?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    encounters?: boolean | User$encountersArgs<ExtArgs>
    nurseEncounters?: boolean | User$nurseEncountersArgs<ExtArgs>
    doctorSchedules?: boolean | User$doctorSchedulesArgs<ExtArgs>
    doctorBranches?: boolean | User$doctorBranchesArgs<ExtArgs>
    receptionSchedules?: boolean | User$receptionSchedulesArgs<ExtArgs>
    receptionBranches?: boolean | User$receptionBranchesArgs<ExtArgs>
    nurseSchedules?: boolean | User$nurseSchedulesArgs<ExtArgs>
    nurseBranches?: boolean | User$nurseBranchesArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    employeeBenefits?: boolean | User$employeeBenefitsArgs<ExtArgs>
    createdLedgerEntries?: boolean | User$createdLedgerEntriesArgs<ExtArgs>
    approvedLedgerEntries?: boolean | User$approvedLedgerEntriesArgs<ExtArgs>
    employeeVouchers?: boolean | User$employeeVouchersArgs<ExtArgs>
    createdEmployeeVouchers?: boolean | User$createdEmployeeVouchersArgs<ExtArgs>
    authorizationCodes?: boolean | User$authorizationCodesArgs<ExtArgs>
    sterilizationIndicators?: boolean | User$sterilizationIndicatorsArgs<ExtArgs>
    openedSterilizationPackages?: boolean | User$openedSterilizationPackagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      nurseEncounters: Prisma.$EncounterPayload<ExtArgs>[]
      doctorSchedules: Prisma.$DoctorSchedulePayload<ExtArgs>[]
      doctorBranches: Prisma.$DoctorBranchPayload<ExtArgs>[]
      receptionSchedules: Prisma.$ReceptionSchedulePayload<ExtArgs>[]
      receptionBranches: Prisma.$ReceptionBranchPayload<ExtArgs>[]
      nurseSchedules: Prisma.$NurseSchedulePayload<ExtArgs>[]
      nurseBranches: Prisma.$NurseBranchPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      employeeBenefits: Prisma.$EmployeeBenefitPayload<ExtArgs>[]
      createdLedgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      approvedLedgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      employeeVouchers: Prisma.$EmployeeVoucherPayload<ExtArgs>[]
      createdEmployeeVouchers: Prisma.$EmployeeVoucherPayload<ExtArgs>[]
      authorizationCodes: Prisma.$AuthorizationCodePayload<ExtArgs>[]
      sterilizationIndicators: Prisma.$SterilizationIndicatorPayload<ExtArgs>[]
      openedSterilizationPackages: Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      ovog: string | null
      name: string | null
      role: $Enums.UserRole
      branchId: number | null
      createdAt: Date
      phone: string | null
      regNo: string | null
      licenseNumber: string | null
      licenseExpiryDate: Date | null
      signatureImagePath: string | null
      stampImagePath: string | null
      idPhotoPath: string | null
      calendarOrder: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    encounters<T extends User$encountersArgs<ExtArgs> = {}>(args?: Subset<T, User$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    nurseEncounters<T extends User$nurseEncountersArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseEncountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    doctorSchedules<T extends User$doctorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    doctorBranches<T extends User$doctorBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findMany"> | Null>
    receptionSchedules<T extends User$receptionSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$receptionSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    receptionBranches<T extends User$receptionBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$receptionBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findMany"> | Null>
    nurseSchedules<T extends User$nurseSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    nurseBranches<T extends User$nurseBranchesArgs<ExtArgs> = {}>(args?: Subset<T, User$nurseBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    employeeBenefits<T extends User$employeeBenefitsArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeBenefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitPayload<ExtArgs>, T, "findMany"> | Null>
    createdLedgerEntries<T extends User$createdLedgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLedgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    approvedLedgerEntries<T extends User$approvedLedgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedLedgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    employeeVouchers<T extends User$employeeVouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    createdEmployeeVouchers<T extends User$createdEmployeeVouchersArgs<ExtArgs> = {}>(args?: Subset<T, User$createdEmployeeVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany"> | Null>
    authorizationCodes<T extends User$authorizationCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$authorizationCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findMany"> | Null>
    sterilizationIndicators<T extends User$sterilizationIndicatorsArgs<ExtArgs> = {}>(args?: Subset<T, User$sterilizationIndicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    openedSterilizationPackages<T extends User$openedSterilizationPackagesArgs<ExtArgs> = {}>(args?: Subset<T, User$openedSterilizationPackagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly ovog: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly branchId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly phone: FieldRef<"User", 'String'>
    readonly regNo: FieldRef<"User", 'String'>
    readonly licenseNumber: FieldRef<"User", 'String'>
    readonly licenseExpiryDate: FieldRef<"User", 'DateTime'>
    readonly signatureImagePath: FieldRef<"User", 'String'>
    readonly stampImagePath: FieldRef<"User", 'String'>
    readonly idPhotoPath: FieldRef<"User", 'String'>
    readonly calendarOrder: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.encounters
   */
  export type User$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * User.nurseEncounters
   */
  export type User$nurseEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * User.doctorSchedules
   */
  export type User$doctorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    cursor?: DoctorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * User.doctorBranches
   */
  export type User$doctorBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    where?: DoctorBranchWhereInput
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    cursor?: DoctorBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * User.receptionSchedules
   */
  export type User$receptionSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    where?: ReceptionScheduleWhereInput
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    cursor?: ReceptionScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * User.receptionBranches
   */
  export type User$receptionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    where?: ReceptionBranchWhereInput
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    cursor?: ReceptionBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * User.nurseSchedules
   */
  export type User$nurseSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    where?: NurseScheduleWhereInput
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    cursor?: NurseScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * User.nurseBranches
   */
  export type User$nurseBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    where?: NurseBranchWhereInput
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    cursor?: NurseBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.employeeBenefits
   */
  export type User$employeeBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefit
     */
    select?: EmployeeBenefitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitInclude<ExtArgs> | null
    where?: EmployeeBenefitWhereInput
    orderBy?: EmployeeBenefitOrderByWithRelationInput | EmployeeBenefitOrderByWithRelationInput[]
    cursor?: EmployeeBenefitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitScalarFieldEnum | EmployeeBenefitScalarFieldEnum[]
  }

  /**
   * User.createdLedgerEntries
   */
  export type User$createdLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * User.approvedLedgerEntries
   */
  export type User$approvedLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * User.employeeVouchers
   */
  export type User$employeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    cursor?: EmployeeVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * User.createdEmployeeVouchers
   */
  export type User$createdEmployeeVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    cursor?: EmployeeVoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * User.authorizationCodes
   */
  export type User$authorizationCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    where?: AuthorizationCodeWhereInput
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    cursor?: AuthorizationCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * User.sterilizationIndicators
   */
  export type User$sterilizationIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SterilizationIndicator
     */
    select?: SterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SterilizationIndicatorInclude<ExtArgs> | null
    where?: SterilizationIndicatorWhereInput
    orderBy?: SterilizationIndicatorOrderByWithRelationInput | SterilizationIndicatorOrderByWithRelationInput[]
    cursor?: SterilizationIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SterilizationIndicatorScalarFieldEnum | SterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * User.openedSterilizationPackages
   */
  export type User$openedSterilizationPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    where?: EncounterSterilizationPackageUseWhereInput
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterSterilizationPackageUseScalarFieldEnum | EncounterSterilizationPackageUseScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    regNo: string | null
    ovog: string | null
    name: string | null
    gender: string | null
    birthDate: Date | null
    phone: string | null
    address: string | null
    bloodType: string | null
    citizenship: string | null
    emergencyPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    branchId: number | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    regNo: string | null
    ovog: string | null
    name: string | null
    gender: string | null
    birthDate: Date | null
    phone: string | null
    address: string | null
    bloodType: string | null
    citizenship: string | null
    emergencyPhone: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    branchId: number | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    regNo: number
    ovog: number
    name: number
    gender: number
    birthDate: number
    phone: number
    address: number
    bloodType: number
    citizenship: number
    emergencyPhone: number
    notes: number
    createdAt: number
    updatedAt: number
    branchId: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    regNo?: true
    ovog?: true
    name?: true
    gender?: true
    birthDate?: true
    phone?: true
    address?: true
    bloodType?: true
    citizenship?: true
    emergencyPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    regNo?: true
    ovog?: true
    name?: true
    gender?: true
    birthDate?: true
    phone?: true
    address?: true
    bloodType?: true
    citizenship?: true
    emergencyPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    regNo?: true
    ovog?: true
    name?: true
    gender?: true
    birthDate?: true
    phone?: true
    address?: true
    bloodType?: true
    citizenship?: true
    emergencyPhone?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    branchId?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    regNo: string | null
    ovog: string | null
    name: string
    gender: string | null
    birthDate: Date | null
    phone: string | null
    address: string | null
    bloodType: string | null
    citizenship: string | null
    emergencyPhone: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    branchId: number
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    ovog?: boolean
    name?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    address?: boolean
    bloodType?: boolean
    citizenship?: boolean
    emergencyPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patientBook?: boolean | Patient$patientBookArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    bookings?: boolean | Patient$bookingsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Patient$ledgerEntriesArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Patient$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    ovog?: boolean
    name?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    address?: boolean
    bloodType?: boolean
    citizenship?: boolean
    emergencyPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    regNo?: boolean
    ovog?: boolean
    name?: boolean
    gender?: boolean
    birthDate?: boolean
    phone?: boolean
    address?: boolean
    bloodType?: boolean
    citizenship?: boolean
    emergencyPhone?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchId?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patientBook?: boolean | Patient$patientBookArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    bookings?: boolean | Patient$bookingsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    ledgerEntries?: boolean | Patient$ledgerEntriesArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Patient$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patientBook: Prisma.$PatientBookPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      employeeBenefitUsages: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regNo: string | null
      ovog: string | null
      name: string
      gender: string | null
      birthDate: Date | null
      phone: string | null
      address: string | null
      bloodType: string | null
      citizenship: string | null
      emergencyPhone: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      branchId: number
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patientBook<T extends Patient$patientBookArgs<ExtArgs> = {}>(args?: Subset<T, Patient$patientBookArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Patient$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    ledgerEntries<T extends Patient$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    employeeBenefitUsages<T extends Patient$employeeBenefitUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$employeeBenefitUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'Int'>
    readonly regNo: FieldRef<"Patient", 'String'>
    readonly ovog: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly bloodType: FieldRef<"Patient", 'String'>
    readonly citizenship: FieldRef<"Patient", 'String'>
    readonly emergencyPhone: FieldRef<"Patient", 'String'>
    readonly notes: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly branchId: FieldRef<"Patient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.patientBook
   */
  export type Patient$patientBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    where?: PatientBookWhereInput
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.bookings
   */
  export type Patient$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.ledgerEntries
   */
  export type Patient$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Patient.employeeBenefitUsages
   */
  export type Patient$employeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model PatientBook
   */

  export type AggregatePatientBook = {
    _count: PatientBookCountAggregateOutputType | null
    _avg: PatientBookAvgAggregateOutputType | null
    _sum: PatientBookSumAggregateOutputType | null
    _min: PatientBookMinAggregateOutputType | null
    _max: PatientBookMaxAggregateOutputType | null
  }

  export type PatientBookAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
  }

  export type PatientBookSumAggregateOutputType = {
    id: number | null
    patientId: number | null
  }

  export type PatientBookMinAggregateOutputType = {
    id: number | null
    bookNumber: string | null
    patientId: number | null
  }

  export type PatientBookMaxAggregateOutputType = {
    id: number | null
    bookNumber: string | null
    patientId: number | null
  }

  export type PatientBookCountAggregateOutputType = {
    id: number
    bookNumber: number
    patientId: number
    _all: number
  }


  export type PatientBookAvgAggregateInputType = {
    id?: true
    patientId?: true
  }

  export type PatientBookSumAggregateInputType = {
    id?: true
    patientId?: true
  }

  export type PatientBookMinAggregateInputType = {
    id?: true
    bookNumber?: true
    patientId?: true
  }

  export type PatientBookMaxAggregateInputType = {
    id?: true
    bookNumber?: true
    patientId?: true
  }

  export type PatientBookCountAggregateInputType = {
    id?: true
    bookNumber?: true
    patientId?: true
    _all?: true
  }

  export type PatientBookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientBook to aggregate.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientBooks
    **/
    _count?: true | PatientBookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientBookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientBookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientBookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientBookMaxAggregateInputType
  }

  export type GetPatientBookAggregateType<T extends PatientBookAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientBook[P]>
      : GetScalarType<T[P], AggregatePatientBook[P]>
  }




  export type PatientBookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientBookWhereInput
    orderBy?: PatientBookOrderByWithAggregationInput | PatientBookOrderByWithAggregationInput[]
    by: PatientBookScalarFieldEnum[] | PatientBookScalarFieldEnum
    having?: PatientBookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientBookCountAggregateInputType | true
    _avg?: PatientBookAvgAggregateInputType
    _sum?: PatientBookSumAggregateInputType
    _min?: PatientBookMinAggregateInputType
    _max?: PatientBookMaxAggregateInputType
  }

  export type PatientBookGroupByOutputType = {
    id: number
    bookNumber: string
    patientId: number
    _count: PatientBookCountAggregateOutputType | null
    _avg: PatientBookAvgAggregateOutputType | null
    _sum: PatientBookSumAggregateOutputType | null
    _min: PatientBookMinAggregateOutputType | null
    _max: PatientBookMaxAggregateOutputType | null
  }

  type GetPatientBookGroupByPayload<T extends PatientBookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientBookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientBookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientBookGroupByOutputType[P]>
            : GetScalarType<T[P], PatientBookGroupByOutputType[P]>
        }
      >
    >


  export type PatientBookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookNumber?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    encounters?: boolean | PatientBook$encountersArgs<ExtArgs>
    visitCard?: boolean | PatientBook$visitCardArgs<ExtArgs>
    orthoCard?: boolean | PatientBook$orthoCardArgs<ExtArgs>
    _count?: boolean | PatientBookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBook"]>

  export type PatientBookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookNumber?: boolean
    patientId?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientBook"]>

  export type PatientBookSelectScalar = {
    id?: boolean
    bookNumber?: boolean
    patientId?: boolean
  }

  export type PatientBookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    encounters?: boolean | PatientBook$encountersArgs<ExtArgs>
    visitCard?: boolean | PatientBook$visitCardArgs<ExtArgs>
    orthoCard?: boolean | PatientBook$orthoCardArgs<ExtArgs>
    _count?: boolean | PatientBookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientBookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PatientBookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientBook"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      visitCard: Prisma.$VisitCardPayload<ExtArgs> | null
      orthoCard: Prisma.$OrthoCardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookNumber: string
      patientId: number
    }, ExtArgs["result"]["patientBook"]>
    composites: {}
  }

  type PatientBookGetPayload<S extends boolean | null | undefined | PatientBookDefaultArgs> = $Result.GetResult<Prisma.$PatientBookPayload, S>

  type PatientBookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientBookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientBookCountAggregateInputType | true
    }

  export interface PatientBookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientBook'], meta: { name: 'PatientBook' } }
    /**
     * Find zero or one PatientBook that matches the filter.
     * @param {PatientBookFindUniqueArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientBookFindUniqueArgs>(args: SelectSubset<T, PatientBookFindUniqueArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientBook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientBookFindUniqueOrThrowArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientBookFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientBookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientBook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookFindFirstArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientBookFindFirstArgs>(args?: SelectSubset<T, PatientBookFindFirstArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientBook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookFindFirstOrThrowArgs} args - Arguments to find a PatientBook
     * @example
     * // Get one PatientBook
     * const patientBook = await prisma.patientBook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientBookFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientBookFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientBooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientBooks
     * const patientBooks = await prisma.patientBook.findMany()
     * 
     * // Get first 10 PatientBooks
     * const patientBooks = await prisma.patientBook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientBookWithIdOnly = await prisma.patientBook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientBookFindManyArgs>(args?: SelectSubset<T, PatientBookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientBook.
     * @param {PatientBookCreateArgs} args - Arguments to create a PatientBook.
     * @example
     * // Create one PatientBook
     * const PatientBook = await prisma.patientBook.create({
     *   data: {
     *     // ... data to create a PatientBook
     *   }
     * })
     * 
     */
    create<T extends PatientBookCreateArgs>(args: SelectSubset<T, PatientBookCreateArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientBooks.
     * @param {PatientBookCreateManyArgs} args - Arguments to create many PatientBooks.
     * @example
     * // Create many PatientBooks
     * const patientBook = await prisma.patientBook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientBookCreateManyArgs>(args?: SelectSubset<T, PatientBookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientBooks and returns the data saved in the database.
     * @param {PatientBookCreateManyAndReturnArgs} args - Arguments to create many PatientBooks.
     * @example
     * // Create many PatientBooks
     * const patientBook = await prisma.patientBook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientBooks and only return the `id`
     * const patientBookWithIdOnly = await prisma.patientBook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientBookCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientBookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientBook.
     * @param {PatientBookDeleteArgs} args - Arguments to delete one PatientBook.
     * @example
     * // Delete one PatientBook
     * const PatientBook = await prisma.patientBook.delete({
     *   where: {
     *     // ... filter to delete one PatientBook
     *   }
     * })
     * 
     */
    delete<T extends PatientBookDeleteArgs>(args: SelectSubset<T, PatientBookDeleteArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientBook.
     * @param {PatientBookUpdateArgs} args - Arguments to update one PatientBook.
     * @example
     * // Update one PatientBook
     * const patientBook = await prisma.patientBook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientBookUpdateArgs>(args: SelectSubset<T, PatientBookUpdateArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientBooks.
     * @param {PatientBookDeleteManyArgs} args - Arguments to filter PatientBooks to delete.
     * @example
     * // Delete a few PatientBooks
     * const { count } = await prisma.patientBook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientBookDeleteManyArgs>(args?: SelectSubset<T, PatientBookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientBooks
     * const patientBook = await prisma.patientBook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientBookUpdateManyArgs>(args: SelectSubset<T, PatientBookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientBook.
     * @param {PatientBookUpsertArgs} args - Arguments to update or create a PatientBook.
     * @example
     * // Update or create a PatientBook
     * const patientBook = await prisma.patientBook.upsert({
     *   create: {
     *     // ... data to create a PatientBook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientBook we want to update
     *   }
     * })
     */
    upsert<T extends PatientBookUpsertArgs>(args: SelectSubset<T, PatientBookUpsertArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientBooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookCountArgs} args - Arguments to filter PatientBooks to count.
     * @example
     * // Count the number of PatientBooks
     * const count = await prisma.patientBook.count({
     *   where: {
     *     // ... the filter for the PatientBooks we want to count
     *   }
     * })
    **/
    count<T extends PatientBookCountArgs>(
      args?: Subset<T, PatientBookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientBookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientBookAggregateArgs>(args: Subset<T, PatientBookAggregateArgs>): Prisma.PrismaPromise<GetPatientBookAggregateType<T>>

    /**
     * Group by PatientBook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientBookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientBookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientBookGroupByArgs['orderBy'] }
        : { orderBy?: PatientBookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientBookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientBook model
   */
  readonly fields: PatientBookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientBook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientBookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends PatientBook$encountersArgs<ExtArgs> = {}>(args?: Subset<T, PatientBook$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    visitCard<T extends PatientBook$visitCardArgs<ExtArgs> = {}>(args?: Subset<T, PatientBook$visitCardArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    orthoCard<T extends PatientBook$orthoCardArgs<ExtArgs> = {}>(args?: Subset<T, PatientBook$orthoCardArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientBook model
   */ 
  interface PatientBookFieldRefs {
    readonly id: FieldRef<"PatientBook", 'Int'>
    readonly bookNumber: FieldRef<"PatientBook", 'String'>
    readonly patientId: FieldRef<"PatientBook", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PatientBook findUnique
   */
  export type PatientBookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook findUniqueOrThrow
   */
  export type PatientBookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook findFirst
   */
  export type PatientBookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientBooks.
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientBooks.
     */
    distinct?: PatientBookScalarFieldEnum | PatientBookScalarFieldEnum[]
  }

  /**
   * PatientBook findFirstOrThrow
   */
  export type PatientBookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBook to fetch.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientBooks.
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientBooks.
     */
    distinct?: PatientBookScalarFieldEnum | PatientBookScalarFieldEnum[]
  }

  /**
   * PatientBook findMany
   */
  export type PatientBookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter, which PatientBooks to fetch.
     */
    where?: PatientBookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientBooks to fetch.
     */
    orderBy?: PatientBookOrderByWithRelationInput | PatientBookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientBooks.
     */
    cursor?: PatientBookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientBooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientBooks.
     */
    skip?: number
    distinct?: PatientBookScalarFieldEnum | PatientBookScalarFieldEnum[]
  }

  /**
   * PatientBook create
   */
  export type PatientBookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientBook.
     */
    data: XOR<PatientBookCreateInput, PatientBookUncheckedCreateInput>
  }

  /**
   * PatientBook createMany
   */
  export type PatientBookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientBooks.
     */
    data: PatientBookCreateManyInput | PatientBookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientBook createManyAndReturn
   */
  export type PatientBookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientBooks.
     */
    data: PatientBookCreateManyInput | PatientBookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientBook update
   */
  export type PatientBookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientBook.
     */
    data: XOR<PatientBookUpdateInput, PatientBookUncheckedUpdateInput>
    /**
     * Choose, which PatientBook to update.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook updateMany
   */
  export type PatientBookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientBooks.
     */
    data: XOR<PatientBookUpdateManyMutationInput, PatientBookUncheckedUpdateManyInput>
    /**
     * Filter which PatientBooks to update
     */
    where?: PatientBookWhereInput
  }

  /**
   * PatientBook upsert
   */
  export type PatientBookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientBook to update in case it exists.
     */
    where: PatientBookWhereUniqueInput
    /**
     * In case the PatientBook found by the `where` argument doesn't exist, create a new PatientBook with this data.
     */
    create: XOR<PatientBookCreateInput, PatientBookUncheckedCreateInput>
    /**
     * In case the PatientBook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientBookUpdateInput, PatientBookUncheckedUpdateInput>
  }

  /**
   * PatientBook delete
   */
  export type PatientBookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
    /**
     * Filter which PatientBook to delete.
     */
    where: PatientBookWhereUniqueInput
  }

  /**
   * PatientBook deleteMany
   */
  export type PatientBookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientBooks to delete
     */
    where?: PatientBookWhereInput
  }

  /**
   * PatientBook.encounters
   */
  export type PatientBook$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * PatientBook.visitCard
   */
  export type PatientBook$visitCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    where?: VisitCardWhereInput
  }

  /**
   * PatientBook.orthoCard
   */
  export type PatientBook$orthoCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    where?: OrthoCardWhereInput
  }

  /**
   * PatientBook without action
   */
  export type PatientBookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientBook
     */
    select?: PatientBookSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientBookInclude<ExtArgs> | null
  }


  /**
   * Model VisitCard
   */

  export type AggregateVisitCard = {
    _count: VisitCardCountAggregateOutputType | null
    _avg: VisitCardAvgAggregateOutputType | null
    _sum: VisitCardSumAggregateOutputType | null
    _min: VisitCardMinAggregateOutputType | null
    _max: VisitCardMaxAggregateOutputType | null
  }

  export type VisitCardAvgAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type VisitCardSumAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type VisitCardMinAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    type: $Enums.VisitCardType | null
    patientSignaturePath: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCardMaxAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    type: $Enums.VisitCardType | null
    patientSignaturePath: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VisitCardCountAggregateOutputType = {
    id: number
    patientBookId: number
    type: number
    answers: number
    patientSignaturePath: number
    signedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VisitCardAvgAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type VisitCardSumAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type VisitCardMinAggregateInputType = {
    id?: true
    patientBookId?: true
    type?: true
    patientSignaturePath?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCardMaxAggregateInputType = {
    id?: true
    patientBookId?: true
    type?: true
    patientSignaturePath?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VisitCardCountAggregateInputType = {
    id?: true
    patientBookId?: true
    type?: true
    answers?: true
    patientSignaturePath?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VisitCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitCard to aggregate.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitCards
    **/
    _count?: true | VisitCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisitCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisitCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitCardMaxAggregateInputType
  }

  export type GetVisitCardAggregateType<T extends VisitCardAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitCard[P]>
      : GetScalarType<T[P], AggregateVisitCard[P]>
  }




  export type VisitCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitCardWhereInput
    orderBy?: VisitCardOrderByWithAggregationInput | VisitCardOrderByWithAggregationInput[]
    by: VisitCardScalarFieldEnum[] | VisitCardScalarFieldEnum
    having?: VisitCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitCardCountAggregateInputType | true
    _avg?: VisitCardAvgAggregateInputType
    _sum?: VisitCardSumAggregateInputType
    _min?: VisitCardMinAggregateInputType
    _max?: VisitCardMaxAggregateInputType
  }

  export type VisitCardGroupByOutputType = {
    id: number
    patientBookId: number
    type: $Enums.VisitCardType
    answers: JsonValue
    patientSignaturePath: string | null
    signedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VisitCardCountAggregateOutputType | null
    _avg: VisitCardAvgAggregateOutputType | null
    _sum: VisitCardSumAggregateOutputType | null
    _min: VisitCardMinAggregateOutputType | null
    _max: VisitCardMaxAggregateOutputType | null
  }

  type GetVisitCardGroupByPayload<T extends VisitCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitCardGroupByOutputType[P]>
            : GetScalarType<T[P], VisitCardGroupByOutputType[P]>
        }
      >
    >


  export type VisitCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    type?: boolean
    answers?: boolean
    patientSignaturePath?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitCard"]>

  export type VisitCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    type?: boolean
    answers?: boolean
    patientSignaturePath?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitCard"]>

  export type VisitCardSelectScalar = {
    id?: boolean
    patientBookId?: boolean
    type?: boolean
    answers?: boolean
    patientSignaturePath?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VisitCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }
  export type VisitCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }

  export type $VisitCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitCard"
    objects: {
      patientBook: Prisma.$PatientBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientBookId: number
      type: $Enums.VisitCardType
      answers: Prisma.JsonValue
      patientSignaturePath: string | null
      signedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["visitCard"]>
    composites: {}
  }

  type VisitCardGetPayload<S extends boolean | null | undefined | VisitCardDefaultArgs> = $Result.GetResult<Prisma.$VisitCardPayload, S>

  type VisitCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisitCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisitCardCountAggregateInputType | true
    }

  export interface VisitCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitCard'], meta: { name: 'VisitCard' } }
    /**
     * Find zero or one VisitCard that matches the filter.
     * @param {VisitCardFindUniqueArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitCardFindUniqueArgs>(args: SelectSubset<T, VisitCardFindUniqueArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisitCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisitCardFindUniqueOrThrowArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitCardFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisitCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardFindFirstArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitCardFindFirstArgs>(args?: SelectSubset<T, VisitCardFindFirstArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisitCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardFindFirstOrThrowArgs} args - Arguments to find a VisitCard
     * @example
     * // Get one VisitCard
     * const visitCard = await prisma.visitCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitCardFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisitCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitCards
     * const visitCards = await prisma.visitCard.findMany()
     * 
     * // Get first 10 VisitCards
     * const visitCards = await prisma.visitCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitCardWithIdOnly = await prisma.visitCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitCardFindManyArgs>(args?: SelectSubset<T, VisitCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisitCard.
     * @param {VisitCardCreateArgs} args - Arguments to create a VisitCard.
     * @example
     * // Create one VisitCard
     * const VisitCard = await prisma.visitCard.create({
     *   data: {
     *     // ... data to create a VisitCard
     *   }
     * })
     * 
     */
    create<T extends VisitCardCreateArgs>(args: SelectSubset<T, VisitCardCreateArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisitCards.
     * @param {VisitCardCreateManyArgs} args - Arguments to create many VisitCards.
     * @example
     * // Create many VisitCards
     * const visitCard = await prisma.visitCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitCardCreateManyArgs>(args?: SelectSubset<T, VisitCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisitCards and returns the data saved in the database.
     * @param {VisitCardCreateManyAndReturnArgs} args - Arguments to create many VisitCards.
     * @example
     * // Create many VisitCards
     * const visitCard = await prisma.visitCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisitCards and only return the `id`
     * const visitCardWithIdOnly = await prisma.visitCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisitCardCreateManyAndReturnArgs>(args?: SelectSubset<T, VisitCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisitCard.
     * @param {VisitCardDeleteArgs} args - Arguments to delete one VisitCard.
     * @example
     * // Delete one VisitCard
     * const VisitCard = await prisma.visitCard.delete({
     *   where: {
     *     // ... filter to delete one VisitCard
     *   }
     * })
     * 
     */
    delete<T extends VisitCardDeleteArgs>(args: SelectSubset<T, VisitCardDeleteArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisitCard.
     * @param {VisitCardUpdateArgs} args - Arguments to update one VisitCard.
     * @example
     * // Update one VisitCard
     * const visitCard = await prisma.visitCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitCardUpdateArgs>(args: SelectSubset<T, VisitCardUpdateArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisitCards.
     * @param {VisitCardDeleteManyArgs} args - Arguments to filter VisitCards to delete.
     * @example
     * // Delete a few VisitCards
     * const { count } = await prisma.visitCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitCardDeleteManyArgs>(args?: SelectSubset<T, VisitCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitCards
     * const visitCard = await prisma.visitCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitCardUpdateManyArgs>(args: SelectSubset<T, VisitCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitCard.
     * @param {VisitCardUpsertArgs} args - Arguments to update or create a VisitCard.
     * @example
     * // Update or create a VisitCard
     * const visitCard = await prisma.visitCard.upsert({
     *   create: {
     *     // ... data to create a VisitCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitCard we want to update
     *   }
     * })
     */
    upsert<T extends VisitCardUpsertArgs>(args: SelectSubset<T, VisitCardUpsertArgs<ExtArgs>>): Prisma__VisitCardClient<$Result.GetResult<Prisma.$VisitCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisitCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardCountArgs} args - Arguments to filter VisitCards to count.
     * @example
     * // Count the number of VisitCards
     * const count = await prisma.visitCard.count({
     *   where: {
     *     // ... the filter for the VisitCards we want to count
     *   }
     * })
    **/
    count<T extends VisitCardCountArgs>(
      args?: Subset<T, VisitCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitCardAggregateArgs>(args: Subset<T, VisitCardAggregateArgs>): Prisma.PrismaPromise<GetVisitCardAggregateType<T>>

    /**
     * Group by VisitCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitCardGroupByArgs['orderBy'] }
        : { orderBy?: VisitCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitCard model
   */
  readonly fields: VisitCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientBook<T extends PatientBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientBookDefaultArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitCard model
   */ 
  interface VisitCardFieldRefs {
    readonly id: FieldRef<"VisitCard", 'Int'>
    readonly patientBookId: FieldRef<"VisitCard", 'Int'>
    readonly type: FieldRef<"VisitCard", 'VisitCardType'>
    readonly answers: FieldRef<"VisitCard", 'Json'>
    readonly patientSignaturePath: FieldRef<"VisitCard", 'String'>
    readonly signedAt: FieldRef<"VisitCard", 'DateTime'>
    readonly createdAt: FieldRef<"VisitCard", 'DateTime'>
    readonly updatedAt: FieldRef<"VisitCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisitCard findUnique
   */
  export type VisitCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard findUniqueOrThrow
   */
  export type VisitCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard findFirst
   */
  export type VisitCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitCards.
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitCards.
     */
    distinct?: VisitCardScalarFieldEnum | VisitCardScalarFieldEnum[]
  }

  /**
   * VisitCard findFirstOrThrow
   */
  export type VisitCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCard to fetch.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitCards.
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitCards.
     */
    distinct?: VisitCardScalarFieldEnum | VisitCardScalarFieldEnum[]
  }

  /**
   * VisitCard findMany
   */
  export type VisitCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter, which VisitCards to fetch.
     */
    where?: VisitCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitCards to fetch.
     */
    orderBy?: VisitCardOrderByWithRelationInput | VisitCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitCards.
     */
    cursor?: VisitCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitCards.
     */
    skip?: number
    distinct?: VisitCardScalarFieldEnum | VisitCardScalarFieldEnum[]
  }

  /**
   * VisitCard create
   */
  export type VisitCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitCard.
     */
    data: XOR<VisitCardCreateInput, VisitCardUncheckedCreateInput>
  }

  /**
   * VisitCard createMany
   */
  export type VisitCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitCards.
     */
    data: VisitCardCreateManyInput | VisitCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitCard createManyAndReturn
   */
  export type VisitCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisitCards.
     */
    data: VisitCardCreateManyInput | VisitCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VisitCard update
   */
  export type VisitCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitCard.
     */
    data: XOR<VisitCardUpdateInput, VisitCardUncheckedUpdateInput>
    /**
     * Choose, which VisitCard to update.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard updateMany
   */
  export type VisitCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitCards.
     */
    data: XOR<VisitCardUpdateManyMutationInput, VisitCardUncheckedUpdateManyInput>
    /**
     * Filter which VisitCards to update
     */
    where?: VisitCardWhereInput
  }

  /**
   * VisitCard upsert
   */
  export type VisitCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitCard to update in case it exists.
     */
    where: VisitCardWhereUniqueInput
    /**
     * In case the VisitCard found by the `where` argument doesn't exist, create a new VisitCard with this data.
     */
    create: XOR<VisitCardCreateInput, VisitCardUncheckedCreateInput>
    /**
     * In case the VisitCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitCardUpdateInput, VisitCardUncheckedUpdateInput>
  }

  /**
   * VisitCard delete
   */
  export type VisitCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
    /**
     * Filter which VisitCard to delete.
     */
    where: VisitCardWhereUniqueInput
  }

  /**
   * VisitCard deleteMany
   */
  export type VisitCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitCards to delete
     */
    where?: VisitCardWhereInput
  }

  /**
   * VisitCard without action
   */
  export type VisitCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitCard
     */
    select?: VisitCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitCardInclude<ExtArgs> | null
  }


  /**
   * Model OrthoCard
   */

  export type AggregateOrthoCard = {
    _count: OrthoCardCountAggregateOutputType | null
    _avg: OrthoCardAvgAggregateOutputType | null
    _sum: OrthoCardSumAggregateOutputType | null
    _min: OrthoCardMinAggregateOutputType | null
    _max: OrthoCardMaxAggregateOutputType | null
  }

  export type OrthoCardAvgAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type OrthoCardSumAggregateOutputType = {
    id: number | null
    patientBookId: number | null
  }

  export type OrthoCardMinAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrthoCardMaxAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrthoCardCountAggregateOutputType = {
    id: number
    patientBookId: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrthoCardAvgAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type OrthoCardSumAggregateInputType = {
    id?: true
    patientBookId?: true
  }

  export type OrthoCardMinAggregateInputType = {
    id?: true
    patientBookId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrthoCardMaxAggregateInputType = {
    id?: true
    patientBookId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrthoCardCountAggregateInputType = {
    id?: true
    patientBookId?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrthoCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrthoCard to aggregate.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrthoCards
    **/
    _count?: true | OrthoCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrthoCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrthoCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrthoCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrthoCardMaxAggregateInputType
  }

  export type GetOrthoCardAggregateType<T extends OrthoCardAggregateArgs> = {
        [P in keyof T & keyof AggregateOrthoCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrthoCard[P]>
      : GetScalarType<T[P], AggregateOrthoCard[P]>
  }




  export type OrthoCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrthoCardWhereInput
    orderBy?: OrthoCardOrderByWithAggregationInput | OrthoCardOrderByWithAggregationInput[]
    by: OrthoCardScalarFieldEnum[] | OrthoCardScalarFieldEnum
    having?: OrthoCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrthoCardCountAggregateInputType | true
    _avg?: OrthoCardAvgAggregateInputType
    _sum?: OrthoCardSumAggregateInputType
    _min?: OrthoCardMinAggregateInputType
    _max?: OrthoCardMaxAggregateInputType
  }

  export type OrthoCardGroupByOutputType = {
    id: number
    patientBookId: number
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: OrthoCardCountAggregateOutputType | null
    _avg: OrthoCardAvgAggregateOutputType | null
    _sum: OrthoCardSumAggregateOutputType | null
    _min: OrthoCardMinAggregateOutputType | null
    _max: OrthoCardMaxAggregateOutputType | null
  }

  type GetOrthoCardGroupByPayload<T extends OrthoCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrthoCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrthoCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrthoCardGroupByOutputType[P]>
            : GetScalarType<T[P], OrthoCardGroupByOutputType[P]>
        }
      >
    >


  export type OrthoCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orthoCard"]>

  export type OrthoCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orthoCard"]>

  export type OrthoCardSelectScalar = {
    id?: boolean
    patientBookId?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrthoCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }
  export type OrthoCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
  }

  export type $OrthoCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrthoCard"
    objects: {
      patientBook: Prisma.$PatientBookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientBookId: number
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orthoCard"]>
    composites: {}
  }

  type OrthoCardGetPayload<S extends boolean | null | undefined | OrthoCardDefaultArgs> = $Result.GetResult<Prisma.$OrthoCardPayload, S>

  type OrthoCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrthoCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrthoCardCountAggregateInputType | true
    }

  export interface OrthoCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrthoCard'], meta: { name: 'OrthoCard' } }
    /**
     * Find zero or one OrthoCard that matches the filter.
     * @param {OrthoCardFindUniqueArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrthoCardFindUniqueArgs>(args: SelectSubset<T, OrthoCardFindUniqueArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrthoCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrthoCardFindUniqueOrThrowArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrthoCardFindUniqueOrThrowArgs>(args: SelectSubset<T, OrthoCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrthoCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardFindFirstArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrthoCardFindFirstArgs>(args?: SelectSubset<T, OrthoCardFindFirstArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrthoCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardFindFirstOrThrowArgs} args - Arguments to find a OrthoCard
     * @example
     * // Get one OrthoCard
     * const orthoCard = await prisma.orthoCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrthoCardFindFirstOrThrowArgs>(args?: SelectSubset<T, OrthoCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrthoCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrthoCards
     * const orthoCards = await prisma.orthoCard.findMany()
     * 
     * // Get first 10 OrthoCards
     * const orthoCards = await prisma.orthoCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orthoCardWithIdOnly = await prisma.orthoCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrthoCardFindManyArgs>(args?: SelectSubset<T, OrthoCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrthoCard.
     * @param {OrthoCardCreateArgs} args - Arguments to create a OrthoCard.
     * @example
     * // Create one OrthoCard
     * const OrthoCard = await prisma.orthoCard.create({
     *   data: {
     *     // ... data to create a OrthoCard
     *   }
     * })
     * 
     */
    create<T extends OrthoCardCreateArgs>(args: SelectSubset<T, OrthoCardCreateArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrthoCards.
     * @param {OrthoCardCreateManyArgs} args - Arguments to create many OrthoCards.
     * @example
     * // Create many OrthoCards
     * const orthoCard = await prisma.orthoCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrthoCardCreateManyArgs>(args?: SelectSubset<T, OrthoCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrthoCards and returns the data saved in the database.
     * @param {OrthoCardCreateManyAndReturnArgs} args - Arguments to create many OrthoCards.
     * @example
     * // Create many OrthoCards
     * const orthoCard = await prisma.orthoCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrthoCards and only return the `id`
     * const orthoCardWithIdOnly = await prisma.orthoCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrthoCardCreateManyAndReturnArgs>(args?: SelectSubset<T, OrthoCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrthoCard.
     * @param {OrthoCardDeleteArgs} args - Arguments to delete one OrthoCard.
     * @example
     * // Delete one OrthoCard
     * const OrthoCard = await prisma.orthoCard.delete({
     *   where: {
     *     // ... filter to delete one OrthoCard
     *   }
     * })
     * 
     */
    delete<T extends OrthoCardDeleteArgs>(args: SelectSubset<T, OrthoCardDeleteArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrthoCard.
     * @param {OrthoCardUpdateArgs} args - Arguments to update one OrthoCard.
     * @example
     * // Update one OrthoCard
     * const orthoCard = await prisma.orthoCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrthoCardUpdateArgs>(args: SelectSubset<T, OrthoCardUpdateArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrthoCards.
     * @param {OrthoCardDeleteManyArgs} args - Arguments to filter OrthoCards to delete.
     * @example
     * // Delete a few OrthoCards
     * const { count } = await prisma.orthoCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrthoCardDeleteManyArgs>(args?: SelectSubset<T, OrthoCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrthoCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrthoCards
     * const orthoCard = await prisma.orthoCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrthoCardUpdateManyArgs>(args: SelectSubset<T, OrthoCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrthoCard.
     * @param {OrthoCardUpsertArgs} args - Arguments to update or create a OrthoCard.
     * @example
     * // Update or create a OrthoCard
     * const orthoCard = await prisma.orthoCard.upsert({
     *   create: {
     *     // ... data to create a OrthoCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrthoCard we want to update
     *   }
     * })
     */
    upsert<T extends OrthoCardUpsertArgs>(args: SelectSubset<T, OrthoCardUpsertArgs<ExtArgs>>): Prisma__OrthoCardClient<$Result.GetResult<Prisma.$OrthoCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrthoCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardCountArgs} args - Arguments to filter OrthoCards to count.
     * @example
     * // Count the number of OrthoCards
     * const count = await prisma.orthoCard.count({
     *   where: {
     *     // ... the filter for the OrthoCards we want to count
     *   }
     * })
    **/
    count<T extends OrthoCardCountArgs>(
      args?: Subset<T, OrthoCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrthoCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrthoCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrthoCardAggregateArgs>(args: Subset<T, OrthoCardAggregateArgs>): Prisma.PrismaPromise<GetOrthoCardAggregateType<T>>

    /**
     * Group by OrthoCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrthoCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrthoCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrthoCardGroupByArgs['orderBy'] }
        : { orderBy?: OrthoCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrthoCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrthoCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrthoCard model
   */
  readonly fields: OrthoCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrthoCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrthoCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientBook<T extends PatientBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientBookDefaultArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrthoCard model
   */ 
  interface OrthoCardFieldRefs {
    readonly id: FieldRef<"OrthoCard", 'Int'>
    readonly patientBookId: FieldRef<"OrthoCard", 'Int'>
    readonly data: FieldRef<"OrthoCard", 'Json'>
    readonly createdAt: FieldRef<"OrthoCard", 'DateTime'>
    readonly updatedAt: FieldRef<"OrthoCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrthoCard findUnique
   */
  export type OrthoCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard findUniqueOrThrow
   */
  export type OrthoCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard findFirst
   */
  export type OrthoCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrthoCards.
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrthoCards.
     */
    distinct?: OrthoCardScalarFieldEnum | OrthoCardScalarFieldEnum[]
  }

  /**
   * OrthoCard findFirstOrThrow
   */
  export type OrthoCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCard to fetch.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrthoCards.
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrthoCards.
     */
    distinct?: OrthoCardScalarFieldEnum | OrthoCardScalarFieldEnum[]
  }

  /**
   * OrthoCard findMany
   */
  export type OrthoCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter, which OrthoCards to fetch.
     */
    where?: OrthoCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrthoCards to fetch.
     */
    orderBy?: OrthoCardOrderByWithRelationInput | OrthoCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrthoCards.
     */
    cursor?: OrthoCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrthoCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrthoCards.
     */
    skip?: number
    distinct?: OrthoCardScalarFieldEnum | OrthoCardScalarFieldEnum[]
  }

  /**
   * OrthoCard create
   */
  export type OrthoCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * The data needed to create a OrthoCard.
     */
    data: XOR<OrthoCardCreateInput, OrthoCardUncheckedCreateInput>
  }

  /**
   * OrthoCard createMany
   */
  export type OrthoCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrthoCards.
     */
    data: OrthoCardCreateManyInput | OrthoCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrthoCard createManyAndReturn
   */
  export type OrthoCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrthoCards.
     */
    data: OrthoCardCreateManyInput | OrthoCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrthoCard update
   */
  export type OrthoCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * The data needed to update a OrthoCard.
     */
    data: XOR<OrthoCardUpdateInput, OrthoCardUncheckedUpdateInput>
    /**
     * Choose, which OrthoCard to update.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard updateMany
   */
  export type OrthoCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrthoCards.
     */
    data: XOR<OrthoCardUpdateManyMutationInput, OrthoCardUncheckedUpdateManyInput>
    /**
     * Filter which OrthoCards to update
     */
    where?: OrthoCardWhereInput
  }

  /**
   * OrthoCard upsert
   */
  export type OrthoCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * The filter to search for the OrthoCard to update in case it exists.
     */
    where: OrthoCardWhereUniqueInput
    /**
     * In case the OrthoCard found by the `where` argument doesn't exist, create a new OrthoCard with this data.
     */
    create: XOR<OrthoCardCreateInput, OrthoCardUncheckedCreateInput>
    /**
     * In case the OrthoCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrthoCardUpdateInput, OrthoCardUncheckedUpdateInput>
  }

  /**
   * OrthoCard delete
   */
  export type OrthoCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
    /**
     * Filter which OrthoCard to delete.
     */
    where: OrthoCardWhereUniqueInput
  }

  /**
   * OrthoCard deleteMany
   */
  export type OrthoCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrthoCards to delete
     */
    where?: OrthoCardWhereInput
  }

  /**
   * OrthoCard without action
   */
  export type OrthoCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrthoCard
     */
    select?: OrthoCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrthoCardInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
    scheduledAt: Date | null
    endAt: Date | null
    status: string | null
    notes: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    patientId: number | null
    doctorId: number | null
    branchId: number | null
    scheduledAt: Date | null
    endAt: Date | null
    status: string | null
    notes: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    branchId: number
    scheduledAt: number
    endAt: number
    status: number
    notes: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
    scheduledAt?: true
    endAt?: true
    status?: true
    notes?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
    scheduledAt?: true
    endAt?: true
    status?: true
    notes?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    branchId?: true
    scheduledAt?: true
    endAt?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    patientId: number
    doctorId: number | null
    branchId: number
    scheduledAt: Date
    endAt: Date | null
    status: string
    notes: string | null
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    branchId?: boolean
    scheduledAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Appointment$encountersArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    branchId?: boolean
    scheduledAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    branchId?: boolean
    scheduledAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Appointment$encountersArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | Appointment$doctorArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientId: number
      doctorId: number | null
      branchId: number
      scheduledAt: Date
      endAt: Date | null
      status: string
      notes: string | null
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends Appointment$doctorArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends Appointment$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly patientId: FieldRef<"Appointment", 'Int'>
    readonly doctorId: FieldRef<"Appointment", 'Int'>
    readonly branchId: FieldRef<"Appointment", 'Int'>
    readonly scheduledAt: FieldRef<"Appointment", 'DateTime'>
    readonly endAt: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment.doctor
   */
  export type Appointment$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Appointment.encounters
   */
  export type Appointment$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    status: $Enums.BookingStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    patientId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    status: $Enums.BookingStatus | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    doctorId: number
    branchId: number
    patientId: number
    date: number
    startTime: number
    endTime: number
    status: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    patientId?: true
    date?: true
    startTime?: true
    endTime?: true
    status?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    doctorId: number
    branchId: number
    patientId: number
    date: Date
    startTime: string
    endTime: string
    status: $Enums.BookingStatus
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    patientId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    patientId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    patientId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctorId: number
      branchId: number
      patientId: number
      date: Date
      startTime: string
      endTime: string
      status: $Enums.BookingStatus
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly doctorId: FieldRef<"Booking", 'Int'>
    readonly branchId: FieldRef<"Booking", 'Int'>
    readonly patientId: FieldRef<"Booking", 'Int'>
    readonly date: FieldRef<"Booking", 'DateTime'>
    readonly startTime: FieldRef<"Booking", 'String'>
    readonly endTime: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly note: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterAvgAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    appointmentId: number | null
    nurseId: number | null
  }

  export type EncounterSumAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    appointmentId: number | null
    nurseId: number | null
  }

  export type EncounterMinAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    visitDate: Date | null
    notes: string | null
    appointmentId: number | null
    nurseId: number | null
    patientSignaturePath: string | null
    patientSignedAt: Date | null
    doctorSignaturePath: string | null
    doctorSignedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: number | null
    patientBookId: number | null
    doctorId: number | null
    visitDate: Date | null
    notes: string | null
    appointmentId: number | null
    nurseId: number | null
    patientSignaturePath: string | null
    patientSignedAt: Date | null
    doctorSignaturePath: string | null
    doctorSignedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    patientBookId: number
    doctorId: number
    visitDate: number
    notes: number
    appointmentId: number
    nurseId: number
    patientSignaturePath: number
    patientSignedAt: number
    doctorSignaturePath: number
    doctorSignedAt: number
    _all: number
  }


  export type EncounterAvgAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    appointmentId?: true
    nurseId?: true
  }

  export type EncounterSumAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    appointmentId?: true
    nurseId?: true
  }

  export type EncounterMinAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    visitDate?: true
    notes?: true
    appointmentId?: true
    nurseId?: true
    patientSignaturePath?: true
    patientSignedAt?: true
    doctorSignaturePath?: true
    doctorSignedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    visitDate?: true
    notes?: true
    appointmentId?: true
    nurseId?: true
    patientSignaturePath?: true
    patientSignedAt?: true
    doctorSignaturePath?: true
    doctorSignedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    patientBookId?: true
    doctorId?: true
    visitDate?: true
    notes?: true
    appointmentId?: true
    nurseId?: true
    patientSignaturePath?: true
    patientSignedAt?: true
    doctorSignaturePath?: true
    doctorSignedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _avg?: EncounterAvgAggregateInputType
    _sum?: EncounterSumAggregateInputType
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: number
    patientBookId: number
    doctorId: number
    visitDate: Date
    notes: string | null
    appointmentId: number | null
    nurseId: number | null
    patientSignaturePath: string | null
    patientSignedAt: Date | null
    doctorSignaturePath: string | null
    doctorSignedAt: Date | null
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    notes?: boolean
    appointmentId?: boolean
    nurseId?: boolean
    patientSignaturePath?: boolean
    patientSignedAt?: boolean
    doctorSignaturePath?: boolean
    doctorSignedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
    chartTeeth?: boolean | Encounter$chartTeethArgs<ExtArgs>
    invoice?: boolean | Encounter$invoiceArgs<ExtArgs>
    prescription?: boolean | Encounter$prescriptionArgs<ExtArgs>
    media?: boolean | Encounter$mediaArgs<ExtArgs>
    encounterServices?: boolean | Encounter$encounterServicesArgs<ExtArgs>
    diagnoses?: boolean | Encounter$diagnosesArgs<ExtArgs>
    consents?: boolean | Encounter$consentsArgs<ExtArgs>
    sterilizationPackageUses?: boolean | Encounter$sterilizationPackageUsesArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Encounter$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientBookId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    notes?: boolean
    appointmentId?: boolean
    nurseId?: boolean
    patientSignaturePath?: boolean
    patientSignedAt?: boolean
    doctorSignaturePath?: boolean
    doctorSignedAt?: boolean
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    patientBookId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    notes?: boolean
    appointmentId?: boolean
    nurseId?: boolean
    patientSignaturePath?: boolean
    patientSignedAt?: boolean
    doctorSignaturePath?: boolean
    doctorSignedAt?: boolean
  }

  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
    chartTeeth?: boolean | Encounter$chartTeethArgs<ExtArgs>
    invoice?: boolean | Encounter$invoiceArgs<ExtArgs>
    prescription?: boolean | Encounter$prescriptionArgs<ExtArgs>
    media?: boolean | Encounter$mediaArgs<ExtArgs>
    encounterServices?: boolean | Encounter$encounterServicesArgs<ExtArgs>
    diagnoses?: boolean | Encounter$diagnosesArgs<ExtArgs>
    consents?: boolean | Encounter$consentsArgs<ExtArgs>
    sterilizationPackageUses?: boolean | Encounter$sterilizationPackageUsesArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Encounter$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientBook?: boolean | PatientBookDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | Encounter$appointmentArgs<ExtArgs>
    nurse?: boolean | Encounter$nurseArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      patientBook: Prisma.$PatientBookPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      nurse: Prisma.$UserPayload<ExtArgs> | null
      chartTeeth: Prisma.$ChartToothPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
      media: Prisma.$MediaPayload<ExtArgs>[]
      encounterServices: Prisma.$EncounterServicePayload<ExtArgs>[]
      diagnoses: Prisma.$EncounterDiagnosisPayload<ExtArgs>[]
      consents: Prisma.$EncounterConsentPayload<ExtArgs>[]
      sterilizationPackageUses: Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>[]
      employeeBenefitUsages: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      patientBookId: number
      doctorId: number
      visitDate: Date
      notes: string | null
      appointmentId: number | null
      nurseId: number | null
      patientSignaturePath: string | null
      patientSignedAt: Date | null
      doctorSignaturePath: string | null
      doctorSignedAt: Date | null
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patientBook<T extends PatientBookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientBookDefaultArgs<ExtArgs>>): Prisma__PatientBookClient<$Result.GetResult<Prisma.$PatientBookPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    appointment<T extends Encounter$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    nurse<T extends Encounter$nurseArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$nurseArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chartTeeth<T extends Encounter$chartTeethArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$chartTeethArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findMany"> | Null>
    invoice<T extends Encounter$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prescription<T extends Encounter$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    media<T extends Encounter$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany"> | Null>
    encounterServices<T extends Encounter$encounterServicesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$encounterServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findMany"> | Null>
    diagnoses<T extends Encounter$diagnosesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$diagnosesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findMany"> | Null>
    consents<T extends Encounter$consentsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findMany"> | Null>
    sterilizationPackageUses<T extends Encounter$sterilizationPackageUsesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$sterilizationPackageUsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSterilizationPackageUsePayload<ExtArgs>, T, "findMany"> | Null>
    employeeBenefitUsages<T extends Encounter$employeeBenefitUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$employeeBenefitUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */ 
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'Int'>
    readonly patientBookId: FieldRef<"Encounter", 'Int'>
    readonly doctorId: FieldRef<"Encounter", 'Int'>
    readonly visitDate: FieldRef<"Encounter", 'DateTime'>
    readonly notes: FieldRef<"Encounter", 'String'>
    readonly appointmentId: FieldRef<"Encounter", 'Int'>
    readonly nurseId: FieldRef<"Encounter", 'Int'>
    readonly patientSignaturePath: FieldRef<"Encounter", 'String'>
    readonly patientSignedAt: FieldRef<"Encounter", 'DateTime'>
    readonly doctorSignaturePath: FieldRef<"Encounter", 'String'>
    readonly doctorSignedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter.appointment
   */
  export type Encounter$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * Encounter.nurse
   */
  export type Encounter$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Encounter.chartTeeth
   */
  export type Encounter$chartTeethArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    where?: ChartToothWhereInput
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    cursor?: ChartToothWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * Encounter.invoice
   */
  export type Encounter$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Encounter.prescription
   */
  export type Encounter$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }

  /**
   * Encounter.media
   */
  export type Encounter$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Encounter.encounterServices
   */
  export type Encounter$encounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    where?: EncounterServiceWhereInput
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    cursor?: EncounterServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * Encounter.diagnoses
   */
  export type Encounter$diagnosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    where?: EncounterDiagnosisWhereInput
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    cursor?: EncounterDiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * Encounter.consents
   */
  export type Encounter$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    where?: EncounterConsentWhereInput
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    cursor?: EncounterConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * Encounter.sterilizationPackageUses
   */
  export type Encounter$sterilizationPackageUsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSterilizationPackageUse
     */
    select?: EncounterSterilizationPackageUseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSterilizationPackageUseInclude<ExtArgs> | null
    where?: EncounterSterilizationPackageUseWhereInput
    orderBy?: EncounterSterilizationPackageUseOrderByWithRelationInput | EncounterSterilizationPackageUseOrderByWithRelationInput[]
    cursor?: EncounterSterilizationPackageUseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterSterilizationPackageUseScalarFieldEnum | EncounterSterilizationPackageUseScalarFieldEnum[]
  }

  /**
   * Encounter.employeeBenefitUsages
   */
  export type Encounter$employeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model EncounterConsent
   */

  export type AggregateEncounterConsent = {
    _count: EncounterConsentCountAggregateOutputType | null
    _avg: EncounterConsentAvgAggregateOutputType | null
    _sum: EncounterConsentSumAggregateOutputType | null
    _min: EncounterConsentMinAggregateOutputType | null
    _max: EncounterConsentMaxAggregateOutputType | null
  }

  export type EncounterConsentAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type EncounterConsentSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type EncounterConsentMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterConsentMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterConsentCountAggregateOutputType = {
    id: number
    encounterId: number
    type: number
    answers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncounterConsentAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type EncounterConsentSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type EncounterConsentMinAggregateInputType = {
    id?: true
    encounterId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterConsentMaxAggregateInputType = {
    id?: true
    encounterId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterConsentCountAggregateInputType = {
    id?: true
    encounterId?: true
    type?: true
    answers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncounterConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConsent to aggregate.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterConsents
    **/
    _count?: true | EncounterConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterConsentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterConsentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterConsentMaxAggregateInputType
  }

  export type GetEncounterConsentAggregateType<T extends EncounterConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterConsent[P]>
      : GetScalarType<T[P], AggregateEncounterConsent[P]>
  }




  export type EncounterConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConsentWhereInput
    orderBy?: EncounterConsentOrderByWithAggregationInput | EncounterConsentOrderByWithAggregationInput[]
    by: EncounterConsentScalarFieldEnum[] | EncounterConsentScalarFieldEnum
    having?: EncounterConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterConsentCountAggregateInputType | true
    _avg?: EncounterConsentAvgAggregateInputType
    _sum?: EncounterConsentSumAggregateInputType
    _min?: EncounterConsentMinAggregateInputType
    _max?: EncounterConsentMaxAggregateInputType
  }

  export type EncounterConsentGroupByOutputType = {
    id: number
    encounterId: number
    type: string
    answers: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: EncounterConsentCountAggregateOutputType | null
    _avg: EncounterConsentAvgAggregateOutputType | null
    _sum: EncounterConsentSumAggregateOutputType | null
    _min: EncounterConsentMinAggregateOutputType | null
    _max: EncounterConsentMaxAggregateOutputType | null
  }

  type GetEncounterConsentGroupByPayload<T extends EncounterConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterConsentGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterConsentGroupByOutputType[P]>
        }
      >
    >


  export type EncounterConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    type?: boolean
    answers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConsent"]>

  export type EncounterConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    type?: boolean
    answers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConsent"]>

  export type EncounterConsentSelectScalar = {
    id?: boolean
    encounterId?: boolean
    type?: boolean
    answers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncounterConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type EncounterConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $EncounterConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterConsent"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      type: string
      answers: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encounterConsent"]>
    composites: {}
  }

  type EncounterConsentGetPayload<S extends boolean | null | undefined | EncounterConsentDefaultArgs> = $Result.GetResult<Prisma.$EncounterConsentPayload, S>

  type EncounterConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterConsentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterConsentCountAggregateInputType | true
    }

  export interface EncounterConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterConsent'], meta: { name: 'EncounterConsent' } }
    /**
     * Find zero or one EncounterConsent that matches the filter.
     * @param {EncounterConsentFindUniqueArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterConsentFindUniqueArgs>(args: SelectSubset<T, EncounterConsentFindUniqueArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterConsent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterConsentFindUniqueOrThrowArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentFindFirstArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterConsentFindFirstArgs>(args?: SelectSubset<T, EncounterConsentFindFirstArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentFindFirstOrThrowArgs} args - Arguments to find a EncounterConsent
     * @example
     * // Get one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterConsents
     * const encounterConsents = await prisma.encounterConsent.findMany()
     * 
     * // Get first 10 EncounterConsents
     * const encounterConsents = await prisma.encounterConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterConsentWithIdOnly = await prisma.encounterConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterConsentFindManyArgs>(args?: SelectSubset<T, EncounterConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterConsent.
     * @param {EncounterConsentCreateArgs} args - Arguments to create a EncounterConsent.
     * @example
     * // Create one EncounterConsent
     * const EncounterConsent = await prisma.encounterConsent.create({
     *   data: {
     *     // ... data to create a EncounterConsent
     *   }
     * })
     * 
     */
    create<T extends EncounterConsentCreateArgs>(args: SelectSubset<T, EncounterConsentCreateArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterConsents.
     * @param {EncounterConsentCreateManyArgs} args - Arguments to create many EncounterConsents.
     * @example
     * // Create many EncounterConsents
     * const encounterConsent = await prisma.encounterConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterConsentCreateManyArgs>(args?: SelectSubset<T, EncounterConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterConsents and returns the data saved in the database.
     * @param {EncounterConsentCreateManyAndReturnArgs} args - Arguments to create many EncounterConsents.
     * @example
     * // Create many EncounterConsents
     * const encounterConsent = await prisma.encounterConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterConsents and only return the `id`
     * const encounterConsentWithIdOnly = await prisma.encounterConsent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterConsent.
     * @param {EncounterConsentDeleteArgs} args - Arguments to delete one EncounterConsent.
     * @example
     * // Delete one EncounterConsent
     * const EncounterConsent = await prisma.encounterConsent.delete({
     *   where: {
     *     // ... filter to delete one EncounterConsent
     *   }
     * })
     * 
     */
    delete<T extends EncounterConsentDeleteArgs>(args: SelectSubset<T, EncounterConsentDeleteArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterConsent.
     * @param {EncounterConsentUpdateArgs} args - Arguments to update one EncounterConsent.
     * @example
     * // Update one EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterConsentUpdateArgs>(args: SelectSubset<T, EncounterConsentUpdateArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterConsents.
     * @param {EncounterConsentDeleteManyArgs} args - Arguments to filter EncounterConsents to delete.
     * @example
     * // Delete a few EncounterConsents
     * const { count } = await prisma.encounterConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterConsentDeleteManyArgs>(args?: SelectSubset<T, EncounterConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterConsents
     * const encounterConsent = await prisma.encounterConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterConsentUpdateManyArgs>(args: SelectSubset<T, EncounterConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterConsent.
     * @param {EncounterConsentUpsertArgs} args - Arguments to update or create a EncounterConsent.
     * @example
     * // Update or create a EncounterConsent
     * const encounterConsent = await prisma.encounterConsent.upsert({
     *   create: {
     *     // ... data to create a EncounterConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterConsent we want to update
     *   }
     * })
     */
    upsert<T extends EncounterConsentUpsertArgs>(args: SelectSubset<T, EncounterConsentUpsertArgs<ExtArgs>>): Prisma__EncounterConsentClient<$Result.GetResult<Prisma.$EncounterConsentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentCountArgs} args - Arguments to filter EncounterConsents to count.
     * @example
     * // Count the number of EncounterConsents
     * const count = await prisma.encounterConsent.count({
     *   where: {
     *     // ... the filter for the EncounterConsents we want to count
     *   }
     * })
    **/
    count<T extends EncounterConsentCountArgs>(
      args?: Subset<T, EncounterConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterConsentAggregateArgs>(args: Subset<T, EncounterConsentAggregateArgs>): Prisma.PrismaPromise<GetEncounterConsentAggregateType<T>>

    /**
     * Group by EncounterConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterConsentGroupByArgs['orderBy'] }
        : { orderBy?: EncounterConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterConsent model
   */
  readonly fields: EncounterConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterConsent model
   */ 
  interface EncounterConsentFieldRefs {
    readonly id: FieldRef<"EncounterConsent", 'Int'>
    readonly encounterId: FieldRef<"EncounterConsent", 'Int'>
    readonly type: FieldRef<"EncounterConsent", 'String'>
    readonly answers: FieldRef<"EncounterConsent", 'Json'>
    readonly createdAt: FieldRef<"EncounterConsent", 'DateTime'>
    readonly updatedAt: FieldRef<"EncounterConsent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterConsent findUnique
   */
  export type EncounterConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent findUniqueOrThrow
   */
  export type EncounterConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent findFirst
   */
  export type EncounterConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConsents.
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConsents.
     */
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * EncounterConsent findFirstOrThrow
   */
  export type EncounterConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsent to fetch.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConsents.
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConsents.
     */
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * EncounterConsent findMany
   */
  export type EncounterConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConsents to fetch.
     */
    where?: EncounterConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConsents to fetch.
     */
    orderBy?: EncounterConsentOrderByWithRelationInput | EncounterConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterConsents.
     */
    cursor?: EncounterConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConsents.
     */
    skip?: number
    distinct?: EncounterConsentScalarFieldEnum | EncounterConsentScalarFieldEnum[]
  }

  /**
   * EncounterConsent create
   */
  export type EncounterConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterConsent.
     */
    data: XOR<EncounterConsentCreateInput, EncounterConsentUncheckedCreateInput>
  }

  /**
   * EncounterConsent createMany
   */
  export type EncounterConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterConsents.
     */
    data: EncounterConsentCreateManyInput | EncounterConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterConsent createManyAndReturn
   */
  export type EncounterConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterConsents.
     */
    data: EncounterConsentCreateManyInput | EncounterConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterConsent update
   */
  export type EncounterConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterConsent.
     */
    data: XOR<EncounterConsentUpdateInput, EncounterConsentUncheckedUpdateInput>
    /**
     * Choose, which EncounterConsent to update.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent updateMany
   */
  export type EncounterConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterConsents.
     */
    data: XOR<EncounterConsentUpdateManyMutationInput, EncounterConsentUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConsents to update
     */
    where?: EncounterConsentWhereInput
  }

  /**
   * EncounterConsent upsert
   */
  export type EncounterConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterConsent to update in case it exists.
     */
    where: EncounterConsentWhereUniqueInput
    /**
     * In case the EncounterConsent found by the `where` argument doesn't exist, create a new EncounterConsent with this data.
     */
    create: XOR<EncounterConsentCreateInput, EncounterConsentUncheckedCreateInput>
    /**
     * In case the EncounterConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterConsentUpdateInput, EncounterConsentUncheckedUpdateInput>
  }

  /**
   * EncounterConsent delete
   */
  export type EncounterConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
    /**
     * Filter which EncounterConsent to delete.
     */
    where: EncounterConsentWhereUniqueInput
  }

  /**
   * EncounterConsent deleteMany
   */
  export type EncounterConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConsents to delete
     */
    where?: EncounterConsentWhereInput
  }

  /**
   * EncounterConsent without action
   */
  export type EncounterConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConsent
     */
    select?: EncounterConsentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConsentInclude<ExtArgs> | null
  }


  /**
   * Model ChartTooth
   */

  export type AggregateChartTooth = {
    _count: ChartToothCountAggregateOutputType | null
    _avg: ChartToothAvgAggregateOutputType | null
    _sum: ChartToothSumAggregateOutputType | null
    _min: ChartToothMinAggregateOutputType | null
    _max: ChartToothMaxAggregateOutputType | null
  }

  export type ChartToothAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type ChartToothSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type ChartToothMinAggregateOutputType = {
    id: number | null
    toothCode: string | null
    toothGroup: string | null
    status: string | null
    notes: string | null
    encounterId: number | null
  }

  export type ChartToothMaxAggregateOutputType = {
    id: number | null
    toothCode: string | null
    toothGroup: string | null
    status: string | null
    notes: string | null
    encounterId: number | null
  }

  export type ChartToothCountAggregateOutputType = {
    id: number
    toothCode: number
    toothGroup: number
    status: number
    notes: number
    encounterId: number
    _all: number
  }


  export type ChartToothAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type ChartToothSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type ChartToothMinAggregateInputType = {
    id?: true
    toothCode?: true
    toothGroup?: true
    status?: true
    notes?: true
    encounterId?: true
  }

  export type ChartToothMaxAggregateInputType = {
    id?: true
    toothCode?: true
    toothGroup?: true
    status?: true
    notes?: true
    encounterId?: true
  }

  export type ChartToothCountAggregateInputType = {
    id?: true
    toothCode?: true
    toothGroup?: true
    status?: true
    notes?: true
    encounterId?: true
    _all?: true
  }

  export type ChartToothAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartTooth to aggregate.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartTooths
    **/
    _count?: true | ChartToothCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChartToothAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChartToothSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartToothMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartToothMaxAggregateInputType
  }

  export type GetChartToothAggregateType<T extends ChartToothAggregateArgs> = {
        [P in keyof T & keyof AggregateChartTooth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartTooth[P]>
      : GetScalarType<T[P], AggregateChartTooth[P]>
  }




  export type ChartToothGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartToothWhereInput
    orderBy?: ChartToothOrderByWithAggregationInput | ChartToothOrderByWithAggregationInput[]
    by: ChartToothScalarFieldEnum[] | ChartToothScalarFieldEnum
    having?: ChartToothScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartToothCountAggregateInputType | true
    _avg?: ChartToothAvgAggregateInputType
    _sum?: ChartToothSumAggregateInputType
    _min?: ChartToothMinAggregateInputType
    _max?: ChartToothMaxAggregateInputType
  }

  export type ChartToothGroupByOutputType = {
    id: number
    toothCode: string
    toothGroup: string | null
    status: string | null
    notes: string | null
    encounterId: number
    _count: ChartToothCountAggregateOutputType | null
    _avg: ChartToothAvgAggregateOutputType | null
    _sum: ChartToothSumAggregateOutputType | null
    _min: ChartToothMinAggregateOutputType | null
    _max: ChartToothMaxAggregateOutputType | null
  }

  type GetChartToothGroupByPayload<T extends ChartToothGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartToothGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartToothGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartToothGroupByOutputType[P]>
            : GetScalarType<T[P], ChartToothGroupByOutputType[P]>
        }
      >
    >


  export type ChartToothSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    toothCode?: boolean
    toothGroup?: boolean
    status?: boolean
    notes?: boolean
    encounterId?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    chartNotes?: boolean | ChartTooth$chartNotesArgs<ExtArgs>
    _count?: boolean | ChartToothCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartTooth"]>

  export type ChartToothSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    toothCode?: boolean
    toothGroup?: boolean
    status?: boolean
    notes?: boolean
    encounterId?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartTooth"]>

  export type ChartToothSelectScalar = {
    id?: boolean
    toothCode?: boolean
    toothGroup?: boolean
    status?: boolean
    notes?: boolean
    encounterId?: boolean
  }

  export type ChartToothInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    chartNotes?: boolean | ChartTooth$chartNotesArgs<ExtArgs>
    _count?: boolean | ChartToothCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChartToothIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $ChartToothPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartTooth"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      chartNotes: Prisma.$ChartNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      toothCode: string
      toothGroup: string | null
      status: string | null
      notes: string | null
      encounterId: number
    }, ExtArgs["result"]["chartTooth"]>
    composites: {}
  }

  type ChartToothGetPayload<S extends boolean | null | undefined | ChartToothDefaultArgs> = $Result.GetResult<Prisma.$ChartToothPayload, S>

  type ChartToothCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChartToothFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChartToothCountAggregateInputType | true
    }

  export interface ChartToothDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartTooth'], meta: { name: 'ChartTooth' } }
    /**
     * Find zero or one ChartTooth that matches the filter.
     * @param {ChartToothFindUniqueArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartToothFindUniqueArgs>(args: SelectSubset<T, ChartToothFindUniqueArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChartTooth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChartToothFindUniqueOrThrowArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartToothFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartToothFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChartTooth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothFindFirstArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartToothFindFirstArgs>(args?: SelectSubset<T, ChartToothFindFirstArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChartTooth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothFindFirstOrThrowArgs} args - Arguments to find a ChartTooth
     * @example
     * // Get one ChartTooth
     * const chartTooth = await prisma.chartTooth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartToothFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartToothFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChartTooths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartTooths
     * const chartTooths = await prisma.chartTooth.findMany()
     * 
     * // Get first 10 ChartTooths
     * const chartTooths = await prisma.chartTooth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartToothWithIdOnly = await prisma.chartTooth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartToothFindManyArgs>(args?: SelectSubset<T, ChartToothFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChartTooth.
     * @param {ChartToothCreateArgs} args - Arguments to create a ChartTooth.
     * @example
     * // Create one ChartTooth
     * const ChartTooth = await prisma.chartTooth.create({
     *   data: {
     *     // ... data to create a ChartTooth
     *   }
     * })
     * 
     */
    create<T extends ChartToothCreateArgs>(args: SelectSubset<T, ChartToothCreateArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChartTooths.
     * @param {ChartToothCreateManyArgs} args - Arguments to create many ChartTooths.
     * @example
     * // Create many ChartTooths
     * const chartTooth = await prisma.chartTooth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartToothCreateManyArgs>(args?: SelectSubset<T, ChartToothCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartTooths and returns the data saved in the database.
     * @param {ChartToothCreateManyAndReturnArgs} args - Arguments to create many ChartTooths.
     * @example
     * // Create many ChartTooths
     * const chartTooth = await prisma.chartTooth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartTooths and only return the `id`
     * const chartToothWithIdOnly = await prisma.chartTooth.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartToothCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartToothCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChartTooth.
     * @param {ChartToothDeleteArgs} args - Arguments to delete one ChartTooth.
     * @example
     * // Delete one ChartTooth
     * const ChartTooth = await prisma.chartTooth.delete({
     *   where: {
     *     // ... filter to delete one ChartTooth
     *   }
     * })
     * 
     */
    delete<T extends ChartToothDeleteArgs>(args: SelectSubset<T, ChartToothDeleteArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChartTooth.
     * @param {ChartToothUpdateArgs} args - Arguments to update one ChartTooth.
     * @example
     * // Update one ChartTooth
     * const chartTooth = await prisma.chartTooth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartToothUpdateArgs>(args: SelectSubset<T, ChartToothUpdateArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChartTooths.
     * @param {ChartToothDeleteManyArgs} args - Arguments to filter ChartTooths to delete.
     * @example
     * // Delete a few ChartTooths
     * const { count } = await prisma.chartTooth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartToothDeleteManyArgs>(args?: SelectSubset<T, ChartToothDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartTooths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartTooths
     * const chartTooth = await prisma.chartTooth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartToothUpdateManyArgs>(args: SelectSubset<T, ChartToothUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChartTooth.
     * @param {ChartToothUpsertArgs} args - Arguments to update or create a ChartTooth.
     * @example
     * // Update or create a ChartTooth
     * const chartTooth = await prisma.chartTooth.upsert({
     *   create: {
     *     // ... data to create a ChartTooth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartTooth we want to update
     *   }
     * })
     */
    upsert<T extends ChartToothUpsertArgs>(args: SelectSubset<T, ChartToothUpsertArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChartTooths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothCountArgs} args - Arguments to filter ChartTooths to count.
     * @example
     * // Count the number of ChartTooths
     * const count = await prisma.chartTooth.count({
     *   where: {
     *     // ... the filter for the ChartTooths we want to count
     *   }
     * })
    **/
    count<T extends ChartToothCountArgs>(
      args?: Subset<T, ChartToothCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartToothCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartTooth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartToothAggregateArgs>(args: Subset<T, ChartToothAggregateArgs>): Prisma.PrismaPromise<GetChartToothAggregateType<T>>

    /**
     * Group by ChartTooth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartToothGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartToothGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartToothGroupByArgs['orderBy'] }
        : { orderBy?: ChartToothGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartToothGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartToothGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartTooth model
   */
  readonly fields: ChartToothFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartTooth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartToothClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chartNotes<T extends ChartTooth$chartNotesArgs<ExtArgs> = {}>(args?: Subset<T, ChartTooth$chartNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartTooth model
   */ 
  interface ChartToothFieldRefs {
    readonly id: FieldRef<"ChartTooth", 'Int'>
    readonly toothCode: FieldRef<"ChartTooth", 'String'>
    readonly toothGroup: FieldRef<"ChartTooth", 'String'>
    readonly status: FieldRef<"ChartTooth", 'String'>
    readonly notes: FieldRef<"ChartTooth", 'String'>
    readonly encounterId: FieldRef<"ChartTooth", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChartTooth findUnique
   */
  export type ChartToothFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth findUniqueOrThrow
   */
  export type ChartToothFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth findFirst
   */
  export type ChartToothFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartTooths.
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartTooths.
     */
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * ChartTooth findFirstOrThrow
   */
  export type ChartToothFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooth to fetch.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartTooths.
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartTooths.
     */
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * ChartTooth findMany
   */
  export type ChartToothFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter, which ChartTooths to fetch.
     */
    where?: ChartToothWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartTooths to fetch.
     */
    orderBy?: ChartToothOrderByWithRelationInput | ChartToothOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartTooths.
     */
    cursor?: ChartToothWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartTooths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartTooths.
     */
    skip?: number
    distinct?: ChartToothScalarFieldEnum | ChartToothScalarFieldEnum[]
  }

  /**
   * ChartTooth create
   */
  export type ChartToothCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartTooth.
     */
    data: XOR<ChartToothCreateInput, ChartToothUncheckedCreateInput>
  }

  /**
   * ChartTooth createMany
   */
  export type ChartToothCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartTooths.
     */
    data: ChartToothCreateManyInput | ChartToothCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartTooth createManyAndReturn
   */
  export type ChartToothCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChartTooths.
     */
    data: ChartToothCreateManyInput | ChartToothCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartTooth update
   */
  export type ChartToothUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartTooth.
     */
    data: XOR<ChartToothUpdateInput, ChartToothUncheckedUpdateInput>
    /**
     * Choose, which ChartTooth to update.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth updateMany
   */
  export type ChartToothUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartTooths.
     */
    data: XOR<ChartToothUpdateManyMutationInput, ChartToothUncheckedUpdateManyInput>
    /**
     * Filter which ChartTooths to update
     */
    where?: ChartToothWhereInput
  }

  /**
   * ChartTooth upsert
   */
  export type ChartToothUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartTooth to update in case it exists.
     */
    where: ChartToothWhereUniqueInput
    /**
     * In case the ChartTooth found by the `where` argument doesn't exist, create a new ChartTooth with this data.
     */
    create: XOR<ChartToothCreateInput, ChartToothUncheckedCreateInput>
    /**
     * In case the ChartTooth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartToothUpdateInput, ChartToothUncheckedUpdateInput>
  }

  /**
   * ChartTooth delete
   */
  export type ChartToothDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
    /**
     * Filter which ChartTooth to delete.
     */
    where: ChartToothWhereUniqueInput
  }

  /**
   * ChartTooth deleteMany
   */
  export type ChartToothDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartTooths to delete
     */
    where?: ChartToothWhereInput
  }

  /**
   * ChartTooth.chartNotes
   */
  export type ChartTooth$chartNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    where?: ChartNoteWhereInput
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    cursor?: ChartNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartTooth without action
   */
  export type ChartToothDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartTooth
     */
    select?: ChartToothSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartToothInclude<ExtArgs> | null
  }


  /**
   * Model ChartNote
   */

  export type AggregateChartNote = {
    _count: ChartNoteCountAggregateOutputType | null
    _avg: ChartNoteAvgAggregateOutputType | null
    _sum: ChartNoteSumAggregateOutputType | null
    _min: ChartNoteMinAggregateOutputType | null
    _max: ChartNoteMaxAggregateOutputType | null
  }

  export type ChartNoteAvgAggregateOutputType = {
    id: number | null
    chartToothId: number | null
  }

  export type ChartNoteSumAggregateOutputType = {
    id: number | null
    chartToothId: number | null
  }

  export type ChartNoteMinAggregateOutputType = {
    id: number | null
    chartToothId: number | null
    description: string | null
    createdAt: Date | null
  }

  export type ChartNoteMaxAggregateOutputType = {
    id: number | null
    chartToothId: number | null
    description: string | null
    createdAt: Date | null
  }

  export type ChartNoteCountAggregateOutputType = {
    id: number
    chartToothId: number
    description: number
    createdAt: number
    _all: number
  }


  export type ChartNoteAvgAggregateInputType = {
    id?: true
    chartToothId?: true
  }

  export type ChartNoteSumAggregateInputType = {
    id?: true
    chartToothId?: true
  }

  export type ChartNoteMinAggregateInputType = {
    id?: true
    chartToothId?: true
    description?: true
    createdAt?: true
  }

  export type ChartNoteMaxAggregateInputType = {
    id?: true
    chartToothId?: true
    description?: true
    createdAt?: true
  }

  export type ChartNoteCountAggregateInputType = {
    id?: true
    chartToothId?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ChartNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartNote to aggregate.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartNotes
    **/
    _count?: true | ChartNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChartNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChartNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartNoteMaxAggregateInputType
  }

  export type GetChartNoteAggregateType<T extends ChartNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateChartNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartNote[P]>
      : GetScalarType<T[P], AggregateChartNote[P]>
  }




  export type ChartNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartNoteWhereInput
    orderBy?: ChartNoteOrderByWithAggregationInput | ChartNoteOrderByWithAggregationInput[]
    by: ChartNoteScalarFieldEnum[] | ChartNoteScalarFieldEnum
    having?: ChartNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartNoteCountAggregateInputType | true
    _avg?: ChartNoteAvgAggregateInputType
    _sum?: ChartNoteSumAggregateInputType
    _min?: ChartNoteMinAggregateInputType
    _max?: ChartNoteMaxAggregateInputType
  }

  export type ChartNoteGroupByOutputType = {
    id: number
    chartToothId: number
    description: string
    createdAt: Date
    _count: ChartNoteCountAggregateOutputType | null
    _avg: ChartNoteAvgAggregateOutputType | null
    _sum: ChartNoteSumAggregateOutputType | null
    _min: ChartNoteMinAggregateOutputType | null
    _max: ChartNoteMaxAggregateOutputType | null
  }

  type GetChartNoteGroupByPayload<T extends ChartNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ChartNoteGroupByOutputType[P]>
        }
      >
    >


  export type ChartNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chartToothId?: boolean
    description?: boolean
    createdAt?: boolean
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartNote"]>

  export type ChartNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chartToothId?: boolean
    description?: boolean
    createdAt?: boolean
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartNote"]>

  export type ChartNoteSelectScalar = {
    id?: boolean
    chartToothId?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ChartNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }
  export type ChartNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartTooth?: boolean | ChartToothDefaultArgs<ExtArgs>
  }

  export type $ChartNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartNote"
    objects: {
      chartTooth: Prisma.$ChartToothPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chartToothId: number
      description: string
      createdAt: Date
    }, ExtArgs["result"]["chartNote"]>
    composites: {}
  }

  type ChartNoteGetPayload<S extends boolean | null | undefined | ChartNoteDefaultArgs> = $Result.GetResult<Prisma.$ChartNotePayload, S>

  type ChartNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChartNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChartNoteCountAggregateInputType | true
    }

  export interface ChartNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartNote'], meta: { name: 'ChartNote' } }
    /**
     * Find zero or one ChartNote that matches the filter.
     * @param {ChartNoteFindUniqueArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartNoteFindUniqueArgs>(args: SelectSubset<T, ChartNoteFindUniqueArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChartNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChartNoteFindUniqueOrThrowArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChartNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteFindFirstArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartNoteFindFirstArgs>(args?: SelectSubset<T, ChartNoteFindFirstArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChartNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteFindFirstOrThrowArgs} args - Arguments to find a ChartNote
     * @example
     * // Get one ChartNote
     * const chartNote = await prisma.chartNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChartNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartNotes
     * const chartNotes = await prisma.chartNote.findMany()
     * 
     * // Get first 10 ChartNotes
     * const chartNotes = await prisma.chartNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartNoteWithIdOnly = await prisma.chartNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartNoteFindManyArgs>(args?: SelectSubset<T, ChartNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChartNote.
     * @param {ChartNoteCreateArgs} args - Arguments to create a ChartNote.
     * @example
     * // Create one ChartNote
     * const ChartNote = await prisma.chartNote.create({
     *   data: {
     *     // ... data to create a ChartNote
     *   }
     * })
     * 
     */
    create<T extends ChartNoteCreateArgs>(args: SelectSubset<T, ChartNoteCreateArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChartNotes.
     * @param {ChartNoteCreateManyArgs} args - Arguments to create many ChartNotes.
     * @example
     * // Create many ChartNotes
     * const chartNote = await prisma.chartNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartNoteCreateManyArgs>(args?: SelectSubset<T, ChartNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartNotes and returns the data saved in the database.
     * @param {ChartNoteCreateManyAndReturnArgs} args - Arguments to create many ChartNotes.
     * @example
     * // Create many ChartNotes
     * const chartNote = await prisma.chartNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartNotes and only return the `id`
     * const chartNoteWithIdOnly = await prisma.chartNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChartNote.
     * @param {ChartNoteDeleteArgs} args - Arguments to delete one ChartNote.
     * @example
     * // Delete one ChartNote
     * const ChartNote = await prisma.chartNote.delete({
     *   where: {
     *     // ... filter to delete one ChartNote
     *   }
     * })
     * 
     */
    delete<T extends ChartNoteDeleteArgs>(args: SelectSubset<T, ChartNoteDeleteArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChartNote.
     * @param {ChartNoteUpdateArgs} args - Arguments to update one ChartNote.
     * @example
     * // Update one ChartNote
     * const chartNote = await prisma.chartNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartNoteUpdateArgs>(args: SelectSubset<T, ChartNoteUpdateArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChartNotes.
     * @param {ChartNoteDeleteManyArgs} args - Arguments to filter ChartNotes to delete.
     * @example
     * // Delete a few ChartNotes
     * const { count } = await prisma.chartNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartNoteDeleteManyArgs>(args?: SelectSubset<T, ChartNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartNotes
     * const chartNote = await prisma.chartNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartNoteUpdateManyArgs>(args: SelectSubset<T, ChartNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChartNote.
     * @param {ChartNoteUpsertArgs} args - Arguments to update or create a ChartNote.
     * @example
     * // Update or create a ChartNote
     * const chartNote = await prisma.chartNote.upsert({
     *   create: {
     *     // ... data to create a ChartNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartNote we want to update
     *   }
     * })
     */
    upsert<T extends ChartNoteUpsertArgs>(args: SelectSubset<T, ChartNoteUpsertArgs<ExtArgs>>): Prisma__ChartNoteClient<$Result.GetResult<Prisma.$ChartNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChartNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteCountArgs} args - Arguments to filter ChartNotes to count.
     * @example
     * // Count the number of ChartNotes
     * const count = await prisma.chartNote.count({
     *   where: {
     *     // ... the filter for the ChartNotes we want to count
     *   }
     * })
    **/
    count<T extends ChartNoteCountArgs>(
      args?: Subset<T, ChartNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartNoteAggregateArgs>(args: Subset<T, ChartNoteAggregateArgs>): Prisma.PrismaPromise<GetChartNoteAggregateType<T>>

    /**
     * Group by ChartNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartNoteGroupByArgs['orderBy'] }
        : { orderBy?: ChartNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartNote model
   */
  readonly fields: ChartNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chartTooth<T extends ChartToothDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartToothDefaultArgs<ExtArgs>>): Prisma__ChartToothClient<$Result.GetResult<Prisma.$ChartToothPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartNote model
   */ 
  interface ChartNoteFieldRefs {
    readonly id: FieldRef<"ChartNote", 'Int'>
    readonly chartToothId: FieldRef<"ChartNote", 'Int'>
    readonly description: FieldRef<"ChartNote", 'String'>
    readonly createdAt: FieldRef<"ChartNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChartNote findUnique
   */
  export type ChartNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote findUniqueOrThrow
   */
  export type ChartNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote findFirst
   */
  export type ChartNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartNotes.
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartNotes.
     */
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartNote findFirstOrThrow
   */
  export type ChartNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNote to fetch.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartNotes.
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartNotes.
     */
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartNote findMany
   */
  export type ChartNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter, which ChartNotes to fetch.
     */
    where?: ChartNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartNotes to fetch.
     */
    orderBy?: ChartNoteOrderByWithRelationInput | ChartNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartNotes.
     */
    cursor?: ChartNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartNotes.
     */
    skip?: number
    distinct?: ChartNoteScalarFieldEnum | ChartNoteScalarFieldEnum[]
  }

  /**
   * ChartNote create
   */
  export type ChartNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartNote.
     */
    data: XOR<ChartNoteCreateInput, ChartNoteUncheckedCreateInput>
  }

  /**
   * ChartNote createMany
   */
  export type ChartNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartNotes.
     */
    data: ChartNoteCreateManyInput | ChartNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartNote createManyAndReturn
   */
  export type ChartNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChartNotes.
     */
    data: ChartNoteCreateManyInput | ChartNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartNote update
   */
  export type ChartNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartNote.
     */
    data: XOR<ChartNoteUpdateInput, ChartNoteUncheckedUpdateInput>
    /**
     * Choose, which ChartNote to update.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote updateMany
   */
  export type ChartNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartNotes.
     */
    data: XOR<ChartNoteUpdateManyMutationInput, ChartNoteUncheckedUpdateManyInput>
    /**
     * Filter which ChartNotes to update
     */
    where?: ChartNoteWhereInput
  }

  /**
   * ChartNote upsert
   */
  export type ChartNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartNote to update in case it exists.
     */
    where: ChartNoteWhereUniqueInput
    /**
     * In case the ChartNote found by the `where` argument doesn't exist, create a new ChartNote with this data.
     */
    create: XOR<ChartNoteCreateInput, ChartNoteUncheckedCreateInput>
    /**
     * In case the ChartNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartNoteUpdateInput, ChartNoteUncheckedUpdateInput>
  }

  /**
   * ChartNote delete
   */
  export type ChartNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
    /**
     * Filter which ChartNote to delete.
     */
    where: ChartNoteWhereUniqueInput
  }

  /**
   * ChartNote deleteMany
   */
  export type ChartNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartNotes to delete
     */
    where?: ChartNoteWhereInput
  }

  /**
   * ChartNote without action
   */
  export type ChartNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartNote
     */
    select?: ChartNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartNoteInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisAvgAggregateOutputType = {
    id: number | null
  }

  export type DiagnosisSumAggregateOutputType = {
    id: number | null
  }

  export type DiagnosisMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiagnosisAvgAggregateInputType = {
    id?: true
  }

  export type DiagnosisSumAggregateInputType = {
    id?: true
  }

  export type DiagnosisMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiagnosisCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _avg?: DiagnosisAvgAggregateInputType
    _sum?: DiagnosisSumAggregateInputType
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    problems?: boolean | Diagnosis$problemsArgs<ExtArgs>
    encounters?: boolean | Diagnosis$encountersArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems?: boolean | Diagnosis$problemsArgs<ExtArgs>
    encounters?: boolean | Diagnosis$encountersArgs<ExtArgs>
    _count?: boolean | DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      problems: Prisma.$DiagnosisProblemPayload<ExtArgs>[]
      encounters: Prisma.$EncounterDiagnosisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }

  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisFindUniqueArgs>(args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisFindFirstArgs>(args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosisFindManyArgs>(args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
     */
    create<T extends DiagnosisCreateArgs>(args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisCreateManyArgs>(args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `id`
     * const diagnosisWithIdOnly = await prisma.diagnosis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisDeleteArgs>(args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisUpdateArgs>(args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisDeleteManyArgs>(args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisUpdateManyArgs>(args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisUpsertArgs>(args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problems<T extends Diagnosis$problemsArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$problemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findMany"> | Null>
    encounters<T extends Diagnosis$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Diagnosis$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diagnosis model
   */ 
  interface DiagnosisFieldRefs {
    readonly id: FieldRef<"Diagnosis", 'Int'>
    readonly code: FieldRef<"Diagnosis", 'String'>
    readonly name: FieldRef<"Diagnosis", 'String'>
    readonly description: FieldRef<"Diagnosis", 'String'>
    readonly createdAt: FieldRef<"Diagnosis", 'DateTime'>
    readonly updatedAt: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis.problems
   */
  export type Diagnosis$problemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    where?: DiagnosisProblemWhereInput
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    cursor?: DiagnosisProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * Diagnosis.encounters
   */
  export type Diagnosis$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    where?: EncounterDiagnosisWhereInput
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    cursor?: EncounterDiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model DiagnosisProblem
   */

  export type AggregateDiagnosisProblem = {
    _count: DiagnosisProblemCountAggregateOutputType | null
    _avg: DiagnosisProblemAvgAggregateOutputType | null
    _sum: DiagnosisProblemSumAggregateOutputType | null
    _min: DiagnosisProblemMinAggregateOutputType | null
    _max: DiagnosisProblemMaxAggregateOutputType | null
  }

  export type DiagnosisProblemAvgAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    order: number | null
  }

  export type DiagnosisProblemSumAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    order: number | null
  }

  export type DiagnosisProblemMinAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    label: string | null
    order: number | null
    active: boolean | null
  }

  export type DiagnosisProblemMaxAggregateOutputType = {
    id: number | null
    diagnosisId: number | null
    label: string | null
    order: number | null
    active: boolean | null
  }

  export type DiagnosisProblemCountAggregateOutputType = {
    id: number
    diagnosisId: number
    label: number
    order: number
    active: number
    _all: number
  }


  export type DiagnosisProblemAvgAggregateInputType = {
    id?: true
    diagnosisId?: true
    order?: true
  }

  export type DiagnosisProblemSumAggregateInputType = {
    id?: true
    diagnosisId?: true
    order?: true
  }

  export type DiagnosisProblemMinAggregateInputType = {
    id?: true
    diagnosisId?: true
    label?: true
    order?: true
    active?: true
  }

  export type DiagnosisProblemMaxAggregateInputType = {
    id?: true
    diagnosisId?: true
    label?: true
    order?: true
    active?: true
  }

  export type DiagnosisProblemCountAggregateInputType = {
    id?: true
    diagnosisId?: true
    label?: true
    order?: true
    active?: true
    _all?: true
  }

  export type DiagnosisProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosisProblem to aggregate.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiagnosisProblems
    **/
    _count?: true | DiagnosisProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosisProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosisProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisProblemMaxAggregateInputType
  }

  export type GetDiagnosisProblemAggregateType<T extends DiagnosisProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosisProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosisProblem[P]>
      : GetScalarType<T[P], AggregateDiagnosisProblem[P]>
  }




  export type DiagnosisProblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisProblemWhereInput
    orderBy?: DiagnosisProblemOrderByWithAggregationInput | DiagnosisProblemOrderByWithAggregationInput[]
    by: DiagnosisProblemScalarFieldEnum[] | DiagnosisProblemScalarFieldEnum
    having?: DiagnosisProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisProblemCountAggregateInputType | true
    _avg?: DiagnosisProblemAvgAggregateInputType
    _sum?: DiagnosisProblemSumAggregateInputType
    _min?: DiagnosisProblemMinAggregateInputType
    _max?: DiagnosisProblemMaxAggregateInputType
  }

  export type DiagnosisProblemGroupByOutputType = {
    id: number
    diagnosisId: number
    label: string
    order: number
    active: boolean
    _count: DiagnosisProblemCountAggregateOutputType | null
    _avg: DiagnosisProblemAvgAggregateOutputType | null
    _sum: DiagnosisProblemSumAggregateOutputType | null
    _min: DiagnosisProblemMinAggregateOutputType | null
    _max: DiagnosisProblemMaxAggregateOutputType | null
  }

  type GetDiagnosisProblemGroupByPayload<T extends DiagnosisProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisProblemGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisProblemGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisProblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosisId?: boolean
    label?: boolean
    order?: boolean
    active?: boolean
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosisProblem"]>

  export type DiagnosisProblemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    diagnosisId?: boolean
    label?: boolean
    order?: boolean
    active?: boolean
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosisProblem"]>

  export type DiagnosisProblemSelectScalar = {
    id?: boolean
    diagnosisId?: boolean
    label?: boolean
    order?: boolean
    active?: boolean
  }

  export type DiagnosisProblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }
  export type DiagnosisProblemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }

  export type $DiagnosisProblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiagnosisProblem"
    objects: {
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      diagnosisId: number
      label: string
      order: number
      active: boolean
    }, ExtArgs["result"]["diagnosisProblem"]>
    composites: {}
  }

  type DiagnosisProblemGetPayload<S extends boolean | null | undefined | DiagnosisProblemDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisProblemPayload, S>

  type DiagnosisProblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisProblemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisProblemCountAggregateInputType | true
    }

  export interface DiagnosisProblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiagnosisProblem'], meta: { name: 'DiagnosisProblem' } }
    /**
     * Find zero or one DiagnosisProblem that matches the filter.
     * @param {DiagnosisProblemFindUniqueArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisProblemFindUniqueArgs>(args: SelectSubset<T, DiagnosisProblemFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DiagnosisProblem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisProblemFindUniqueOrThrowArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisProblemFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisProblemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DiagnosisProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemFindFirstArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisProblemFindFirstArgs>(args?: SelectSubset<T, DiagnosisProblemFindFirstArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DiagnosisProblem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemFindFirstOrThrowArgs} args - Arguments to find a DiagnosisProblem
     * @example
     * // Get one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisProblemFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisProblemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DiagnosisProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiagnosisProblems
     * const diagnosisProblems = await prisma.diagnosisProblem.findMany()
     * 
     * // Get first 10 DiagnosisProblems
     * const diagnosisProblems = await prisma.diagnosisProblem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diagnosisProblemWithIdOnly = await prisma.diagnosisProblem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiagnosisProblemFindManyArgs>(args?: SelectSubset<T, DiagnosisProblemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DiagnosisProblem.
     * @param {DiagnosisProblemCreateArgs} args - Arguments to create a DiagnosisProblem.
     * @example
     * // Create one DiagnosisProblem
     * const DiagnosisProblem = await prisma.diagnosisProblem.create({
     *   data: {
     *     // ... data to create a DiagnosisProblem
     *   }
     * })
     * 
     */
    create<T extends DiagnosisProblemCreateArgs>(args: SelectSubset<T, DiagnosisProblemCreateArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DiagnosisProblems.
     * @param {DiagnosisProblemCreateManyArgs} args - Arguments to create many DiagnosisProblems.
     * @example
     * // Create many DiagnosisProblems
     * const diagnosisProblem = await prisma.diagnosisProblem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisProblemCreateManyArgs>(args?: SelectSubset<T, DiagnosisProblemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiagnosisProblems and returns the data saved in the database.
     * @param {DiagnosisProblemCreateManyAndReturnArgs} args - Arguments to create many DiagnosisProblems.
     * @example
     * // Create many DiagnosisProblems
     * const diagnosisProblem = await prisma.diagnosisProblem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiagnosisProblems and only return the `id`
     * const diagnosisProblemWithIdOnly = await prisma.diagnosisProblem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisProblemCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisProblemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DiagnosisProblem.
     * @param {DiagnosisProblemDeleteArgs} args - Arguments to delete one DiagnosisProblem.
     * @example
     * // Delete one DiagnosisProblem
     * const DiagnosisProblem = await prisma.diagnosisProblem.delete({
     *   where: {
     *     // ... filter to delete one DiagnosisProblem
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisProblemDeleteArgs>(args: SelectSubset<T, DiagnosisProblemDeleteArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DiagnosisProblem.
     * @param {DiagnosisProblemUpdateArgs} args - Arguments to update one DiagnosisProblem.
     * @example
     * // Update one DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisProblemUpdateArgs>(args: SelectSubset<T, DiagnosisProblemUpdateArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DiagnosisProblems.
     * @param {DiagnosisProblemDeleteManyArgs} args - Arguments to filter DiagnosisProblems to delete.
     * @example
     * // Delete a few DiagnosisProblems
     * const { count } = await prisma.diagnosisProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisProblemDeleteManyArgs>(args?: SelectSubset<T, DiagnosisProblemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiagnosisProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiagnosisProblems
     * const diagnosisProblem = await prisma.diagnosisProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisProblemUpdateManyArgs>(args: SelectSubset<T, DiagnosisProblemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiagnosisProblem.
     * @param {DiagnosisProblemUpsertArgs} args - Arguments to update or create a DiagnosisProblem.
     * @example
     * // Update or create a DiagnosisProblem
     * const diagnosisProblem = await prisma.diagnosisProblem.upsert({
     *   create: {
     *     // ... data to create a DiagnosisProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiagnosisProblem we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisProblemUpsertArgs>(args: SelectSubset<T, DiagnosisProblemUpsertArgs<ExtArgs>>): Prisma__DiagnosisProblemClient<$Result.GetResult<Prisma.$DiagnosisProblemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DiagnosisProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemCountArgs} args - Arguments to filter DiagnosisProblems to count.
     * @example
     * // Count the number of DiagnosisProblems
     * const count = await prisma.diagnosisProblem.count({
     *   where: {
     *     // ... the filter for the DiagnosisProblems we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisProblemCountArgs>(
      args?: Subset<T, DiagnosisProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiagnosisProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisProblemAggregateArgs>(args: Subset<T, DiagnosisProblemAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisProblemAggregateType<T>>

    /**
     * Group by DiagnosisProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisProblemGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiagnosisProblem model
   */
  readonly fields: DiagnosisProblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiagnosisProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisProblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diagnosis<T extends DiagnosisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiagnosisDefaultArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiagnosisProblem model
   */ 
  interface DiagnosisProblemFieldRefs {
    readonly id: FieldRef<"DiagnosisProblem", 'Int'>
    readonly diagnosisId: FieldRef<"DiagnosisProblem", 'Int'>
    readonly label: FieldRef<"DiagnosisProblem", 'String'>
    readonly order: FieldRef<"DiagnosisProblem", 'Int'>
    readonly active: FieldRef<"DiagnosisProblem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DiagnosisProblem findUnique
   */
  export type DiagnosisProblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem findUniqueOrThrow
   */
  export type DiagnosisProblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem findFirst
   */
  export type DiagnosisProblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosisProblems.
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosisProblems.
     */
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * DiagnosisProblem findFirstOrThrow
   */
  export type DiagnosisProblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblem to fetch.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiagnosisProblems.
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiagnosisProblems.
     */
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * DiagnosisProblem findMany
   */
  export type DiagnosisProblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter, which DiagnosisProblems to fetch.
     */
    where?: DiagnosisProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiagnosisProblems to fetch.
     */
    orderBy?: DiagnosisProblemOrderByWithRelationInput | DiagnosisProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiagnosisProblems.
     */
    cursor?: DiagnosisProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiagnosisProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiagnosisProblems.
     */
    skip?: number
    distinct?: DiagnosisProblemScalarFieldEnum | DiagnosisProblemScalarFieldEnum[]
  }

  /**
   * DiagnosisProblem create
   */
  export type DiagnosisProblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * The data needed to create a DiagnosisProblem.
     */
    data: XOR<DiagnosisProblemCreateInput, DiagnosisProblemUncheckedCreateInput>
  }

  /**
   * DiagnosisProblem createMany
   */
  export type DiagnosisProblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiagnosisProblems.
     */
    data: DiagnosisProblemCreateManyInput | DiagnosisProblemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiagnosisProblem createManyAndReturn
   */
  export type DiagnosisProblemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DiagnosisProblems.
     */
    data: DiagnosisProblemCreateManyInput | DiagnosisProblemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiagnosisProblem update
   */
  export type DiagnosisProblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * The data needed to update a DiagnosisProblem.
     */
    data: XOR<DiagnosisProblemUpdateInput, DiagnosisProblemUncheckedUpdateInput>
    /**
     * Choose, which DiagnosisProblem to update.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem updateMany
   */
  export type DiagnosisProblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiagnosisProblems.
     */
    data: XOR<DiagnosisProblemUpdateManyMutationInput, DiagnosisProblemUncheckedUpdateManyInput>
    /**
     * Filter which DiagnosisProblems to update
     */
    where?: DiagnosisProblemWhereInput
  }

  /**
   * DiagnosisProblem upsert
   */
  export type DiagnosisProblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * The filter to search for the DiagnosisProblem to update in case it exists.
     */
    where: DiagnosisProblemWhereUniqueInput
    /**
     * In case the DiagnosisProblem found by the `where` argument doesn't exist, create a new DiagnosisProblem with this data.
     */
    create: XOR<DiagnosisProblemCreateInput, DiagnosisProblemUncheckedCreateInput>
    /**
     * In case the DiagnosisProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisProblemUpdateInput, DiagnosisProblemUncheckedUpdateInput>
  }

  /**
   * DiagnosisProblem delete
   */
  export type DiagnosisProblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
    /**
     * Filter which DiagnosisProblem to delete.
     */
    where: DiagnosisProblemWhereUniqueInput
  }

  /**
   * DiagnosisProblem deleteMany
   */
  export type DiagnosisProblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiagnosisProblems to delete
     */
    where?: DiagnosisProblemWhereInput
  }

  /**
   * DiagnosisProblem without action
   */
  export type DiagnosisProblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiagnosisProblem
     */
    select?: DiagnosisProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisProblemInclude<ExtArgs> | null
  }


  /**
   * Model EncounterDiagnosis
   */

  export type AggregateEncounterDiagnosis = {
    _count: EncounterDiagnosisCountAggregateOutputType | null
    _avg: EncounterDiagnosisAvgAggregateOutputType | null
    _sum: EncounterDiagnosisSumAggregateOutputType | null
    _min: EncounterDiagnosisMinAggregateOutputType | null
    _max: EncounterDiagnosisMaxAggregateOutputType | null
  }

  export type EncounterDiagnosisAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
  }

  export type EncounterDiagnosisSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
  }

  export type EncounterDiagnosisMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
    toothCode: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EncounterDiagnosisMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    diagnosisId: number | null
    toothCode: string | null
    note: string | null
    createdAt: Date | null
  }

  export type EncounterDiagnosisCountAggregateOutputType = {
    id: number
    encounterId: number
    diagnosisId: number
    toothCode: number
    selectedProblemIds: number
    note: number
    createdAt: number
    _all: number
  }


  export type EncounterDiagnosisAvgAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
  }

  export type EncounterDiagnosisSumAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
  }

  export type EncounterDiagnosisMinAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
    toothCode?: true
    note?: true
    createdAt?: true
  }

  export type EncounterDiagnosisMaxAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
    toothCode?: true
    note?: true
    createdAt?: true
  }

  export type EncounterDiagnosisCountAggregateInputType = {
    id?: true
    encounterId?: true
    diagnosisId?: true
    toothCode?: true
    selectedProblemIds?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type EncounterDiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterDiagnosis to aggregate.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterDiagnoses
    **/
    _count?: true | EncounterDiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterDiagnosisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterDiagnosisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterDiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterDiagnosisMaxAggregateInputType
  }

  export type GetEncounterDiagnosisAggregateType<T extends EncounterDiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterDiagnosis[P]>
      : GetScalarType<T[P], AggregateEncounterDiagnosis[P]>
  }




  export type EncounterDiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisWhereInput
    orderBy?: EncounterDiagnosisOrderByWithAggregationInput | EncounterDiagnosisOrderByWithAggregationInput[]
    by: EncounterDiagnosisScalarFieldEnum[] | EncounterDiagnosisScalarFieldEnum
    having?: EncounterDiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterDiagnosisCountAggregateInputType | true
    _avg?: EncounterDiagnosisAvgAggregateInputType
    _sum?: EncounterDiagnosisSumAggregateInputType
    _min?: EncounterDiagnosisMinAggregateInputType
    _max?: EncounterDiagnosisMaxAggregateInputType
  }

  export type EncounterDiagnosisGroupByOutputType = {
    id: number
    encounterId: number
    diagnosisId: number
    toothCode: string | null
    selectedProblemIds: JsonValue | null
    note: string | null
    createdAt: Date
    _count: EncounterDiagnosisCountAggregateOutputType | null
    _avg: EncounterDiagnosisAvgAggregateOutputType | null
    _sum: EncounterDiagnosisSumAggregateOutputType | null
    _min: EncounterDiagnosisMinAggregateOutputType | null
    _max: EncounterDiagnosisMaxAggregateOutputType | null
  }

  type GetEncounterDiagnosisGroupByPayload<T extends EncounterDiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterDiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterDiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterDiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterDiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type EncounterDiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    diagnosisId?: boolean
    toothCode?: boolean
    selectedProblemIds?: boolean
    note?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
    sterilizationIndicators?: boolean | EncounterDiagnosis$sterilizationIndicatorsArgs<ExtArgs>
    _count?: boolean | EncounterDiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterDiagnosis"]>

  export type EncounterDiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    diagnosisId?: boolean
    toothCode?: boolean
    selectedProblemIds?: boolean
    note?: boolean
    createdAt?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterDiagnosis"]>

  export type EncounterDiagnosisSelectScalar = {
    id?: boolean
    encounterId?: boolean
    diagnosisId?: boolean
    toothCode?: boolean
    selectedProblemIds?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type EncounterDiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
    sterilizationIndicators?: boolean | EncounterDiagnosis$sterilizationIndicatorsArgs<ExtArgs>
    _count?: boolean | EncounterDiagnosisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterDiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    diagnosis?: boolean | DiagnosisDefaultArgs<ExtArgs>
  }

  export type $EncounterDiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterDiagnosis"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>
      sterilizationIndicators: Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      diagnosisId: number
      toothCode: string | null
      selectedProblemIds: Prisma.JsonValue | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["encounterDiagnosis"]>
    composites: {}
  }

  type EncounterDiagnosisGetPayload<S extends boolean | null | undefined | EncounterDiagnosisDefaultArgs> = $Result.GetResult<Prisma.$EncounterDiagnosisPayload, S>

  type EncounterDiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterDiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterDiagnosisCountAggregateInputType | true
    }

  export interface EncounterDiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterDiagnosis'], meta: { name: 'EncounterDiagnosis' } }
    /**
     * Find zero or one EncounterDiagnosis that matches the filter.
     * @param {EncounterDiagnosisFindUniqueArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterDiagnosisFindUniqueArgs>(args: SelectSubset<T, EncounterDiagnosisFindUniqueArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterDiagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterDiagnosisFindUniqueOrThrowArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterDiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterDiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterDiagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisFindFirstArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterDiagnosisFindFirstArgs>(args?: SelectSubset<T, EncounterDiagnosisFindFirstArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterDiagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisFindFirstOrThrowArgs} args - Arguments to find a EncounterDiagnosis
     * @example
     * // Get one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterDiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterDiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterDiagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterDiagnoses
     * const encounterDiagnoses = await prisma.encounterDiagnosis.findMany()
     * 
     * // Get first 10 EncounterDiagnoses
     * const encounterDiagnoses = await prisma.encounterDiagnosis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterDiagnosisWithIdOnly = await prisma.encounterDiagnosis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterDiagnosisFindManyArgs>(args?: SelectSubset<T, EncounterDiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterDiagnosis.
     * @param {EncounterDiagnosisCreateArgs} args - Arguments to create a EncounterDiagnosis.
     * @example
     * // Create one EncounterDiagnosis
     * const EncounterDiagnosis = await prisma.encounterDiagnosis.create({
     *   data: {
     *     // ... data to create a EncounterDiagnosis
     *   }
     * })
     * 
     */
    create<T extends EncounterDiagnosisCreateArgs>(args: SelectSubset<T, EncounterDiagnosisCreateArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterDiagnoses.
     * @param {EncounterDiagnosisCreateManyArgs} args - Arguments to create many EncounterDiagnoses.
     * @example
     * // Create many EncounterDiagnoses
     * const encounterDiagnosis = await prisma.encounterDiagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterDiagnosisCreateManyArgs>(args?: SelectSubset<T, EncounterDiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterDiagnoses and returns the data saved in the database.
     * @param {EncounterDiagnosisCreateManyAndReturnArgs} args - Arguments to create many EncounterDiagnoses.
     * @example
     * // Create many EncounterDiagnoses
     * const encounterDiagnosis = await prisma.encounterDiagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterDiagnoses and only return the `id`
     * const encounterDiagnosisWithIdOnly = await prisma.encounterDiagnosis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterDiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterDiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterDiagnosis.
     * @param {EncounterDiagnosisDeleteArgs} args - Arguments to delete one EncounterDiagnosis.
     * @example
     * // Delete one EncounterDiagnosis
     * const EncounterDiagnosis = await prisma.encounterDiagnosis.delete({
     *   where: {
     *     // ... filter to delete one EncounterDiagnosis
     *   }
     * })
     * 
     */
    delete<T extends EncounterDiagnosisDeleteArgs>(args: SelectSubset<T, EncounterDiagnosisDeleteArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterDiagnosis.
     * @param {EncounterDiagnosisUpdateArgs} args - Arguments to update one EncounterDiagnosis.
     * @example
     * // Update one EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterDiagnosisUpdateArgs>(args: SelectSubset<T, EncounterDiagnosisUpdateArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterDiagnoses.
     * @param {EncounterDiagnosisDeleteManyArgs} args - Arguments to filter EncounterDiagnoses to delete.
     * @example
     * // Delete a few EncounterDiagnoses
     * const { count } = await prisma.encounterDiagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDiagnosisDeleteManyArgs>(args?: SelectSubset<T, EncounterDiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterDiagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterDiagnoses
     * const encounterDiagnosis = await prisma.encounterDiagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterDiagnosisUpdateManyArgs>(args: SelectSubset<T, EncounterDiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterDiagnosis.
     * @param {EncounterDiagnosisUpsertArgs} args - Arguments to update or create a EncounterDiagnosis.
     * @example
     * // Update or create a EncounterDiagnosis
     * const encounterDiagnosis = await prisma.encounterDiagnosis.upsert({
     *   create: {
     *     // ... data to create a EncounterDiagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterDiagnosis we want to update
     *   }
     * })
     */
    upsert<T extends EncounterDiagnosisUpsertArgs>(args: SelectSubset<T, EncounterDiagnosisUpsertArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterDiagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisCountArgs} args - Arguments to filter EncounterDiagnoses to count.
     * @example
     * // Count the number of EncounterDiagnoses
     * const count = await prisma.encounterDiagnosis.count({
     *   where: {
     *     // ... the filter for the EncounterDiagnoses we want to count
     *   }
     * })
    **/
    count<T extends EncounterDiagnosisCountArgs>(
      args?: Subset<T, EncounterDiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterDiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterDiagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterDiagnosisAggregateArgs>(args: Subset<T, EncounterDiagnosisAggregateArgs>): Prisma.PrismaPromise<GetEncounterDiagnosisAggregateType<T>>

    /**
     * Group by EncounterDiagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterDiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterDiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: EncounterDiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterDiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterDiagnosis model
   */
  readonly fields: EncounterDiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterDiagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterDiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    diagnosis<T extends DiagnosisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiagnosisDefaultArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sterilizationIndicators<T extends EncounterDiagnosis$sterilizationIndicatorsArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDiagnosis$sterilizationIndicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterDiagnosis model
   */ 
  interface EncounterDiagnosisFieldRefs {
    readonly id: FieldRef<"EncounterDiagnosis", 'Int'>
    readonly encounterId: FieldRef<"EncounterDiagnosis", 'Int'>
    readonly diagnosisId: FieldRef<"EncounterDiagnosis", 'Int'>
    readonly toothCode: FieldRef<"EncounterDiagnosis", 'String'>
    readonly selectedProblemIds: FieldRef<"EncounterDiagnosis", 'Json'>
    readonly note: FieldRef<"EncounterDiagnosis", 'String'>
    readonly createdAt: FieldRef<"EncounterDiagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterDiagnosis findUnique
   */
  export type EncounterDiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis findUniqueOrThrow
   */
  export type EncounterDiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis findFirst
   */
  export type EncounterDiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterDiagnoses.
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterDiagnoses.
     */
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis findFirstOrThrow
   */
  export type EncounterDiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosis to fetch.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterDiagnoses.
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterDiagnoses.
     */
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis findMany
   */
  export type EncounterDiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnoses to fetch.
     */
    where?: EncounterDiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnoses to fetch.
     */
    orderBy?: EncounterDiagnosisOrderByWithRelationInput | EncounterDiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterDiagnoses.
     */
    cursor?: EncounterDiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnoses.
     */
    skip?: number
    distinct?: EncounterDiagnosisScalarFieldEnum | EncounterDiagnosisScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis create
   */
  export type EncounterDiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterDiagnosis.
     */
    data: XOR<EncounterDiagnosisCreateInput, EncounterDiagnosisUncheckedCreateInput>
  }

  /**
   * EncounterDiagnosis createMany
   */
  export type EncounterDiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterDiagnoses.
     */
    data: EncounterDiagnosisCreateManyInput | EncounterDiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterDiagnosis createManyAndReturn
   */
  export type EncounterDiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterDiagnoses.
     */
    data: EncounterDiagnosisCreateManyInput | EncounterDiagnosisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterDiagnosis update
   */
  export type EncounterDiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterDiagnosis.
     */
    data: XOR<EncounterDiagnosisUpdateInput, EncounterDiagnosisUncheckedUpdateInput>
    /**
     * Choose, which EncounterDiagnosis to update.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis updateMany
   */
  export type EncounterDiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterDiagnoses.
     */
    data: XOR<EncounterDiagnosisUpdateManyMutationInput, EncounterDiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which EncounterDiagnoses to update
     */
    where?: EncounterDiagnosisWhereInput
  }

  /**
   * EncounterDiagnosis upsert
   */
  export type EncounterDiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterDiagnosis to update in case it exists.
     */
    where: EncounterDiagnosisWhereUniqueInput
    /**
     * In case the EncounterDiagnosis found by the `where` argument doesn't exist, create a new EncounterDiagnosis with this data.
     */
    create: XOR<EncounterDiagnosisCreateInput, EncounterDiagnosisUncheckedCreateInput>
    /**
     * In case the EncounterDiagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterDiagnosisUpdateInput, EncounterDiagnosisUncheckedUpdateInput>
  }

  /**
   * EncounterDiagnosis delete
   */
  export type EncounterDiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
    /**
     * Filter which EncounterDiagnosis to delete.
     */
    where: EncounterDiagnosisWhereUniqueInput
  }

  /**
   * EncounterDiagnosis deleteMany
   */
  export type EncounterDiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterDiagnoses to delete
     */
    where?: EncounterDiagnosisWhereInput
  }

  /**
   * EncounterDiagnosis.sterilizationIndicators
   */
  export type EncounterDiagnosis$sterilizationIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput[]
    cursor?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterDiagnosisSterilizationIndicatorScalarFieldEnum | EncounterDiagnosisSterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosis without action
   */
  export type EncounterDiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosis
     */
    select?: EncounterDiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model EncounterDiagnosisSterilizationIndicator
   */

  export type AggregateEncounterDiagnosisSterilizationIndicator = {
    _count: EncounterDiagnosisSterilizationIndicatorCountAggregateOutputType | null
    _avg: EncounterDiagnosisSterilizationIndicatorAvgAggregateOutputType | null
    _sum: EncounterDiagnosisSterilizationIndicatorSumAggregateOutputType | null
    _min: EncounterDiagnosisSterilizationIndicatorMinAggregateOutputType | null
    _max: EncounterDiagnosisSterilizationIndicatorMaxAggregateOutputType | null
  }

  export type EncounterDiagnosisSterilizationIndicatorAvgAggregateOutputType = {
    id: number | null
    encounterDiagnosisId: number | null
    indicatorId: number | null
  }

  export type EncounterDiagnosisSterilizationIndicatorSumAggregateOutputType = {
    id: number | null
    encounterDiagnosisId: number | null
    indicatorId: number | null
  }

  export type EncounterDiagnosisSterilizationIndicatorMinAggregateOutputType = {
    id: number | null
    encounterDiagnosisId: number | null
    indicatorId: number | null
    createdAt: Date | null
  }

  export type EncounterDiagnosisSterilizationIndicatorMaxAggregateOutputType = {
    id: number | null
    encounterDiagnosisId: number | null
    indicatorId: number | null
    createdAt: Date | null
  }

  export type EncounterDiagnosisSterilizationIndicatorCountAggregateOutputType = {
    id: number
    encounterDiagnosisId: number
    indicatorId: number
    createdAt: number
    _all: number
  }


  export type EncounterDiagnosisSterilizationIndicatorAvgAggregateInputType = {
    id?: true
    encounterDiagnosisId?: true
    indicatorId?: true
  }

  export type EncounterDiagnosisSterilizationIndicatorSumAggregateInputType = {
    id?: true
    encounterDiagnosisId?: true
    indicatorId?: true
  }

  export type EncounterDiagnosisSterilizationIndicatorMinAggregateInputType = {
    id?: true
    encounterDiagnosisId?: true
    indicatorId?: true
    createdAt?: true
  }

  export type EncounterDiagnosisSterilizationIndicatorMaxAggregateInputType = {
    id?: true
    encounterDiagnosisId?: true
    indicatorId?: true
    createdAt?: true
  }

  export type EncounterDiagnosisSterilizationIndicatorCountAggregateInputType = {
    id?: true
    encounterDiagnosisId?: true
    indicatorId?: true
    createdAt?: true
    _all?: true
  }

  export type EncounterDiagnosisSterilizationIndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterDiagnosisSterilizationIndicator to aggregate.
     */
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnosisSterilizationIndicators to fetch.
     */
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnosisSterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnosisSterilizationIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterDiagnosisSterilizationIndicators
    **/
    _count?: true | EncounterDiagnosisSterilizationIndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterDiagnosisSterilizationIndicatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterDiagnosisSterilizationIndicatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterDiagnosisSterilizationIndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterDiagnosisSterilizationIndicatorMaxAggregateInputType
  }

  export type GetEncounterDiagnosisSterilizationIndicatorAggregateType<T extends EncounterDiagnosisSterilizationIndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterDiagnosisSterilizationIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterDiagnosisSterilizationIndicator[P]>
      : GetScalarType<T[P], AggregateEncounterDiagnosisSterilizationIndicator[P]>
  }




  export type EncounterDiagnosisSterilizationIndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithAggregationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithAggregationInput[]
    by: EncounterDiagnosisSterilizationIndicatorScalarFieldEnum[] | EncounterDiagnosisSterilizationIndicatorScalarFieldEnum
    having?: EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterDiagnosisSterilizationIndicatorCountAggregateInputType | true
    _avg?: EncounterDiagnosisSterilizationIndicatorAvgAggregateInputType
    _sum?: EncounterDiagnosisSterilizationIndicatorSumAggregateInputType
    _min?: EncounterDiagnosisSterilizationIndicatorMinAggregateInputType
    _max?: EncounterDiagnosisSterilizationIndicatorMaxAggregateInputType
  }

  export type EncounterDiagnosisSterilizationIndicatorGroupByOutputType = {
    id: number
    encounterDiagnosisId: number
    indicatorId: number
    createdAt: Date
    _count: EncounterDiagnosisSterilizationIndicatorCountAggregateOutputType | null
    _avg: EncounterDiagnosisSterilizationIndicatorAvgAggregateOutputType | null
    _sum: EncounterDiagnosisSterilizationIndicatorSumAggregateOutputType | null
    _min: EncounterDiagnosisSterilizationIndicatorMinAggregateOutputType | null
    _max: EncounterDiagnosisSterilizationIndicatorMaxAggregateOutputType | null
  }

  type GetEncounterDiagnosisSterilizationIndicatorGroupByPayload<T extends EncounterDiagnosisSterilizationIndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterDiagnosisSterilizationIndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterDiagnosisSterilizationIndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterDiagnosisSterilizationIndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterDiagnosisSterilizationIndicatorGroupByOutputType[P]>
        }
      >
    >


  export type EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterDiagnosisId?: boolean
    indicatorId?: boolean
    createdAt?: boolean
    encounterDiagnosis?: boolean | EncounterDiagnosisDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterDiagnosisSterilizationIndicator"]>

  export type EncounterDiagnosisSterilizationIndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterDiagnosisId?: boolean
    indicatorId?: boolean
    createdAt?: boolean
    encounterDiagnosis?: boolean | EncounterDiagnosisDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterDiagnosisSterilizationIndicator"]>

  export type EncounterDiagnosisSterilizationIndicatorSelectScalar = {
    id?: boolean
    encounterDiagnosisId?: boolean
    indicatorId?: boolean
    createdAt?: boolean
  }

  export type EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterDiagnosis?: boolean | EncounterDiagnosisDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
  }
  export type EncounterDiagnosisSterilizationIndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterDiagnosis?: boolean | EncounterDiagnosisDefaultArgs<ExtArgs>
    indicator?: boolean | SterilizationIndicatorDefaultArgs<ExtArgs>
  }

  export type $EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterDiagnosisSterilizationIndicator"
    objects: {
      encounterDiagnosis: Prisma.$EncounterDiagnosisPayload<ExtArgs>
      indicator: Prisma.$SterilizationIndicatorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterDiagnosisId: number
      indicatorId: number
      createdAt: Date
    }, ExtArgs["result"]["encounterDiagnosisSterilizationIndicator"]>
    composites: {}
  }

  type EncounterDiagnosisSterilizationIndicatorGetPayload<S extends boolean | null | undefined | EncounterDiagnosisSterilizationIndicatorDefaultArgs> = $Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload, S>

  type EncounterDiagnosisSterilizationIndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterDiagnosisSterilizationIndicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterDiagnosisSterilizationIndicatorCountAggregateInputType | true
    }

  export interface EncounterDiagnosisSterilizationIndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterDiagnosisSterilizationIndicator'], meta: { name: 'EncounterDiagnosisSterilizationIndicator' } }
    /**
     * Find zero or one EncounterDiagnosisSterilizationIndicator that matches the filter.
     * @param {EncounterDiagnosisSterilizationIndicatorFindUniqueArgs} args - Arguments to find a EncounterDiagnosisSterilizationIndicator
     * @example
     * // Get one EncounterDiagnosisSterilizationIndicator
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterDiagnosisSterilizationIndicatorFindUniqueArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorFindUniqueArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterDiagnosisSterilizationIndicator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterDiagnosisSterilizationIndicatorFindUniqueOrThrowArgs} args - Arguments to find a EncounterDiagnosisSterilizationIndicator
     * @example
     * // Get one EncounterDiagnosisSterilizationIndicator
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterDiagnosisSterilizationIndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterDiagnosisSterilizationIndicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorFindFirstArgs} args - Arguments to find a EncounterDiagnosisSterilizationIndicator
     * @example
     * // Get one EncounterDiagnosisSterilizationIndicator
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterDiagnosisSterilizationIndicatorFindFirstArgs>(args?: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorFindFirstArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterDiagnosisSterilizationIndicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorFindFirstOrThrowArgs} args - Arguments to find a EncounterDiagnosisSterilizationIndicator
     * @example
     * // Get one EncounterDiagnosisSterilizationIndicator
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterDiagnosisSterilizationIndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterDiagnosisSterilizationIndicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterDiagnosisSterilizationIndicators
     * const encounterDiagnosisSterilizationIndicators = await prisma.encounterDiagnosisSterilizationIndicator.findMany()
     * 
     * // Get first 10 EncounterDiagnosisSterilizationIndicators
     * const encounterDiagnosisSterilizationIndicators = await prisma.encounterDiagnosisSterilizationIndicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterDiagnosisSterilizationIndicatorWithIdOnly = await prisma.encounterDiagnosisSterilizationIndicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterDiagnosisSterilizationIndicatorFindManyArgs>(args?: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterDiagnosisSterilizationIndicator.
     * @param {EncounterDiagnosisSterilizationIndicatorCreateArgs} args - Arguments to create a EncounterDiagnosisSterilizationIndicator.
     * @example
     * // Create one EncounterDiagnosisSterilizationIndicator
     * const EncounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.create({
     *   data: {
     *     // ... data to create a EncounterDiagnosisSterilizationIndicator
     *   }
     * })
     * 
     */
    create<T extends EncounterDiagnosisSterilizationIndicatorCreateArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorCreateArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterDiagnosisSterilizationIndicators.
     * @param {EncounterDiagnosisSterilizationIndicatorCreateManyArgs} args - Arguments to create many EncounterDiagnosisSterilizationIndicators.
     * @example
     * // Create many EncounterDiagnosisSterilizationIndicators
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterDiagnosisSterilizationIndicatorCreateManyArgs>(args?: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterDiagnosisSterilizationIndicators and returns the data saved in the database.
     * @param {EncounterDiagnosisSterilizationIndicatorCreateManyAndReturnArgs} args - Arguments to create many EncounterDiagnosisSterilizationIndicators.
     * @example
     * // Create many EncounterDiagnosisSterilizationIndicators
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterDiagnosisSterilizationIndicators and only return the `id`
     * const encounterDiagnosisSterilizationIndicatorWithIdOnly = await prisma.encounterDiagnosisSterilizationIndicator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterDiagnosisSterilizationIndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterDiagnosisSterilizationIndicator.
     * @param {EncounterDiagnosisSterilizationIndicatorDeleteArgs} args - Arguments to delete one EncounterDiagnosisSterilizationIndicator.
     * @example
     * // Delete one EncounterDiagnosisSterilizationIndicator
     * const EncounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.delete({
     *   where: {
     *     // ... filter to delete one EncounterDiagnosisSterilizationIndicator
     *   }
     * })
     * 
     */
    delete<T extends EncounterDiagnosisSterilizationIndicatorDeleteArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorDeleteArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterDiagnosisSterilizationIndicator.
     * @param {EncounterDiagnosisSterilizationIndicatorUpdateArgs} args - Arguments to update one EncounterDiagnosisSterilizationIndicator.
     * @example
     * // Update one EncounterDiagnosisSterilizationIndicator
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterDiagnosisSterilizationIndicatorUpdateArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorUpdateArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterDiagnosisSterilizationIndicators.
     * @param {EncounterDiagnosisSterilizationIndicatorDeleteManyArgs} args - Arguments to filter EncounterDiagnosisSterilizationIndicators to delete.
     * @example
     * // Delete a few EncounterDiagnosisSterilizationIndicators
     * const { count } = await prisma.encounterDiagnosisSterilizationIndicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDiagnosisSterilizationIndicatorDeleteManyArgs>(args?: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterDiagnosisSterilizationIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterDiagnosisSterilizationIndicators
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterDiagnosisSterilizationIndicatorUpdateManyArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterDiagnosisSterilizationIndicator.
     * @param {EncounterDiagnosisSterilizationIndicatorUpsertArgs} args - Arguments to update or create a EncounterDiagnosisSterilizationIndicator.
     * @example
     * // Update or create a EncounterDiagnosisSterilizationIndicator
     * const encounterDiagnosisSterilizationIndicator = await prisma.encounterDiagnosisSterilizationIndicator.upsert({
     *   create: {
     *     // ... data to create a EncounterDiagnosisSterilizationIndicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterDiagnosisSterilizationIndicator we want to update
     *   }
     * })
     */
    upsert<T extends EncounterDiagnosisSterilizationIndicatorUpsertArgs>(args: SelectSubset<T, EncounterDiagnosisSterilizationIndicatorUpsertArgs<ExtArgs>>): Prisma__EncounterDiagnosisSterilizationIndicatorClient<$Result.GetResult<Prisma.$EncounterDiagnosisSterilizationIndicatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterDiagnosisSterilizationIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorCountArgs} args - Arguments to filter EncounterDiagnosisSterilizationIndicators to count.
     * @example
     * // Count the number of EncounterDiagnosisSterilizationIndicators
     * const count = await prisma.encounterDiagnosisSterilizationIndicator.count({
     *   where: {
     *     // ... the filter for the EncounterDiagnosisSterilizationIndicators we want to count
     *   }
     * })
    **/
    count<T extends EncounterDiagnosisSterilizationIndicatorCountArgs>(
      args?: Subset<T, EncounterDiagnosisSterilizationIndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterDiagnosisSterilizationIndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterDiagnosisSterilizationIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterDiagnosisSterilizationIndicatorAggregateArgs>(args: Subset<T, EncounterDiagnosisSterilizationIndicatorAggregateArgs>): Prisma.PrismaPromise<GetEncounterDiagnosisSterilizationIndicatorAggregateType<T>>

    /**
     * Group by EncounterDiagnosisSterilizationIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterDiagnosisSterilizationIndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterDiagnosisSterilizationIndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterDiagnosisSterilizationIndicatorGroupByArgs['orderBy'] }
        : { orderBy?: EncounterDiagnosisSterilizationIndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterDiagnosisSterilizationIndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterDiagnosisSterilizationIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterDiagnosisSterilizationIndicator model
   */
  readonly fields: EncounterDiagnosisSterilizationIndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterDiagnosisSterilizationIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterDiagnosisSterilizationIndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounterDiagnosis<T extends EncounterDiagnosisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDiagnosisDefaultArgs<ExtArgs>>): Prisma__EncounterDiagnosisClient<$Result.GetResult<Prisma.$EncounterDiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    indicator<T extends SterilizationIndicatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SterilizationIndicatorDefaultArgs<ExtArgs>>): Prisma__SterilizationIndicatorClient<$Result.GetResult<Prisma.$SterilizationIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterDiagnosisSterilizationIndicator model
   */ 
  interface EncounterDiagnosisSterilizationIndicatorFieldRefs {
    readonly id: FieldRef<"EncounterDiagnosisSterilizationIndicator", 'Int'>
    readonly encounterDiagnosisId: FieldRef<"EncounterDiagnosisSterilizationIndicator", 'Int'>
    readonly indicatorId: FieldRef<"EncounterDiagnosisSterilizationIndicator", 'Int'>
    readonly createdAt: FieldRef<"EncounterDiagnosisSterilizationIndicator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncounterDiagnosisSterilizationIndicator findUnique
   */
  export type EncounterDiagnosisSterilizationIndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosisSterilizationIndicator to fetch.
     */
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
  }

  /**
   * EncounterDiagnosisSterilizationIndicator findUniqueOrThrow
   */
  export type EncounterDiagnosisSterilizationIndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosisSterilizationIndicator to fetch.
     */
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
  }

  /**
   * EncounterDiagnosisSterilizationIndicator findFirst
   */
  export type EncounterDiagnosisSterilizationIndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosisSterilizationIndicator to fetch.
     */
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnosisSterilizationIndicators to fetch.
     */
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterDiagnosisSterilizationIndicators.
     */
    cursor?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnosisSterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnosisSterilizationIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterDiagnosisSterilizationIndicators.
     */
    distinct?: EncounterDiagnosisSterilizationIndicatorScalarFieldEnum | EncounterDiagnosisSterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosisSterilizationIndicator findFirstOrThrow
   */
  export type EncounterDiagnosisSterilizationIndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosisSterilizationIndicator to fetch.
     */
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnosisSterilizationIndicators to fetch.
     */
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterDiagnosisSterilizationIndicators.
     */
    cursor?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnosisSterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnosisSterilizationIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterDiagnosisSterilizationIndicators.
     */
    distinct?: EncounterDiagnosisSterilizationIndicatorScalarFieldEnum | EncounterDiagnosisSterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosisSterilizationIndicator findMany
   */
  export type EncounterDiagnosisSterilizationIndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which EncounterDiagnosisSterilizationIndicators to fetch.
     */
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterDiagnosisSterilizationIndicators to fetch.
     */
    orderBy?: EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput | EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterDiagnosisSterilizationIndicators.
     */
    cursor?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterDiagnosisSterilizationIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterDiagnosisSterilizationIndicators.
     */
    skip?: number
    distinct?: EncounterDiagnosisSterilizationIndicatorScalarFieldEnum | EncounterDiagnosisSterilizationIndicatorScalarFieldEnum[]
  }

  /**
   * EncounterDiagnosisSterilizationIndicator create
   */
  export type EncounterDiagnosisSterilizationIndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterDiagnosisSterilizationIndicator.
     */
    data: XOR<EncounterDiagnosisSterilizationIndicatorCreateInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateInput>
  }

  /**
   * EncounterDiagnosisSterilizationIndicator createMany
   */
  export type EncounterDiagnosisSterilizationIndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterDiagnosisSterilizationIndicators.
     */
    data: EncounterDiagnosisSterilizationIndicatorCreateManyInput | EncounterDiagnosisSterilizationIndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterDiagnosisSterilizationIndicator createManyAndReturn
   */
  export type EncounterDiagnosisSterilizationIndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterDiagnosisSterilizationIndicators.
     */
    data: EncounterDiagnosisSterilizationIndicatorCreateManyInput | EncounterDiagnosisSterilizationIndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterDiagnosisSterilizationIndicator update
   */
  export type EncounterDiagnosisSterilizationIndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterDiagnosisSterilizationIndicator.
     */
    data: XOR<EncounterDiagnosisSterilizationIndicatorUpdateInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateInput>
    /**
     * Choose, which EncounterDiagnosisSterilizationIndicator to update.
     */
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
  }

  /**
   * EncounterDiagnosisSterilizationIndicator updateMany
   */
  export type EncounterDiagnosisSterilizationIndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterDiagnosisSterilizationIndicators.
     */
    data: XOR<EncounterDiagnosisSterilizationIndicatorUpdateManyMutationInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which EncounterDiagnosisSterilizationIndicators to update
     */
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
  }

  /**
   * EncounterDiagnosisSterilizationIndicator upsert
   */
  export type EncounterDiagnosisSterilizationIndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterDiagnosisSterilizationIndicator to update in case it exists.
     */
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    /**
     * In case the EncounterDiagnosisSterilizationIndicator found by the `where` argument doesn't exist, create a new EncounterDiagnosisSterilizationIndicator with this data.
     */
    create: XOR<EncounterDiagnosisSterilizationIndicatorCreateInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateInput>
    /**
     * In case the EncounterDiagnosisSterilizationIndicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterDiagnosisSterilizationIndicatorUpdateInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateInput>
  }

  /**
   * EncounterDiagnosisSterilizationIndicator delete
   */
  export type EncounterDiagnosisSterilizationIndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
    /**
     * Filter which EncounterDiagnosisSterilizationIndicator to delete.
     */
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
  }

  /**
   * EncounterDiagnosisSterilizationIndicator deleteMany
   */
  export type EncounterDiagnosisSterilizationIndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterDiagnosisSterilizationIndicators to delete
     */
    where?: EncounterDiagnosisSterilizationIndicatorWhereInput
  }

  /**
   * EncounterDiagnosisSterilizationIndicator without action
   */
  export type EncounterDiagnosisSterilizationIndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterDiagnosisSterilizationIndicator
     */
    select?: EncounterDiagnosisSterilizationIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterDiagnosisSterilizationIndicatorInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    code: string | null
    category: $Enums.ServiceCategory | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    code: string | null
    category: $Enums.ServiceCategory | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    code: number
    category: number
    name: number
    price: number
    isActive: number
    description: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    code?: true
    category?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    code?: true
    category?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    code?: true
    category?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    code: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive: boolean
    description: string | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    encounterServices?: boolean | Service$encounterServicesArgs<ExtArgs>
    serviceBranches?: boolean | Service$serviceBranchesArgs<ExtArgs>
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    code?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounterServices?: boolean | Service$encounterServicesArgs<ExtArgs>
    serviceBranches?: boolean | Service$serviceBranchesArgs<ExtArgs>
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      encounterServices: Prisma.$EncounterServicePayload<ExtArgs>[]
      serviceBranches: Prisma.$ServiceBranchPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string | null
      category: $Enums.ServiceCategory
      name: string
      price: number
      isActive: boolean
      description: string | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounterServices<T extends Service$encounterServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$encounterServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findMany"> | Null>
    serviceBranches<T extends Service$serviceBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany"> | Null>
    invoiceItems<T extends Service$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly code: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'ServiceCategory'>
    readonly name: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Float'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly description: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.encounterServices
   */
  export type Service$encounterServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    where?: EncounterServiceWhereInput
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    cursor?: EncounterServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * Service.serviceBranches
   */
  export type Service$serviceBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    cursor?: ServiceBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * Service.invoiceItems
   */
  export type Service$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceBranch
   */

  export type AggregateServiceBranch = {
    _count: ServiceBranchCountAggregateOutputType | null
    _avg: ServiceBranchAvgAggregateOutputType | null
    _sum: ServiceBranchSumAggregateOutputType | null
    _min: ServiceBranchMinAggregateOutputType | null
    _max: ServiceBranchMaxAggregateOutputType | null
  }

  export type ServiceBranchAvgAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchSumAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchMinAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchMaxAggregateOutputType = {
    serviceId: number | null
    branchId: number | null
  }

  export type ServiceBranchCountAggregateOutputType = {
    serviceId: number
    branchId: number
    _all: number
  }


  export type ServiceBranchAvgAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchSumAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchMinAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchMaxAggregateInputType = {
    serviceId?: true
    branchId?: true
  }

  export type ServiceBranchCountAggregateInputType = {
    serviceId?: true
    branchId?: true
    _all?: true
  }

  export type ServiceBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBranch to aggregate.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceBranches
    **/
    _count?: true | ServiceBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceBranchMaxAggregateInputType
  }

  export type GetServiceBranchAggregateType<T extends ServiceBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceBranch[P]>
      : GetScalarType<T[P], AggregateServiceBranch[P]>
  }




  export type ServiceBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceBranchWhereInput
    orderBy?: ServiceBranchOrderByWithAggregationInput | ServiceBranchOrderByWithAggregationInput[]
    by: ServiceBranchScalarFieldEnum[] | ServiceBranchScalarFieldEnum
    having?: ServiceBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceBranchCountAggregateInputType | true
    _avg?: ServiceBranchAvgAggregateInputType
    _sum?: ServiceBranchSumAggregateInputType
    _min?: ServiceBranchMinAggregateInputType
    _max?: ServiceBranchMaxAggregateInputType
  }

  export type ServiceBranchGroupByOutputType = {
    serviceId: number
    branchId: number
    _count: ServiceBranchCountAggregateOutputType | null
    _avg: ServiceBranchAvgAggregateOutputType | null
    _sum: ServiceBranchSumAggregateOutputType | null
    _min: ServiceBranchMinAggregateOutputType | null
    _max: ServiceBranchMaxAggregateOutputType | null
  }

  type GetServiceBranchGroupByPayload<T extends ServiceBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceBranchGroupByOutputType[P]>
        }
      >
    >


  export type ServiceBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    branchId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    branchId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceBranch"]>

  export type ServiceBranchSelectScalar = {
    serviceId?: boolean
    branchId?: boolean
  }

  export type ServiceBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ServiceBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ServiceBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceBranch"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      serviceId: number
      branchId: number
    }, ExtArgs["result"]["serviceBranch"]>
    composites: {}
  }

  type ServiceBranchGetPayload<S extends boolean | null | undefined | ServiceBranchDefaultArgs> = $Result.GetResult<Prisma.$ServiceBranchPayload, S>

  type ServiceBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceBranchCountAggregateInputType | true
    }

  export interface ServiceBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceBranch'], meta: { name: 'ServiceBranch' } }
    /**
     * Find zero or one ServiceBranch that matches the filter.
     * @param {ServiceBranchFindUniqueArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceBranchFindUniqueArgs>(args: SelectSubset<T, ServiceBranchFindUniqueArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceBranchFindUniqueOrThrowArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindFirstArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceBranchFindFirstArgs>(args?: SelectSubset<T, ServiceBranchFindFirstArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindFirstOrThrowArgs} args - Arguments to find a ServiceBranch
     * @example
     * // Get one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceBranches
     * const serviceBranches = await prisma.serviceBranch.findMany()
     * 
     * // Get first 10 ServiceBranches
     * const serviceBranches = await prisma.serviceBranch.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const serviceBranchWithServiceIdOnly = await prisma.serviceBranch.findMany({ select: { serviceId: true } })
     * 
     */
    findMany<T extends ServiceBranchFindManyArgs>(args?: SelectSubset<T, ServiceBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceBranch.
     * @param {ServiceBranchCreateArgs} args - Arguments to create a ServiceBranch.
     * @example
     * // Create one ServiceBranch
     * const ServiceBranch = await prisma.serviceBranch.create({
     *   data: {
     *     // ... data to create a ServiceBranch
     *   }
     * })
     * 
     */
    create<T extends ServiceBranchCreateArgs>(args: SelectSubset<T, ServiceBranchCreateArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceBranches.
     * @param {ServiceBranchCreateManyArgs} args - Arguments to create many ServiceBranches.
     * @example
     * // Create many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceBranchCreateManyArgs>(args?: SelectSubset<T, ServiceBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceBranches and returns the data saved in the database.
     * @param {ServiceBranchCreateManyAndReturnArgs} args - Arguments to create many ServiceBranches.
     * @example
     * // Create many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceBranches and only return the `serviceId`
     * const serviceBranchWithServiceIdOnly = await prisma.serviceBranch.createManyAndReturn({ 
     *   select: { serviceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceBranch.
     * @param {ServiceBranchDeleteArgs} args - Arguments to delete one ServiceBranch.
     * @example
     * // Delete one ServiceBranch
     * const ServiceBranch = await prisma.serviceBranch.delete({
     *   where: {
     *     // ... filter to delete one ServiceBranch
     *   }
     * })
     * 
     */
    delete<T extends ServiceBranchDeleteArgs>(args: SelectSubset<T, ServiceBranchDeleteArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceBranch.
     * @param {ServiceBranchUpdateArgs} args - Arguments to update one ServiceBranch.
     * @example
     * // Update one ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceBranchUpdateArgs>(args: SelectSubset<T, ServiceBranchUpdateArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceBranches.
     * @param {ServiceBranchDeleteManyArgs} args - Arguments to filter ServiceBranches to delete.
     * @example
     * // Delete a few ServiceBranches
     * const { count } = await prisma.serviceBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceBranchDeleteManyArgs>(args?: SelectSubset<T, ServiceBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceBranches
     * const serviceBranch = await prisma.serviceBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceBranchUpdateManyArgs>(args: SelectSubset<T, ServiceBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceBranch.
     * @param {ServiceBranchUpsertArgs} args - Arguments to update or create a ServiceBranch.
     * @example
     * // Update or create a ServiceBranch
     * const serviceBranch = await prisma.serviceBranch.upsert({
     *   create: {
     *     // ... data to create a ServiceBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceBranch we want to update
     *   }
     * })
     */
    upsert<T extends ServiceBranchUpsertArgs>(args: SelectSubset<T, ServiceBranchUpsertArgs<ExtArgs>>): Prisma__ServiceBranchClient<$Result.GetResult<Prisma.$ServiceBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchCountArgs} args - Arguments to filter ServiceBranches to count.
     * @example
     * // Count the number of ServiceBranches
     * const count = await prisma.serviceBranch.count({
     *   where: {
     *     // ... the filter for the ServiceBranches we want to count
     *   }
     * })
    **/
    count<T extends ServiceBranchCountArgs>(
      args?: Subset<T, ServiceBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceBranchAggregateArgs>(args: Subset<T, ServiceBranchAggregateArgs>): Prisma.PrismaPromise<GetServiceBranchAggregateType<T>>

    /**
     * Group by ServiceBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceBranchGroupByArgs['orderBy'] }
        : { orderBy?: ServiceBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceBranch model
   */
  readonly fields: ServiceBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceBranch model
   */ 
  interface ServiceBranchFieldRefs {
    readonly serviceId: FieldRef<"ServiceBranch", 'Int'>
    readonly branchId: FieldRef<"ServiceBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceBranch findUnique
   */
  export type ServiceBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch findUniqueOrThrow
   */
  export type ServiceBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch findFirst
   */
  export type ServiceBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBranches.
     */
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch findFirstOrThrow
   */
  export type ServiceBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranch to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceBranches.
     */
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch findMany
   */
  export type ServiceBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter, which ServiceBranches to fetch.
     */
    where?: ServiceBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceBranches to fetch.
     */
    orderBy?: ServiceBranchOrderByWithRelationInput | ServiceBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceBranches.
     */
    cursor?: ServiceBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceBranches.
     */
    skip?: number
    distinct?: ServiceBranchScalarFieldEnum | ServiceBranchScalarFieldEnum[]
  }

  /**
   * ServiceBranch create
   */
  export type ServiceBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceBranch.
     */
    data: XOR<ServiceBranchCreateInput, ServiceBranchUncheckedCreateInput>
  }

  /**
   * ServiceBranch createMany
   */
  export type ServiceBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceBranches.
     */
    data: ServiceBranchCreateManyInput | ServiceBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceBranch createManyAndReturn
   */
  export type ServiceBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceBranches.
     */
    data: ServiceBranchCreateManyInput | ServiceBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceBranch update
   */
  export type ServiceBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceBranch.
     */
    data: XOR<ServiceBranchUpdateInput, ServiceBranchUncheckedUpdateInput>
    /**
     * Choose, which ServiceBranch to update.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch updateMany
   */
  export type ServiceBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceBranches.
     */
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyInput>
    /**
     * Filter which ServiceBranches to update
     */
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceBranch upsert
   */
  export type ServiceBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceBranch to update in case it exists.
     */
    where: ServiceBranchWhereUniqueInput
    /**
     * In case the ServiceBranch found by the `where` argument doesn't exist, create a new ServiceBranch with this data.
     */
    create: XOR<ServiceBranchCreateInput, ServiceBranchUncheckedCreateInput>
    /**
     * In case the ServiceBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceBranchUpdateInput, ServiceBranchUncheckedUpdateInput>
  }

  /**
   * ServiceBranch delete
   */
  export type ServiceBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
    /**
     * Filter which ServiceBranch to delete.
     */
    where: ServiceBranchWhereUniqueInput
  }

  /**
   * ServiceBranch deleteMany
   */
  export type ServiceBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceBranches to delete
     */
    where?: ServiceBranchWhereInput
  }

  /**
   * ServiceBranch without action
   */
  export type ServiceBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceBranch
     */
    select?: ServiceBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceBranchInclude<ExtArgs> | null
  }


  /**
   * Model EncounterService
   */

  export type AggregateEncounterService = {
    _count: EncounterServiceCountAggregateOutputType | null
    _avg: EncounterServiceAvgAggregateOutputType | null
    _sum: EncounterServiceSumAggregateOutputType | null
    _min: EncounterServiceMinAggregateOutputType | null
    _max: EncounterServiceMaxAggregateOutputType | null
  }

  export type EncounterServiceAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    serviceId: number | null
    quantity: number | null
    price: number | null
  }

  export type EncounterServiceCountAggregateOutputType = {
    id: number
    encounterId: number
    serviceId: number
    quantity: number
    price: number
    _all: number
  }


  export type EncounterServiceAvgAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceSumAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceMinAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceMaxAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
  }

  export type EncounterServiceCountAggregateInputType = {
    id?: true
    encounterId?: true
    serviceId?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type EncounterServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterService to aggregate.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterServices
    **/
    _count?: true | EncounterServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterServiceMaxAggregateInputType
  }

  export type GetEncounterServiceAggregateType<T extends EncounterServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterService[P]>
      : GetScalarType<T[P], AggregateEncounterService[P]>
  }




  export type EncounterServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterServiceWhereInput
    orderBy?: EncounterServiceOrderByWithAggregationInput | EncounterServiceOrderByWithAggregationInput[]
    by: EncounterServiceScalarFieldEnum[] | EncounterServiceScalarFieldEnum
    having?: EncounterServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterServiceCountAggregateInputType | true
    _avg?: EncounterServiceAvgAggregateInputType
    _sum?: EncounterServiceSumAggregateInputType
    _min?: EncounterServiceMinAggregateInputType
    _max?: EncounterServiceMaxAggregateInputType
  }

  export type EncounterServiceGroupByOutputType = {
    id: number
    encounterId: number
    serviceId: number
    quantity: number
    price: number
    _count: EncounterServiceCountAggregateOutputType | null
    _avg: EncounterServiceAvgAggregateOutputType | null
    _sum: EncounterServiceSumAggregateOutputType | null
    _min: EncounterServiceMinAggregateOutputType | null
    _max: EncounterServiceMaxAggregateOutputType | null
  }

  type GetEncounterServiceGroupByPayload<T extends EncounterServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterServiceGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterServiceGroupByOutputType[P]>
        }
      >
    >


  export type EncounterServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterService"]>

  export type EncounterServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterService"]>

  export type EncounterServiceSelectScalar = {
    id?: boolean
    encounterId?: boolean
    serviceId?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type EncounterServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type EncounterServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $EncounterServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterService"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      serviceId: number
      quantity: number
      price: number
    }, ExtArgs["result"]["encounterService"]>
    composites: {}
  }

  type EncounterServiceGetPayload<S extends boolean | null | undefined | EncounterServiceDefaultArgs> = $Result.GetResult<Prisma.$EncounterServicePayload, S>

  type EncounterServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterServiceCountAggregateInputType | true
    }

  export interface EncounterServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterService'], meta: { name: 'EncounterService' } }
    /**
     * Find zero or one EncounterService that matches the filter.
     * @param {EncounterServiceFindUniqueArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterServiceFindUniqueArgs>(args: SelectSubset<T, EncounterServiceFindUniqueArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EncounterService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterServiceFindUniqueOrThrowArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EncounterService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceFindFirstArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterServiceFindFirstArgs>(args?: SelectSubset<T, EncounterServiceFindFirstArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EncounterService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceFindFirstOrThrowArgs} args - Arguments to find a EncounterService
     * @example
     * // Get one EncounterService
     * const encounterService = await prisma.encounterService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EncounterServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterServices
     * const encounterServices = await prisma.encounterService.findMany()
     * 
     * // Get first 10 EncounterServices
     * const encounterServices = await prisma.encounterService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterServiceWithIdOnly = await prisma.encounterService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterServiceFindManyArgs>(args?: SelectSubset<T, EncounterServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EncounterService.
     * @param {EncounterServiceCreateArgs} args - Arguments to create a EncounterService.
     * @example
     * // Create one EncounterService
     * const EncounterService = await prisma.encounterService.create({
     *   data: {
     *     // ... data to create a EncounterService
     *   }
     * })
     * 
     */
    create<T extends EncounterServiceCreateArgs>(args: SelectSubset<T, EncounterServiceCreateArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EncounterServices.
     * @param {EncounterServiceCreateManyArgs} args - Arguments to create many EncounterServices.
     * @example
     * // Create many EncounterServices
     * const encounterService = await prisma.encounterService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterServiceCreateManyArgs>(args?: SelectSubset<T, EncounterServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterServices and returns the data saved in the database.
     * @param {EncounterServiceCreateManyAndReturnArgs} args - Arguments to create many EncounterServices.
     * @example
     * // Create many EncounterServices
     * const encounterService = await prisma.encounterService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterServices and only return the `id`
     * const encounterServiceWithIdOnly = await prisma.encounterService.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EncounterService.
     * @param {EncounterServiceDeleteArgs} args - Arguments to delete one EncounterService.
     * @example
     * // Delete one EncounterService
     * const EncounterService = await prisma.encounterService.delete({
     *   where: {
     *     // ... filter to delete one EncounterService
     *   }
     * })
     * 
     */
    delete<T extends EncounterServiceDeleteArgs>(args: SelectSubset<T, EncounterServiceDeleteArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EncounterService.
     * @param {EncounterServiceUpdateArgs} args - Arguments to update one EncounterService.
     * @example
     * // Update one EncounterService
     * const encounterService = await prisma.encounterService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterServiceUpdateArgs>(args: SelectSubset<T, EncounterServiceUpdateArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EncounterServices.
     * @param {EncounterServiceDeleteManyArgs} args - Arguments to filter EncounterServices to delete.
     * @example
     * // Delete a few EncounterServices
     * const { count } = await prisma.encounterService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterServiceDeleteManyArgs>(args?: SelectSubset<T, EncounterServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterServices
     * const encounterService = await prisma.encounterService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterServiceUpdateManyArgs>(args: SelectSubset<T, EncounterServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EncounterService.
     * @param {EncounterServiceUpsertArgs} args - Arguments to update or create a EncounterService.
     * @example
     * // Update or create a EncounterService
     * const encounterService = await prisma.encounterService.upsert({
     *   create: {
     *     // ... data to create a EncounterService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterService we want to update
     *   }
     * })
     */
    upsert<T extends EncounterServiceUpsertArgs>(args: SelectSubset<T, EncounterServiceUpsertArgs<ExtArgs>>): Prisma__EncounterServiceClient<$Result.GetResult<Prisma.$EncounterServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EncounterServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceCountArgs} args - Arguments to filter EncounterServices to count.
     * @example
     * // Count the number of EncounterServices
     * const count = await prisma.encounterService.count({
     *   where: {
     *     // ... the filter for the EncounterServices we want to count
     *   }
     * })
    **/
    count<T extends EncounterServiceCountArgs>(
      args?: Subset<T, EncounterServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterServiceAggregateArgs>(args: Subset<T, EncounterServiceAggregateArgs>): Prisma.PrismaPromise<GetEncounterServiceAggregateType<T>>

    /**
     * Group by EncounterService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterServiceGroupByArgs['orderBy'] }
        : { orderBy?: EncounterServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterService model
   */
  readonly fields: EncounterServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterService model
   */ 
  interface EncounterServiceFieldRefs {
    readonly id: FieldRef<"EncounterService", 'Int'>
    readonly encounterId: FieldRef<"EncounterService", 'Int'>
    readonly serviceId: FieldRef<"EncounterService", 'Int'>
    readonly quantity: FieldRef<"EncounterService", 'Int'>
    readonly price: FieldRef<"EncounterService", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * EncounterService findUnique
   */
  export type EncounterServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService findUniqueOrThrow
   */
  export type EncounterServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService findFirst
   */
  export type EncounterServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterServices.
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterServices.
     */
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * EncounterService findFirstOrThrow
   */
  export type EncounterServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterService to fetch.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterServices.
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterServices.
     */
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * EncounterService findMany
   */
  export type EncounterServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter, which EncounterServices to fetch.
     */
    where?: EncounterServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterServices to fetch.
     */
    orderBy?: EncounterServiceOrderByWithRelationInput | EncounterServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterServices.
     */
    cursor?: EncounterServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterServices.
     */
    skip?: number
    distinct?: EncounterServiceScalarFieldEnum | EncounterServiceScalarFieldEnum[]
  }

  /**
   * EncounterService create
   */
  export type EncounterServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterService.
     */
    data: XOR<EncounterServiceCreateInput, EncounterServiceUncheckedCreateInput>
  }

  /**
   * EncounterService createMany
   */
  export type EncounterServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterServices.
     */
    data: EncounterServiceCreateManyInput | EncounterServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterService createManyAndReturn
   */
  export type EncounterServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EncounterServices.
     */
    data: EncounterServiceCreateManyInput | EncounterServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterService update
   */
  export type EncounterServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterService.
     */
    data: XOR<EncounterServiceUpdateInput, EncounterServiceUncheckedUpdateInput>
    /**
     * Choose, which EncounterService to update.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService updateMany
   */
  export type EncounterServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterServices.
     */
    data: XOR<EncounterServiceUpdateManyMutationInput, EncounterServiceUncheckedUpdateManyInput>
    /**
     * Filter which EncounterServices to update
     */
    where?: EncounterServiceWhereInput
  }

  /**
   * EncounterService upsert
   */
  export type EncounterServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterService to update in case it exists.
     */
    where: EncounterServiceWhereUniqueInput
    /**
     * In case the EncounterService found by the `where` argument doesn't exist, create a new EncounterService with this data.
     */
    create: XOR<EncounterServiceCreateInput, EncounterServiceUncheckedCreateInput>
    /**
     * In case the EncounterService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterServiceUpdateInput, EncounterServiceUncheckedUpdateInput>
  }

  /**
   * EncounterService delete
   */
  export type EncounterServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
    /**
     * Filter which EncounterService to delete.
     */
    where: EncounterServiceWhereUniqueInput
  }

  /**
   * EncounterService deleteMany
   */
  export type EncounterServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterServices to delete
     */
    where?: EncounterServiceWhereInput
  }

  /**
   * EncounterService without action
   */
  export type EncounterServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterService
     */
    select?: EncounterServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterServiceInclude<ExtArgs> | null
  }


  /**
   * Model Procedure
   */

  export type AggregateProcedure = {
    _count: ProcedureCountAggregateOutputType | null
    _avg: ProcedureAvgAggregateOutputType | null
    _sum: ProcedureSumAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  export type ProcedureAvgAggregateOutputType = {
    price: number | null
  }

  export type ProcedureSumAggregateOutputType = {
    price: number | null
  }

  export type ProcedureMinAggregateOutputType = {
    code: string | null
    name: string | null
    price: number | null
  }

  export type ProcedureMaxAggregateOutputType = {
    code: string | null
    name: string | null
    price: number | null
  }

  export type ProcedureCountAggregateOutputType = {
    code: number
    name: number
    price: number
    _all: number
  }


  export type ProcedureAvgAggregateInputType = {
    price?: true
  }

  export type ProcedureSumAggregateInputType = {
    price?: true
  }

  export type ProcedureMinAggregateInputType = {
    code?: true
    name?: true
    price?: true
  }

  export type ProcedureMaxAggregateInputType = {
    code?: true
    name?: true
    price?: true
  }

  export type ProcedureCountAggregateInputType = {
    code?: true
    name?: true
    price?: true
    _all?: true
  }

  export type ProcedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedure to aggregate.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procedures
    **/
    _count?: true | ProcedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcedureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcedureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureMaxAggregateInputType
  }

  export type GetProcedureAggregateType<T extends ProcedureAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedure[P]>
      : GetScalarType<T[P], AggregateProcedure[P]>
  }




  export type ProcedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureWhereInput
    orderBy?: ProcedureOrderByWithAggregationInput | ProcedureOrderByWithAggregationInput[]
    by: ProcedureScalarFieldEnum[] | ProcedureScalarFieldEnum
    having?: ProcedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureCountAggregateInputType | true
    _avg?: ProcedureAvgAggregateInputType
    _sum?: ProcedureSumAggregateInputType
    _min?: ProcedureMinAggregateInputType
    _max?: ProcedureMaxAggregateInputType
  }

  export type ProcedureGroupByOutputType = {
    code: string
    name: string
    price: number
    _count: ProcedureCountAggregateOutputType | null
    _avg: ProcedureAvgAggregateOutputType | null
    _sum: ProcedureSumAggregateOutputType | null
    _min: ProcedureMinAggregateOutputType | null
    _max: ProcedureMaxAggregateOutputType | null
  }

  type GetProcedureGroupByPayload<T extends ProcedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    price?: boolean
    invoiceItems?: boolean | Procedure$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    price?: boolean
  }, ExtArgs["result"]["procedure"]>

  export type ProcedureSelectScalar = {
    code?: boolean
    name?: boolean
    price?: boolean
  }

  export type ProcedureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | Procedure$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ProcedureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcedureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProcedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Procedure"
    objects: {
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      price: number
    }, ExtArgs["result"]["procedure"]>
    composites: {}
  }

  type ProcedureGetPayload<S extends boolean | null | undefined | ProcedureDefaultArgs> = $Result.GetResult<Prisma.$ProcedurePayload, S>

  type ProcedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcedureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedureCountAggregateInputType | true
    }

  export interface ProcedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Procedure'], meta: { name: 'Procedure' } }
    /**
     * Find zero or one Procedure that matches the filter.
     * @param {ProcedureFindUniqueArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureFindUniqueArgs>(args: SelectSubset<T, ProcedureFindUniqueArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Procedure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcedureFindUniqueOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Procedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureFindFirstArgs>(args?: SelectSubset<T, ProcedureFindFirstArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Procedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindFirstOrThrowArgs} args - Arguments to find a Procedure
     * @example
     * // Get one Procedure
     * const procedure = await prisma.procedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procedures
     * const procedures = await prisma.procedure.findMany()
     * 
     * // Get first 10 Procedures
     * const procedures = await prisma.procedure.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const procedureWithCodeOnly = await prisma.procedure.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends ProcedureFindManyArgs>(args?: SelectSubset<T, ProcedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Procedure.
     * @param {ProcedureCreateArgs} args - Arguments to create a Procedure.
     * @example
     * // Create one Procedure
     * const Procedure = await prisma.procedure.create({
     *   data: {
     *     // ... data to create a Procedure
     *   }
     * })
     * 
     */
    create<T extends ProcedureCreateArgs>(args: SelectSubset<T, ProcedureCreateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procedures.
     * @param {ProcedureCreateManyArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureCreateManyArgs>(args?: SelectSubset<T, ProcedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procedures and returns the data saved in the database.
     * @param {ProcedureCreateManyAndReturnArgs} args - Arguments to create many Procedures.
     * @example
     * // Create many Procedures
     * const procedure = await prisma.procedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procedures and only return the `code`
     * const procedureWithCodeOnly = await prisma.procedure.createManyAndReturn({ 
     *   select: { code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Procedure.
     * @param {ProcedureDeleteArgs} args - Arguments to delete one Procedure.
     * @example
     * // Delete one Procedure
     * const Procedure = await prisma.procedure.delete({
     *   where: {
     *     // ... filter to delete one Procedure
     *   }
     * })
     * 
     */
    delete<T extends ProcedureDeleteArgs>(args: SelectSubset<T, ProcedureDeleteArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Procedure.
     * @param {ProcedureUpdateArgs} args - Arguments to update one Procedure.
     * @example
     * // Update one Procedure
     * const procedure = await prisma.procedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureUpdateArgs>(args: SelectSubset<T, ProcedureUpdateArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procedures.
     * @param {ProcedureDeleteManyArgs} args - Arguments to filter Procedures to delete.
     * @example
     * // Delete a few Procedures
     * const { count } = await prisma.procedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureDeleteManyArgs>(args?: SelectSubset<T, ProcedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procedures
     * const procedure = await prisma.procedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureUpdateManyArgs>(args: SelectSubset<T, ProcedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Procedure.
     * @param {ProcedureUpsertArgs} args - Arguments to update or create a Procedure.
     * @example
     * // Update or create a Procedure
     * const procedure = await prisma.procedure.upsert({
     *   create: {
     *     // ... data to create a Procedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Procedure we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureUpsertArgs>(args: SelectSubset<T, ProcedureUpsertArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureCountArgs} args - Arguments to filter Procedures to count.
     * @example
     * // Count the number of Procedures
     * const count = await prisma.procedure.count({
     *   where: {
     *     // ... the filter for the Procedures we want to count
     *   }
     * })
    **/
    count<T extends ProcedureCountArgs>(
      args?: Subset<T, ProcedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureAggregateArgs>(args: Subset<T, ProcedureAggregateArgs>): Prisma.PrismaPromise<GetProcedureAggregateType<T>>

    /**
     * Group by Procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Procedure model
   */
  readonly fields: ProcedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Procedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoiceItems<T extends Procedure$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Procedure$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Procedure model
   */ 
  interface ProcedureFieldRefs {
    readonly code: FieldRef<"Procedure", 'String'>
    readonly name: FieldRef<"Procedure", 'String'>
    readonly price: FieldRef<"Procedure", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Procedure findUnique
   */
  export type ProcedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findUniqueOrThrow
   */
  export type ProcedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure findFirst
   */
  export type ProcedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findFirstOrThrow
   */
  export type ProcedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedure to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procedures.
     */
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure findMany
   */
  export type ProcedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter, which Procedures to fetch.
     */
    where?: ProcedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procedures to fetch.
     */
    orderBy?: ProcedureOrderByWithRelationInput | ProcedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procedures.
     */
    cursor?: ProcedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procedures.
     */
    skip?: number
    distinct?: ProcedureScalarFieldEnum | ProcedureScalarFieldEnum[]
  }

  /**
   * Procedure create
   */
  export type ProcedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to create a Procedure.
     */
    data: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
  }

  /**
   * Procedure createMany
   */
  export type ProcedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure createManyAndReturn
   */
  export type ProcedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Procedures.
     */
    data: ProcedureCreateManyInput | ProcedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Procedure update
   */
  export type ProcedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The data needed to update a Procedure.
     */
    data: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
    /**
     * Choose, which Procedure to update.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure updateMany
   */
  export type ProcedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procedures.
     */
    data: XOR<ProcedureUpdateManyMutationInput, ProcedureUncheckedUpdateManyInput>
    /**
     * Filter which Procedures to update
     */
    where?: ProcedureWhereInput
  }

  /**
   * Procedure upsert
   */
  export type ProcedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * The filter to search for the Procedure to update in case it exists.
     */
    where: ProcedureWhereUniqueInput
    /**
     * In case the Procedure found by the `where` argument doesn't exist, create a new Procedure with this data.
     */
    create: XOR<ProcedureCreateInput, ProcedureUncheckedCreateInput>
    /**
     * In case the Procedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureUpdateInput, ProcedureUncheckedUpdateInput>
  }

  /**
   * Procedure delete
   */
  export type ProcedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    /**
     * Filter which Procedure to delete.
     */
    where: ProcedureWhereUniqueInput
  }

  /**
   * Procedure deleteMany
   */
  export type ProcedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procedures to delete
     */
    where?: ProcedureWhereInput
  }

  /**
   * Procedure.invoiceItems
   */
  export type Procedure$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Procedure without action
   */
  export type ProcedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    categoryId: number | null
    price: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    categoryId: number | null
    price: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    categoryId: number | null
    code: string | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    categoryId: number | null
    code: string | null
    name: string | null
    price: number | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    branchId: number
    categoryId: number
    code: number
    name: number
    price: number
    isActive: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    branchId?: true
    categoryId?: true
    price?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    branchId?: true
    categoryId?: true
    price?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    branchId?: true
    categoryId?: true
    code?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    branchId?: true
    categoryId?: true
    code?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    branchId?: true
    categoryId?: true
    code?: true
    name?: true
    price?: true
    isActive?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    branchId: number
    categoryId: number
    code: string | null
    name: string
    price: number
    isActive: boolean
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    categoryId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    stockMovements?: boolean | Product$stockMovementsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    categoryId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    branchId?: boolean
    categoryId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    stockMovements?: boolean | Product$stockMovementsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs>
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      stockMovements: Prisma.$ProductStockMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      categoryId: number
      code: string | null
      name: string
      price: number
      isActive: boolean
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoiceItems<T extends Product$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    stockMovements<T extends Product$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly branchId: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly code: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly description: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.invoiceItems
   */
  export type Product$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Product.stockMovements
   */
  export type Product$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    where?: ProductStockMovementWhereInput
    orderBy?: ProductStockMovementOrderByWithRelationInput | ProductStockMovementOrderByWithRelationInput[]
    cursor?: ProductStockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockMovementScalarFieldEnum | ProductStockMovementScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductStockMovement
   */

  export type AggregateProductStockMovement = {
    _count: ProductStockMovementCountAggregateOutputType | null
    _avg: ProductStockMovementAvgAggregateOutputType | null
    _sum: ProductStockMovementSumAggregateOutputType | null
    _min: ProductStockMovementMinAggregateOutputType | null
    _max: ProductStockMovementMaxAggregateOutputType | null
  }

  export type ProductStockMovementAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    productId: number | null
    quantityDelta: number | null
    invoiceId: number | null
    ledgerEntryId: number | null
  }

  export type ProductStockMovementSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    productId: number | null
    quantityDelta: number | null
    invoiceId: number | null
    ledgerEntryId: number | null
  }

  export type ProductStockMovementMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    productId: number | null
    type: $Enums.ProductStockMovementType | null
    quantityDelta: number | null
    invoiceId: number | null
    ledgerEntryId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type ProductStockMovementMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    productId: number | null
    type: $Enums.ProductStockMovementType | null
    quantityDelta: number | null
    invoiceId: number | null
    ledgerEntryId: number | null
    note: string | null
    createdAt: Date | null
  }

  export type ProductStockMovementCountAggregateOutputType = {
    id: number
    branchId: number
    productId: number
    type: number
    quantityDelta: number
    invoiceId: number
    ledgerEntryId: number
    note: number
    createdAt: number
    _all: number
  }


  export type ProductStockMovementAvgAggregateInputType = {
    id?: true
    branchId?: true
    productId?: true
    quantityDelta?: true
    invoiceId?: true
    ledgerEntryId?: true
  }

  export type ProductStockMovementSumAggregateInputType = {
    id?: true
    branchId?: true
    productId?: true
    quantityDelta?: true
    invoiceId?: true
    ledgerEntryId?: true
  }

  export type ProductStockMovementMinAggregateInputType = {
    id?: true
    branchId?: true
    productId?: true
    type?: true
    quantityDelta?: true
    invoiceId?: true
    ledgerEntryId?: true
    note?: true
    createdAt?: true
  }

  export type ProductStockMovementMaxAggregateInputType = {
    id?: true
    branchId?: true
    productId?: true
    type?: true
    quantityDelta?: true
    invoiceId?: true
    ledgerEntryId?: true
    note?: true
    createdAt?: true
  }

  export type ProductStockMovementCountAggregateInputType = {
    id?: true
    branchId?: true
    productId?: true
    type?: true
    quantityDelta?: true
    invoiceId?: true
    ledgerEntryId?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type ProductStockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStockMovement to aggregate.
     */
    where?: ProductStockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockMovements to fetch.
     */
    orderBy?: ProductStockMovementOrderByWithRelationInput | ProductStockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStockMovements
    **/
    _count?: true | ProductStockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductStockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductStockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStockMovementMaxAggregateInputType
  }

  export type GetProductStockMovementAggregateType<T extends ProductStockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStockMovement[P]>
      : GetScalarType<T[P], AggregateProductStockMovement[P]>
  }




  export type ProductStockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockMovementWhereInput
    orderBy?: ProductStockMovementOrderByWithAggregationInput | ProductStockMovementOrderByWithAggregationInput[]
    by: ProductStockMovementScalarFieldEnum[] | ProductStockMovementScalarFieldEnum
    having?: ProductStockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStockMovementCountAggregateInputType | true
    _avg?: ProductStockMovementAvgAggregateInputType
    _sum?: ProductStockMovementSumAggregateInputType
    _min?: ProductStockMovementMinAggregateInputType
    _max?: ProductStockMovementMaxAggregateInputType
  }

  export type ProductStockMovementGroupByOutputType = {
    id: number
    branchId: number
    productId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId: number | null
    ledgerEntryId: number | null
    note: string | null
    createdAt: Date
    _count: ProductStockMovementCountAggregateOutputType | null
    _avg: ProductStockMovementAvgAggregateOutputType | null
    _sum: ProductStockMovementSumAggregateOutputType | null
    _min: ProductStockMovementMinAggregateOutputType | null
    _max: ProductStockMovementMaxAggregateOutputType | null
  }

  type GetProductStockMovementGroupByPayload<T extends ProductStockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStockMovementGroupByOutputType[P]>
        }
      >
    >


  export type ProductStockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    productId?: boolean
    type?: boolean
    quantityDelta?: boolean
    invoiceId?: boolean
    ledgerEntryId?: boolean
    note?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStockMovement"]>

  export type ProductStockMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    productId?: boolean
    type?: boolean
    quantityDelta?: boolean
    invoiceId?: boolean
    ledgerEntryId?: boolean
    note?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStockMovement"]>

  export type ProductStockMovementSelectScalar = {
    id?: boolean
    branchId?: boolean
    productId?: boolean
    type?: boolean
    quantityDelta?: boolean
    invoiceId?: boolean
    ledgerEntryId?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type ProductStockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductStockMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductStockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStockMovement"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      productId: number
      type: $Enums.ProductStockMovementType
      quantityDelta: number
      invoiceId: number | null
      ledgerEntryId: number | null
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["productStockMovement"]>
    composites: {}
  }

  type ProductStockMovementGetPayload<S extends boolean | null | undefined | ProductStockMovementDefaultArgs> = $Result.GetResult<Prisma.$ProductStockMovementPayload, S>

  type ProductStockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductStockMovementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductStockMovementCountAggregateInputType | true
    }

  export interface ProductStockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStockMovement'], meta: { name: 'ProductStockMovement' } }
    /**
     * Find zero or one ProductStockMovement that matches the filter.
     * @param {ProductStockMovementFindUniqueArgs} args - Arguments to find a ProductStockMovement
     * @example
     * // Get one ProductStockMovement
     * const productStockMovement = await prisma.productStockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStockMovementFindUniqueArgs>(args: SelectSubset<T, ProductStockMovementFindUniqueArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductStockMovement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductStockMovementFindUniqueOrThrowArgs} args - Arguments to find a ProductStockMovement
     * @example
     * // Get one ProductStockMovement
     * const productStockMovement = await prisma.productStockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductStockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementFindFirstArgs} args - Arguments to find a ProductStockMovement
     * @example
     * // Get one ProductStockMovement
     * const productStockMovement = await prisma.productStockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStockMovementFindFirstArgs>(args?: SelectSubset<T, ProductStockMovementFindFirstArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductStockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementFindFirstOrThrowArgs} args - Arguments to find a ProductStockMovement
     * @example
     * // Get one ProductStockMovement
     * const productStockMovement = await prisma.productStockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductStockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStockMovements
     * const productStockMovements = await prisma.productStockMovement.findMany()
     * 
     * // Get first 10 ProductStockMovements
     * const productStockMovements = await prisma.productStockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productStockMovementWithIdOnly = await prisma.productStockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductStockMovementFindManyArgs>(args?: SelectSubset<T, ProductStockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductStockMovement.
     * @param {ProductStockMovementCreateArgs} args - Arguments to create a ProductStockMovement.
     * @example
     * // Create one ProductStockMovement
     * const ProductStockMovement = await prisma.productStockMovement.create({
     *   data: {
     *     // ... data to create a ProductStockMovement
     *   }
     * })
     * 
     */
    create<T extends ProductStockMovementCreateArgs>(args: SelectSubset<T, ProductStockMovementCreateArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductStockMovements.
     * @param {ProductStockMovementCreateManyArgs} args - Arguments to create many ProductStockMovements.
     * @example
     * // Create many ProductStockMovements
     * const productStockMovement = await prisma.productStockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStockMovementCreateManyArgs>(args?: SelectSubset<T, ProductStockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductStockMovements and returns the data saved in the database.
     * @param {ProductStockMovementCreateManyAndReturnArgs} args - Arguments to create many ProductStockMovements.
     * @example
     * // Create many ProductStockMovements
     * const productStockMovement = await prisma.productStockMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductStockMovements and only return the `id`
     * const productStockMovementWithIdOnly = await prisma.productStockMovement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductStockMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductStockMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductStockMovement.
     * @param {ProductStockMovementDeleteArgs} args - Arguments to delete one ProductStockMovement.
     * @example
     * // Delete one ProductStockMovement
     * const ProductStockMovement = await prisma.productStockMovement.delete({
     *   where: {
     *     // ... filter to delete one ProductStockMovement
     *   }
     * })
     * 
     */
    delete<T extends ProductStockMovementDeleteArgs>(args: SelectSubset<T, ProductStockMovementDeleteArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductStockMovement.
     * @param {ProductStockMovementUpdateArgs} args - Arguments to update one ProductStockMovement.
     * @example
     * // Update one ProductStockMovement
     * const productStockMovement = await prisma.productStockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStockMovementUpdateArgs>(args: SelectSubset<T, ProductStockMovementUpdateArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductStockMovements.
     * @param {ProductStockMovementDeleteManyArgs} args - Arguments to filter ProductStockMovements to delete.
     * @example
     * // Delete a few ProductStockMovements
     * const { count } = await prisma.productStockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStockMovementDeleteManyArgs>(args?: SelectSubset<T, ProductStockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStockMovements
     * const productStockMovement = await prisma.productStockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStockMovementUpdateManyArgs>(args: SelectSubset<T, ProductStockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductStockMovement.
     * @param {ProductStockMovementUpsertArgs} args - Arguments to update or create a ProductStockMovement.
     * @example
     * // Update or create a ProductStockMovement
     * const productStockMovement = await prisma.productStockMovement.upsert({
     *   create: {
     *     // ... data to create a ProductStockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStockMovement we want to update
     *   }
     * })
     */
    upsert<T extends ProductStockMovementUpsertArgs>(args: SelectSubset<T, ProductStockMovementUpsertArgs<ExtArgs>>): Prisma__ProductStockMovementClient<$Result.GetResult<Prisma.$ProductStockMovementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductStockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementCountArgs} args - Arguments to filter ProductStockMovements to count.
     * @example
     * // Count the number of ProductStockMovements
     * const count = await prisma.productStockMovement.count({
     *   where: {
     *     // ... the filter for the ProductStockMovements we want to count
     *   }
     * })
    **/
    count<T extends ProductStockMovementCountArgs>(
      args?: Subset<T, ProductStockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStockMovementAggregateArgs>(args: Subset<T, ProductStockMovementAggregateArgs>): Prisma.PrismaPromise<GetProductStockMovementAggregateType<T>>

    /**
     * Group by ProductStockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStockMovementGroupByArgs['orderBy'] }
        : { orderBy?: ProductStockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStockMovement model
   */
  readonly fields: ProductStockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStockMovement model
   */ 
  interface ProductStockMovementFieldRefs {
    readonly id: FieldRef<"ProductStockMovement", 'Int'>
    readonly branchId: FieldRef<"ProductStockMovement", 'Int'>
    readonly productId: FieldRef<"ProductStockMovement", 'Int'>
    readonly type: FieldRef<"ProductStockMovement", 'ProductStockMovementType'>
    readonly quantityDelta: FieldRef<"ProductStockMovement", 'Int'>
    readonly invoiceId: FieldRef<"ProductStockMovement", 'Int'>
    readonly ledgerEntryId: FieldRef<"ProductStockMovement", 'Int'>
    readonly note: FieldRef<"ProductStockMovement", 'String'>
    readonly createdAt: FieldRef<"ProductStockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductStockMovement findUnique
   */
  export type ProductStockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockMovement to fetch.
     */
    where: ProductStockMovementWhereUniqueInput
  }

  /**
   * ProductStockMovement findUniqueOrThrow
   */
  export type ProductStockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockMovement to fetch.
     */
    where: ProductStockMovementWhereUniqueInput
  }

  /**
   * ProductStockMovement findFirst
   */
  export type ProductStockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockMovement to fetch.
     */
    where?: ProductStockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockMovements to fetch.
     */
    orderBy?: ProductStockMovementOrderByWithRelationInput | ProductStockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStockMovements.
     */
    cursor?: ProductStockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStockMovements.
     */
    distinct?: ProductStockMovementScalarFieldEnum | ProductStockMovementScalarFieldEnum[]
  }

  /**
   * ProductStockMovement findFirstOrThrow
   */
  export type ProductStockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockMovement to fetch.
     */
    where?: ProductStockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockMovements to fetch.
     */
    orderBy?: ProductStockMovementOrderByWithRelationInput | ProductStockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStockMovements.
     */
    cursor?: ProductStockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStockMovements.
     */
    distinct?: ProductStockMovementScalarFieldEnum | ProductStockMovementScalarFieldEnum[]
  }

  /**
   * ProductStockMovement findMany
   */
  export type ProductStockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * Filter, which ProductStockMovements to fetch.
     */
    where?: ProductStockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStockMovements to fetch.
     */
    orderBy?: ProductStockMovementOrderByWithRelationInput | ProductStockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStockMovements.
     */
    cursor?: ProductStockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStockMovements.
     */
    skip?: number
    distinct?: ProductStockMovementScalarFieldEnum | ProductStockMovementScalarFieldEnum[]
  }

  /**
   * ProductStockMovement create
   */
  export type ProductStockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStockMovement.
     */
    data: XOR<ProductStockMovementCreateInput, ProductStockMovementUncheckedCreateInput>
  }

  /**
   * ProductStockMovement createMany
   */
  export type ProductStockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStockMovements.
     */
    data: ProductStockMovementCreateManyInput | ProductStockMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStockMovement createManyAndReturn
   */
  export type ProductStockMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductStockMovements.
     */
    data: ProductStockMovementCreateManyInput | ProductStockMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStockMovement update
   */
  export type ProductStockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStockMovement.
     */
    data: XOR<ProductStockMovementUpdateInput, ProductStockMovementUncheckedUpdateInput>
    /**
     * Choose, which ProductStockMovement to update.
     */
    where: ProductStockMovementWhereUniqueInput
  }

  /**
   * ProductStockMovement updateMany
   */
  export type ProductStockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStockMovements.
     */
    data: XOR<ProductStockMovementUpdateManyMutationInput, ProductStockMovementUncheckedUpdateManyInput>
    /**
     * Filter which ProductStockMovements to update
     */
    where?: ProductStockMovementWhereInput
  }

  /**
   * ProductStockMovement upsert
   */
  export type ProductStockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStockMovement to update in case it exists.
     */
    where: ProductStockMovementWhereUniqueInput
    /**
     * In case the ProductStockMovement found by the `where` argument doesn't exist, create a new ProductStockMovement with this data.
     */
    create: XOR<ProductStockMovementCreateInput, ProductStockMovementUncheckedCreateInput>
    /**
     * In case the ProductStockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStockMovementUpdateInput, ProductStockMovementUncheckedUpdateInput>
  }

  /**
   * ProductStockMovement delete
   */
  export type ProductStockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
    /**
     * Filter which ProductStockMovement to delete.
     */
    where: ProductStockMovementWhereUniqueInput
  }

  /**
   * ProductStockMovement deleteMany
   */
  export type ProductStockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStockMovements to delete
     */
    where?: ProductStockMovementWhereInput
  }

  /**
   * ProductStockMovement without action
   */
  export type ProductStockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStockMovement
     */
    select?: ProductStockMovementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockMovementInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
    branchId: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    branchId: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
    branchId?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    branchId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    branchId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    branchId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: number
    branchId: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    branchId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */ 
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'Int'>
    readonly branchId: FieldRef<"ProductCategory", 'Int'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorNameSnapshot: string | null
    patientNameSnapshot: string | null
    diagnosisSummary: string | null
    clinicNameSnapshot: string | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    doctorNameSnapshot: string | null
    patientNameSnapshot: string | null
    diagnosisSummary: string | null
    clinicNameSnapshot: string | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    encounterId: number
    createdAt: number
    updatedAt: number
    doctorNameSnapshot: number
    patientNameSnapshot: number
    diagnosisSummary: number
    clinicNameSnapshot: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    encounterId?: true
    createdAt?: true
    updatedAt?: true
    doctorNameSnapshot?: true
    patientNameSnapshot?: true
    diagnosisSummary?: true
    clinicNameSnapshot?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    encounterId?: true
    createdAt?: true
    updatedAt?: true
    doctorNameSnapshot?: true
    patientNameSnapshot?: true
    diagnosisSummary?: true
    clinicNameSnapshot?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    encounterId?: true
    createdAt?: true
    updatedAt?: true
    doctorNameSnapshot?: true
    patientNameSnapshot?: true
    diagnosisSummary?: true
    clinicNameSnapshot?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: number
    encounterId: number
    createdAt: Date
    updatedAt: Date
    doctorNameSnapshot: string | null
    patientNameSnapshot: string | null
    diagnosisSummary: string | null
    clinicNameSnapshot: string | null
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorNameSnapshot?: boolean
    patientNameSnapshot?: boolean
    diagnosisSummary?: boolean
    clinicNameSnapshot?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    items?: boolean | Prescription$itemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorNameSnapshot?: boolean
    patientNameSnapshot?: boolean
    diagnosisSummary?: boolean
    clinicNameSnapshot?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    encounterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorNameSnapshot?: boolean
    patientNameSnapshot?: boolean
    diagnosisSummary?: boolean
    clinicNameSnapshot?: boolean
  }

  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    items?: boolean | Prescription$itemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      items: Prisma.$PrescriptionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      createdAt: Date
      updatedAt: Date
      doctorNameSnapshot: string | null
      patientNameSnapshot: string | null
      diagnosisSummary: string | null
      clinicNameSnapshot: string | null
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Prescription$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */ 
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'Int'>
    readonly encounterId: FieldRef<"Prescription", 'Int'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly updatedAt: FieldRef<"Prescription", 'DateTime'>
    readonly doctorNameSnapshot: FieldRef<"Prescription", 'String'>
    readonly patientNameSnapshot: FieldRef<"Prescription", 'String'>
    readonly diagnosisSummary: FieldRef<"Prescription", 'String'>
    readonly clinicNameSnapshot: FieldRef<"Prescription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription.items
   */
  export type Prescription$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionItem
   */

  export type AggregatePrescriptionItem = {
    _count: PrescriptionItemCountAggregateOutputType | null
    _avg: PrescriptionItemAvgAggregateOutputType | null
    _sum: PrescriptionItemSumAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  export type PrescriptionItemAvgAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
  }

  export type PrescriptionItemSumAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
  }

  export type PrescriptionItemMinAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    drugName: string | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
    note: string | null
  }

  export type PrescriptionItemMaxAggregateOutputType = {
    id: number | null
    prescriptionId: number | null
    order: number | null
    drugName: string | null
    durationDays: number | null
    quantityPerTake: number | null
    frequencyPerDay: number | null
    note: string | null
  }

  export type PrescriptionItemCountAggregateOutputType = {
    id: number
    prescriptionId: number
    order: number
    drugName: number
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note: number
    _all: number
  }


  export type PrescriptionItemAvgAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
  }

  export type PrescriptionItemSumAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
  }

  export type PrescriptionItemMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    drugName?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
    note?: true
  }

  export type PrescriptionItemMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    drugName?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
    note?: true
  }

  export type PrescriptionItemCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    order?: true
    drugName?: true
    durationDays?: true
    quantityPerTake?: true
    frequencyPerDay?: true
    note?: true
    _all?: true
  }

  export type PrescriptionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItem to aggregate.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionItems
    **/
    _count?: true | PrescriptionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type GetPrescriptionItemAggregateType<T extends PrescriptionItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionItem[P]>
      : GetScalarType<T[P], AggregatePrescriptionItem[P]>
  }




  export type PrescriptionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithAggregationInput | PrescriptionItemOrderByWithAggregationInput[]
    by: PrescriptionItemScalarFieldEnum[] | PrescriptionItemScalarFieldEnum
    having?: PrescriptionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionItemCountAggregateInputType | true
    _avg?: PrescriptionItemAvgAggregateInputType
    _sum?: PrescriptionItemSumAggregateInputType
    _min?: PrescriptionItemMinAggregateInputType
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type PrescriptionItemGroupByOutputType = {
    id: number
    prescriptionId: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note: string | null
    _count: PrescriptionItemCountAggregateOutputType | null
    _avg: PrescriptionItemAvgAggregateOutputType | null
    _sum: PrescriptionItemSumAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  type GetPrescriptionItemGroupByPayload<T extends PrescriptionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    order?: boolean
    drugName?: boolean
    durationDays?: boolean
    quantityPerTake?: boolean
    frequencyPerDay?: boolean
    note?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    order?: boolean
    drugName?: boolean
    durationDays?: boolean
    quantityPerTake?: boolean
    frequencyPerDay?: boolean
    note?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    order?: boolean
    drugName?: boolean
    durationDays?: boolean
    quantityPerTake?: boolean
    frequencyPerDay?: boolean
    note?: boolean
  }

  export type PrescriptionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }

  export type $PrescriptionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionItem"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      prescriptionId: number
      order: number
      drugName: string
      durationDays: number
      quantityPerTake: number
      frequencyPerDay: number
      note: string | null
    }, ExtArgs["result"]["prescriptionItem"]>
    composites: {}
  }

  type PrescriptionItemGetPayload<S extends boolean | null | undefined | PrescriptionItemDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionItemPayload, S>

  type PrescriptionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrescriptionItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrescriptionItemCountAggregateInputType | true
    }

  export interface PrescriptionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionItem'], meta: { name: 'PrescriptionItem' } }
    /**
     * Find zero or one PrescriptionItem that matches the filter.
     * @param {PrescriptionItemFindUniqueArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionItemFindUniqueArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrescriptionItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrescriptionItemFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrescriptionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionItemFindFirstArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrescriptionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrescriptionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany()
     * 
     * // Get first 10 PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionItemFindManyArgs>(args?: SelectSubset<T, PrescriptionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrescriptionItem.
     * @param {PrescriptionItemCreateArgs} args - Arguments to create a PrescriptionItem.
     * @example
     * // Create one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.create({
     *   data: {
     *     // ... data to create a PrescriptionItem
     *   }
     * })
     * 
     */
    create<T extends PrescriptionItemCreateArgs>(args: SelectSubset<T, PrescriptionItemCreateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrescriptionItems.
     * @param {PrescriptionItemCreateManyArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionItemCreateManyArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionItems and returns the data saved in the database.
     * @param {PrescriptionItemCreateManyAndReturnArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrescriptionItem.
     * @param {PrescriptionItemDeleteArgs} args - Arguments to delete one PrescriptionItem.
     * @example
     * // Delete one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionItem
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionItemDeleteArgs>(args: SelectSubset<T, PrescriptionItemDeleteArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrescriptionItem.
     * @param {PrescriptionItemUpdateArgs} args - Arguments to update one PrescriptionItem.
     * @example
     * // Update one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionItemUpdateArgs>(args: SelectSubset<T, PrescriptionItemUpdateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrescriptionItems.
     * @param {PrescriptionItemDeleteManyArgs} args - Arguments to filter PrescriptionItems to delete.
     * @example
     * // Delete a few PrescriptionItems
     * const { count } = await prisma.prescriptionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionItemDeleteManyArgs>(args?: SelectSubset<T, PrescriptionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionItemUpdateManyArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrescriptionItem.
     * @param {PrescriptionItemUpsertArgs} args - Arguments to update or create a PrescriptionItem.
     * @example
     * // Update or create a PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.upsert({
     *   create: {
     *     // ... data to create a PrescriptionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionItem we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionItemUpsertArgs>(args: SelectSubset<T, PrescriptionItemUpsertArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemCountArgs} args - Arguments to filter PrescriptionItems to count.
     * @example
     * // Count the number of PrescriptionItems
     * const count = await prisma.prescriptionItem.count({
     *   where: {
     *     // ... the filter for the PrescriptionItems we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionItemCountArgs>(
      args?: Subset<T, PrescriptionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionItemAggregateArgs>(args: Subset<T, PrescriptionItemAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionItemAggregateType<T>>

    /**
     * Group by PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionItemGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionItem model
   */
  readonly fields: PrescriptionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionItem model
   */ 
  interface PrescriptionItemFieldRefs {
    readonly id: FieldRef<"PrescriptionItem", 'Int'>
    readonly prescriptionId: FieldRef<"PrescriptionItem", 'Int'>
    readonly order: FieldRef<"PrescriptionItem", 'Int'>
    readonly drugName: FieldRef<"PrescriptionItem", 'String'>
    readonly durationDays: FieldRef<"PrescriptionItem", 'Int'>
    readonly quantityPerTake: FieldRef<"PrescriptionItem", 'Int'>
    readonly frequencyPerDay: FieldRef<"PrescriptionItem", 'Int'>
    readonly note: FieldRef<"PrescriptionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionItem findUnique
   */
  export type PrescriptionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findUniqueOrThrow
   */
  export type PrescriptionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findFirst
   */
  export type PrescriptionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findFirstOrThrow
   */
  export type PrescriptionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findMany
   */
  export type PrescriptionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItems to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem create
   */
  export type PrescriptionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionItem.
     */
    data: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
  }

  /**
   * PrescriptionItem createMany
   */
  export type PrescriptionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionItem createManyAndReturn
   */
  export type PrescriptionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem update
   */
  export type PrescriptionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionItem.
     */
    data: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionItem to update.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem updateMany
   */
  export type PrescriptionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
  }

  /**
   * PrescriptionItem upsert
   */
  export type PrescriptionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionItem to update in case it exists.
     */
    where: PrescriptionItemWhereUniqueInput
    /**
     * In case the PrescriptionItem found by the `where` argument doesn't exist, create a new PrescriptionItem with this data.
     */
    create: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
    /**
     * In case the PrescriptionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
  }

  /**
   * PrescriptionItem delete
   */
  export type PrescriptionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionItem to delete.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem deleteMany
   */
  export type PrescriptionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItems to delete
     */
    where?: PrescriptionItemWhereInput
  }

  /**
   * PrescriptionItem without action
   */
  export type PrescriptionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    finalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    finalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    discountPercent: $Enums.DiscountPercent | null
    finalAmount: number | null
    statusLegacy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    encounterId: number | null
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    discountPercent: $Enums.DiscountPercent | null
    finalAmount: number | null
    statusLegacy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    branchId: number
    encounterId: number
    patientId: number
    totalAmount: number
    totalBeforeDiscount: number
    discountPercent: number
    finalAmount: number
    statusLegacy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    finalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    finalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    discountPercent?: true
    finalAmount?: true
    statusLegacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    discountPercent?: true
    finalAmount?: true
    statusLegacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    totalAmount?: true
    totalBeforeDiscount?: true
    discountPercent?: true
    finalAmount?: true
    statusLegacy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    branchId: number | null
    encounterId: number
    patientId: number | null
    totalAmount: number | null
    totalBeforeDiscount: number | null
    discountPercent: $Enums.DiscountPercent
    finalAmount: number | null
    statusLegacy: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    totalAmount?: boolean
    totalBeforeDiscount?: boolean
    discountPercent?: boolean
    finalAmount?: boolean
    statusLegacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    eBarimtReceipt?: boolean | Invoice$eBarimtReceiptArgs<ExtArgs>
    ledgerEntries?: boolean | Invoice$ledgerEntriesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Invoice$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    totalAmount?: boolean
    totalBeforeDiscount?: boolean
    discountPercent?: boolean
    finalAmount?: boolean
    statusLegacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    totalAmount?: boolean
    totalBeforeDiscount?: boolean
    discountPercent?: boolean
    finalAmount?: boolean
    statusLegacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    eBarimtReceipt?: boolean | Invoice$eBarimtReceiptArgs<ExtArgs>
    ledgerEntries?: boolean | Invoice$ledgerEntriesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    employeeBenefitUsages?: boolean | Invoice$employeeBenefitUsagesArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Invoice$branchArgs<ExtArgs>
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    patient?: boolean | Invoice$patientArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      encounter: Prisma.$EncounterPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs> | null
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      eBarimtReceipt: Prisma.$EBarimtReceiptPayload<ExtArgs> | null
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      employeeBenefitUsages: Prisma.$EmployeeBenefitUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number | null
      encounterId: number
      patientId: number | null
      totalAmount: number | null
      totalBeforeDiscount: number | null
      discountPercent: $Enums.DiscountPercent
      finalAmount: number | null
      statusLegacy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Invoice$branchArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends Invoice$patientArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    eBarimtReceipt<T extends Invoice$eBarimtReceiptArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$eBarimtReceiptArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ledgerEntries<T extends Invoice$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    employeeBenefitUsages<T extends Invoice$employeeBenefitUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$employeeBenefitUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeBenefitUsagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly branchId: FieldRef<"Invoice", 'Int'>
    readonly encounterId: FieldRef<"Invoice", 'Int'>
    readonly patientId: FieldRef<"Invoice", 'Int'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly totalBeforeDiscount: FieldRef<"Invoice", 'Float'>
    readonly discountPercent: FieldRef<"Invoice", 'DiscountPercent'>
    readonly finalAmount: FieldRef<"Invoice", 'Float'>
    readonly statusLegacy: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.branch
   */
  export type Invoice$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Invoice.patient
   */
  export type Invoice$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.eBarimtReceipt
   */
  export type Invoice$eBarimtReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    where?: EBarimtReceiptWhereInput
  }

  /**
   * Invoice.ledgerEntries
   */
  export type Invoice$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.employeeBenefitUsages
   */
  export type Invoice$employeeBenefitUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeBenefitUsage
     */
    select?: EmployeeBenefitUsageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeBenefitUsageInclude<ExtArgs> | null
    where?: EmployeeBenefitUsageWhereInput
    orderBy?: EmployeeBenefitUsageOrderByWithRelationInput | EmployeeBenefitUsageOrderByWithRelationInput[]
    cursor?: EmployeeBenefitUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeBenefitUsageScalarFieldEnum | EmployeeBenefitUsageScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    serviceId: number | null
    productId: number | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    serviceId: number | null
    productId: number | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemType: $Enums.InvoiceItemType | null
    serviceId: number | null
    productId: number | null
    procedureCode: string | null
    name: string | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
    createdAt: Date | null
    source: $Enums.InvoiceItemSource | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemType: $Enums.InvoiceItemType | null
    serviceId: number | null
    productId: number | null
    procedureCode: string | null
    name: string | null
    unitPrice: number | null
    quantity: number | null
    lineTotal: number | null
    createdAt: Date | null
    source: $Enums.InvoiceItemSource | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemType: number
    serviceId: number
    productId: number
    procedureCode: number
    name: number
    unitPrice: number
    quantity: number
    lineTotal: number
    createdAt: number
    source: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    productId?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    productId?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    serviceId?: true
    productId?: true
    procedureCode?: true
    name?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
    createdAt?: true
    source?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    serviceId?: true
    productId?: true
    procedureCode?: true
    name?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
    createdAt?: true
    source?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    serviceId?: true
    productId?: true
    procedureCode?: true
    name?: true
    unitPrice?: true
    quantity?: true
    lineTotal?: true
    createdAt?: true
    source?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId: number | null
    productId: number | null
    procedureCode: string | null
    name: string
    unitPrice: number
    quantity: number
    lineTotal: number
    createdAt: Date
    source: $Enums.InvoiceItemSource
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    procedureCode?: boolean
    name?: boolean
    unitPrice?: boolean
    quantity?: boolean
    lineTotal?: boolean
    createdAt?: boolean
    source?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    procedureCode?: boolean
    name?: boolean
    unitPrice?: boolean
    quantity?: boolean
    lineTotal?: boolean
    createdAt?: boolean
    source?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    serviceId?: boolean
    productId?: boolean
    procedureCode?: boolean
    name?: boolean
    unitPrice?: boolean
    quantity?: boolean
    lineTotal?: boolean
    createdAt?: boolean
    source?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | InvoiceItem$serviceArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    procedure?: boolean | InvoiceItem$procedureArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      procedure: Prisma.$ProcedurePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      itemType: $Enums.InvoiceItemType
      serviceId: number | null
      productId: number | null
      procedureCode: string | null
      name: string
      unitPrice: number
      quantity: number
      lineTotal: number
      createdAt: Date
      source: $Enums.InvoiceItemSource
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends InvoiceItem$serviceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product<T extends InvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    procedure<T extends InvoiceItem$procedureArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$procedureArgs<ExtArgs>>): Prisma__ProcedureClient<$Result.GetResult<Prisma.$ProcedurePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'Int'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'Int'>
    readonly itemType: FieldRef<"InvoiceItem", 'InvoiceItemType'>
    readonly serviceId: FieldRef<"InvoiceItem", 'Int'>
    readonly productId: FieldRef<"InvoiceItem", 'Int'>
    readonly procedureCode: FieldRef<"InvoiceItem", 'String'>
    readonly name: FieldRef<"InvoiceItem", 'String'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Float'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly lineTotal: FieldRef<"InvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
    readonly source: FieldRef<"InvoiceItem", 'InvoiceItemSource'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem.service
   */
  export type InvoiceItem$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * InvoiceItem.product
   */
  export type InvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * InvoiceItem.procedure
   */
  export type InvoiceItem$procedureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Procedure
     */
    select?: ProcedureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureInclude<ExtArgs> | null
    where?: ProcedureWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
    method: string | null
    qpayTxnId: string | null
    timestamp: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    amount: number | null
    method: string | null
    qpayTxnId: string | null
    timestamp: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    amount: number
    method: number
    qpayTxnId: number
    timestamp: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    method?: true
    qpayTxnId?: true
    timestamp?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    method?: true
    qpayTxnId?: true
    timestamp?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    method?: true
    qpayTxnId?: true
    timestamp?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    invoiceId: number
    amount: number
    method: string
    qpayTxnId: string | null
    timestamp: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    qpayTxnId?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    qpayTxnId?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    method?: boolean
    qpayTxnId?: boolean
    timestamp?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      amount: number
      method: string
      qpayTxnId: string | null
      timestamp: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly invoiceId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly qpayTxnId: FieldRef<"Payment", 'String'>
    readonly timestamp: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model EBarimtReceipt
   */

  export type AggregateEBarimtReceipt = {
    _count: EBarimtReceiptCountAggregateOutputType | null
    _avg: EBarimtReceiptAvgAggregateOutputType | null
    _sum: EBarimtReceiptSumAggregateOutputType | null
    _min: EBarimtReceiptMinAggregateOutputType | null
    _max: EBarimtReceiptMaxAggregateOutputType | null
  }

  export type EBarimtReceiptAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
  }

  export type EBarimtReceiptSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
  }

  export type EBarimtReceiptMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    receiptNumber: string | null
    timestamp: Date | null
  }

  export type EBarimtReceiptMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    receiptNumber: string | null
    timestamp: Date | null
  }

  export type EBarimtReceiptCountAggregateOutputType = {
    id: number
    invoiceId: number
    receiptNumber: number
    timestamp: number
    _all: number
  }


  export type EBarimtReceiptAvgAggregateInputType = {
    id?: true
    invoiceId?: true
  }

  export type EBarimtReceiptSumAggregateInputType = {
    id?: true
    invoiceId?: true
  }

  export type EBarimtReceiptMinAggregateInputType = {
    id?: true
    invoiceId?: true
    receiptNumber?: true
    timestamp?: true
  }

  export type EBarimtReceiptMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    receiptNumber?: true
    timestamp?: true
  }

  export type EBarimtReceiptCountAggregateInputType = {
    id?: true
    invoiceId?: true
    receiptNumber?: true
    timestamp?: true
    _all?: true
  }

  export type EBarimtReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBarimtReceipt to aggregate.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EBarimtReceipts
    **/
    _count?: true | EBarimtReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EBarimtReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EBarimtReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EBarimtReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EBarimtReceiptMaxAggregateInputType
  }

  export type GetEBarimtReceiptAggregateType<T extends EBarimtReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateEBarimtReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEBarimtReceipt[P]>
      : GetScalarType<T[P], AggregateEBarimtReceipt[P]>
  }




  export type EBarimtReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EBarimtReceiptWhereInput
    orderBy?: EBarimtReceiptOrderByWithAggregationInput | EBarimtReceiptOrderByWithAggregationInput[]
    by: EBarimtReceiptScalarFieldEnum[] | EBarimtReceiptScalarFieldEnum
    having?: EBarimtReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EBarimtReceiptCountAggregateInputType | true
    _avg?: EBarimtReceiptAvgAggregateInputType
    _sum?: EBarimtReceiptSumAggregateInputType
    _min?: EBarimtReceiptMinAggregateInputType
    _max?: EBarimtReceiptMaxAggregateInputType
  }

  export type EBarimtReceiptGroupByOutputType = {
    id: number
    invoiceId: number
    receiptNumber: string
    timestamp: Date
    _count: EBarimtReceiptCountAggregateOutputType | null
    _avg: EBarimtReceiptAvgAggregateOutputType | null
    _sum: EBarimtReceiptSumAggregateOutputType | null
    _min: EBarimtReceiptMinAggregateOutputType | null
    _max: EBarimtReceiptMaxAggregateOutputType | null
  }

  type GetEBarimtReceiptGroupByPayload<T extends EBarimtReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EBarimtReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EBarimtReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EBarimtReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], EBarimtReceiptGroupByOutputType[P]>
        }
      >
    >


  export type EBarimtReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    receiptNumber?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eBarimtReceipt"]>

  export type EBarimtReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    receiptNumber?: boolean
    timestamp?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eBarimtReceipt"]>

  export type EBarimtReceiptSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    receiptNumber?: boolean
    timestamp?: boolean
  }

  export type EBarimtReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type EBarimtReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $EBarimtReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EBarimtReceipt"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      receiptNumber: string
      timestamp: Date
    }, ExtArgs["result"]["eBarimtReceipt"]>
    composites: {}
  }

  type EBarimtReceiptGetPayload<S extends boolean | null | undefined | EBarimtReceiptDefaultArgs> = $Result.GetResult<Prisma.$EBarimtReceiptPayload, S>

  type EBarimtReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EBarimtReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EBarimtReceiptCountAggregateInputType | true
    }

  export interface EBarimtReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EBarimtReceipt'], meta: { name: 'EBarimtReceipt' } }
    /**
     * Find zero or one EBarimtReceipt that matches the filter.
     * @param {EBarimtReceiptFindUniqueArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EBarimtReceiptFindUniqueArgs>(args: SelectSubset<T, EBarimtReceiptFindUniqueArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EBarimtReceipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EBarimtReceiptFindUniqueOrThrowArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EBarimtReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, EBarimtReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EBarimtReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptFindFirstArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EBarimtReceiptFindFirstArgs>(args?: SelectSubset<T, EBarimtReceiptFindFirstArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EBarimtReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptFindFirstOrThrowArgs} args - Arguments to find a EBarimtReceipt
     * @example
     * // Get one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EBarimtReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, EBarimtReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EBarimtReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EBarimtReceipts
     * const eBarimtReceipts = await prisma.eBarimtReceipt.findMany()
     * 
     * // Get first 10 EBarimtReceipts
     * const eBarimtReceipts = await prisma.eBarimtReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eBarimtReceiptWithIdOnly = await prisma.eBarimtReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EBarimtReceiptFindManyArgs>(args?: SelectSubset<T, EBarimtReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EBarimtReceipt.
     * @param {EBarimtReceiptCreateArgs} args - Arguments to create a EBarimtReceipt.
     * @example
     * // Create one EBarimtReceipt
     * const EBarimtReceipt = await prisma.eBarimtReceipt.create({
     *   data: {
     *     // ... data to create a EBarimtReceipt
     *   }
     * })
     * 
     */
    create<T extends EBarimtReceiptCreateArgs>(args: SelectSubset<T, EBarimtReceiptCreateArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EBarimtReceipts.
     * @param {EBarimtReceiptCreateManyArgs} args - Arguments to create many EBarimtReceipts.
     * @example
     * // Create many EBarimtReceipts
     * const eBarimtReceipt = await prisma.eBarimtReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EBarimtReceiptCreateManyArgs>(args?: SelectSubset<T, EBarimtReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EBarimtReceipts and returns the data saved in the database.
     * @param {EBarimtReceiptCreateManyAndReturnArgs} args - Arguments to create many EBarimtReceipts.
     * @example
     * // Create many EBarimtReceipts
     * const eBarimtReceipt = await prisma.eBarimtReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EBarimtReceipts and only return the `id`
     * const eBarimtReceiptWithIdOnly = await prisma.eBarimtReceipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EBarimtReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, EBarimtReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EBarimtReceipt.
     * @param {EBarimtReceiptDeleteArgs} args - Arguments to delete one EBarimtReceipt.
     * @example
     * // Delete one EBarimtReceipt
     * const EBarimtReceipt = await prisma.eBarimtReceipt.delete({
     *   where: {
     *     // ... filter to delete one EBarimtReceipt
     *   }
     * })
     * 
     */
    delete<T extends EBarimtReceiptDeleteArgs>(args: SelectSubset<T, EBarimtReceiptDeleteArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EBarimtReceipt.
     * @param {EBarimtReceiptUpdateArgs} args - Arguments to update one EBarimtReceipt.
     * @example
     * // Update one EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EBarimtReceiptUpdateArgs>(args: SelectSubset<T, EBarimtReceiptUpdateArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EBarimtReceipts.
     * @param {EBarimtReceiptDeleteManyArgs} args - Arguments to filter EBarimtReceipts to delete.
     * @example
     * // Delete a few EBarimtReceipts
     * const { count } = await prisma.eBarimtReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EBarimtReceiptDeleteManyArgs>(args?: SelectSubset<T, EBarimtReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EBarimtReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EBarimtReceipts
     * const eBarimtReceipt = await prisma.eBarimtReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EBarimtReceiptUpdateManyArgs>(args: SelectSubset<T, EBarimtReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EBarimtReceipt.
     * @param {EBarimtReceiptUpsertArgs} args - Arguments to update or create a EBarimtReceipt.
     * @example
     * // Update or create a EBarimtReceipt
     * const eBarimtReceipt = await prisma.eBarimtReceipt.upsert({
     *   create: {
     *     // ... data to create a EBarimtReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EBarimtReceipt we want to update
     *   }
     * })
     */
    upsert<T extends EBarimtReceiptUpsertArgs>(args: SelectSubset<T, EBarimtReceiptUpsertArgs<ExtArgs>>): Prisma__EBarimtReceiptClient<$Result.GetResult<Prisma.$EBarimtReceiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EBarimtReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptCountArgs} args - Arguments to filter EBarimtReceipts to count.
     * @example
     * // Count the number of EBarimtReceipts
     * const count = await prisma.eBarimtReceipt.count({
     *   where: {
     *     // ... the filter for the EBarimtReceipts we want to count
     *   }
     * })
    **/
    count<T extends EBarimtReceiptCountArgs>(
      args?: Subset<T, EBarimtReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EBarimtReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EBarimtReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EBarimtReceiptAggregateArgs>(args: Subset<T, EBarimtReceiptAggregateArgs>): Prisma.PrismaPromise<GetEBarimtReceiptAggregateType<T>>

    /**
     * Group by EBarimtReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBarimtReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EBarimtReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EBarimtReceiptGroupByArgs['orderBy'] }
        : { orderBy?: EBarimtReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EBarimtReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEBarimtReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EBarimtReceipt model
   */
  readonly fields: EBarimtReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EBarimtReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EBarimtReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EBarimtReceipt model
   */ 
  interface EBarimtReceiptFieldRefs {
    readonly id: FieldRef<"EBarimtReceipt", 'Int'>
    readonly invoiceId: FieldRef<"EBarimtReceipt", 'Int'>
    readonly receiptNumber: FieldRef<"EBarimtReceipt", 'String'>
    readonly timestamp: FieldRef<"EBarimtReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EBarimtReceipt findUnique
   */
  export type EBarimtReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt findUniqueOrThrow
   */
  export type EBarimtReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt findFirst
   */
  export type EBarimtReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBarimtReceipts.
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBarimtReceipts.
     */
    distinct?: EBarimtReceiptScalarFieldEnum | EBarimtReceiptScalarFieldEnum[]
  }

  /**
   * EBarimtReceipt findFirstOrThrow
   */
  export type EBarimtReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipt to fetch.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBarimtReceipts.
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBarimtReceipts.
     */
    distinct?: EBarimtReceiptScalarFieldEnum | EBarimtReceiptScalarFieldEnum[]
  }

  /**
   * EBarimtReceipt findMany
   */
  export type EBarimtReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter, which EBarimtReceipts to fetch.
     */
    where?: EBarimtReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBarimtReceipts to fetch.
     */
    orderBy?: EBarimtReceiptOrderByWithRelationInput | EBarimtReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EBarimtReceipts.
     */
    cursor?: EBarimtReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBarimtReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBarimtReceipts.
     */
    skip?: number
    distinct?: EBarimtReceiptScalarFieldEnum | EBarimtReceiptScalarFieldEnum[]
  }

  /**
   * EBarimtReceipt create
   */
  export type EBarimtReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a EBarimtReceipt.
     */
    data: XOR<EBarimtReceiptCreateInput, EBarimtReceiptUncheckedCreateInput>
  }

  /**
   * EBarimtReceipt createMany
   */
  export type EBarimtReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EBarimtReceipts.
     */
    data: EBarimtReceiptCreateManyInput | EBarimtReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EBarimtReceipt createManyAndReturn
   */
  export type EBarimtReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EBarimtReceipts.
     */
    data: EBarimtReceiptCreateManyInput | EBarimtReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EBarimtReceipt update
   */
  export type EBarimtReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a EBarimtReceipt.
     */
    data: XOR<EBarimtReceiptUpdateInput, EBarimtReceiptUncheckedUpdateInput>
    /**
     * Choose, which EBarimtReceipt to update.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt updateMany
   */
  export type EBarimtReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EBarimtReceipts.
     */
    data: XOR<EBarimtReceiptUpdateManyMutationInput, EBarimtReceiptUncheckedUpdateManyInput>
    /**
     * Filter which EBarimtReceipts to update
     */
    where?: EBarimtReceiptWhereInput
  }

  /**
   * EBarimtReceipt upsert
   */
  export type EBarimtReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the EBarimtReceipt to update in case it exists.
     */
    where: EBarimtReceiptWhereUniqueInput
    /**
     * In case the EBarimtReceipt found by the `where` argument doesn't exist, create a new EBarimtReceipt with this data.
     */
    create: XOR<EBarimtReceiptCreateInput, EBarimtReceiptUncheckedCreateInput>
    /**
     * In case the EBarimtReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EBarimtReceiptUpdateInput, EBarimtReceiptUncheckedUpdateInput>
  }

  /**
   * EBarimtReceipt delete
   */
  export type EBarimtReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
    /**
     * Filter which EBarimtReceipt to delete.
     */
    where: EBarimtReceiptWhereUniqueInput
  }

  /**
   * EBarimtReceipt deleteMany
   */
  export type EBarimtReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBarimtReceipts to delete
     */
    where?: EBarimtReceiptWhereInput
  }

  /**
   * EBarimtReceipt without action
   */
  export type EBarimtReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBarimtReceipt
     */
    select?: EBarimtReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EBarimtReceiptInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    type: $Enums.LedgerEntryType | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
    createdAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    patientId: number | null
    invoiceId: number | null
    type: $Enums.LedgerEntryType | null
    amount: number | null
    createdById: number | null
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
    createdAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    branchId: number
    patientId: number
    invoiceId: number
    type: number
    amount: number
    createdById: number
    approvedById: number
    approvalCodeId: number
    employeeVoucherId: number
    meta: number
    createdAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    type?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
    createdAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    type?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
    createdAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    invoiceId?: true
    type?: true
    amount?: true
    createdById?: true
    approvedById?: true
    approvalCodeId?: true
    employeeVoucherId?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: number
    branchId: number
    patientId: number
    invoiceId: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById: number | null
    approvalCodeId: number | null
    employeeVoucherId: number | null
    meta: JsonValue | null
    createdAt: Date
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    invoiceId?: boolean
    type?: boolean
    amount?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvalCodeId?: boolean
    employeeVoucherId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    invoiceId?: boolean
    type?: boolean
    amount?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvalCodeId?: boolean
    employeeVoucherId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    invoiceId?: boolean
    type?: boolean
    amount?: boolean
    createdById?: boolean
    approvedById?: boolean
    approvalCodeId?: boolean
    employeeVoucherId?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | LedgerEntry$invoiceArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | LedgerEntry$approvedByArgs<ExtArgs>
    approvalCode?: boolean | LedgerEntry$approvalCodeArgs<ExtArgs>
    employeeVoucher?: boolean | LedgerEntry$employeeVoucherArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      approvalCode: Prisma.$AuthorizationCodePayload<ExtArgs> | null
      employeeVoucher: Prisma.$EmployeeVoucherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      patientId: number
      invoiceId: number | null
      type: $Enums.LedgerEntryType
      amount: number
      createdById: number
      approvedById: number | null
      approvalCodeId: number | null
      employeeVoucherId: number | null
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends LedgerEntry$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approvedBy<T extends LedgerEntry$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    approvalCode<T extends LedgerEntry$approvalCodeArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$approvalCodeArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employeeVoucher<T extends LedgerEntry$employeeVoucherArgs<ExtArgs> = {}>(args?: Subset<T, LedgerEntry$employeeVoucherArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */ 
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'Int'>
    readonly branchId: FieldRef<"LedgerEntry", 'Int'>
    readonly patientId: FieldRef<"LedgerEntry", 'Int'>
    readonly invoiceId: FieldRef<"LedgerEntry", 'Int'>
    readonly type: FieldRef<"LedgerEntry", 'LedgerEntryType'>
    readonly amount: FieldRef<"LedgerEntry", 'Float'>
    readonly createdById: FieldRef<"LedgerEntry", 'Int'>
    readonly approvedById: FieldRef<"LedgerEntry", 'Int'>
    readonly approvalCodeId: FieldRef<"LedgerEntry", 'Int'>
    readonly employeeVoucherId: FieldRef<"LedgerEntry", 'Int'>
    readonly meta: FieldRef<"LedgerEntry", 'Json'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
  }

  /**
   * LedgerEntry.invoice
   */
  export type LedgerEntry$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * LedgerEntry.approvedBy
   */
  export type LedgerEntry$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LedgerEntry.approvalCode
   */
  export type LedgerEntry$approvalCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    where?: AuthorizationCodeWhereInput
  }

  /**
   * LedgerEntry.employeeVoucher
   */
  export type LedgerEntry$employeeVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    where?: EmployeeVoucherWhereInput
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model AuthorizationCode
   */

  export type AggregateAuthorizationCode = {
    _count: AuthorizationCodeCountAggregateOutputType | null
    _avg: AuthorizationCodeAvgAggregateOutputType | null
    _sum: AuthorizationCodeSumAggregateOutputType | null
    _min: AuthorizationCodeMinAggregateOutputType | null
    _max: AuthorizationCodeMaxAggregateOutputType | null
  }

  export type AuthorizationCodeAvgAggregateOutputType = {
    id: number | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
  }

  export type AuthorizationCodeSumAggregateOutputType = {
    id: number | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
  }

  export type AuthorizationCodeMinAggregateOutputType = {
    id: number | null
    code: string | null
    purpose: string | null
    isEnabled: boolean | null
    expiresAt: Date | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorizationCodeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    purpose: string | null
    isEnabled: boolean | null
    expiresAt: Date | null
    maxUses: number | null
    usedCount: number | null
    createdById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorizationCodeCountAggregateOutputType = {
    id: number
    code: number
    purpose: number
    isEnabled: number
    expiresAt: number
    maxUses: number
    usedCount: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthorizationCodeAvgAggregateInputType = {
    id?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
  }

  export type AuthorizationCodeSumAggregateInputType = {
    id?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
  }

  export type AuthorizationCodeMinAggregateInputType = {
    id?: true
    code?: true
    purpose?: true
    isEnabled?: true
    expiresAt?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorizationCodeMaxAggregateInputType = {
    id?: true
    code?: true
    purpose?: true
    isEnabled?: true
    expiresAt?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorizationCodeCountAggregateInputType = {
    id?: true
    code?: true
    purpose?: true
    isEnabled?: true
    expiresAt?: true
    maxUses?: true
    usedCount?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorizationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthorizationCode to aggregate.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthorizationCodes
    **/
    _count?: true | AuthorizationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorizationCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorizationCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorizationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorizationCodeMaxAggregateInputType
  }

  export type GetAuthorizationCodeAggregateType<T extends AuthorizationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorizationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorizationCode[P]>
      : GetScalarType<T[P], AggregateAuthorizationCode[P]>
  }




  export type AuthorizationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorizationCodeWhereInput
    orderBy?: AuthorizationCodeOrderByWithAggregationInput | AuthorizationCodeOrderByWithAggregationInput[]
    by: AuthorizationCodeScalarFieldEnum[] | AuthorizationCodeScalarFieldEnum
    having?: AuthorizationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorizationCodeCountAggregateInputType | true
    _avg?: AuthorizationCodeAvgAggregateInputType
    _sum?: AuthorizationCodeSumAggregateInputType
    _min?: AuthorizationCodeMinAggregateInputType
    _max?: AuthorizationCodeMaxAggregateInputType
  }

  export type AuthorizationCodeGroupByOutputType = {
    id: number
    code: string
    purpose: string
    isEnabled: boolean
    expiresAt: Date | null
    maxUses: number | null
    usedCount: number
    createdById: number
    createdAt: Date
    updatedAt: Date
    _count: AuthorizationCodeCountAggregateOutputType | null
    _avg: AuthorizationCodeAvgAggregateOutputType | null
    _sum: AuthorizationCodeSumAggregateOutputType | null
    _min: AuthorizationCodeMinAggregateOutputType | null
    _max: AuthorizationCodeMaxAggregateOutputType | null
  }

  type GetAuthorizationCodeGroupByPayload<T extends AuthorizationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorizationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorizationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorizationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorizationCodeGroupByOutputType[P]>
        }
      >
    >


  export type AuthorizationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    purpose?: boolean
    isEnabled?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    usedCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | AuthorizationCode$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authorizationCode"]>

  export type AuthorizationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    purpose?: boolean
    isEnabled?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    usedCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authorizationCode"]>

  export type AuthorizationCodeSelectScalar = {
    id?: boolean
    code?: boolean
    purpose?: boolean
    isEnabled?: boolean
    expiresAt?: boolean
    maxUses?: boolean
    usedCount?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthorizationCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | AuthorizationCode$ledgerEntriesArgs<ExtArgs>
    _count?: boolean | AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorizationCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthorizationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthorizationCode"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      purpose: string
      isEnabled: boolean
      expiresAt: Date | null
      maxUses: number | null
      usedCount: number
      createdById: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authorizationCode"]>
    composites: {}
  }

  type AuthorizationCodeGetPayload<S extends boolean | null | undefined | AuthorizationCodeDefaultArgs> = $Result.GetResult<Prisma.$AuthorizationCodePayload, S>

  type AuthorizationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthorizationCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthorizationCodeCountAggregateInputType | true
    }

  export interface AuthorizationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthorizationCode'], meta: { name: 'AuthorizationCode' } }
    /**
     * Find zero or one AuthorizationCode that matches the filter.
     * @param {AuthorizationCodeFindUniqueArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorizationCodeFindUniqueArgs>(args: SelectSubset<T, AuthorizationCodeFindUniqueArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuthorizationCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthorizationCodeFindUniqueOrThrowArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorizationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuthorizationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeFindFirstArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorizationCodeFindFirstArgs>(args?: SelectSubset<T, AuthorizationCodeFindFirstArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuthorizationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeFindFirstOrThrowArgs} args - Arguments to find a AuthorizationCode
     * @example
     * // Get one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorizationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorizationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuthorizationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthorizationCodes
     * const authorizationCodes = await prisma.authorizationCode.findMany()
     * 
     * // Get first 10 AuthorizationCodes
     * const authorizationCodes = await prisma.authorizationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorizationCodeWithIdOnly = await prisma.authorizationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorizationCodeFindManyArgs>(args?: SelectSubset<T, AuthorizationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuthorizationCode.
     * @param {AuthorizationCodeCreateArgs} args - Arguments to create a AuthorizationCode.
     * @example
     * // Create one AuthorizationCode
     * const AuthorizationCode = await prisma.authorizationCode.create({
     *   data: {
     *     // ... data to create a AuthorizationCode
     *   }
     * })
     * 
     */
    create<T extends AuthorizationCodeCreateArgs>(args: SelectSubset<T, AuthorizationCodeCreateArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuthorizationCodes.
     * @param {AuthorizationCodeCreateManyArgs} args - Arguments to create many AuthorizationCodes.
     * @example
     * // Create many AuthorizationCodes
     * const authorizationCode = await prisma.authorizationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorizationCodeCreateManyArgs>(args?: SelectSubset<T, AuthorizationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthorizationCodes and returns the data saved in the database.
     * @param {AuthorizationCodeCreateManyAndReturnArgs} args - Arguments to create many AuthorizationCodes.
     * @example
     * // Create many AuthorizationCodes
     * const authorizationCode = await prisma.authorizationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthorizationCodes and only return the `id`
     * const authorizationCodeWithIdOnly = await prisma.authorizationCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorizationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorizationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuthorizationCode.
     * @param {AuthorizationCodeDeleteArgs} args - Arguments to delete one AuthorizationCode.
     * @example
     * // Delete one AuthorizationCode
     * const AuthorizationCode = await prisma.authorizationCode.delete({
     *   where: {
     *     // ... filter to delete one AuthorizationCode
     *   }
     * })
     * 
     */
    delete<T extends AuthorizationCodeDeleteArgs>(args: SelectSubset<T, AuthorizationCodeDeleteArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuthorizationCode.
     * @param {AuthorizationCodeUpdateArgs} args - Arguments to update one AuthorizationCode.
     * @example
     * // Update one AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorizationCodeUpdateArgs>(args: SelectSubset<T, AuthorizationCodeUpdateArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuthorizationCodes.
     * @param {AuthorizationCodeDeleteManyArgs} args - Arguments to filter AuthorizationCodes to delete.
     * @example
     * // Delete a few AuthorizationCodes
     * const { count } = await prisma.authorizationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorizationCodeDeleteManyArgs>(args?: SelectSubset<T, AuthorizationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthorizationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthorizationCodes
     * const authorizationCode = await prisma.authorizationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorizationCodeUpdateManyArgs>(args: SelectSubset<T, AuthorizationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthorizationCode.
     * @param {AuthorizationCodeUpsertArgs} args - Arguments to update or create a AuthorizationCode.
     * @example
     * // Update or create a AuthorizationCode
     * const authorizationCode = await prisma.authorizationCode.upsert({
     *   create: {
     *     // ... data to create a AuthorizationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthorizationCode we want to update
     *   }
     * })
     */
    upsert<T extends AuthorizationCodeUpsertArgs>(args: SelectSubset<T, AuthorizationCodeUpsertArgs<ExtArgs>>): Prisma__AuthorizationCodeClient<$Result.GetResult<Prisma.$AuthorizationCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuthorizationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeCountArgs} args - Arguments to filter AuthorizationCodes to count.
     * @example
     * // Count the number of AuthorizationCodes
     * const count = await prisma.authorizationCode.count({
     *   where: {
     *     // ... the filter for the AuthorizationCodes we want to count
     *   }
     * })
    **/
    count<T extends AuthorizationCodeCountArgs>(
      args?: Subset<T, AuthorizationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorizationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthorizationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorizationCodeAggregateArgs>(args: Subset<T, AuthorizationCodeAggregateArgs>): Prisma.PrismaPromise<GetAuthorizationCodeAggregateType<T>>

    /**
     * Group by AuthorizationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorizationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorizationCodeGroupByArgs['orderBy'] }
        : { orderBy?: AuthorizationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorizationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorizationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthorizationCode model
   */
  readonly fields: AuthorizationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthorizationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorizationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerEntries<T extends AuthorizationCode$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, AuthorizationCode$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthorizationCode model
   */ 
  interface AuthorizationCodeFieldRefs {
    readonly id: FieldRef<"AuthorizationCode", 'Int'>
    readonly code: FieldRef<"AuthorizationCode", 'String'>
    readonly purpose: FieldRef<"AuthorizationCode", 'String'>
    readonly isEnabled: FieldRef<"AuthorizationCode", 'Boolean'>
    readonly expiresAt: FieldRef<"AuthorizationCode", 'DateTime'>
    readonly maxUses: FieldRef<"AuthorizationCode", 'Int'>
    readonly usedCount: FieldRef<"AuthorizationCode", 'Int'>
    readonly createdById: FieldRef<"AuthorizationCode", 'Int'>
    readonly createdAt: FieldRef<"AuthorizationCode", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthorizationCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthorizationCode findUnique
   */
  export type AuthorizationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode findUniqueOrThrow
   */
  export type AuthorizationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode findFirst
   */
  export type AuthorizationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorizationCodes.
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorizationCodes.
     */
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * AuthorizationCode findFirstOrThrow
   */
  export type AuthorizationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCode to fetch.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthorizationCodes.
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthorizationCodes.
     */
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * AuthorizationCode findMany
   */
  export type AuthorizationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which AuthorizationCodes to fetch.
     */
    where?: AuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthorizationCodes to fetch.
     */
    orderBy?: AuthorizationCodeOrderByWithRelationInput | AuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthorizationCodes.
     */
    cursor?: AuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthorizationCodes.
     */
    skip?: number
    distinct?: AuthorizationCodeScalarFieldEnum | AuthorizationCodeScalarFieldEnum[]
  }

  /**
   * AuthorizationCode create
   */
  export type AuthorizationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthorizationCode.
     */
    data: XOR<AuthorizationCodeCreateInput, AuthorizationCodeUncheckedCreateInput>
  }

  /**
   * AuthorizationCode createMany
   */
  export type AuthorizationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthorizationCodes.
     */
    data: AuthorizationCodeCreateManyInput | AuthorizationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthorizationCode createManyAndReturn
   */
  export type AuthorizationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuthorizationCodes.
     */
    data: AuthorizationCodeCreateManyInput | AuthorizationCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthorizationCode update
   */
  export type AuthorizationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthorizationCode.
     */
    data: XOR<AuthorizationCodeUpdateInput, AuthorizationCodeUncheckedUpdateInput>
    /**
     * Choose, which AuthorizationCode to update.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode updateMany
   */
  export type AuthorizationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthorizationCodes.
     */
    data: XOR<AuthorizationCodeUpdateManyMutationInput, AuthorizationCodeUncheckedUpdateManyInput>
    /**
     * Filter which AuthorizationCodes to update
     */
    where?: AuthorizationCodeWhereInput
  }

  /**
   * AuthorizationCode upsert
   */
  export type AuthorizationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthorizationCode to update in case it exists.
     */
    where: AuthorizationCodeWhereUniqueInput
    /**
     * In case the AuthorizationCode found by the `where` argument doesn't exist, create a new AuthorizationCode with this data.
     */
    create: XOR<AuthorizationCodeCreateInput, AuthorizationCodeUncheckedCreateInput>
    /**
     * In case the AuthorizationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorizationCodeUpdateInput, AuthorizationCodeUncheckedUpdateInput>
  }

  /**
   * AuthorizationCode delete
   */
  export type AuthorizationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter which AuthorizationCode to delete.
     */
    where: AuthorizationCodeWhereUniqueInput
  }

  /**
   * AuthorizationCode deleteMany
   */
  export type AuthorizationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthorizationCodes to delete
     */
    where?: AuthorizationCodeWhereInput
  }

  /**
   * AuthorizationCode.ledgerEntries
   */
  export type AuthorizationCode$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * AuthorizationCode without action
   */
  export type AuthorizationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationCode
     */
    select?: AuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationCodeInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeVoucher
   */

  export type AggregateEmployeeVoucher = {
    _count: EmployeeVoucherCountAggregateOutputType | null
    _avg: EmployeeVoucherAvgAggregateOutputType | null
    _sum: EmployeeVoucherSumAggregateOutputType | null
    _min: EmployeeVoucherMinAggregateOutputType | null
    _max: EmployeeVoucherMaxAggregateOutputType | null
  }

  export type EmployeeVoucherAvgAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    balanceCap: number | null
    usedAmount: number | null
    createdById: number | null
  }

  export type EmployeeVoucherSumAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    balanceCap: number | null
    usedAmount: number | null
    createdById: number | null
  }

  export type EmployeeVoucherMinAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    code: string | null
    status: $Enums.EmployeeVoucherStatus | null
    balanceCap: number | null
    usedAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
  }

  export type EmployeeVoucherMaxAggregateOutputType = {
    id: number | null
    branchId: number | null
    employeeId: number | null
    code: string | null
    status: $Enums.EmployeeVoucherStatus | null
    balanceCap: number | null
    usedAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
  }

  export type EmployeeVoucherCountAggregateOutputType = {
    id: number
    branchId: number
    employeeId: number
    code: number
    status: number
    balanceCap: number
    usedAmount: number
    eligibility: number
    allowedPatientIds: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type EmployeeVoucherAvgAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    balanceCap?: true
    usedAmount?: true
    createdById?: true
  }

  export type EmployeeVoucherSumAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    balanceCap?: true
    usedAmount?: true
    createdById?: true
  }

  export type EmployeeVoucherMinAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    code?: true
    status?: true
    balanceCap?: true
    usedAmount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmployeeVoucherMaxAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    code?: true
    status?: true
    balanceCap?: true
    usedAmount?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type EmployeeVoucherCountAggregateInputType = {
    id?: true
    branchId?: true
    employeeId?: true
    code?: true
    status?: true
    balanceCap?: true
    usedAmount?: true
    eligibility?: true
    allowedPatientIds?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type EmployeeVoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeVoucher to aggregate.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeVouchers
    **/
    _count?: true | EmployeeVoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeVoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeVoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeVoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeVoucherMaxAggregateInputType
  }

  export type GetEmployeeVoucherAggregateType<T extends EmployeeVoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeVoucher[P]>
      : GetScalarType<T[P], AggregateEmployeeVoucher[P]>
  }




  export type EmployeeVoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeVoucherWhereInput
    orderBy?: EmployeeVoucherOrderByWithAggregationInput | EmployeeVoucherOrderByWithAggregationInput[]
    by: EmployeeVoucherScalarFieldEnum[] | EmployeeVoucherScalarFieldEnum
    having?: EmployeeVoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeVoucherCountAggregateInputType | true
    _avg?: EmployeeVoucherAvgAggregateInputType
    _sum?: EmployeeVoucherSumAggregateInputType
    _min?: EmployeeVoucherMinAggregateInputType
    _max?: EmployeeVoucherMaxAggregateInputType
  }

  export type EmployeeVoucherGroupByOutputType = {
    id: number
    branchId: number
    employeeId: number
    code: string
    status: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount: number
    eligibility: JsonValue
    allowedPatientIds: JsonValue
    createdAt: Date
    updatedAt: Date
    createdById: number
    _count: EmployeeVoucherCountAggregateOutputType | null
    _avg: EmployeeVoucherAvgAggregateOutputType | null
    _sum: EmployeeVoucherSumAggregateOutputType | null
    _min: EmployeeVoucherMinAggregateOutputType | null
    _max: EmployeeVoucherMaxAggregateOutputType | null
  }

  type GetEmployeeVoucherGroupByPayload<T extends EmployeeVoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeVoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeVoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeVoucherGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeVoucherGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeVoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    employeeId?: boolean
    code?: boolean
    status?: boolean
    balanceCap?: boolean
    usedAmount?: boolean
    eligibility?: boolean
    allowedPatientIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | EmployeeVoucher$ledgerEntriesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeVoucher"]>

  export type EmployeeVoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    employeeId?: boolean
    code?: boolean
    status?: boolean
    balanceCap?: boolean
    usedAmount?: boolean
    eligibility?: boolean
    allowedPatientIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeVoucher"]>

  export type EmployeeVoucherSelectScalar = {
    id?: boolean
    branchId?: boolean
    employeeId?: boolean
    code?: boolean
    status?: boolean
    balanceCap?: boolean
    usedAmount?: boolean
    eligibility?: boolean
    allowedPatientIds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type EmployeeVoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    ledgerEntries?: boolean | EmployeeVoucher$ledgerEntriesArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeVoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeeVoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeVoucher"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      employee: Prisma.$UserPayload<ExtArgs>
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      branchId: number
      employeeId: number
      code: string
      status: $Enums.EmployeeVoucherStatus
      balanceCap: number
      usedAmount: number
      eligibility: Prisma.JsonValue
      allowedPatientIds: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      createdById: number
    }, ExtArgs["result"]["employeeVoucher"]>
    composites: {}
  }

  type EmployeeVoucherGetPayload<S extends boolean | null | undefined | EmployeeVoucherDefaultArgs> = $Result.GetResult<Prisma.$EmployeeVoucherPayload, S>

  type EmployeeVoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeVoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeVoucherCountAggregateInputType | true
    }

  export interface EmployeeVoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeVoucher'], meta: { name: 'EmployeeVoucher' } }
    /**
     * Find zero or one EmployeeVoucher that matches the filter.
     * @param {EmployeeVoucherFindUniqueArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeVoucherFindUniqueArgs>(args: SelectSubset<T, EmployeeVoucherFindUniqueArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeVoucher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeVoucherFindUniqueOrThrowArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeVoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeVoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeVoucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherFindFirstArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeVoucherFindFirstArgs>(args?: SelectSubset<T, EmployeeVoucherFindFirstArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeVoucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherFindFirstOrThrowArgs} args - Arguments to find a EmployeeVoucher
     * @example
     * // Get one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeVoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeVoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeVouchers
     * const employeeVouchers = await prisma.employeeVoucher.findMany()
     * 
     * // Get first 10 EmployeeVouchers
     * const employeeVouchers = await prisma.employeeVoucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeVoucherWithIdOnly = await prisma.employeeVoucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeVoucherFindManyArgs>(args?: SelectSubset<T, EmployeeVoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeVoucher.
     * @param {EmployeeVoucherCreateArgs} args - Arguments to create a EmployeeVoucher.
     * @example
     * // Create one EmployeeVoucher
     * const EmployeeVoucher = await prisma.employeeVoucher.create({
     *   data: {
     *     // ... data to create a EmployeeVoucher
     *   }
     * })
     * 
     */
    create<T extends EmployeeVoucherCreateArgs>(args: SelectSubset<T, EmployeeVoucherCreateArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeVouchers.
     * @param {EmployeeVoucherCreateManyArgs} args - Arguments to create many EmployeeVouchers.
     * @example
     * // Create many EmployeeVouchers
     * const employeeVoucher = await prisma.employeeVoucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeVoucherCreateManyArgs>(args?: SelectSubset<T, EmployeeVoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeVouchers and returns the data saved in the database.
     * @param {EmployeeVoucherCreateManyAndReturnArgs} args - Arguments to create many EmployeeVouchers.
     * @example
     * // Create many EmployeeVouchers
     * const employeeVoucher = await prisma.employeeVoucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeVouchers and only return the `id`
     * const employeeVoucherWithIdOnly = await prisma.employeeVoucher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeVoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeVoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeVoucher.
     * @param {EmployeeVoucherDeleteArgs} args - Arguments to delete one EmployeeVoucher.
     * @example
     * // Delete one EmployeeVoucher
     * const EmployeeVoucher = await prisma.employeeVoucher.delete({
     *   where: {
     *     // ... filter to delete one EmployeeVoucher
     *   }
     * })
     * 
     */
    delete<T extends EmployeeVoucherDeleteArgs>(args: SelectSubset<T, EmployeeVoucherDeleteArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeVoucher.
     * @param {EmployeeVoucherUpdateArgs} args - Arguments to update one EmployeeVoucher.
     * @example
     * // Update one EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeVoucherUpdateArgs>(args: SelectSubset<T, EmployeeVoucherUpdateArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeVouchers.
     * @param {EmployeeVoucherDeleteManyArgs} args - Arguments to filter EmployeeVouchers to delete.
     * @example
     * // Delete a few EmployeeVouchers
     * const { count } = await prisma.employeeVoucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeVoucherDeleteManyArgs>(args?: SelectSubset<T, EmployeeVoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeVouchers
     * const employeeVoucher = await prisma.employeeVoucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeVoucherUpdateManyArgs>(args: SelectSubset<T, EmployeeVoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeVoucher.
     * @param {EmployeeVoucherUpsertArgs} args - Arguments to update or create a EmployeeVoucher.
     * @example
     * // Update or create a EmployeeVoucher
     * const employeeVoucher = await prisma.employeeVoucher.upsert({
     *   create: {
     *     // ... data to create a EmployeeVoucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeVoucher we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeVoucherUpsertArgs>(args: SelectSubset<T, EmployeeVoucherUpsertArgs<ExtArgs>>): Prisma__EmployeeVoucherClient<$Result.GetResult<Prisma.$EmployeeVoucherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherCountArgs} args - Arguments to filter EmployeeVouchers to count.
     * @example
     * // Count the number of EmployeeVouchers
     * const count = await prisma.employeeVoucher.count({
     *   where: {
     *     // ... the filter for the EmployeeVouchers we want to count
     *   }
     * })
    **/
    count<T extends EmployeeVoucherCountArgs>(
      args?: Subset<T, EmployeeVoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeVoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeVoucherAggregateArgs>(args: Subset<T, EmployeeVoucherAggregateArgs>): Prisma.PrismaPromise<GetEmployeeVoucherAggregateType<T>>

    /**
     * Group by EmployeeVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeVoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeVoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeVoucherGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeVoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeVoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeVoucher model
   */
  readonly fields: EmployeeVoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeVoucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeVoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ledgerEntries<T extends EmployeeVoucher$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeVoucher$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany"> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeVoucher model
   */ 
  interface EmployeeVoucherFieldRefs {
    readonly id: FieldRef<"EmployeeVoucher", 'Int'>
    readonly branchId: FieldRef<"EmployeeVoucher", 'Int'>
    readonly employeeId: FieldRef<"EmployeeVoucher", 'Int'>
    readonly code: FieldRef<"EmployeeVoucher", 'String'>
    readonly status: FieldRef<"EmployeeVoucher", 'EmployeeVoucherStatus'>
    readonly balanceCap: FieldRef<"EmployeeVoucher", 'Float'>
    readonly usedAmount: FieldRef<"EmployeeVoucher", 'Float'>
    readonly eligibility: FieldRef<"EmployeeVoucher", 'Json'>
    readonly allowedPatientIds: FieldRef<"EmployeeVoucher", 'Json'>
    readonly createdAt: FieldRef<"EmployeeVoucher", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeVoucher", 'DateTime'>
    readonly createdById: FieldRef<"EmployeeVoucher", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeVoucher findUnique
   */
  export type EmployeeVoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher findUniqueOrThrow
   */
  export type EmployeeVoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher findFirst
   */
  export type EmployeeVoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeVouchers.
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeVouchers.
     */
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher findFirstOrThrow
   */
  export type EmployeeVoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVoucher to fetch.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeVouchers.
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeVouchers.
     */
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher findMany
   */
  export type EmployeeVoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeVouchers to fetch.
     */
    where?: EmployeeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeVouchers to fetch.
     */
    orderBy?: EmployeeVoucherOrderByWithRelationInput | EmployeeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeVouchers.
     */
    cursor?: EmployeeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeVouchers.
     */
    skip?: number
    distinct?: EmployeeVoucherScalarFieldEnum | EmployeeVoucherScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher create
   */
  export type EmployeeVoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeVoucher.
     */
    data: XOR<EmployeeVoucherCreateInput, EmployeeVoucherUncheckedCreateInput>
  }

  /**
   * EmployeeVoucher createMany
   */
  export type EmployeeVoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeVouchers.
     */
    data: EmployeeVoucherCreateManyInput | EmployeeVoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeVoucher createManyAndReturn
   */
  export type EmployeeVoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeVouchers.
     */
    data: EmployeeVoucherCreateManyInput | EmployeeVoucherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeVoucher update
   */
  export type EmployeeVoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeVoucher.
     */
    data: XOR<EmployeeVoucherUpdateInput, EmployeeVoucherUncheckedUpdateInput>
    /**
     * Choose, which EmployeeVoucher to update.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher updateMany
   */
  export type EmployeeVoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeVouchers.
     */
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeVouchers to update
     */
    where?: EmployeeVoucherWhereInput
  }

  /**
   * EmployeeVoucher upsert
   */
  export type EmployeeVoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeVoucher to update in case it exists.
     */
    where: EmployeeVoucherWhereUniqueInput
    /**
     * In case the EmployeeVoucher found by the `where` argument doesn't exist, create a new EmployeeVoucher with this data.
     */
    create: XOR<EmployeeVoucherCreateInput, EmployeeVoucherUncheckedCreateInput>
    /**
     * In case the EmployeeVoucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeVoucherUpdateInput, EmployeeVoucherUncheckedUpdateInput>
  }

  /**
   * EmployeeVoucher delete
   */
  export type EmployeeVoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
    /**
     * Filter which EmployeeVoucher to delete.
     */
    where: EmployeeVoucherWhereUniqueInput
  }

  /**
   * EmployeeVoucher deleteMany
   */
  export type EmployeeVoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeVouchers to delete
     */
    where?: EmployeeVoucherWhereInput
  }

  /**
   * EmployeeVoucher.ledgerEntries
   */
  export type EmployeeVoucher$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * EmployeeVoucher without action
   */
  export type EmployeeVoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeVoucher
     */
    select?: EmployeeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeVoucherInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    encounterId: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    encounterId: number | null
    filePath: string | null
    toothCode: string | null
    type: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    encounterId: number | null
    filePath: string | null
    toothCode: string | null
    type: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    encounterId: number
    filePath: number
    toothCode: number
    type: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    encounterId?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    encounterId?: true
    filePath?: true
    toothCode?: true
    type?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    encounterId?: true
    filePath?: true
    toothCode?: true
    type?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    encounterId?: true
    filePath?: true
    toothCode?: true
    type?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: number
    encounterId: number
    filePath: string
    toothCode: string | null
    type: string
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    filePath?: boolean
    toothCode?: boolean
    type?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounterId?: boolean
    filePath?: boolean
    toothCode?: boolean
    type?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    encounterId?: boolean
    filePath?: boolean
    toothCode?: boolean
    type?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounterId: number
      filePath: string
      toothCode: string | null
      type: string
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'Int'>
    readonly encounterId: FieldRef<"Media", 'Int'>
    readonly filePath: FieldRef<"Media", 'String'>
    readonly toothCode: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model DoctorSchedule
   */

  export type AggregateDoctorSchedule = {
    _count: DoctorScheduleCountAggregateOutputType | null
    _avg: DoctorScheduleAvgAggregateOutputType | null
    _sum: DoctorScheduleSumAggregateOutputType | null
    _min: DoctorScheduleMinAggregateOutputType | null
    _max: DoctorScheduleMaxAggregateOutputType | null
  }

  export type DoctorScheduleAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorScheduleSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorScheduleMinAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type DoctorScheduleMaxAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type DoctorScheduleCountAggregateOutputType = {
    id: number
    doctorId: number
    branchId: number
    date: number
    startTime: number
    endTime: number
    note: number
    _all: number
  }


  export type DoctorScheduleAvgAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorScheduleSumAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorScheduleMinAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type DoctorScheduleMaxAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type DoctorScheduleCountAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
    _all?: true
  }

  export type DoctorScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSchedule to aggregate.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorSchedules
    **/
    _count?: true | DoctorScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorScheduleMaxAggregateInputType
  }

  export type GetDoctorScheduleAggregateType<T extends DoctorScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorSchedule[P]>
      : GetScalarType<T[P], AggregateDoctorSchedule[P]>
  }




  export type DoctorScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorScheduleWhereInput
    orderBy?: DoctorScheduleOrderByWithAggregationInput | DoctorScheduleOrderByWithAggregationInput[]
    by: DoctorScheduleScalarFieldEnum[] | DoctorScheduleScalarFieldEnum
    having?: DoctorScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorScheduleCountAggregateInputType | true
    _avg?: DoctorScheduleAvgAggregateInputType
    _sum?: DoctorScheduleSumAggregateInputType
    _min?: DoctorScheduleMinAggregateInputType
    _max?: DoctorScheduleMaxAggregateInputType
  }

  export type DoctorScheduleGroupByOutputType = {
    id: number
    doctorId: number
    branchId: number
    date: Date
    startTime: string
    endTime: string
    note: string | null
    _count: DoctorScheduleCountAggregateOutputType | null
    _avg: DoctorScheduleAvgAggregateOutputType | null
    _sum: DoctorScheduleSumAggregateOutputType | null
    _min: DoctorScheduleMinAggregateOutputType | null
    _max: DoctorScheduleMaxAggregateOutputType | null
  }

  type GetDoctorScheduleGroupByPayload<T extends DoctorScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorScheduleGroupByOutputType[P]>
        }
      >
    >


  export type DoctorScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorSchedule"]>

  export type DoctorScheduleSelectScalar = {
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
  }

  export type DoctorScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type DoctorScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $DoctorSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorSchedule"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctorId: number
      branchId: number
      date: Date
      startTime: string
      endTime: string
      note: string | null
    }, ExtArgs["result"]["doctorSchedule"]>
    composites: {}
  }

  type DoctorScheduleGetPayload<S extends boolean | null | undefined | DoctorScheduleDefaultArgs> = $Result.GetResult<Prisma.$DoctorSchedulePayload, S>

  type DoctorScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorScheduleCountAggregateInputType | true
    }

  export interface DoctorScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorSchedule'], meta: { name: 'DoctorSchedule' } }
    /**
     * Find zero or one DoctorSchedule that matches the filter.
     * @param {DoctorScheduleFindUniqueArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorScheduleFindUniqueArgs>(args: SelectSubset<T, DoctorScheduleFindUniqueArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoctorSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorScheduleFindUniqueOrThrowArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoctorSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindFirstArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorScheduleFindFirstArgs>(args?: SelectSubset<T, DoctorScheduleFindFirstArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoctorSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindFirstOrThrowArgs} args - Arguments to find a DoctorSchedule
     * @example
     * // Get one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoctorSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorSchedules
     * const doctorSchedules = await prisma.doctorSchedule.findMany()
     * 
     * // Get first 10 DoctorSchedules
     * const doctorSchedules = await prisma.doctorSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorScheduleFindManyArgs>(args?: SelectSubset<T, DoctorScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoctorSchedule.
     * @param {DoctorScheduleCreateArgs} args - Arguments to create a DoctorSchedule.
     * @example
     * // Create one DoctorSchedule
     * const DoctorSchedule = await prisma.doctorSchedule.create({
     *   data: {
     *     // ... data to create a DoctorSchedule
     *   }
     * })
     * 
     */
    create<T extends DoctorScheduleCreateArgs>(args: SelectSubset<T, DoctorScheduleCreateArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoctorSchedules.
     * @param {DoctorScheduleCreateManyArgs} args - Arguments to create many DoctorSchedules.
     * @example
     * // Create many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorScheduleCreateManyArgs>(args?: SelectSubset<T, DoctorScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorSchedules and returns the data saved in the database.
     * @param {DoctorScheduleCreateManyAndReturnArgs} args - Arguments to create many DoctorSchedules.
     * @example
     * // Create many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorSchedules and only return the `id`
     * const doctorScheduleWithIdOnly = await prisma.doctorSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoctorSchedule.
     * @param {DoctorScheduleDeleteArgs} args - Arguments to delete one DoctorSchedule.
     * @example
     * // Delete one DoctorSchedule
     * const DoctorSchedule = await prisma.doctorSchedule.delete({
     *   where: {
     *     // ... filter to delete one DoctorSchedule
     *   }
     * })
     * 
     */
    delete<T extends DoctorScheduleDeleteArgs>(args: SelectSubset<T, DoctorScheduleDeleteArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoctorSchedule.
     * @param {DoctorScheduleUpdateArgs} args - Arguments to update one DoctorSchedule.
     * @example
     * // Update one DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorScheduleUpdateArgs>(args: SelectSubset<T, DoctorScheduleUpdateArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoctorSchedules.
     * @param {DoctorScheduleDeleteManyArgs} args - Arguments to filter DoctorSchedules to delete.
     * @example
     * // Delete a few DoctorSchedules
     * const { count } = await prisma.doctorSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorScheduleDeleteManyArgs>(args?: SelectSubset<T, DoctorScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorSchedules
     * const doctorSchedule = await prisma.doctorSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorScheduleUpdateManyArgs>(args: SelectSubset<T, DoctorScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorSchedule.
     * @param {DoctorScheduleUpsertArgs} args - Arguments to update or create a DoctorSchedule.
     * @example
     * // Update or create a DoctorSchedule
     * const doctorSchedule = await prisma.doctorSchedule.upsert({
     *   create: {
     *     // ... data to create a DoctorSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorSchedule we want to update
     *   }
     * })
     */
    upsert<T extends DoctorScheduleUpsertArgs>(args: SelectSubset<T, DoctorScheduleUpsertArgs<ExtArgs>>): Prisma__DoctorScheduleClient<$Result.GetResult<Prisma.$DoctorSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoctorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleCountArgs} args - Arguments to filter DoctorSchedules to count.
     * @example
     * // Count the number of DoctorSchedules
     * const count = await prisma.doctorSchedule.count({
     *   where: {
     *     // ... the filter for the DoctorSchedules we want to count
     *   }
     * })
    **/
    count<T extends DoctorScheduleCountArgs>(
      args?: Subset<T, DoctorScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorScheduleAggregateArgs>(args: Subset<T, DoctorScheduleAggregateArgs>): Prisma.PrismaPromise<GetDoctorScheduleAggregateType<T>>

    /**
     * Group by DoctorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorScheduleGroupByArgs['orderBy'] }
        : { orderBy?: DoctorScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorSchedule model
   */
  readonly fields: DoctorScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorSchedule model
   */ 
  interface DoctorScheduleFieldRefs {
    readonly id: FieldRef<"DoctorSchedule", 'Int'>
    readonly doctorId: FieldRef<"DoctorSchedule", 'Int'>
    readonly branchId: FieldRef<"DoctorSchedule", 'Int'>
    readonly date: FieldRef<"DoctorSchedule", 'DateTime'>
    readonly startTime: FieldRef<"DoctorSchedule", 'String'>
    readonly endTime: FieldRef<"DoctorSchedule", 'String'>
    readonly note: FieldRef<"DoctorSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DoctorSchedule findUnique
   */
  export type DoctorScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule findUniqueOrThrow
   */
  export type DoctorScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule findFirst
   */
  export type DoctorScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorSchedules.
     */
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule findFirstOrThrow
   */
  export type DoctorScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedule to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorSchedules.
     */
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule findMany
   */
  export type DoctorScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which DoctorSchedules to fetch.
     */
    where?: DoctorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorSchedules to fetch.
     */
    orderBy?: DoctorScheduleOrderByWithRelationInput | DoctorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorSchedules.
     */
    cursor?: DoctorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorSchedules.
     */
    skip?: number
    distinct?: DoctorScheduleScalarFieldEnum | DoctorScheduleScalarFieldEnum[]
  }

  /**
   * DoctorSchedule create
   */
  export type DoctorScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorSchedule.
     */
    data: XOR<DoctorScheduleCreateInput, DoctorScheduleUncheckedCreateInput>
  }

  /**
   * DoctorSchedule createMany
   */
  export type DoctorScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorSchedules.
     */
    data: DoctorScheduleCreateManyInput | DoctorScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorSchedule createManyAndReturn
   */
  export type DoctorScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoctorSchedules.
     */
    data: DoctorScheduleCreateManyInput | DoctorScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorSchedule update
   */
  export type DoctorScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorSchedule.
     */
    data: XOR<DoctorScheduleUpdateInput, DoctorScheduleUncheckedUpdateInput>
    /**
     * Choose, which DoctorSchedule to update.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule updateMany
   */
  export type DoctorScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorSchedules.
     */
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyInput>
    /**
     * Filter which DoctorSchedules to update
     */
    where?: DoctorScheduleWhereInput
  }

  /**
   * DoctorSchedule upsert
   */
  export type DoctorScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorSchedule to update in case it exists.
     */
    where: DoctorScheduleWhereUniqueInput
    /**
     * In case the DoctorSchedule found by the `where` argument doesn't exist, create a new DoctorSchedule with this data.
     */
    create: XOR<DoctorScheduleCreateInput, DoctorScheduleUncheckedCreateInput>
    /**
     * In case the DoctorSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorScheduleUpdateInput, DoctorScheduleUncheckedUpdateInput>
  }

  /**
   * DoctorSchedule delete
   */
  export type DoctorScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
    /**
     * Filter which DoctorSchedule to delete.
     */
    where: DoctorScheduleWhereUniqueInput
  }

  /**
   * DoctorSchedule deleteMany
   */
  export type DoctorScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorSchedules to delete
     */
    where?: DoctorScheduleWhereInput
  }

  /**
   * DoctorSchedule without action
   */
  export type DoctorScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorSchedule
     */
    select?: DoctorScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ReceptionSchedule
   */

  export type AggregateReceptionSchedule = {
    _count: ReceptionScheduleCountAggregateOutputType | null
    _avg: ReceptionScheduleAvgAggregateOutputType | null
    _sum: ReceptionScheduleSumAggregateOutputType | null
    _min: ReceptionScheduleMinAggregateOutputType | null
    _max: ReceptionScheduleMaxAggregateOutputType | null
  }

  export type ReceptionScheduleAvgAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionScheduleSumAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionScheduleMinAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type ReceptionScheduleMaxAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type ReceptionScheduleCountAggregateOutputType = {
    id: number
    receptionId: number
    branchId: number
    date: number
    startTime: number
    endTime: number
    note: number
    _all: number
  }


  export type ReceptionScheduleAvgAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionScheduleSumAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionScheduleMinAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type ReceptionScheduleMaxAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type ReceptionScheduleCountAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
    _all?: true
  }

  export type ReceptionScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionSchedule to aggregate.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceptionSchedules
    **/
    _count?: true | ReceptionScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceptionScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceptionScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceptionScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceptionScheduleMaxAggregateInputType
  }

  export type GetReceptionScheduleAggregateType<T extends ReceptionScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateReceptionSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceptionSchedule[P]>
      : GetScalarType<T[P], AggregateReceptionSchedule[P]>
  }




  export type ReceptionScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionScheduleWhereInput
    orderBy?: ReceptionScheduleOrderByWithAggregationInput | ReceptionScheduleOrderByWithAggregationInput[]
    by: ReceptionScheduleScalarFieldEnum[] | ReceptionScheduleScalarFieldEnum
    having?: ReceptionScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceptionScheduleCountAggregateInputType | true
    _avg?: ReceptionScheduleAvgAggregateInputType
    _sum?: ReceptionScheduleSumAggregateInputType
    _min?: ReceptionScheduleMinAggregateInputType
    _max?: ReceptionScheduleMaxAggregateInputType
  }

  export type ReceptionScheduleGroupByOutputType = {
    id: number
    receptionId: number
    branchId: number
    date: Date
    startTime: string
    endTime: string
    note: string | null
    _count: ReceptionScheduleCountAggregateOutputType | null
    _avg: ReceptionScheduleAvgAggregateOutputType | null
    _sum: ReceptionScheduleSumAggregateOutputType | null
    _min: ReceptionScheduleMinAggregateOutputType | null
    _max: ReceptionScheduleMaxAggregateOutputType | null
  }

  type GetReceptionScheduleGroupByPayload<T extends ReceptionScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceptionScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceptionScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceptionScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ReceptionScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ReceptionScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionSchedule"]>

  export type ReceptionScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionSchedule"]>

  export type ReceptionScheduleSelectScalar = {
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
  }

  export type ReceptionScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ReceptionScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ReceptionSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceptionSchedule"
    objects: {
      reception: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receptionId: number
      branchId: number
      date: Date
      startTime: string
      endTime: string
      note: string | null
    }, ExtArgs["result"]["receptionSchedule"]>
    composites: {}
  }

  type ReceptionScheduleGetPayload<S extends boolean | null | undefined | ReceptionScheduleDefaultArgs> = $Result.GetResult<Prisma.$ReceptionSchedulePayload, S>

  type ReceptionScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceptionScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceptionScheduleCountAggregateInputType | true
    }

  export interface ReceptionScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceptionSchedule'], meta: { name: 'ReceptionSchedule' } }
    /**
     * Find zero or one ReceptionSchedule that matches the filter.
     * @param {ReceptionScheduleFindUniqueArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceptionScheduleFindUniqueArgs>(args: SelectSubset<T, ReceptionScheduleFindUniqueArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReceptionSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceptionScheduleFindUniqueOrThrowArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceptionScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceptionScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReceptionSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleFindFirstArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceptionScheduleFindFirstArgs>(args?: SelectSubset<T, ReceptionScheduleFindFirstArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReceptionSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleFindFirstOrThrowArgs} args - Arguments to find a ReceptionSchedule
     * @example
     * // Get one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceptionScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceptionScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReceptionSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceptionSchedules
     * const receptionSchedules = await prisma.receptionSchedule.findMany()
     * 
     * // Get first 10 ReceptionSchedules
     * const receptionSchedules = await prisma.receptionSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receptionScheduleWithIdOnly = await prisma.receptionSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceptionScheduleFindManyArgs>(args?: SelectSubset<T, ReceptionScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReceptionSchedule.
     * @param {ReceptionScheduleCreateArgs} args - Arguments to create a ReceptionSchedule.
     * @example
     * // Create one ReceptionSchedule
     * const ReceptionSchedule = await prisma.receptionSchedule.create({
     *   data: {
     *     // ... data to create a ReceptionSchedule
     *   }
     * })
     * 
     */
    create<T extends ReceptionScheduleCreateArgs>(args: SelectSubset<T, ReceptionScheduleCreateArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReceptionSchedules.
     * @param {ReceptionScheduleCreateManyArgs} args - Arguments to create many ReceptionSchedules.
     * @example
     * // Create many ReceptionSchedules
     * const receptionSchedule = await prisma.receptionSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceptionScheduleCreateManyArgs>(args?: SelectSubset<T, ReceptionScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceptionSchedules and returns the data saved in the database.
     * @param {ReceptionScheduleCreateManyAndReturnArgs} args - Arguments to create many ReceptionSchedules.
     * @example
     * // Create many ReceptionSchedules
     * const receptionSchedule = await prisma.receptionSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceptionSchedules and only return the `id`
     * const receptionScheduleWithIdOnly = await prisma.receptionSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceptionScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceptionScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReceptionSchedule.
     * @param {ReceptionScheduleDeleteArgs} args - Arguments to delete one ReceptionSchedule.
     * @example
     * // Delete one ReceptionSchedule
     * const ReceptionSchedule = await prisma.receptionSchedule.delete({
     *   where: {
     *     // ... filter to delete one ReceptionSchedule
     *   }
     * })
     * 
     */
    delete<T extends ReceptionScheduleDeleteArgs>(args: SelectSubset<T, ReceptionScheduleDeleteArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReceptionSchedule.
     * @param {ReceptionScheduleUpdateArgs} args - Arguments to update one ReceptionSchedule.
     * @example
     * // Update one ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceptionScheduleUpdateArgs>(args: SelectSubset<T, ReceptionScheduleUpdateArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReceptionSchedules.
     * @param {ReceptionScheduleDeleteManyArgs} args - Arguments to filter ReceptionSchedules to delete.
     * @example
     * // Delete a few ReceptionSchedules
     * const { count } = await prisma.receptionSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceptionScheduleDeleteManyArgs>(args?: SelectSubset<T, ReceptionScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceptionSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceptionSchedules
     * const receptionSchedule = await prisma.receptionSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceptionScheduleUpdateManyArgs>(args: SelectSubset<T, ReceptionScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceptionSchedule.
     * @param {ReceptionScheduleUpsertArgs} args - Arguments to update or create a ReceptionSchedule.
     * @example
     * // Update or create a ReceptionSchedule
     * const receptionSchedule = await prisma.receptionSchedule.upsert({
     *   create: {
     *     // ... data to create a ReceptionSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceptionSchedule we want to update
     *   }
     * })
     */
    upsert<T extends ReceptionScheduleUpsertArgs>(args: SelectSubset<T, ReceptionScheduleUpsertArgs<ExtArgs>>): Prisma__ReceptionScheduleClient<$Result.GetResult<Prisma.$ReceptionSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReceptionSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleCountArgs} args - Arguments to filter ReceptionSchedules to count.
     * @example
     * // Count the number of ReceptionSchedules
     * const count = await prisma.receptionSchedule.count({
     *   where: {
     *     // ... the filter for the ReceptionSchedules we want to count
     *   }
     * })
    **/
    count<T extends ReceptionScheduleCountArgs>(
      args?: Subset<T, ReceptionScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceptionScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceptionSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceptionScheduleAggregateArgs>(args: Subset<T, ReceptionScheduleAggregateArgs>): Prisma.PrismaPromise<GetReceptionScheduleAggregateType<T>>

    /**
     * Group by ReceptionSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceptionScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceptionScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ReceptionScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceptionScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceptionScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceptionSchedule model
   */
  readonly fields: ReceptionScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceptionSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceptionScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reception<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceptionSchedule model
   */ 
  interface ReceptionScheduleFieldRefs {
    readonly id: FieldRef<"ReceptionSchedule", 'Int'>
    readonly receptionId: FieldRef<"ReceptionSchedule", 'Int'>
    readonly branchId: FieldRef<"ReceptionSchedule", 'Int'>
    readonly date: FieldRef<"ReceptionSchedule", 'DateTime'>
    readonly startTime: FieldRef<"ReceptionSchedule", 'String'>
    readonly endTime: FieldRef<"ReceptionSchedule", 'String'>
    readonly note: FieldRef<"ReceptionSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReceptionSchedule findUnique
   */
  export type ReceptionScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule findUniqueOrThrow
   */
  export type ReceptionScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule findFirst
   */
  export type ReceptionScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionSchedules.
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionSchedules.
     */
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * ReceptionSchedule findFirstOrThrow
   */
  export type ReceptionScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedule to fetch.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionSchedules.
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionSchedules.
     */
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * ReceptionSchedule findMany
   */
  export type ReceptionScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionSchedules to fetch.
     */
    where?: ReceptionScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionSchedules to fetch.
     */
    orderBy?: ReceptionScheduleOrderByWithRelationInput | ReceptionScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceptionSchedules.
     */
    cursor?: ReceptionScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionSchedules.
     */
    skip?: number
    distinct?: ReceptionScheduleScalarFieldEnum | ReceptionScheduleScalarFieldEnum[]
  }

  /**
   * ReceptionSchedule create
   */
  export type ReceptionScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceptionSchedule.
     */
    data: XOR<ReceptionScheduleCreateInput, ReceptionScheduleUncheckedCreateInput>
  }

  /**
   * ReceptionSchedule createMany
   */
  export type ReceptionScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceptionSchedules.
     */
    data: ReceptionScheduleCreateManyInput | ReceptionScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceptionSchedule createManyAndReturn
   */
  export type ReceptionScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReceptionSchedules.
     */
    data: ReceptionScheduleCreateManyInput | ReceptionScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceptionSchedule update
   */
  export type ReceptionScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceptionSchedule.
     */
    data: XOR<ReceptionScheduleUpdateInput, ReceptionScheduleUncheckedUpdateInput>
    /**
     * Choose, which ReceptionSchedule to update.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule updateMany
   */
  export type ReceptionScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceptionSchedules.
     */
    data: XOR<ReceptionScheduleUpdateManyMutationInput, ReceptionScheduleUncheckedUpdateManyInput>
    /**
     * Filter which ReceptionSchedules to update
     */
    where?: ReceptionScheduleWhereInput
  }

  /**
   * ReceptionSchedule upsert
   */
  export type ReceptionScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceptionSchedule to update in case it exists.
     */
    where: ReceptionScheduleWhereUniqueInput
    /**
     * In case the ReceptionSchedule found by the `where` argument doesn't exist, create a new ReceptionSchedule with this data.
     */
    create: XOR<ReceptionScheduleCreateInput, ReceptionScheduleUncheckedCreateInput>
    /**
     * In case the ReceptionSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceptionScheduleUpdateInput, ReceptionScheduleUncheckedUpdateInput>
  }

  /**
   * ReceptionSchedule delete
   */
  export type ReceptionScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
    /**
     * Filter which ReceptionSchedule to delete.
     */
    where: ReceptionScheduleWhereUniqueInput
  }

  /**
   * ReceptionSchedule deleteMany
   */
  export type ReceptionScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionSchedules to delete
     */
    where?: ReceptionScheduleWhereInput
  }

  /**
   * ReceptionSchedule without action
   */
  export type ReceptionScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionSchedule
     */
    select?: ReceptionScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionScheduleInclude<ExtArgs> | null
  }


  /**
   * Model DoctorBranch
   */

  export type AggregateDoctorBranch = {
    _count: DoctorBranchCountAggregateOutputType | null
    _avg: DoctorBranchAvgAggregateOutputType | null
    _sum: DoctorBranchSumAggregateOutputType | null
    _min: DoctorBranchMinAggregateOutputType | null
    _max: DoctorBranchMaxAggregateOutputType | null
  }

  export type DoctorBranchAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchMinAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchMaxAggregateOutputType = {
    id: number | null
    doctorId: number | null
    branchId: number | null
  }

  export type DoctorBranchCountAggregateOutputType = {
    id: number
    doctorId: number
    branchId: number
    _all: number
  }


  export type DoctorBranchAvgAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchSumAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchMinAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchMaxAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
  }

  export type DoctorBranchCountAggregateInputType = {
    id?: true
    doctorId?: true
    branchId?: true
    _all?: true
  }

  export type DoctorBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorBranch to aggregate.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorBranches
    **/
    _count?: true | DoctorBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorBranchMaxAggregateInputType
  }

  export type GetDoctorBranchAggregateType<T extends DoctorBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorBranch[P]>
      : GetScalarType<T[P], AggregateDoctorBranch[P]>
  }




  export type DoctorBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorBranchWhereInput
    orderBy?: DoctorBranchOrderByWithAggregationInput | DoctorBranchOrderByWithAggregationInput[]
    by: DoctorBranchScalarFieldEnum[] | DoctorBranchScalarFieldEnum
    having?: DoctorBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorBranchCountAggregateInputType | true
    _avg?: DoctorBranchAvgAggregateInputType
    _sum?: DoctorBranchSumAggregateInputType
    _min?: DoctorBranchMinAggregateInputType
    _max?: DoctorBranchMaxAggregateInputType
  }

  export type DoctorBranchGroupByOutputType = {
    id: number
    doctorId: number
    branchId: number
    _count: DoctorBranchCountAggregateOutputType | null
    _avg: DoctorBranchAvgAggregateOutputType | null
    _sum: DoctorBranchSumAggregateOutputType | null
    _min: DoctorBranchMinAggregateOutputType | null
    _max: DoctorBranchMaxAggregateOutputType | null
  }

  type GetDoctorBranchGroupByPayload<T extends DoctorBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorBranchGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorBranchGroupByOutputType[P]>
        }
      >
    >


  export type DoctorBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorBranch"]>

  export type DoctorBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctorBranch"]>

  export type DoctorBranchSelectScalar = {
    id?: boolean
    doctorId?: boolean
    branchId?: boolean
  }

  export type DoctorBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type DoctorBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $DoctorBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorBranch"
    objects: {
      doctor: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doctorId: number
      branchId: number
    }, ExtArgs["result"]["doctorBranch"]>
    composites: {}
  }

  type DoctorBranchGetPayload<S extends boolean | null | undefined | DoctorBranchDefaultArgs> = $Result.GetResult<Prisma.$DoctorBranchPayload, S>

  type DoctorBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorBranchCountAggregateInputType | true
    }

  export interface DoctorBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorBranch'], meta: { name: 'DoctorBranch' } }
    /**
     * Find zero or one DoctorBranch that matches the filter.
     * @param {DoctorBranchFindUniqueArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorBranchFindUniqueArgs>(args: SelectSubset<T, DoctorBranchFindUniqueArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoctorBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorBranchFindUniqueOrThrowArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoctorBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchFindFirstArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorBranchFindFirstArgs>(args?: SelectSubset<T, DoctorBranchFindFirstArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoctorBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchFindFirstOrThrowArgs} args - Arguments to find a DoctorBranch
     * @example
     * // Get one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoctorBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorBranches
     * const doctorBranches = await prisma.doctorBranch.findMany()
     * 
     * // Get first 10 DoctorBranches
     * const doctorBranches = await prisma.doctorBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorBranchWithIdOnly = await prisma.doctorBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorBranchFindManyArgs>(args?: SelectSubset<T, DoctorBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoctorBranch.
     * @param {DoctorBranchCreateArgs} args - Arguments to create a DoctorBranch.
     * @example
     * // Create one DoctorBranch
     * const DoctorBranch = await prisma.doctorBranch.create({
     *   data: {
     *     // ... data to create a DoctorBranch
     *   }
     * })
     * 
     */
    create<T extends DoctorBranchCreateArgs>(args: SelectSubset<T, DoctorBranchCreateArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoctorBranches.
     * @param {DoctorBranchCreateManyArgs} args - Arguments to create many DoctorBranches.
     * @example
     * // Create many DoctorBranches
     * const doctorBranch = await prisma.doctorBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorBranchCreateManyArgs>(args?: SelectSubset<T, DoctorBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorBranches and returns the data saved in the database.
     * @param {DoctorBranchCreateManyAndReturnArgs} args - Arguments to create many DoctorBranches.
     * @example
     * // Create many DoctorBranches
     * const doctorBranch = await prisma.doctorBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorBranches and only return the `id`
     * const doctorBranchWithIdOnly = await prisma.doctorBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoctorBranch.
     * @param {DoctorBranchDeleteArgs} args - Arguments to delete one DoctorBranch.
     * @example
     * // Delete one DoctorBranch
     * const DoctorBranch = await prisma.doctorBranch.delete({
     *   where: {
     *     // ... filter to delete one DoctorBranch
     *   }
     * })
     * 
     */
    delete<T extends DoctorBranchDeleteArgs>(args: SelectSubset<T, DoctorBranchDeleteArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoctorBranch.
     * @param {DoctorBranchUpdateArgs} args - Arguments to update one DoctorBranch.
     * @example
     * // Update one DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorBranchUpdateArgs>(args: SelectSubset<T, DoctorBranchUpdateArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoctorBranches.
     * @param {DoctorBranchDeleteManyArgs} args - Arguments to filter DoctorBranches to delete.
     * @example
     * // Delete a few DoctorBranches
     * const { count } = await prisma.doctorBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorBranchDeleteManyArgs>(args?: SelectSubset<T, DoctorBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorBranches
     * const doctorBranch = await prisma.doctorBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorBranchUpdateManyArgs>(args: SelectSubset<T, DoctorBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorBranch.
     * @param {DoctorBranchUpsertArgs} args - Arguments to update or create a DoctorBranch.
     * @example
     * // Update or create a DoctorBranch
     * const doctorBranch = await prisma.doctorBranch.upsert({
     *   create: {
     *     // ... data to create a DoctorBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorBranch we want to update
     *   }
     * })
     */
    upsert<T extends DoctorBranchUpsertArgs>(args: SelectSubset<T, DoctorBranchUpsertArgs<ExtArgs>>): Prisma__DoctorBranchClient<$Result.GetResult<Prisma.$DoctorBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoctorBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchCountArgs} args - Arguments to filter DoctorBranches to count.
     * @example
     * // Count the number of DoctorBranches
     * const count = await prisma.doctorBranch.count({
     *   where: {
     *     // ... the filter for the DoctorBranches we want to count
     *   }
     * })
    **/
    count<T extends DoctorBranchCountArgs>(
      args?: Subset<T, DoctorBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorBranchAggregateArgs>(args: Subset<T, DoctorBranchAggregateArgs>): Prisma.PrismaPromise<GetDoctorBranchAggregateType<T>>

    /**
     * Group by DoctorBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorBranchGroupByArgs['orderBy'] }
        : { orderBy?: DoctorBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorBranch model
   */
  readonly fields: DoctorBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorBranch model
   */ 
  interface DoctorBranchFieldRefs {
    readonly id: FieldRef<"DoctorBranch", 'Int'>
    readonly doctorId: FieldRef<"DoctorBranch", 'Int'>
    readonly branchId: FieldRef<"DoctorBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DoctorBranch findUnique
   */
  export type DoctorBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch findUniqueOrThrow
   */
  export type DoctorBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch findFirst
   */
  export type DoctorBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorBranches.
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorBranches.
     */
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * DoctorBranch findFirstOrThrow
   */
  export type DoctorBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranch to fetch.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorBranches.
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorBranches.
     */
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * DoctorBranch findMany
   */
  export type DoctorBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter, which DoctorBranches to fetch.
     */
    where?: DoctorBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorBranches to fetch.
     */
    orderBy?: DoctorBranchOrderByWithRelationInput | DoctorBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorBranches.
     */
    cursor?: DoctorBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorBranches.
     */
    skip?: number
    distinct?: DoctorBranchScalarFieldEnum | DoctorBranchScalarFieldEnum[]
  }

  /**
   * DoctorBranch create
   */
  export type DoctorBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorBranch.
     */
    data: XOR<DoctorBranchCreateInput, DoctorBranchUncheckedCreateInput>
  }

  /**
   * DoctorBranch createMany
   */
  export type DoctorBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorBranches.
     */
    data: DoctorBranchCreateManyInput | DoctorBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DoctorBranch createManyAndReturn
   */
  export type DoctorBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoctorBranches.
     */
    data: DoctorBranchCreateManyInput | DoctorBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorBranch update
   */
  export type DoctorBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorBranch.
     */
    data: XOR<DoctorBranchUpdateInput, DoctorBranchUncheckedUpdateInput>
    /**
     * Choose, which DoctorBranch to update.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch updateMany
   */
  export type DoctorBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorBranches.
     */
    data: XOR<DoctorBranchUpdateManyMutationInput, DoctorBranchUncheckedUpdateManyInput>
    /**
     * Filter which DoctorBranches to update
     */
    where?: DoctorBranchWhereInput
  }

  /**
   * DoctorBranch upsert
   */
  export type DoctorBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorBranch to update in case it exists.
     */
    where: DoctorBranchWhereUniqueInput
    /**
     * In case the DoctorBranch found by the `where` argument doesn't exist, create a new DoctorBranch with this data.
     */
    create: XOR<DoctorBranchCreateInput, DoctorBranchUncheckedCreateInput>
    /**
     * In case the DoctorBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorBranchUpdateInput, DoctorBranchUncheckedUpdateInput>
  }

  /**
   * DoctorBranch delete
   */
  export type DoctorBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
    /**
     * Filter which DoctorBranch to delete.
     */
    where: DoctorBranchWhereUniqueInput
  }

  /**
   * DoctorBranch deleteMany
   */
  export type DoctorBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorBranches to delete
     */
    where?: DoctorBranchWhereInput
  }

  /**
   * DoctorBranch without action
   */
  export type DoctorBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorBranch
     */
    select?: DoctorBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorBranchInclude<ExtArgs> | null
  }


  /**
   * Model ReceptionBranch
   */

  export type AggregateReceptionBranch = {
    _count: ReceptionBranchCountAggregateOutputType | null
    _avg: ReceptionBranchAvgAggregateOutputType | null
    _sum: ReceptionBranchSumAggregateOutputType | null
    _min: ReceptionBranchMinAggregateOutputType | null
    _max: ReceptionBranchMaxAggregateOutputType | null
  }

  export type ReceptionBranchAvgAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchSumAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchMinAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchMaxAggregateOutputType = {
    id: number | null
    receptionId: number | null
    branchId: number | null
  }

  export type ReceptionBranchCountAggregateOutputType = {
    id: number
    receptionId: number
    branchId: number
    _all: number
  }


  export type ReceptionBranchAvgAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchSumAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchMinAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchMaxAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
  }

  export type ReceptionBranchCountAggregateInputType = {
    id?: true
    receptionId?: true
    branchId?: true
    _all?: true
  }

  export type ReceptionBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionBranch to aggregate.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceptionBranches
    **/
    _count?: true | ReceptionBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceptionBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceptionBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceptionBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceptionBranchMaxAggregateInputType
  }

  export type GetReceptionBranchAggregateType<T extends ReceptionBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateReceptionBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceptionBranch[P]>
      : GetScalarType<T[P], AggregateReceptionBranch[P]>
  }




  export type ReceptionBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceptionBranchWhereInput
    orderBy?: ReceptionBranchOrderByWithAggregationInput | ReceptionBranchOrderByWithAggregationInput[]
    by: ReceptionBranchScalarFieldEnum[] | ReceptionBranchScalarFieldEnum
    having?: ReceptionBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceptionBranchCountAggregateInputType | true
    _avg?: ReceptionBranchAvgAggregateInputType
    _sum?: ReceptionBranchSumAggregateInputType
    _min?: ReceptionBranchMinAggregateInputType
    _max?: ReceptionBranchMaxAggregateInputType
  }

  export type ReceptionBranchGroupByOutputType = {
    id: number
    receptionId: number
    branchId: number
    _count: ReceptionBranchCountAggregateOutputType | null
    _avg: ReceptionBranchAvgAggregateOutputType | null
    _sum: ReceptionBranchSumAggregateOutputType | null
    _min: ReceptionBranchMinAggregateOutputType | null
    _max: ReceptionBranchMaxAggregateOutputType | null
  }

  type GetReceptionBranchGroupByPayload<T extends ReceptionBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceptionBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceptionBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceptionBranchGroupByOutputType[P]>
            : GetScalarType<T[P], ReceptionBranchGroupByOutputType[P]>
        }
      >
    >


  export type ReceptionBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionBranch"]>

  export type ReceptionBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receptionBranch"]>

  export type ReceptionBranchSelectScalar = {
    id?: boolean
    receptionId?: boolean
    branchId?: boolean
  }

  export type ReceptionBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type ReceptionBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reception?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ReceptionBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceptionBranch"
    objects: {
      reception: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receptionId: number
      branchId: number
    }, ExtArgs["result"]["receptionBranch"]>
    composites: {}
  }

  type ReceptionBranchGetPayload<S extends boolean | null | undefined | ReceptionBranchDefaultArgs> = $Result.GetResult<Prisma.$ReceptionBranchPayload, S>

  type ReceptionBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceptionBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceptionBranchCountAggregateInputType | true
    }

  export interface ReceptionBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceptionBranch'], meta: { name: 'ReceptionBranch' } }
    /**
     * Find zero or one ReceptionBranch that matches the filter.
     * @param {ReceptionBranchFindUniqueArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceptionBranchFindUniqueArgs>(args: SelectSubset<T, ReceptionBranchFindUniqueArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReceptionBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReceptionBranchFindUniqueOrThrowArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceptionBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceptionBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReceptionBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchFindFirstArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceptionBranchFindFirstArgs>(args?: SelectSubset<T, ReceptionBranchFindFirstArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReceptionBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchFindFirstOrThrowArgs} args - Arguments to find a ReceptionBranch
     * @example
     * // Get one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceptionBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceptionBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReceptionBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceptionBranches
     * const receptionBranches = await prisma.receptionBranch.findMany()
     * 
     * // Get first 10 ReceptionBranches
     * const receptionBranches = await prisma.receptionBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receptionBranchWithIdOnly = await prisma.receptionBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceptionBranchFindManyArgs>(args?: SelectSubset<T, ReceptionBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReceptionBranch.
     * @param {ReceptionBranchCreateArgs} args - Arguments to create a ReceptionBranch.
     * @example
     * // Create one ReceptionBranch
     * const ReceptionBranch = await prisma.receptionBranch.create({
     *   data: {
     *     // ... data to create a ReceptionBranch
     *   }
     * })
     * 
     */
    create<T extends ReceptionBranchCreateArgs>(args: SelectSubset<T, ReceptionBranchCreateArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReceptionBranches.
     * @param {ReceptionBranchCreateManyArgs} args - Arguments to create many ReceptionBranches.
     * @example
     * // Create many ReceptionBranches
     * const receptionBranch = await prisma.receptionBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceptionBranchCreateManyArgs>(args?: SelectSubset<T, ReceptionBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceptionBranches and returns the data saved in the database.
     * @param {ReceptionBranchCreateManyAndReturnArgs} args - Arguments to create many ReceptionBranches.
     * @example
     * // Create many ReceptionBranches
     * const receptionBranch = await prisma.receptionBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceptionBranches and only return the `id`
     * const receptionBranchWithIdOnly = await prisma.receptionBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceptionBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceptionBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReceptionBranch.
     * @param {ReceptionBranchDeleteArgs} args - Arguments to delete one ReceptionBranch.
     * @example
     * // Delete one ReceptionBranch
     * const ReceptionBranch = await prisma.receptionBranch.delete({
     *   where: {
     *     // ... filter to delete one ReceptionBranch
     *   }
     * })
     * 
     */
    delete<T extends ReceptionBranchDeleteArgs>(args: SelectSubset<T, ReceptionBranchDeleteArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReceptionBranch.
     * @param {ReceptionBranchUpdateArgs} args - Arguments to update one ReceptionBranch.
     * @example
     * // Update one ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceptionBranchUpdateArgs>(args: SelectSubset<T, ReceptionBranchUpdateArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReceptionBranches.
     * @param {ReceptionBranchDeleteManyArgs} args - Arguments to filter ReceptionBranches to delete.
     * @example
     * // Delete a few ReceptionBranches
     * const { count } = await prisma.receptionBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceptionBranchDeleteManyArgs>(args?: SelectSubset<T, ReceptionBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceptionBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceptionBranches
     * const receptionBranch = await prisma.receptionBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceptionBranchUpdateManyArgs>(args: SelectSubset<T, ReceptionBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceptionBranch.
     * @param {ReceptionBranchUpsertArgs} args - Arguments to update or create a ReceptionBranch.
     * @example
     * // Update or create a ReceptionBranch
     * const receptionBranch = await prisma.receptionBranch.upsert({
     *   create: {
     *     // ... data to create a ReceptionBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceptionBranch we want to update
     *   }
     * })
     */
    upsert<T extends ReceptionBranchUpsertArgs>(args: SelectSubset<T, ReceptionBranchUpsertArgs<ExtArgs>>): Prisma__ReceptionBranchClient<$Result.GetResult<Prisma.$ReceptionBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReceptionBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchCountArgs} args - Arguments to filter ReceptionBranches to count.
     * @example
     * // Count the number of ReceptionBranches
     * const count = await prisma.receptionBranch.count({
     *   where: {
     *     // ... the filter for the ReceptionBranches we want to count
     *   }
     * })
    **/
    count<T extends ReceptionBranchCountArgs>(
      args?: Subset<T, ReceptionBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceptionBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceptionBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceptionBranchAggregateArgs>(args: Subset<T, ReceptionBranchAggregateArgs>): Prisma.PrismaPromise<GetReceptionBranchAggregateType<T>>

    /**
     * Group by ReceptionBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceptionBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceptionBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceptionBranchGroupByArgs['orderBy'] }
        : { orderBy?: ReceptionBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceptionBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceptionBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceptionBranch model
   */
  readonly fields: ReceptionBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceptionBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceptionBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reception<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceptionBranch model
   */ 
  interface ReceptionBranchFieldRefs {
    readonly id: FieldRef<"ReceptionBranch", 'Int'>
    readonly receptionId: FieldRef<"ReceptionBranch", 'Int'>
    readonly branchId: FieldRef<"ReceptionBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReceptionBranch findUnique
   */
  export type ReceptionBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch findUniqueOrThrow
   */
  export type ReceptionBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch findFirst
   */
  export type ReceptionBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionBranches.
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionBranches.
     */
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * ReceptionBranch findFirstOrThrow
   */
  export type ReceptionBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranch to fetch.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceptionBranches.
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceptionBranches.
     */
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * ReceptionBranch findMany
   */
  export type ReceptionBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter, which ReceptionBranches to fetch.
     */
    where?: ReceptionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceptionBranches to fetch.
     */
    orderBy?: ReceptionBranchOrderByWithRelationInput | ReceptionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceptionBranches.
     */
    cursor?: ReceptionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceptionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceptionBranches.
     */
    skip?: number
    distinct?: ReceptionBranchScalarFieldEnum | ReceptionBranchScalarFieldEnum[]
  }

  /**
   * ReceptionBranch create
   */
  export type ReceptionBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceptionBranch.
     */
    data: XOR<ReceptionBranchCreateInput, ReceptionBranchUncheckedCreateInput>
  }

  /**
   * ReceptionBranch createMany
   */
  export type ReceptionBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceptionBranches.
     */
    data: ReceptionBranchCreateManyInput | ReceptionBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceptionBranch createManyAndReturn
   */
  export type ReceptionBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReceptionBranches.
     */
    data: ReceptionBranchCreateManyInput | ReceptionBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceptionBranch update
   */
  export type ReceptionBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceptionBranch.
     */
    data: XOR<ReceptionBranchUpdateInput, ReceptionBranchUncheckedUpdateInput>
    /**
     * Choose, which ReceptionBranch to update.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch updateMany
   */
  export type ReceptionBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceptionBranches.
     */
    data: XOR<ReceptionBranchUpdateManyMutationInput, ReceptionBranchUncheckedUpdateManyInput>
    /**
     * Filter which ReceptionBranches to update
     */
    where?: ReceptionBranchWhereInput
  }

  /**
   * ReceptionBranch upsert
   */
  export type ReceptionBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceptionBranch to update in case it exists.
     */
    where: ReceptionBranchWhereUniqueInput
    /**
     * In case the ReceptionBranch found by the `where` argument doesn't exist, create a new ReceptionBranch with this data.
     */
    create: XOR<ReceptionBranchCreateInput, ReceptionBranchUncheckedCreateInput>
    /**
     * In case the ReceptionBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceptionBranchUpdateInput, ReceptionBranchUncheckedUpdateInput>
  }

  /**
   * ReceptionBranch delete
   */
  export type ReceptionBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
    /**
     * Filter which ReceptionBranch to delete.
     */
    where: ReceptionBranchWhereUniqueInput
  }

  /**
   * ReceptionBranch deleteMany
   */
  export type ReceptionBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceptionBranches to delete
     */
    where?: ReceptionBranchWhereInput
  }

  /**
   * ReceptionBranch without action
   */
  export type ReceptionBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceptionBranch
     */
    select?: ReceptionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceptionBranchInclude<ExtArgs> | null
  }


  /**
   * Model NurseBranch
   */

  export type AggregateNurseBranch = {
    _count: NurseBranchCountAggregateOutputType | null
    _avg: NurseBranchAvgAggregateOutputType | null
    _sum: NurseBranchSumAggregateOutputType | null
    _min: NurseBranchMinAggregateOutputType | null
    _max: NurseBranchMaxAggregateOutputType | null
  }

  export type NurseBranchAvgAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchSumAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchMinAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchMaxAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseBranchCountAggregateOutputType = {
    id: number
    nurseId: number
    branchId: number
    _all: number
  }


  export type NurseBranchAvgAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchSumAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchMinAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchMaxAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseBranchCountAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    _all?: true
  }

  export type NurseBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseBranch to aggregate.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NurseBranches
    **/
    _count?: true | NurseBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NurseBranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NurseBranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseBranchMaxAggregateInputType
  }

  export type GetNurseBranchAggregateType<T extends NurseBranchAggregateArgs> = {
        [P in keyof T & keyof AggregateNurseBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurseBranch[P]>
      : GetScalarType<T[P], AggregateNurseBranch[P]>
  }




  export type NurseBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseBranchWhereInput
    orderBy?: NurseBranchOrderByWithAggregationInput | NurseBranchOrderByWithAggregationInput[]
    by: NurseBranchScalarFieldEnum[] | NurseBranchScalarFieldEnum
    having?: NurseBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseBranchCountAggregateInputType | true
    _avg?: NurseBranchAvgAggregateInputType
    _sum?: NurseBranchSumAggregateInputType
    _min?: NurseBranchMinAggregateInputType
    _max?: NurseBranchMaxAggregateInputType
  }

  export type NurseBranchGroupByOutputType = {
    id: number
    nurseId: number
    branchId: number
    _count: NurseBranchCountAggregateOutputType | null
    _avg: NurseBranchAvgAggregateOutputType | null
    _sum: NurseBranchSumAggregateOutputType | null
    _min: NurseBranchMinAggregateOutputType | null
    _max: NurseBranchMaxAggregateOutputType | null
  }

  type GetNurseBranchGroupByPayload<T extends NurseBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseBranchGroupByOutputType[P]>
            : GetScalarType<T[P], NurseBranchGroupByOutputType[P]>
        }
      >
    >


  export type NurseBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseBranch"]>

  export type NurseBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseBranch"]>

  export type NurseBranchSelectScalar = {
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
  }

  export type NurseBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type NurseBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $NurseBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NurseBranch"
    objects: {
      nurse: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nurseId: number
      branchId: number
    }, ExtArgs["result"]["nurseBranch"]>
    composites: {}
  }

  type NurseBranchGetPayload<S extends boolean | null | undefined | NurseBranchDefaultArgs> = $Result.GetResult<Prisma.$NurseBranchPayload, S>

  type NurseBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NurseBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NurseBranchCountAggregateInputType | true
    }

  export interface NurseBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NurseBranch'], meta: { name: 'NurseBranch' } }
    /**
     * Find zero or one NurseBranch that matches the filter.
     * @param {NurseBranchFindUniqueArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NurseBranchFindUniqueArgs>(args: SelectSubset<T, NurseBranchFindUniqueArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NurseBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NurseBranchFindUniqueOrThrowArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NurseBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, NurseBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NurseBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchFindFirstArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NurseBranchFindFirstArgs>(args?: SelectSubset<T, NurseBranchFindFirstArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NurseBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchFindFirstOrThrowArgs} args - Arguments to find a NurseBranch
     * @example
     * // Get one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NurseBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, NurseBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NurseBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NurseBranches
     * const nurseBranches = await prisma.nurseBranch.findMany()
     * 
     * // Get first 10 NurseBranches
     * const nurseBranches = await prisma.nurseBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nurseBranchWithIdOnly = await prisma.nurseBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NurseBranchFindManyArgs>(args?: SelectSubset<T, NurseBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NurseBranch.
     * @param {NurseBranchCreateArgs} args - Arguments to create a NurseBranch.
     * @example
     * // Create one NurseBranch
     * const NurseBranch = await prisma.nurseBranch.create({
     *   data: {
     *     // ... data to create a NurseBranch
     *   }
     * })
     * 
     */
    create<T extends NurseBranchCreateArgs>(args: SelectSubset<T, NurseBranchCreateArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NurseBranches.
     * @param {NurseBranchCreateManyArgs} args - Arguments to create many NurseBranches.
     * @example
     * // Create many NurseBranches
     * const nurseBranch = await prisma.nurseBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NurseBranchCreateManyArgs>(args?: SelectSubset<T, NurseBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NurseBranches and returns the data saved in the database.
     * @param {NurseBranchCreateManyAndReturnArgs} args - Arguments to create many NurseBranches.
     * @example
     * // Create many NurseBranches
     * const nurseBranch = await prisma.nurseBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NurseBranches and only return the `id`
     * const nurseBranchWithIdOnly = await prisma.nurseBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NurseBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, NurseBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NurseBranch.
     * @param {NurseBranchDeleteArgs} args - Arguments to delete one NurseBranch.
     * @example
     * // Delete one NurseBranch
     * const NurseBranch = await prisma.nurseBranch.delete({
     *   where: {
     *     // ... filter to delete one NurseBranch
     *   }
     * })
     * 
     */
    delete<T extends NurseBranchDeleteArgs>(args: SelectSubset<T, NurseBranchDeleteArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NurseBranch.
     * @param {NurseBranchUpdateArgs} args - Arguments to update one NurseBranch.
     * @example
     * // Update one NurseBranch
     * const nurseBranch = await prisma.nurseBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NurseBranchUpdateArgs>(args: SelectSubset<T, NurseBranchUpdateArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NurseBranches.
     * @param {NurseBranchDeleteManyArgs} args - Arguments to filter NurseBranches to delete.
     * @example
     * // Delete a few NurseBranches
     * const { count } = await prisma.nurseBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NurseBranchDeleteManyArgs>(args?: SelectSubset<T, NurseBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NurseBranches
     * const nurseBranch = await prisma.nurseBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NurseBranchUpdateManyArgs>(args: SelectSubset<T, NurseBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NurseBranch.
     * @param {NurseBranchUpsertArgs} args - Arguments to update or create a NurseBranch.
     * @example
     * // Update or create a NurseBranch
     * const nurseBranch = await prisma.nurseBranch.upsert({
     *   create: {
     *     // ... data to create a NurseBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NurseBranch we want to update
     *   }
     * })
     */
    upsert<T extends NurseBranchUpsertArgs>(args: SelectSubset<T, NurseBranchUpsertArgs<ExtArgs>>): Prisma__NurseBranchClient<$Result.GetResult<Prisma.$NurseBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NurseBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchCountArgs} args - Arguments to filter NurseBranches to count.
     * @example
     * // Count the number of NurseBranches
     * const count = await prisma.nurseBranch.count({
     *   where: {
     *     // ... the filter for the NurseBranches we want to count
     *   }
     * })
    **/
    count<T extends NurseBranchCountArgs>(
      args?: Subset<T, NurseBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NurseBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseBranchAggregateArgs>(args: Subset<T, NurseBranchAggregateArgs>): Prisma.PrismaPromise<GetNurseBranchAggregateType<T>>

    /**
     * Group by NurseBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NurseBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NurseBranchGroupByArgs['orderBy'] }
        : { orderBy?: NurseBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NurseBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NurseBranch model
   */
  readonly fields: NurseBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NurseBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NurseBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nurse<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NurseBranch model
   */ 
  interface NurseBranchFieldRefs {
    readonly id: FieldRef<"NurseBranch", 'Int'>
    readonly nurseId: FieldRef<"NurseBranch", 'Int'>
    readonly branchId: FieldRef<"NurseBranch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NurseBranch findUnique
   */
  export type NurseBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch findUniqueOrThrow
   */
  export type NurseBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch findFirst
   */
  export type NurseBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseBranches.
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseBranches.
     */
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * NurseBranch findFirstOrThrow
   */
  export type NurseBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranch to fetch.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseBranches.
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseBranches.
     */
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * NurseBranch findMany
   */
  export type NurseBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter, which NurseBranches to fetch.
     */
    where?: NurseBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseBranches to fetch.
     */
    orderBy?: NurseBranchOrderByWithRelationInput | NurseBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NurseBranches.
     */
    cursor?: NurseBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseBranches.
     */
    skip?: number
    distinct?: NurseBranchScalarFieldEnum | NurseBranchScalarFieldEnum[]
  }

  /**
   * NurseBranch create
   */
  export type NurseBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a NurseBranch.
     */
    data: XOR<NurseBranchCreateInput, NurseBranchUncheckedCreateInput>
  }

  /**
   * NurseBranch createMany
   */
  export type NurseBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NurseBranches.
     */
    data: NurseBranchCreateManyInput | NurseBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NurseBranch createManyAndReturn
   */
  export type NurseBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NurseBranches.
     */
    data: NurseBranchCreateManyInput | NurseBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NurseBranch update
   */
  export type NurseBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a NurseBranch.
     */
    data: XOR<NurseBranchUpdateInput, NurseBranchUncheckedUpdateInput>
    /**
     * Choose, which NurseBranch to update.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch updateMany
   */
  export type NurseBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NurseBranches.
     */
    data: XOR<NurseBranchUpdateManyMutationInput, NurseBranchUncheckedUpdateManyInput>
    /**
     * Filter which NurseBranches to update
     */
    where?: NurseBranchWhereInput
  }

  /**
   * NurseBranch upsert
   */
  export type NurseBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the NurseBranch to update in case it exists.
     */
    where: NurseBranchWhereUniqueInput
    /**
     * In case the NurseBranch found by the `where` argument doesn't exist, create a new NurseBranch with this data.
     */
    create: XOR<NurseBranchCreateInput, NurseBranchUncheckedCreateInput>
    /**
     * In case the NurseBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NurseBranchUpdateInput, NurseBranchUncheckedUpdateInput>
  }

  /**
   * NurseBranch delete
   */
  export type NurseBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
    /**
     * Filter which NurseBranch to delete.
     */
    where: NurseBranchWhereUniqueInput
  }

  /**
   * NurseBranch deleteMany
   */
  export type NurseBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseBranches to delete
     */
    where?: NurseBranchWhereInput
  }

  /**
   * NurseBranch without action
   */
  export type NurseBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseBranch
     */
    select?: NurseBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseBranchInclude<ExtArgs> | null
  }


  /**
   * Model NurseSchedule
   */

  export type AggregateNurseSchedule = {
    _count: NurseScheduleCountAggregateOutputType | null
    _avg: NurseScheduleAvgAggregateOutputType | null
    _sum: NurseScheduleSumAggregateOutputType | null
    _min: NurseScheduleMinAggregateOutputType | null
    _max: NurseScheduleMaxAggregateOutputType | null
  }

  export type NurseScheduleAvgAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseScheduleSumAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
  }

  export type NurseScheduleMinAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type NurseScheduleMaxAggregateOutputType = {
    id: number | null
    nurseId: number | null
    branchId: number | null
    date: Date | null
    startTime: string | null
    endTime: string | null
    note: string | null
  }

  export type NurseScheduleCountAggregateOutputType = {
    id: number
    nurseId: number
    branchId: number
    date: number
    startTime: number
    endTime: number
    note: number
    _all: number
  }


  export type NurseScheduleAvgAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseScheduleSumAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
  }

  export type NurseScheduleMinAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type NurseScheduleMaxAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
  }

  export type NurseScheduleCountAggregateInputType = {
    id?: true
    nurseId?: true
    branchId?: true
    date?: true
    startTime?: true
    endTime?: true
    note?: true
    _all?: true
  }

  export type NurseScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseSchedule to aggregate.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NurseSchedules
    **/
    _count?: true | NurseScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NurseScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NurseScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NurseScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NurseScheduleMaxAggregateInputType
  }

  export type GetNurseScheduleAggregateType<T extends NurseScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateNurseSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNurseSchedule[P]>
      : GetScalarType<T[P], AggregateNurseSchedule[P]>
  }




  export type NurseScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NurseScheduleWhereInput
    orderBy?: NurseScheduleOrderByWithAggregationInput | NurseScheduleOrderByWithAggregationInput[]
    by: NurseScheduleScalarFieldEnum[] | NurseScheduleScalarFieldEnum
    having?: NurseScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NurseScheduleCountAggregateInputType | true
    _avg?: NurseScheduleAvgAggregateInputType
    _sum?: NurseScheduleSumAggregateInputType
    _min?: NurseScheduleMinAggregateInputType
    _max?: NurseScheduleMaxAggregateInputType
  }

  export type NurseScheduleGroupByOutputType = {
    id: number
    nurseId: number
    branchId: number
    date: Date
    startTime: string
    endTime: string
    note: string | null
    _count: NurseScheduleCountAggregateOutputType | null
    _avg: NurseScheduleAvgAggregateOutputType | null
    _sum: NurseScheduleSumAggregateOutputType | null
    _min: NurseScheduleMinAggregateOutputType | null
    _max: NurseScheduleMaxAggregateOutputType | null
  }

  type GetNurseScheduleGroupByPayload<T extends NurseScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NurseScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NurseScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NurseScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], NurseScheduleGroupByOutputType[P]>
        }
      >
    >


  export type NurseScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseSchedule"]>

  export type NurseScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nurseSchedule"]>

  export type NurseScheduleSelectScalar = {
    id?: boolean
    nurseId?: boolean
    branchId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    note?: boolean
  }

  export type NurseScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type NurseScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nurse?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $NurseSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NurseSchedule"
    objects: {
      nurse: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nurseId: number
      branchId: number
      date: Date
      startTime: string
      endTime: string
      note: string | null
    }, ExtArgs["result"]["nurseSchedule"]>
    composites: {}
  }

  type NurseScheduleGetPayload<S extends boolean | null | undefined | NurseScheduleDefaultArgs> = $Result.GetResult<Prisma.$NurseSchedulePayload, S>

  type NurseScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NurseScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NurseScheduleCountAggregateInputType | true
    }

  export interface NurseScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NurseSchedule'], meta: { name: 'NurseSchedule' } }
    /**
     * Find zero or one NurseSchedule that matches the filter.
     * @param {NurseScheduleFindUniqueArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NurseScheduleFindUniqueArgs>(args: SelectSubset<T, NurseScheduleFindUniqueArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NurseSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NurseScheduleFindUniqueOrThrowArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NurseScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, NurseScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NurseSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleFindFirstArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NurseScheduleFindFirstArgs>(args?: SelectSubset<T, NurseScheduleFindFirstArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NurseSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleFindFirstOrThrowArgs} args - Arguments to find a NurseSchedule
     * @example
     * // Get one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NurseScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, NurseScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NurseSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NurseSchedules
     * const nurseSchedules = await prisma.nurseSchedule.findMany()
     * 
     * // Get first 10 NurseSchedules
     * const nurseSchedules = await prisma.nurseSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nurseScheduleWithIdOnly = await prisma.nurseSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NurseScheduleFindManyArgs>(args?: SelectSubset<T, NurseScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NurseSchedule.
     * @param {NurseScheduleCreateArgs} args - Arguments to create a NurseSchedule.
     * @example
     * // Create one NurseSchedule
     * const NurseSchedule = await prisma.nurseSchedule.create({
     *   data: {
     *     // ... data to create a NurseSchedule
     *   }
     * })
     * 
     */
    create<T extends NurseScheduleCreateArgs>(args: SelectSubset<T, NurseScheduleCreateArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NurseSchedules.
     * @param {NurseScheduleCreateManyArgs} args - Arguments to create many NurseSchedules.
     * @example
     * // Create many NurseSchedules
     * const nurseSchedule = await prisma.nurseSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NurseScheduleCreateManyArgs>(args?: SelectSubset<T, NurseScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NurseSchedules and returns the data saved in the database.
     * @param {NurseScheduleCreateManyAndReturnArgs} args - Arguments to create many NurseSchedules.
     * @example
     * // Create many NurseSchedules
     * const nurseSchedule = await prisma.nurseSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NurseSchedules and only return the `id`
     * const nurseScheduleWithIdOnly = await prisma.nurseSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NurseScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, NurseScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NurseSchedule.
     * @param {NurseScheduleDeleteArgs} args - Arguments to delete one NurseSchedule.
     * @example
     * // Delete one NurseSchedule
     * const NurseSchedule = await prisma.nurseSchedule.delete({
     *   where: {
     *     // ... filter to delete one NurseSchedule
     *   }
     * })
     * 
     */
    delete<T extends NurseScheduleDeleteArgs>(args: SelectSubset<T, NurseScheduleDeleteArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NurseSchedule.
     * @param {NurseScheduleUpdateArgs} args - Arguments to update one NurseSchedule.
     * @example
     * // Update one NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NurseScheduleUpdateArgs>(args: SelectSubset<T, NurseScheduleUpdateArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NurseSchedules.
     * @param {NurseScheduleDeleteManyArgs} args - Arguments to filter NurseSchedules to delete.
     * @example
     * // Delete a few NurseSchedules
     * const { count } = await prisma.nurseSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NurseScheduleDeleteManyArgs>(args?: SelectSubset<T, NurseScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NurseSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NurseSchedules
     * const nurseSchedule = await prisma.nurseSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NurseScheduleUpdateManyArgs>(args: SelectSubset<T, NurseScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NurseSchedule.
     * @param {NurseScheduleUpsertArgs} args - Arguments to update or create a NurseSchedule.
     * @example
     * // Update or create a NurseSchedule
     * const nurseSchedule = await prisma.nurseSchedule.upsert({
     *   create: {
     *     // ... data to create a NurseSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NurseSchedule we want to update
     *   }
     * })
     */
    upsert<T extends NurseScheduleUpsertArgs>(args: SelectSubset<T, NurseScheduleUpsertArgs<ExtArgs>>): Prisma__NurseScheduleClient<$Result.GetResult<Prisma.$NurseSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NurseSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleCountArgs} args - Arguments to filter NurseSchedules to count.
     * @example
     * // Count the number of NurseSchedules
     * const count = await prisma.nurseSchedule.count({
     *   where: {
     *     // ... the filter for the NurseSchedules we want to count
     *   }
     * })
    **/
    count<T extends NurseScheduleCountArgs>(
      args?: Subset<T, NurseScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NurseScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NurseSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NurseScheduleAggregateArgs>(args: Subset<T, NurseScheduleAggregateArgs>): Prisma.PrismaPromise<GetNurseScheduleAggregateType<T>>

    /**
     * Group by NurseSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NurseScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NurseScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NurseScheduleGroupByArgs['orderBy'] }
        : { orderBy?: NurseScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NurseScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNurseScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NurseSchedule model
   */
  readonly fields: NurseScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NurseSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NurseScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nurse<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NurseSchedule model
   */ 
  interface NurseScheduleFieldRefs {
    readonly id: FieldRef<"NurseSchedule", 'Int'>
    readonly nurseId: FieldRef<"NurseSchedule", 'Int'>
    readonly branchId: FieldRef<"NurseSchedule", 'Int'>
    readonly date: FieldRef<"NurseSchedule", 'DateTime'>
    readonly startTime: FieldRef<"NurseSchedule", 'String'>
    readonly endTime: FieldRef<"NurseSchedule", 'String'>
    readonly note: FieldRef<"NurseSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NurseSchedule findUnique
   */
  export type NurseScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule findUniqueOrThrow
   */
  export type NurseScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule findFirst
   */
  export type NurseScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseSchedules.
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseSchedules.
     */
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * NurseSchedule findFirstOrThrow
   */
  export type NurseScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedule to fetch.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NurseSchedules.
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NurseSchedules.
     */
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * NurseSchedule findMany
   */
  export type NurseScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter, which NurseSchedules to fetch.
     */
    where?: NurseScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NurseSchedules to fetch.
     */
    orderBy?: NurseScheduleOrderByWithRelationInput | NurseScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NurseSchedules.
     */
    cursor?: NurseScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NurseSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NurseSchedules.
     */
    skip?: number
    distinct?: NurseScheduleScalarFieldEnum | NurseScheduleScalarFieldEnum[]
  }

  /**
   * NurseSchedule create
   */
  export type NurseScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a NurseSchedule.
     */
    data: XOR<NurseScheduleCreateInput, NurseScheduleUncheckedCreateInput>
  }

  /**
   * NurseSchedule createMany
   */
  export type NurseScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NurseSchedules.
     */
    data: NurseScheduleCreateManyInput | NurseScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NurseSchedule createManyAndReturn
   */
  export type NurseScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NurseSchedules.
     */
    data: NurseScheduleCreateManyInput | NurseScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NurseSchedule update
   */
  export type NurseScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a NurseSchedule.
     */
    data: XOR<NurseScheduleUpdateInput, NurseScheduleUncheckedUpdateInput>
    /**
     * Choose, which NurseSchedule to update.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule updateMany
   */
  export type NurseScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NurseSchedules.
     */
    data: XOR<NurseScheduleUpdateManyMutationInput, NurseScheduleUncheckedUpdateManyInput>
    /**
     * Filter which NurseSchedules to update
     */
    where?: NurseScheduleWhereInput
  }

  /**
   * NurseSchedule upsert
   */
  export type NurseScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the NurseSchedule to update in case it exists.
     */
    where: NurseScheduleWhereUniqueInput
    /**
     * In case the NurseSchedule found by the `where` argument doesn't exist, create a new NurseSchedule with this data.
     */
    create: XOR<NurseScheduleCreateInput, NurseScheduleUncheckedCreateInput>
    /**
     * In case the NurseSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NurseScheduleUpdateInput, NurseScheduleUncheckedUpdateInput>
  }

  /**
   * NurseSchedule delete
   */
  export type NurseScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
    /**
     * Filter which NurseSchedule to delete.
     */
    where: NurseScheduleWhereUniqueInput
  }

  /**
   * NurseSchedule deleteMany
   */
  export type NurseScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NurseSchedules to delete
     */
    where?: NurseScheduleWhereInput
  }

  /**
   * NurseSchedule without action
   */
  export type NurseScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NurseSchedule
     */
    select?: NurseScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NurseScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethodConfig
   */

  export type AggregatePaymentMethodConfig = {
    _count: PaymentMethodConfigCountAggregateOutputType | null
    _avg: PaymentMethodConfigAvgAggregateOutputType | null
    _sum: PaymentMethodConfigSumAggregateOutputType | null
    _min: PaymentMethodConfigMinAggregateOutputType | null
    _max: PaymentMethodConfigMaxAggregateOutputType | null
  }

  export type PaymentMethodConfigAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type PaymentMethodConfigSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type PaymentMethodConfigMinAggregateOutputType = {
    id: number | null
    key: string | null
    label: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodConfigMaxAggregateOutputType = {
    id: number | null
    key: string | null
    label: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodConfigCountAggregateOutputType = {
    id: number
    key: number
    label: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodConfigAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type PaymentMethodConfigSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type PaymentMethodConfigMinAggregateInputType = {
    id?: true
    key?: true
    label?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodConfigMaxAggregateInputType = {
    id?: true
    key?: true
    label?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodConfigCountAggregateInputType = {
    id?: true
    key?: true
    label?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethodConfig to aggregate.
     */
    where?: PaymentMethodConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodConfigs to fetch.
     */
    orderBy?: PaymentMethodConfigOrderByWithRelationInput | PaymentMethodConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethodConfigs
    **/
    _count?: true | PaymentMethodConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodConfigMaxAggregateInputType
  }

  export type GetPaymentMethodConfigAggregateType<T extends PaymentMethodConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethodConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethodConfig[P]>
      : GetScalarType<T[P], AggregatePaymentMethodConfig[P]>
  }




  export type PaymentMethodConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodConfigWhereInput
    orderBy?: PaymentMethodConfigOrderByWithAggregationInput | PaymentMethodConfigOrderByWithAggregationInput[]
    by: PaymentMethodConfigScalarFieldEnum[] | PaymentMethodConfigScalarFieldEnum
    having?: PaymentMethodConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodConfigCountAggregateInputType | true
    _avg?: PaymentMethodConfigAvgAggregateInputType
    _sum?: PaymentMethodConfigSumAggregateInputType
    _min?: PaymentMethodConfigMinAggregateInputType
    _max?: PaymentMethodConfigMaxAggregateInputType
  }

  export type PaymentMethodConfigGroupByOutputType = {
    id: number
    key: string
    label: string
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodConfigCountAggregateOutputType | null
    _avg: PaymentMethodConfigAvgAggregateOutputType | null
    _sum: PaymentMethodConfigSumAggregateOutputType | null
    _min: PaymentMethodConfigMinAggregateOutputType | null
    _max: PaymentMethodConfigMaxAggregateOutputType | null
  }

  type GetPaymentMethodConfigGroupByPayload<T extends PaymentMethodConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    label?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    providers?: boolean | PaymentMethodConfig$providersArgs<ExtArgs>
    _count?: boolean | PaymentMethodConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethodConfig"]>

  export type PaymentMethodConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    label?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethodConfig"]>

  export type PaymentMethodConfigSelectScalar = {
    id?: boolean
    key?: boolean
    label?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | PaymentMethodConfig$providersArgs<ExtArgs>
    _count?: boolean | PaymentMethodConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentMethodConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethodConfig"
    objects: {
      providers: Prisma.$PaymentProviderConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      label: string
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethodConfig"]>
    composites: {}
  }

  type PaymentMethodConfigGetPayload<S extends boolean | null | undefined | PaymentMethodConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodConfigPayload, S>

  type PaymentMethodConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentMethodConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentMethodConfigCountAggregateInputType | true
    }

  export interface PaymentMethodConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethodConfig'], meta: { name: 'PaymentMethodConfig' } }
    /**
     * Find zero or one PaymentMethodConfig that matches the filter.
     * @param {PaymentMethodConfigFindUniqueArgs} args - Arguments to find a PaymentMethodConfig
     * @example
     * // Get one PaymentMethodConfig
     * const paymentMethodConfig = await prisma.paymentMethodConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodConfigFindUniqueArgs>(args: SelectSubset<T, PaymentMethodConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentMethodConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentMethodConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethodConfig
     * @example
     * // Get one PaymentMethodConfig
     * const paymentMethodConfig = await prisma.paymentMethodConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentMethodConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigFindFirstArgs} args - Arguments to find a PaymentMethodConfig
     * @example
     * // Get one PaymentMethodConfig
     * const paymentMethodConfig = await prisma.paymentMethodConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodConfigFindFirstArgs>(args?: SelectSubset<T, PaymentMethodConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentMethodConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentMethodConfig
     * @example
     * // Get one PaymentMethodConfig
     * const paymentMethodConfig = await prisma.paymentMethodConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentMethodConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethodConfigs
     * const paymentMethodConfigs = await prisma.paymentMethodConfig.findMany()
     * 
     * // Get first 10 PaymentMethodConfigs
     * const paymentMethodConfigs = await prisma.paymentMethodConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodConfigWithIdOnly = await prisma.paymentMethodConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodConfigFindManyArgs>(args?: SelectSubset<T, PaymentMethodConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentMethodConfig.
     * @param {PaymentMethodConfigCreateArgs} args - Arguments to create a PaymentMethodConfig.
     * @example
     * // Create one PaymentMethodConfig
     * const PaymentMethodConfig = await prisma.paymentMethodConfig.create({
     *   data: {
     *     // ... data to create a PaymentMethodConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodConfigCreateArgs>(args: SelectSubset<T, PaymentMethodConfigCreateArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentMethodConfigs.
     * @param {PaymentMethodConfigCreateManyArgs} args - Arguments to create many PaymentMethodConfigs.
     * @example
     * // Create many PaymentMethodConfigs
     * const paymentMethodConfig = await prisma.paymentMethodConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodConfigCreateManyArgs>(args?: SelectSubset<T, PaymentMethodConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethodConfigs and returns the data saved in the database.
     * @param {PaymentMethodConfigCreateManyAndReturnArgs} args - Arguments to create many PaymentMethodConfigs.
     * @example
     * // Create many PaymentMethodConfigs
     * const paymentMethodConfig = await prisma.paymentMethodConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethodConfigs and only return the `id`
     * const paymentMethodConfigWithIdOnly = await prisma.paymentMethodConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentMethodConfig.
     * @param {PaymentMethodConfigDeleteArgs} args - Arguments to delete one PaymentMethodConfig.
     * @example
     * // Delete one PaymentMethodConfig
     * const PaymentMethodConfig = await prisma.paymentMethodConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethodConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodConfigDeleteArgs>(args: SelectSubset<T, PaymentMethodConfigDeleteArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentMethodConfig.
     * @param {PaymentMethodConfigUpdateArgs} args - Arguments to update one PaymentMethodConfig.
     * @example
     * // Update one PaymentMethodConfig
     * const paymentMethodConfig = await prisma.paymentMethodConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodConfigUpdateArgs>(args: SelectSubset<T, PaymentMethodConfigUpdateArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentMethodConfigs.
     * @param {PaymentMethodConfigDeleteManyArgs} args - Arguments to filter PaymentMethodConfigs to delete.
     * @example
     * // Delete a few PaymentMethodConfigs
     * const { count } = await prisma.paymentMethodConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethodConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethodConfigs
     * const paymentMethodConfig = await prisma.paymentMethodConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodConfigUpdateManyArgs>(args: SelectSubset<T, PaymentMethodConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethodConfig.
     * @param {PaymentMethodConfigUpsertArgs} args - Arguments to update or create a PaymentMethodConfig.
     * @example
     * // Update or create a PaymentMethodConfig
     * const paymentMethodConfig = await prisma.paymentMethodConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentMethodConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethodConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodConfigUpsertArgs>(args: SelectSubset<T, PaymentMethodConfigUpsertArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentMethodConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigCountArgs} args - Arguments to filter PaymentMethodConfigs to count.
     * @example
     * // Count the number of PaymentMethodConfigs
     * const count = await prisma.paymentMethodConfig.count({
     *   where: {
     *     // ... the filter for the PaymentMethodConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodConfigCountArgs>(
      args?: Subset<T, PaymentMethodConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethodConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodConfigAggregateArgs>(args: Subset<T, PaymentMethodConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodConfigAggregateType<T>>

    /**
     * Group by PaymentMethodConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethodConfig model
   */
  readonly fields: PaymentMethodConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethodConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends PaymentMethodConfig$providersArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodConfig$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethodConfig model
   */ 
  interface PaymentMethodConfigFieldRefs {
    readonly id: FieldRef<"PaymentMethodConfig", 'Int'>
    readonly key: FieldRef<"PaymentMethodConfig", 'String'>
    readonly label: FieldRef<"PaymentMethodConfig", 'String'>
    readonly isActive: FieldRef<"PaymentMethodConfig", 'Boolean'>
    readonly sortOrder: FieldRef<"PaymentMethodConfig", 'Int'>
    readonly createdAt: FieldRef<"PaymentMethodConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethodConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethodConfig findUnique
   */
  export type PaymentMethodConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodConfig to fetch.
     */
    where: PaymentMethodConfigWhereUniqueInput
  }

  /**
   * PaymentMethodConfig findUniqueOrThrow
   */
  export type PaymentMethodConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodConfig to fetch.
     */
    where: PaymentMethodConfigWhereUniqueInput
  }

  /**
   * PaymentMethodConfig findFirst
   */
  export type PaymentMethodConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodConfig to fetch.
     */
    where?: PaymentMethodConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodConfigs to fetch.
     */
    orderBy?: PaymentMethodConfigOrderByWithRelationInput | PaymentMethodConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethodConfigs.
     */
    cursor?: PaymentMethodConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethodConfigs.
     */
    distinct?: PaymentMethodConfigScalarFieldEnum | PaymentMethodConfigScalarFieldEnum[]
  }

  /**
   * PaymentMethodConfig findFirstOrThrow
   */
  export type PaymentMethodConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodConfig to fetch.
     */
    where?: PaymentMethodConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodConfigs to fetch.
     */
    orderBy?: PaymentMethodConfigOrderByWithRelationInput | PaymentMethodConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethodConfigs.
     */
    cursor?: PaymentMethodConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethodConfigs.
     */
    distinct?: PaymentMethodConfigScalarFieldEnum | PaymentMethodConfigScalarFieldEnum[]
  }

  /**
   * PaymentMethodConfig findMany
   */
  export type PaymentMethodConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodConfigs to fetch.
     */
    where?: PaymentMethodConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodConfigs to fetch.
     */
    orderBy?: PaymentMethodConfigOrderByWithRelationInput | PaymentMethodConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethodConfigs.
     */
    cursor?: PaymentMethodConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodConfigs.
     */
    skip?: number
    distinct?: PaymentMethodConfigScalarFieldEnum | PaymentMethodConfigScalarFieldEnum[]
  }

  /**
   * PaymentMethodConfig create
   */
  export type PaymentMethodConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethodConfig.
     */
    data: XOR<PaymentMethodConfigCreateInput, PaymentMethodConfigUncheckedCreateInput>
  }

  /**
   * PaymentMethodConfig createMany
   */
  export type PaymentMethodConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethodConfigs.
     */
    data: PaymentMethodConfigCreateManyInput | PaymentMethodConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethodConfig createManyAndReturn
   */
  export type PaymentMethodConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentMethodConfigs.
     */
    data: PaymentMethodConfigCreateManyInput | PaymentMethodConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethodConfig update
   */
  export type PaymentMethodConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethodConfig.
     */
    data: XOR<PaymentMethodConfigUpdateInput, PaymentMethodConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethodConfig to update.
     */
    where: PaymentMethodConfigWhereUniqueInput
  }

  /**
   * PaymentMethodConfig updateMany
   */
  export type PaymentMethodConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethodConfigs.
     */
    data: XOR<PaymentMethodConfigUpdateManyMutationInput, PaymentMethodConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethodConfigs to update
     */
    where?: PaymentMethodConfigWhereInput
  }

  /**
   * PaymentMethodConfig upsert
   */
  export type PaymentMethodConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethodConfig to update in case it exists.
     */
    where: PaymentMethodConfigWhereUniqueInput
    /**
     * In case the PaymentMethodConfig found by the `where` argument doesn't exist, create a new PaymentMethodConfig with this data.
     */
    create: XOR<PaymentMethodConfigCreateInput, PaymentMethodConfigUncheckedCreateInput>
    /**
     * In case the PaymentMethodConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodConfigUpdateInput, PaymentMethodConfigUncheckedUpdateInput>
  }

  /**
   * PaymentMethodConfig delete
   */
  export type PaymentMethodConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethodConfig to delete.
     */
    where: PaymentMethodConfigWhereUniqueInput
  }

  /**
   * PaymentMethodConfig deleteMany
   */
  export type PaymentMethodConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethodConfigs to delete
     */
    where?: PaymentMethodConfigWhereInput
  }

  /**
   * PaymentMethodConfig.providers
   */
  export type PaymentMethodConfig$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    where?: PaymentProviderConfigWhereInput
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    cursor?: PaymentProviderConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentMethodConfig without action
   */
  export type PaymentMethodConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodConfig
     */
    select?: PaymentMethodConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodConfigInclude<ExtArgs> | null
  }


  /**
   * Model PaymentProviderConfig
   */

  export type AggregatePaymentProviderConfig = {
    _count: PaymentProviderConfigCountAggregateOutputType | null
    _avg: PaymentProviderConfigAvgAggregateOutputType | null
    _sum: PaymentProviderConfigSumAggregateOutputType | null
    _min: PaymentProviderConfigMinAggregateOutputType | null
    _max: PaymentProviderConfigMaxAggregateOutputType | null
  }

  export type PaymentProviderConfigAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type PaymentProviderConfigSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type PaymentProviderConfigMinAggregateOutputType = {
    id: number | null
    methodKey: string | null
    name: string | null
    isActive: boolean | null
    sortOrder: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentProviderConfigMaxAggregateOutputType = {
    id: number | null
    methodKey: string | null
    name: string | null
    isActive: boolean | null
    sortOrder: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentProviderConfigCountAggregateOutputType = {
    id: number
    methodKey: number
    name: number
    isActive: number
    sortOrder: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentProviderConfigAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type PaymentProviderConfigSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type PaymentProviderConfigMinAggregateInputType = {
    id?: true
    methodKey?: true
    name?: true
    isActive?: true
    sortOrder?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentProviderConfigMaxAggregateInputType = {
    id?: true
    methodKey?: true
    name?: true
    isActive?: true
    sortOrder?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentProviderConfigCountAggregateInputType = {
    id?: true
    methodKey?: true
    name?: true
    isActive?: true
    sortOrder?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentProviderConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentProviderConfig to aggregate.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentProviderConfigs
    **/
    _count?: true | PaymentProviderConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentProviderConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentProviderConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentProviderConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentProviderConfigMaxAggregateInputType
  }

  export type GetPaymentProviderConfigAggregateType<T extends PaymentProviderConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentProviderConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentProviderConfig[P]>
      : GetScalarType<T[P], AggregatePaymentProviderConfig[P]>
  }




  export type PaymentProviderConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentProviderConfigWhereInput
    orderBy?: PaymentProviderConfigOrderByWithAggregationInput | PaymentProviderConfigOrderByWithAggregationInput[]
    by: PaymentProviderConfigScalarFieldEnum[] | PaymentProviderConfigScalarFieldEnum
    having?: PaymentProviderConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentProviderConfigCountAggregateInputType | true
    _avg?: PaymentProviderConfigAvgAggregateInputType
    _sum?: PaymentProviderConfigSumAggregateInputType
    _min?: PaymentProviderConfigMinAggregateInputType
    _max?: PaymentProviderConfigMaxAggregateInputType
  }

  export type PaymentProviderConfigGroupByOutputType = {
    id: number
    methodKey: string
    name: string
    isActive: boolean
    sortOrder: number
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentProviderConfigCountAggregateOutputType | null
    _avg: PaymentProviderConfigAvgAggregateOutputType | null
    _sum: PaymentProviderConfigSumAggregateOutputType | null
    _min: PaymentProviderConfigMinAggregateOutputType | null
    _max: PaymentProviderConfigMaxAggregateOutputType | null
  }

  type GetPaymentProviderConfigGroupByPayload<T extends PaymentProviderConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentProviderConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentProviderConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentProviderConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentProviderConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentProviderConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    methodKey?: boolean
    name?: boolean
    isActive?: boolean
    sortOrder?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    method?: boolean | PaymentMethodConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentProviderConfig"]>

  export type PaymentProviderConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    methodKey?: boolean
    name?: boolean
    isActive?: boolean
    sortOrder?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    method?: boolean | PaymentMethodConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentProviderConfig"]>

  export type PaymentProviderConfigSelectScalar = {
    id?: boolean
    methodKey?: boolean
    name?: boolean
    isActive?: boolean
    sortOrder?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentProviderConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    method?: boolean | PaymentMethodConfigDefaultArgs<ExtArgs>
  }
  export type PaymentProviderConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    method?: boolean | PaymentMethodConfigDefaultArgs<ExtArgs>
  }

  export type $PaymentProviderConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentProviderConfig"
    objects: {
      method: Prisma.$PaymentMethodConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      methodKey: string
      name: string
      isActive: boolean
      sortOrder: number
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentProviderConfig"]>
    composites: {}
  }

  type PaymentProviderConfigGetPayload<S extends boolean | null | undefined | PaymentProviderConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentProviderConfigPayload, S>

  type PaymentProviderConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentProviderConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentProviderConfigCountAggregateInputType | true
    }

  export interface PaymentProviderConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentProviderConfig'], meta: { name: 'PaymentProviderConfig' } }
    /**
     * Find zero or one PaymentProviderConfig that matches the filter.
     * @param {PaymentProviderConfigFindUniqueArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentProviderConfigFindUniqueArgs>(args: SelectSubset<T, PaymentProviderConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentProviderConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentProviderConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentProviderConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentProviderConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentProviderConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigFindFirstArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentProviderConfigFindFirstArgs>(args?: SelectSubset<T, PaymentProviderConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentProviderConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentProviderConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentProviderConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentProviderConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentProviderConfigs
     * const paymentProviderConfigs = await prisma.paymentProviderConfig.findMany()
     * 
     * // Get first 10 PaymentProviderConfigs
     * const paymentProviderConfigs = await prisma.paymentProviderConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentProviderConfigWithIdOnly = await prisma.paymentProviderConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentProviderConfigFindManyArgs>(args?: SelectSubset<T, PaymentProviderConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentProviderConfig.
     * @param {PaymentProviderConfigCreateArgs} args - Arguments to create a PaymentProviderConfig.
     * @example
     * // Create one PaymentProviderConfig
     * const PaymentProviderConfig = await prisma.paymentProviderConfig.create({
     *   data: {
     *     // ... data to create a PaymentProviderConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentProviderConfigCreateArgs>(args: SelectSubset<T, PaymentProviderConfigCreateArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentProviderConfigs.
     * @param {PaymentProviderConfigCreateManyArgs} args - Arguments to create many PaymentProviderConfigs.
     * @example
     * // Create many PaymentProviderConfigs
     * const paymentProviderConfig = await prisma.paymentProviderConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentProviderConfigCreateManyArgs>(args?: SelectSubset<T, PaymentProviderConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentProviderConfigs and returns the data saved in the database.
     * @param {PaymentProviderConfigCreateManyAndReturnArgs} args - Arguments to create many PaymentProviderConfigs.
     * @example
     * // Create many PaymentProviderConfigs
     * const paymentProviderConfig = await prisma.paymentProviderConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentProviderConfigs and only return the `id`
     * const paymentProviderConfigWithIdOnly = await prisma.paymentProviderConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentProviderConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentProviderConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentProviderConfig.
     * @param {PaymentProviderConfigDeleteArgs} args - Arguments to delete one PaymentProviderConfig.
     * @example
     * // Delete one PaymentProviderConfig
     * const PaymentProviderConfig = await prisma.paymentProviderConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentProviderConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentProviderConfigDeleteArgs>(args: SelectSubset<T, PaymentProviderConfigDeleteArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentProviderConfig.
     * @param {PaymentProviderConfigUpdateArgs} args - Arguments to update one PaymentProviderConfig.
     * @example
     * // Update one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentProviderConfigUpdateArgs>(args: SelectSubset<T, PaymentProviderConfigUpdateArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentProviderConfigs.
     * @param {PaymentProviderConfigDeleteManyArgs} args - Arguments to filter PaymentProviderConfigs to delete.
     * @example
     * // Delete a few PaymentProviderConfigs
     * const { count } = await prisma.paymentProviderConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentProviderConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentProviderConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentProviderConfigs
     * const paymentProviderConfig = await prisma.paymentProviderConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentProviderConfigUpdateManyArgs>(args: SelectSubset<T, PaymentProviderConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentProviderConfig.
     * @param {PaymentProviderConfigUpsertArgs} args - Arguments to update or create a PaymentProviderConfig.
     * @example
     * // Update or create a PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentProviderConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentProviderConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentProviderConfigUpsertArgs>(args: SelectSubset<T, PaymentProviderConfigUpsertArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigCountArgs} args - Arguments to filter PaymentProviderConfigs to count.
     * @example
     * // Count the number of PaymentProviderConfigs
     * const count = await prisma.paymentProviderConfig.count({
     *   where: {
     *     // ... the filter for the PaymentProviderConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentProviderConfigCountArgs>(
      args?: Subset<T, PaymentProviderConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentProviderConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentProviderConfigAggregateArgs>(args: Subset<T, PaymentProviderConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentProviderConfigAggregateType<T>>

    /**
     * Group by PaymentProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentProviderConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentProviderConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentProviderConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentProviderConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentProviderConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentProviderConfig model
   */
  readonly fields: PaymentProviderConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentProviderConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentProviderConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    method<T extends PaymentMethodConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodConfigDefaultArgs<ExtArgs>>): Prisma__PaymentMethodConfigClient<$Result.GetResult<Prisma.$PaymentMethodConfigPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentProviderConfig model
   */ 
  interface PaymentProviderConfigFieldRefs {
    readonly id: FieldRef<"PaymentProviderConfig", 'Int'>
    readonly methodKey: FieldRef<"PaymentProviderConfig", 'String'>
    readonly name: FieldRef<"PaymentProviderConfig", 'String'>
    readonly isActive: FieldRef<"PaymentProviderConfig", 'Boolean'>
    readonly sortOrder: FieldRef<"PaymentProviderConfig", 'Int'>
    readonly note: FieldRef<"PaymentProviderConfig", 'String'>
    readonly createdAt: FieldRef<"PaymentProviderConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentProviderConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentProviderConfig findUnique
   */
  export type PaymentProviderConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig findUniqueOrThrow
   */
  export type PaymentProviderConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig findFirst
   */
  export type PaymentProviderConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentProviderConfigs.
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentProviderConfigs.
     */
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentProviderConfig findFirstOrThrow
   */
  export type PaymentProviderConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentProviderConfigs.
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentProviderConfigs.
     */
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentProviderConfig findMany
   */
  export type PaymentProviderConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfigs to fetch.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentProviderConfigs.
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentProviderConfig create
   */
  export type PaymentProviderConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentProviderConfig.
     */
    data: XOR<PaymentProviderConfigCreateInput, PaymentProviderConfigUncheckedCreateInput>
  }

  /**
   * PaymentProviderConfig createMany
   */
  export type PaymentProviderConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentProviderConfigs.
     */
    data: PaymentProviderConfigCreateManyInput | PaymentProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentProviderConfig createManyAndReturn
   */
  export type PaymentProviderConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentProviderConfigs.
     */
    data: PaymentProviderConfigCreateManyInput | PaymentProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentProviderConfig update
   */
  export type PaymentProviderConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentProviderConfig.
     */
    data: XOR<PaymentProviderConfigUpdateInput, PaymentProviderConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentProviderConfig to update.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig updateMany
   */
  export type PaymentProviderConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentProviderConfigs.
     */
    data: XOR<PaymentProviderConfigUpdateManyMutationInput, PaymentProviderConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentProviderConfigs to update
     */
    where?: PaymentProviderConfigWhereInput
  }

  /**
   * PaymentProviderConfig upsert
   */
  export type PaymentProviderConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentProviderConfig to update in case it exists.
     */
    where: PaymentProviderConfigWhereUniqueInput
    /**
     * In case the PaymentProviderConfig found by the `where` argument doesn't exist, create a new PaymentProviderConfig with this data.
     */
    create: XOR<PaymentProviderConfigCreateInput, PaymentProviderConfigUncheckedCreateInput>
    /**
     * In case the PaymentProviderConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentProviderConfigUpdateInput, PaymentProviderConfigUncheckedUpdateInput>
  }

  /**
   * PaymentProviderConfig delete
   */
  export type PaymentProviderConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter which PaymentProviderConfig to delete.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig deleteMany
   */
  export type PaymentProviderConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentProviderConfigs to delete
     */
    where?: PaymentProviderConfigWhereInput
  }

  /**
   * PaymentProviderConfig without action
   */
  export type PaymentProviderConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
  }


  /**
   * Model QPayIntent
   */

  export type AggregateQPayIntent = {
    _count: QPayIntentCountAggregateOutputType | null
    _avg: QPayIntentAvgAggregateOutputType | null
    _sum: QPayIntentSumAggregateOutputType | null
    _min: QPayIntentMinAggregateOutputType | null
    _max: QPayIntentMaxAggregateOutputType | null
  }

  export type QPayIntentAvgAggregateOutputType = {
    id: number | null
    objectId: number | null
    amount: number | null
    paidAmount: number | null
  }

  export type QPayIntentSumAggregateOutputType = {
    id: number | null
    objectId: number | null
    amount: number | null
    paidAmount: number | null
  }

  export type QPayIntentMinAggregateOutputType = {
    id: number | null
    environment: string | null
    objectType: string | null
    objectId: number | null
    qpayInvoiceId: string | null
    senderInvoiceNo: string | null
    amount: number | null
    status: string | null
    paidAmount: number | null
    qpayPaymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QPayIntentMaxAggregateOutputType = {
    id: number | null
    environment: string | null
    objectType: string | null
    objectId: number | null
    qpayInvoiceId: string | null
    senderInvoiceNo: string | null
    amount: number | null
    status: string | null
    paidAmount: number | null
    qpayPaymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QPayIntentCountAggregateOutputType = {
    id: number
    environment: number
    objectType: number
    objectId: number
    qpayInvoiceId: number
    senderInvoiceNo: number
    amount: number
    status: number
    paidAmount: number
    qpayPaymentId: number
    raw: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QPayIntentAvgAggregateInputType = {
    id?: true
    objectId?: true
    amount?: true
    paidAmount?: true
  }

  export type QPayIntentSumAggregateInputType = {
    id?: true
    objectId?: true
    amount?: true
    paidAmount?: true
  }

  export type QPayIntentMinAggregateInputType = {
    id?: true
    environment?: true
    objectType?: true
    objectId?: true
    qpayInvoiceId?: true
    senderInvoiceNo?: true
    amount?: true
    status?: true
    paidAmount?: true
    qpayPaymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QPayIntentMaxAggregateInputType = {
    id?: true
    environment?: true
    objectType?: true
    objectId?: true
    qpayInvoiceId?: true
    senderInvoiceNo?: true
    amount?: true
    status?: true
    paidAmount?: true
    qpayPaymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QPayIntentCountAggregateInputType = {
    id?: true
    environment?: true
    objectType?: true
    objectId?: true
    qpayInvoiceId?: true
    senderInvoiceNo?: true
    amount?: true
    status?: true
    paidAmount?: true
    qpayPaymentId?: true
    raw?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QPayIntentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QPayIntent to aggregate.
     */
    where?: QPayIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayIntents to fetch.
     */
    orderBy?: QPayIntentOrderByWithRelationInput | QPayIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QPayIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QPayIntents
    **/
    _count?: true | QPayIntentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QPayIntentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QPayIntentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QPayIntentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QPayIntentMaxAggregateInputType
  }

  export type GetQPayIntentAggregateType<T extends QPayIntentAggregateArgs> = {
        [P in keyof T & keyof AggregateQPayIntent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQPayIntent[P]>
      : GetScalarType<T[P], AggregateQPayIntent[P]>
  }




  export type QPayIntentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QPayIntentWhereInput
    orderBy?: QPayIntentOrderByWithAggregationInput | QPayIntentOrderByWithAggregationInput[]
    by: QPayIntentScalarFieldEnum[] | QPayIntentScalarFieldEnum
    having?: QPayIntentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QPayIntentCountAggregateInputType | true
    _avg?: QPayIntentAvgAggregateInputType
    _sum?: QPayIntentSumAggregateInputType
    _min?: QPayIntentMinAggregateInputType
    _max?: QPayIntentMaxAggregateInputType
  }

  export type QPayIntentGroupByOutputType = {
    id: number
    environment: string
    objectType: string
    objectId: number
    qpayInvoiceId: string
    senderInvoiceNo: string
    amount: number
    status: string
    paidAmount: number | null
    qpayPaymentId: string | null
    raw: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QPayIntentCountAggregateOutputType | null
    _avg: QPayIntentAvgAggregateOutputType | null
    _sum: QPayIntentSumAggregateOutputType | null
    _min: QPayIntentMinAggregateOutputType | null
    _max: QPayIntentMaxAggregateOutputType | null
  }

  type GetQPayIntentGroupByPayload<T extends QPayIntentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QPayIntentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QPayIntentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QPayIntentGroupByOutputType[P]>
            : GetScalarType<T[P], QPayIntentGroupByOutputType[P]>
        }
      >
    >


  export type QPayIntentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    environment?: boolean
    objectType?: boolean
    objectId?: boolean
    qpayInvoiceId?: boolean
    senderInvoiceNo?: boolean
    amount?: boolean
    status?: boolean
    paidAmount?: boolean
    qpayPaymentId?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qPayIntent"]>

  export type QPayIntentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    environment?: boolean
    objectType?: boolean
    objectId?: boolean
    qpayInvoiceId?: boolean
    senderInvoiceNo?: boolean
    amount?: boolean
    status?: boolean
    paidAmount?: boolean
    qpayPaymentId?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["qPayIntent"]>

  export type QPayIntentSelectScalar = {
    id?: boolean
    environment?: boolean
    objectType?: boolean
    objectId?: boolean
    qpayInvoiceId?: boolean
    senderInvoiceNo?: boolean
    amount?: boolean
    status?: boolean
    paidAmount?: boolean
    qpayPaymentId?: boolean
    raw?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $QPayIntentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QPayIntent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      environment: string
      objectType: string
      objectId: number
      qpayInvoiceId: string
      senderInvoiceNo: string
      amount: number
      status: string
      paidAmount: number | null
      qpayPaymentId: string | null
      raw: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qPayIntent"]>
    composites: {}
  }

  type QPayIntentGetPayload<S extends boolean | null | undefined | QPayIntentDefaultArgs> = $Result.GetResult<Prisma.$QPayIntentPayload, S>

  type QPayIntentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QPayIntentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QPayIntentCountAggregateInputType | true
    }

  export interface QPayIntentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QPayIntent'], meta: { name: 'QPayIntent' } }
    /**
     * Find zero or one QPayIntent that matches the filter.
     * @param {QPayIntentFindUniqueArgs} args - Arguments to find a QPayIntent
     * @example
     * // Get one QPayIntent
     * const qPayIntent = await prisma.qPayIntent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QPayIntentFindUniqueArgs>(args: SelectSubset<T, QPayIntentFindUniqueArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QPayIntent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QPayIntentFindUniqueOrThrowArgs} args - Arguments to find a QPayIntent
     * @example
     * // Get one QPayIntent
     * const qPayIntent = await prisma.qPayIntent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QPayIntentFindUniqueOrThrowArgs>(args: SelectSubset<T, QPayIntentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QPayIntent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentFindFirstArgs} args - Arguments to find a QPayIntent
     * @example
     * // Get one QPayIntent
     * const qPayIntent = await prisma.qPayIntent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QPayIntentFindFirstArgs>(args?: SelectSubset<T, QPayIntentFindFirstArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QPayIntent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentFindFirstOrThrowArgs} args - Arguments to find a QPayIntent
     * @example
     * // Get one QPayIntent
     * const qPayIntent = await prisma.qPayIntent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QPayIntentFindFirstOrThrowArgs>(args?: SelectSubset<T, QPayIntentFindFirstOrThrowArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QPayIntents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QPayIntents
     * const qPayIntents = await prisma.qPayIntent.findMany()
     * 
     * // Get first 10 QPayIntents
     * const qPayIntents = await prisma.qPayIntent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qPayIntentWithIdOnly = await prisma.qPayIntent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QPayIntentFindManyArgs>(args?: SelectSubset<T, QPayIntentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QPayIntent.
     * @param {QPayIntentCreateArgs} args - Arguments to create a QPayIntent.
     * @example
     * // Create one QPayIntent
     * const QPayIntent = await prisma.qPayIntent.create({
     *   data: {
     *     // ... data to create a QPayIntent
     *   }
     * })
     * 
     */
    create<T extends QPayIntentCreateArgs>(args: SelectSubset<T, QPayIntentCreateArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QPayIntents.
     * @param {QPayIntentCreateManyArgs} args - Arguments to create many QPayIntents.
     * @example
     * // Create many QPayIntents
     * const qPayIntent = await prisma.qPayIntent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QPayIntentCreateManyArgs>(args?: SelectSubset<T, QPayIntentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QPayIntents and returns the data saved in the database.
     * @param {QPayIntentCreateManyAndReturnArgs} args - Arguments to create many QPayIntents.
     * @example
     * // Create many QPayIntents
     * const qPayIntent = await prisma.qPayIntent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QPayIntents and only return the `id`
     * const qPayIntentWithIdOnly = await prisma.qPayIntent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QPayIntentCreateManyAndReturnArgs>(args?: SelectSubset<T, QPayIntentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QPayIntent.
     * @param {QPayIntentDeleteArgs} args - Arguments to delete one QPayIntent.
     * @example
     * // Delete one QPayIntent
     * const QPayIntent = await prisma.qPayIntent.delete({
     *   where: {
     *     // ... filter to delete one QPayIntent
     *   }
     * })
     * 
     */
    delete<T extends QPayIntentDeleteArgs>(args: SelectSubset<T, QPayIntentDeleteArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QPayIntent.
     * @param {QPayIntentUpdateArgs} args - Arguments to update one QPayIntent.
     * @example
     * // Update one QPayIntent
     * const qPayIntent = await prisma.qPayIntent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QPayIntentUpdateArgs>(args: SelectSubset<T, QPayIntentUpdateArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QPayIntents.
     * @param {QPayIntentDeleteManyArgs} args - Arguments to filter QPayIntents to delete.
     * @example
     * // Delete a few QPayIntents
     * const { count } = await prisma.qPayIntent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QPayIntentDeleteManyArgs>(args?: SelectSubset<T, QPayIntentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QPayIntents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QPayIntents
     * const qPayIntent = await prisma.qPayIntent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QPayIntentUpdateManyArgs>(args: SelectSubset<T, QPayIntentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QPayIntent.
     * @param {QPayIntentUpsertArgs} args - Arguments to update or create a QPayIntent.
     * @example
     * // Update or create a QPayIntent
     * const qPayIntent = await prisma.qPayIntent.upsert({
     *   create: {
     *     // ... data to create a QPayIntent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QPayIntent we want to update
     *   }
     * })
     */
    upsert<T extends QPayIntentUpsertArgs>(args: SelectSubset<T, QPayIntentUpsertArgs<ExtArgs>>): Prisma__QPayIntentClient<$Result.GetResult<Prisma.$QPayIntentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QPayIntents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentCountArgs} args - Arguments to filter QPayIntents to count.
     * @example
     * // Count the number of QPayIntents
     * const count = await prisma.qPayIntent.count({
     *   where: {
     *     // ... the filter for the QPayIntents we want to count
     *   }
     * })
    **/
    count<T extends QPayIntentCountArgs>(
      args?: Subset<T, QPayIntentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QPayIntentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QPayIntent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QPayIntentAggregateArgs>(args: Subset<T, QPayIntentAggregateArgs>): Prisma.PrismaPromise<GetQPayIntentAggregateType<T>>

    /**
     * Group by QPayIntent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QPayIntentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QPayIntentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QPayIntentGroupByArgs['orderBy'] }
        : { orderBy?: QPayIntentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QPayIntentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQPayIntentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QPayIntent model
   */
  readonly fields: QPayIntentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QPayIntent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QPayIntentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QPayIntent model
   */ 
  interface QPayIntentFieldRefs {
    readonly id: FieldRef<"QPayIntent", 'Int'>
    readonly environment: FieldRef<"QPayIntent", 'String'>
    readonly objectType: FieldRef<"QPayIntent", 'String'>
    readonly objectId: FieldRef<"QPayIntent", 'Int'>
    readonly qpayInvoiceId: FieldRef<"QPayIntent", 'String'>
    readonly senderInvoiceNo: FieldRef<"QPayIntent", 'String'>
    readonly amount: FieldRef<"QPayIntent", 'Float'>
    readonly status: FieldRef<"QPayIntent", 'String'>
    readonly paidAmount: FieldRef<"QPayIntent", 'Float'>
    readonly qpayPaymentId: FieldRef<"QPayIntent", 'String'>
    readonly raw: FieldRef<"QPayIntent", 'Json'>
    readonly createdAt: FieldRef<"QPayIntent", 'DateTime'>
    readonly updatedAt: FieldRef<"QPayIntent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QPayIntent findUnique
   */
  export type QPayIntentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * Filter, which QPayIntent to fetch.
     */
    where: QPayIntentWhereUniqueInput
  }

  /**
   * QPayIntent findUniqueOrThrow
   */
  export type QPayIntentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * Filter, which QPayIntent to fetch.
     */
    where: QPayIntentWhereUniqueInput
  }

  /**
   * QPayIntent findFirst
   */
  export type QPayIntentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * Filter, which QPayIntent to fetch.
     */
    where?: QPayIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayIntents to fetch.
     */
    orderBy?: QPayIntentOrderByWithRelationInput | QPayIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QPayIntents.
     */
    cursor?: QPayIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QPayIntents.
     */
    distinct?: QPayIntentScalarFieldEnum | QPayIntentScalarFieldEnum[]
  }

  /**
   * QPayIntent findFirstOrThrow
   */
  export type QPayIntentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * Filter, which QPayIntent to fetch.
     */
    where?: QPayIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayIntents to fetch.
     */
    orderBy?: QPayIntentOrderByWithRelationInput | QPayIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QPayIntents.
     */
    cursor?: QPayIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QPayIntents.
     */
    distinct?: QPayIntentScalarFieldEnum | QPayIntentScalarFieldEnum[]
  }

  /**
   * QPayIntent findMany
   */
  export type QPayIntentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * Filter, which QPayIntents to fetch.
     */
    where?: QPayIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QPayIntents to fetch.
     */
    orderBy?: QPayIntentOrderByWithRelationInput | QPayIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QPayIntents.
     */
    cursor?: QPayIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QPayIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QPayIntents.
     */
    skip?: number
    distinct?: QPayIntentScalarFieldEnum | QPayIntentScalarFieldEnum[]
  }

  /**
   * QPayIntent create
   */
  export type QPayIntentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * The data needed to create a QPayIntent.
     */
    data: XOR<QPayIntentCreateInput, QPayIntentUncheckedCreateInput>
  }

  /**
   * QPayIntent createMany
   */
  export type QPayIntentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QPayIntents.
     */
    data: QPayIntentCreateManyInput | QPayIntentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QPayIntent createManyAndReturn
   */
  export type QPayIntentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QPayIntents.
     */
    data: QPayIntentCreateManyInput | QPayIntentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QPayIntent update
   */
  export type QPayIntentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * The data needed to update a QPayIntent.
     */
    data: XOR<QPayIntentUpdateInput, QPayIntentUncheckedUpdateInput>
    /**
     * Choose, which QPayIntent to update.
     */
    where: QPayIntentWhereUniqueInput
  }

  /**
   * QPayIntent updateMany
   */
  export type QPayIntentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QPayIntents.
     */
    data: XOR<QPayIntentUpdateManyMutationInput, QPayIntentUncheckedUpdateManyInput>
    /**
     * Filter which QPayIntents to update
     */
    where?: QPayIntentWhereInput
  }

  /**
   * QPayIntent upsert
   */
  export type QPayIntentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * The filter to search for the QPayIntent to update in case it exists.
     */
    where: QPayIntentWhereUniqueInput
    /**
     * In case the QPayIntent found by the `where` argument doesn't exist, create a new QPayIntent with this data.
     */
    create: XOR<QPayIntentCreateInput, QPayIntentUncheckedCreateInput>
    /**
     * In case the QPayIntent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QPayIntentUpdateInput, QPayIntentUncheckedUpdateInput>
  }

  /**
   * QPayIntent delete
   */
  export type QPayIntentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
    /**
     * Filter which QPayIntent to delete.
     */
    where: QPayIntentWhereUniqueInput
  }

  /**
   * QPayIntent deleteMany
   */
  export type QPayIntentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QPayIntents to delete
     */
    where?: QPayIntentWhereInput
  }

  /**
   * QPayIntent without action
   */
  export type QPayIntentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QPayIntent
     */
    select?: QPayIntentSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    createdAt: 'createdAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const EmployeeBenefitScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    code: 'code',
    branchId: 'branchId',
    initialAmount: 'initialAmount',
    remainingAmount: 'remainingAmount',
    fromDate: 'fromDate',
    toDate: 'toDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeBenefitScalarFieldEnum = (typeof EmployeeBenefitScalarFieldEnum)[keyof typeof EmployeeBenefitScalarFieldEnum]


  export const EmployeeBenefitUsageScalarFieldEnum: {
    id: 'id',
    employeeBenefitId: 'employeeBenefitId',
    invoiceId: 'invoiceId',
    encounterId: 'encounterId',
    amountUsed: 'amountUsed',
    patientId: 'patientId',
    patientBookNumber: 'patientBookNumber',
    createdAt: 'createdAt'
  };

  export type EmployeeBenefitUsageScalarFieldEnum = (typeof EmployeeBenefitUsageScalarFieldEnum)[keyof typeof EmployeeBenefitUsageScalarFieldEnum]


  export const SterilizationCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SterilizationCategoryScalarFieldEnum = (typeof SterilizationCategoryScalarFieldEnum)[keyof typeof SterilizationCategoryScalarFieldEnum]


  export const SterilizationItemScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SterilizationItemScalarFieldEnum = (typeof SterilizationItemScalarFieldEnum)[keyof typeof SterilizationItemScalarFieldEnum]


  export const SterilizationIndicatorScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    packageName: 'packageName',
    code: 'code',
    indicatorDate: 'indicatorDate',
    specialistUserId: 'specialistUserId',
    packageQuantity: 'packageQuantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SterilizationIndicatorScalarFieldEnum = (typeof SterilizationIndicatorScalarFieldEnum)[keyof typeof SterilizationIndicatorScalarFieldEnum]


  export const SterilizationIndicatorItemScalarFieldEnum: {
    id: 'id',
    indicatorId: 'indicatorId',
    itemId: 'itemId'
  };

  export type SterilizationIndicatorItemScalarFieldEnum = (typeof SterilizationIndicatorItemScalarFieldEnum)[keyof typeof SterilizationIndicatorItemScalarFieldEnum]


  export const EncounterSterilizationPackageUseScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    indicatorId: 'indicatorId',
    usedQuantity: 'usedQuantity',
    openedByUserId: 'openedByUserId',
    createdAt: 'createdAt'
  };

  export type EncounterSterilizationPackageUseScalarFieldEnum = (typeof EncounterSterilizationPackageUseScalarFieldEnum)[keyof typeof EncounterSterilizationPackageUseScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    ovog: 'ovog',
    name: 'name',
    role: 'role',
    branchId: 'branchId',
    createdAt: 'createdAt',
    phone: 'phone',
    regNo: 'regNo',
    licenseNumber: 'licenseNumber',
    licenseExpiryDate: 'licenseExpiryDate',
    signatureImagePath: 'signatureImagePath',
    stampImagePath: 'stampImagePath',
    idPhotoPath: 'idPhotoPath',
    calendarOrder: 'calendarOrder'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    regNo: 'regNo',
    ovog: 'ovog',
    name: 'name',
    gender: 'gender',
    birthDate: 'birthDate',
    phone: 'phone',
    address: 'address',
    bloodType: 'bloodType',
    citizenship: 'citizenship',
    emergencyPhone: 'emergencyPhone',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    branchId: 'branchId'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const PatientBookScalarFieldEnum: {
    id: 'id',
    bookNumber: 'bookNumber',
    patientId: 'patientId'
  };

  export type PatientBookScalarFieldEnum = (typeof PatientBookScalarFieldEnum)[keyof typeof PatientBookScalarFieldEnum]


  export const VisitCardScalarFieldEnum: {
    id: 'id',
    patientBookId: 'patientBookId',
    type: 'type',
    answers: 'answers',
    patientSignaturePath: 'patientSignaturePath',
    signedAt: 'signedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VisitCardScalarFieldEnum = (typeof VisitCardScalarFieldEnum)[keyof typeof VisitCardScalarFieldEnum]


  export const OrthoCardScalarFieldEnum: {
    id: 'id',
    patientBookId: 'patientBookId',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrthoCardScalarFieldEnum = (typeof OrthoCardScalarFieldEnum)[keyof typeof OrthoCardScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    branchId: 'branchId',
    scheduledAt: 'scheduledAt',
    endAt: 'endAt',
    status: 'status',
    notes: 'notes'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    branchId: 'branchId',
    patientId: 'patientId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    patientBookId: 'patientBookId',
    doctorId: 'doctorId',
    visitDate: 'visitDate',
    notes: 'notes',
    appointmentId: 'appointmentId',
    nurseId: 'nurseId',
    patientSignaturePath: 'patientSignaturePath',
    patientSignedAt: 'patientSignedAt',
    doctorSignaturePath: 'doctorSignaturePath',
    doctorSignedAt: 'doctorSignedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const EncounterConsentScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    type: 'type',
    answers: 'answers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncounterConsentScalarFieldEnum = (typeof EncounterConsentScalarFieldEnum)[keyof typeof EncounterConsentScalarFieldEnum]


  export const ChartToothScalarFieldEnum: {
    id: 'id',
    toothCode: 'toothCode',
    toothGroup: 'toothGroup',
    status: 'status',
    notes: 'notes',
    encounterId: 'encounterId'
  };

  export type ChartToothScalarFieldEnum = (typeof ChartToothScalarFieldEnum)[keyof typeof ChartToothScalarFieldEnum]


  export const ChartNoteScalarFieldEnum: {
    id: 'id',
    chartToothId: 'chartToothId',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ChartNoteScalarFieldEnum = (typeof ChartNoteScalarFieldEnum)[keyof typeof ChartNoteScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const DiagnosisProblemScalarFieldEnum: {
    id: 'id',
    diagnosisId: 'diagnosisId',
    label: 'label',
    order: 'order',
    active: 'active'
  };

  export type DiagnosisProblemScalarFieldEnum = (typeof DiagnosisProblemScalarFieldEnum)[keyof typeof DiagnosisProblemScalarFieldEnum]


  export const EncounterDiagnosisScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    diagnosisId: 'diagnosisId',
    toothCode: 'toothCode',
    selectedProblemIds: 'selectedProblemIds',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type EncounterDiagnosisScalarFieldEnum = (typeof EncounterDiagnosisScalarFieldEnum)[keyof typeof EncounterDiagnosisScalarFieldEnum]


  export const EncounterDiagnosisSterilizationIndicatorScalarFieldEnum: {
    id: 'id',
    encounterDiagnosisId: 'encounterDiagnosisId',
    indicatorId: 'indicatorId',
    createdAt: 'createdAt'
  };

  export type EncounterDiagnosisSterilizationIndicatorScalarFieldEnum = (typeof EncounterDiagnosisSterilizationIndicatorScalarFieldEnum)[keyof typeof EncounterDiagnosisSterilizationIndicatorScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    category: 'category',
    name: 'name',
    price: 'price',
    isActive: 'isActive',
    description: 'description'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceBranchScalarFieldEnum: {
    serviceId: 'serviceId',
    branchId: 'branchId'
  };

  export type ServiceBranchScalarFieldEnum = (typeof ServiceBranchScalarFieldEnum)[keyof typeof ServiceBranchScalarFieldEnum]


  export const EncounterServiceScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    price: 'price'
  };

  export type EncounterServiceScalarFieldEnum = (typeof EncounterServiceScalarFieldEnum)[keyof typeof EncounterServiceScalarFieldEnum]


  export const ProcedureScalarFieldEnum: {
    code: 'code',
    name: 'name',
    price: 'price'
  };

  export type ProcedureScalarFieldEnum = (typeof ProcedureScalarFieldEnum)[keyof typeof ProcedureScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    categoryId: 'categoryId',
    code: 'code',
    name: 'name',
    price: 'price',
    isActive: 'isActive',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductStockMovementScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    productId: 'productId',
    type: 'type',
    quantityDelta: 'quantityDelta',
    invoiceId: 'invoiceId',
    ledgerEntryId: 'ledgerEntryId',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type ProductStockMovementScalarFieldEnum = (typeof ProductStockMovementScalarFieldEnum)[keyof typeof ProductStockMovementScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    doctorNameSnapshot: 'doctorNameSnapshot',
    patientNameSnapshot: 'patientNameSnapshot',
    diagnosisSummary: 'diagnosisSummary',
    clinicNameSnapshot: 'clinicNameSnapshot'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionItemScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    order: 'order',
    drugName: 'drugName',
    durationDays: 'durationDays',
    quantityPerTake: 'quantityPerTake',
    frequencyPerDay: 'frequencyPerDay',
    note: 'note'
  };

  export type PrescriptionItemScalarFieldEnum = (typeof PrescriptionItemScalarFieldEnum)[keyof typeof PrescriptionItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    encounterId: 'encounterId',
    patientId: 'patientId',
    totalAmount: 'totalAmount',
    totalBeforeDiscount: 'totalBeforeDiscount',
    discountPercent: 'discountPercent',
    finalAmount: 'finalAmount',
    statusLegacy: 'statusLegacy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemType: 'itemType',
    serviceId: 'serviceId',
    productId: 'productId',
    procedureCode: 'procedureCode',
    name: 'name',
    unitPrice: 'unitPrice',
    quantity: 'quantity',
    lineTotal: 'lineTotal',
    createdAt: 'createdAt',
    source: 'source'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    amount: 'amount',
    method: 'method',
    qpayTxnId: 'qpayTxnId',
    timestamp: 'timestamp'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const EBarimtReceiptScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    receiptNumber: 'receiptNumber',
    timestamp: 'timestamp'
  };

  export type EBarimtReceiptScalarFieldEnum = (typeof EBarimtReceiptScalarFieldEnum)[keyof typeof EBarimtReceiptScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    patientId: 'patientId',
    invoiceId: 'invoiceId',
    type: 'type',
    amount: 'amount',
    createdById: 'createdById',
    approvedById: 'approvedById',
    approvalCodeId: 'approvalCodeId',
    employeeVoucherId: 'employeeVoucherId',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const AuthorizationCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    purpose: 'purpose',
    isEnabled: 'isEnabled',
    expiresAt: 'expiresAt',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorizationCodeScalarFieldEnum = (typeof AuthorizationCodeScalarFieldEnum)[keyof typeof AuthorizationCodeScalarFieldEnum]


  export const EmployeeVoucherScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    employeeId: 'employeeId',
    code: 'code',
    status: 'status',
    balanceCap: 'balanceCap',
    usedAmount: 'usedAmount',
    eligibility: 'eligibility',
    allowedPatientIds: 'allowedPatientIds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type EmployeeVoucherScalarFieldEnum = (typeof EmployeeVoucherScalarFieldEnum)[keyof typeof EmployeeVoucherScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    encounterId: 'encounterId',
    filePath: 'filePath',
    toothCode: 'toothCode',
    type: 'type'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const DoctorScheduleScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    branchId: 'branchId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note'
  };

  export type DoctorScheduleScalarFieldEnum = (typeof DoctorScheduleScalarFieldEnum)[keyof typeof DoctorScheduleScalarFieldEnum]


  export const ReceptionScheduleScalarFieldEnum: {
    id: 'id',
    receptionId: 'receptionId',
    branchId: 'branchId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note'
  };

  export type ReceptionScheduleScalarFieldEnum = (typeof ReceptionScheduleScalarFieldEnum)[keyof typeof ReceptionScheduleScalarFieldEnum]


  export const DoctorBranchScalarFieldEnum: {
    id: 'id',
    doctorId: 'doctorId',
    branchId: 'branchId'
  };

  export type DoctorBranchScalarFieldEnum = (typeof DoctorBranchScalarFieldEnum)[keyof typeof DoctorBranchScalarFieldEnum]


  export const ReceptionBranchScalarFieldEnum: {
    id: 'id',
    receptionId: 'receptionId',
    branchId: 'branchId'
  };

  export type ReceptionBranchScalarFieldEnum = (typeof ReceptionBranchScalarFieldEnum)[keyof typeof ReceptionBranchScalarFieldEnum]


  export const NurseBranchScalarFieldEnum: {
    id: 'id',
    nurseId: 'nurseId',
    branchId: 'branchId'
  };

  export type NurseBranchScalarFieldEnum = (typeof NurseBranchScalarFieldEnum)[keyof typeof NurseBranchScalarFieldEnum]


  export const NurseScheduleScalarFieldEnum: {
    id: 'id',
    nurseId: 'nurseId',
    branchId: 'branchId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    note: 'note'
  };

  export type NurseScheduleScalarFieldEnum = (typeof NurseScheduleScalarFieldEnum)[keyof typeof NurseScheduleScalarFieldEnum]


  export const PaymentMethodConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    label: 'label',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodConfigScalarFieldEnum = (typeof PaymentMethodConfigScalarFieldEnum)[keyof typeof PaymentMethodConfigScalarFieldEnum]


  export const PaymentProviderConfigScalarFieldEnum: {
    id: 'id',
    methodKey: 'methodKey',
    name: 'name',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentProviderConfigScalarFieldEnum = (typeof PaymentProviderConfigScalarFieldEnum)[keyof typeof PaymentProviderConfigScalarFieldEnum]


  export const QPayIntentScalarFieldEnum: {
    id: 'id',
    environment: 'environment',
    objectType: 'objectType',
    objectId: 'objectId',
    qpayInvoiceId: 'qpayInvoiceId',
    senderInvoiceNo: 'senderInvoiceNo',
    amount: 'amount',
    status: 'status',
    paidAmount: 'paidAmount',
    qpayPaymentId: 'qpayPaymentId',
    raw: 'raw',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QPayIntentScalarFieldEnum = (typeof QPayIntentScalarFieldEnum)[keyof typeof QPayIntentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'VisitCardType'
   */
  export type EnumVisitCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitCardType'>
    


  /**
   * Reference to a field of type 'VisitCardType[]'
   */
  export type ListEnumVisitCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitCardType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProductStockMovementType'
   */
  export type EnumProductStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStockMovementType'>
    


  /**
   * Reference to a field of type 'ProductStockMovementType[]'
   */
  export type ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStockMovementType[]'>
    


  /**
   * Reference to a field of type 'DiscountPercent'
   */
  export type EnumDiscountPercentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountPercent'>
    


  /**
   * Reference to a field of type 'DiscountPercent[]'
   */
  export type ListEnumDiscountPercentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountPercent[]'>
    


  /**
   * Reference to a field of type 'InvoiceItemType'
   */
  export type EnumInvoiceItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemType'>
    


  /**
   * Reference to a field of type 'InvoiceItemType[]'
   */
  export type ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemType[]'>
    


  /**
   * Reference to a field of type 'InvoiceItemSource'
   */
  export type EnumInvoiceItemSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemSource'>
    


  /**
   * Reference to a field of type 'InvoiceItemSource[]'
   */
  export type ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceItemSource[]'>
    


  /**
   * Reference to a field of type 'LedgerEntryType'
   */
  export type EnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType'>
    


  /**
   * Reference to a field of type 'LedgerEntryType[]'
   */
  export type ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryType[]'>
    


  /**
   * Reference to a field of type 'EmployeeVoucherStatus'
   */
  export type EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeVoucherStatus'>
    


  /**
   * Reference to a field of type 'EmployeeVoucherStatus[]'
   */
  export type ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeVoucherStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    products?: ProductListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    productStockMovements?: ProductStockMovementListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
    sterilizationIndicators?: SterilizationIndicatorListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    doctorSchedules?: DoctorScheduleOrderByRelationAggregateInput
    serviceBranches?: ServiceBranchOrderByRelationAggregateInput
    doctorBranches?: DoctorBranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    receptionSchedules?: ReceptionScheduleOrderByRelationAggregateInput
    receptionBranches?: ReceptionBranchOrderByRelationAggregateInput
    nurseSchedules?: NurseScheduleOrderByRelationAggregateInput
    nurseBranches?: NurseBranchOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    productCategories?: ProductCategoryOrderByRelationAggregateInput
    productStockMovements?: ProductStockMovementOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    employeeVouchers?: EmployeeVoucherOrderByRelationAggregateInput
    sterilizationIndicators?: SterilizationIndicatorOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    products?: ProductListRelationFilter
    productCategories?: ProductCategoryListRelationFilter
    productStockMovements?: ProductStockMovementListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
    sterilizationIndicators?: SterilizationIndicatorListRelationFilter
  }, "id">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    name?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type EmployeeBenefitWhereInput = {
    AND?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    OR?: EmployeeBenefitWhereInput[]
    NOT?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    id?: IntFilter<"EmployeeBenefit"> | number
    employeeId?: IntFilter<"EmployeeBenefit"> | number
    code?: StringFilter<"EmployeeBenefit"> | string
    branchId?: IntNullableFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
    usages?: EmployeeBenefitUsageListRelationFilter
  }

  export type EmployeeBenefitOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrderInput | SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrderInput | SortOrder
    toDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    usages?: EmployeeBenefitUsageOrderByRelationAggregateInput
  }

  export type EmployeeBenefitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    OR?: EmployeeBenefitWhereInput[]
    NOT?: EmployeeBenefitWhereInput | EmployeeBenefitWhereInput[]
    employeeId?: IntFilter<"EmployeeBenefit"> | number
    branchId?: IntNullableFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
    usages?: EmployeeBenefitUsageListRelationFilter
  }, "id" | "code">

  export type EmployeeBenefitOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrderInput | SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrderInput | SortOrder
    toDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeBenefitCountOrderByAggregateInput
    _avg?: EmployeeBenefitAvgOrderByAggregateInput
    _max?: EmployeeBenefitMaxOrderByAggregateInput
    _min?: EmployeeBenefitMinOrderByAggregateInput
    _sum?: EmployeeBenefitSumOrderByAggregateInput
  }

  export type EmployeeBenefitScalarWhereWithAggregatesInput = {
    AND?: EmployeeBenefitScalarWhereWithAggregatesInput | EmployeeBenefitScalarWhereWithAggregatesInput[]
    OR?: EmployeeBenefitScalarWhereWithAggregatesInput[]
    NOT?: EmployeeBenefitScalarWhereWithAggregatesInput | EmployeeBenefitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    code?: StringWithAggregatesFilter<"EmployeeBenefit"> | string
    branchId?: IntNullableWithAggregatesFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntWithAggregatesFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableWithAggregatesFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableWithAggregatesFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeBenefit"> | Date | string
  }

  export type EmployeeBenefitUsageWhereInput = {
    AND?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    OR?: EmployeeBenefitUsageWhereInput[]
    NOT?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    id?: IntFilter<"EmployeeBenefitUsage"> | number
    employeeBenefitId?: IntFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntFilter<"EmployeeBenefitUsage"> | number
    patientBookNumber?: StringNullableFilter<"EmployeeBenefitUsage"> | string | null
    createdAt?: DateTimeFilter<"EmployeeBenefitUsage"> | Date | string
    employeeBenefit?: XOR<EmployeeBenefitRelationFilter, EmployeeBenefitWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type EmployeeBenefitUsageOrderByWithRelationInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    patientBookNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    employeeBenefit?: EmployeeBenefitOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type EmployeeBenefitUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    OR?: EmployeeBenefitUsageWhereInput[]
    NOT?: EmployeeBenefitUsageWhereInput | EmployeeBenefitUsageWhereInput[]
    employeeBenefitId?: IntFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntFilter<"EmployeeBenefitUsage"> | number
    patientBookNumber?: StringNullableFilter<"EmployeeBenefitUsage"> | string | null
    createdAt?: DateTimeFilter<"EmployeeBenefitUsage"> | Date | string
    employeeBenefit?: XOR<EmployeeBenefitRelationFilter, EmployeeBenefitWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type EmployeeBenefitUsageOrderByWithAggregationInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    patientBookNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmployeeBenefitUsageCountOrderByAggregateInput
    _avg?: EmployeeBenefitUsageAvgOrderByAggregateInput
    _max?: EmployeeBenefitUsageMaxOrderByAggregateInput
    _min?: EmployeeBenefitUsageMinOrderByAggregateInput
    _sum?: EmployeeBenefitUsageSumOrderByAggregateInput
  }

  export type EmployeeBenefitUsageScalarWhereWithAggregatesInput = {
    AND?: EmployeeBenefitUsageScalarWhereWithAggregatesInput | EmployeeBenefitUsageScalarWhereWithAggregatesInput[]
    OR?: EmployeeBenefitUsageScalarWhereWithAggregatesInput[]
    NOT?: EmployeeBenefitUsageScalarWhereWithAggregatesInput | EmployeeBenefitUsageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    employeeBenefitId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntWithAggregatesFilter<"EmployeeBenefitUsage"> | number
    patientBookNumber?: StringNullableWithAggregatesFilter<"EmployeeBenefitUsage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeBenefitUsage"> | Date | string
  }

  export type SterilizationCategoryWhereInput = {
    AND?: SterilizationCategoryWhereInput | SterilizationCategoryWhereInput[]
    OR?: SterilizationCategoryWhereInput[]
    NOT?: SterilizationCategoryWhereInput | SterilizationCategoryWhereInput[]
    id?: IntFilter<"SterilizationCategory"> | number
    name?: StringFilter<"SterilizationCategory"> | string
    createdAt?: DateTimeFilter<"SterilizationCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationCategory"> | Date | string
    items?: SterilizationItemListRelationFilter
  }

  export type SterilizationCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: SterilizationItemOrderByRelationAggregateInput
  }

  export type SterilizationCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: SterilizationCategoryWhereInput | SterilizationCategoryWhereInput[]
    OR?: SterilizationCategoryWhereInput[]
    NOT?: SterilizationCategoryWhereInput | SterilizationCategoryWhereInput[]
    createdAt?: DateTimeFilter<"SterilizationCategory"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationCategory"> | Date | string
    items?: SterilizationItemListRelationFilter
  }, "id" | "name">

  export type SterilizationCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SterilizationCategoryCountOrderByAggregateInput
    _avg?: SterilizationCategoryAvgOrderByAggregateInput
    _max?: SterilizationCategoryMaxOrderByAggregateInput
    _min?: SterilizationCategoryMinOrderByAggregateInput
    _sum?: SterilizationCategorySumOrderByAggregateInput
  }

  export type SterilizationCategoryScalarWhereWithAggregatesInput = {
    AND?: SterilizationCategoryScalarWhereWithAggregatesInput | SterilizationCategoryScalarWhereWithAggregatesInput[]
    OR?: SterilizationCategoryScalarWhereWithAggregatesInput[]
    NOT?: SterilizationCategoryScalarWhereWithAggregatesInput | SterilizationCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SterilizationCategory"> | number
    name?: StringWithAggregatesFilter<"SterilizationCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SterilizationCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SterilizationCategory"> | Date | string
  }

  export type SterilizationItemWhereInput = {
    AND?: SterilizationItemWhereInput | SterilizationItemWhereInput[]
    OR?: SterilizationItemWhereInput[]
    NOT?: SterilizationItemWhereInput | SterilizationItemWhereInput[]
    id?: IntFilter<"SterilizationItem"> | number
    categoryId?: IntFilter<"SterilizationItem"> | number
    name?: StringFilter<"SterilizationItem"> | string
    quantity?: IntFilter<"SterilizationItem"> | number
    createdAt?: DateTimeFilter<"SterilizationItem"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationItem"> | Date | string
    category?: XOR<SterilizationCategoryRelationFilter, SterilizationCategoryWhereInput>
    indicatorItems?: SterilizationIndicatorItemListRelationFilter
  }

  export type SterilizationItemOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SterilizationCategoryOrderByWithRelationInput
    indicatorItems?: SterilizationIndicatorItemOrderByRelationAggregateInput
  }

  export type SterilizationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    categoryId_name?: SterilizationItemCategoryIdNameCompoundUniqueInput
    AND?: SterilizationItemWhereInput | SterilizationItemWhereInput[]
    OR?: SterilizationItemWhereInput[]
    NOT?: SterilizationItemWhereInput | SterilizationItemWhereInput[]
    categoryId?: IntFilter<"SterilizationItem"> | number
    name?: StringFilter<"SterilizationItem"> | string
    quantity?: IntFilter<"SterilizationItem"> | number
    createdAt?: DateTimeFilter<"SterilizationItem"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationItem"> | Date | string
    category?: XOR<SterilizationCategoryRelationFilter, SterilizationCategoryWhereInput>
    indicatorItems?: SterilizationIndicatorItemListRelationFilter
  }, "id" | "categoryId_name">

  export type SterilizationItemOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SterilizationItemCountOrderByAggregateInput
    _avg?: SterilizationItemAvgOrderByAggregateInput
    _max?: SterilizationItemMaxOrderByAggregateInput
    _min?: SterilizationItemMinOrderByAggregateInput
    _sum?: SterilizationItemSumOrderByAggregateInput
  }

  export type SterilizationItemScalarWhereWithAggregatesInput = {
    AND?: SterilizationItemScalarWhereWithAggregatesInput | SterilizationItemScalarWhereWithAggregatesInput[]
    OR?: SterilizationItemScalarWhereWithAggregatesInput[]
    NOT?: SterilizationItemScalarWhereWithAggregatesInput | SterilizationItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SterilizationItem"> | number
    categoryId?: IntWithAggregatesFilter<"SterilizationItem"> | number
    name?: StringWithAggregatesFilter<"SterilizationItem"> | string
    quantity?: IntWithAggregatesFilter<"SterilizationItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SterilizationItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SterilizationItem"> | Date | string
  }

  export type SterilizationIndicatorWhereInput = {
    AND?: SterilizationIndicatorWhereInput | SterilizationIndicatorWhereInput[]
    OR?: SterilizationIndicatorWhereInput[]
    NOT?: SterilizationIndicatorWhereInput | SterilizationIndicatorWhereInput[]
    id?: IntFilter<"SterilizationIndicator"> | number
    branchId?: IntFilter<"SterilizationIndicator"> | number
    packageName?: StringFilter<"SterilizationIndicator"> | string
    code?: StringFilter<"SterilizationIndicator"> | string
    indicatorDate?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    specialistUserId?: IntFilter<"SterilizationIndicator"> | number
    packageQuantity?: IntFilter<"SterilizationIndicator"> | number
    createdAt?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    specialist?: XOR<UserRelationFilter, UserWhereInput>
    items?: SterilizationIndicatorItemListRelationFilter
    uses?: EncounterSterilizationPackageUseListRelationFilter
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorListRelationFilter
  }

  export type SterilizationIndicatorOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    packageName?: SortOrder
    code?: SortOrder
    indicatorDate?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    specialist?: UserOrderByWithRelationInput
    items?: SterilizationIndicatorItemOrderByRelationAggregateInput
    uses?: EncounterSterilizationPackageUseOrderByRelationAggregateInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorOrderByRelationAggregateInput
  }

  export type SterilizationIndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SterilizationIndicatorWhereInput | SterilizationIndicatorWhereInput[]
    OR?: SterilizationIndicatorWhereInput[]
    NOT?: SterilizationIndicatorWhereInput | SterilizationIndicatorWhereInput[]
    branchId?: IntFilter<"SterilizationIndicator"> | number
    packageName?: StringFilter<"SterilizationIndicator"> | string
    code?: StringFilter<"SterilizationIndicator"> | string
    indicatorDate?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    specialistUserId?: IntFilter<"SterilizationIndicator"> | number
    packageQuantity?: IntFilter<"SterilizationIndicator"> | number
    createdAt?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    specialist?: XOR<UserRelationFilter, UserWhereInput>
    items?: SterilizationIndicatorItemListRelationFilter
    uses?: EncounterSterilizationPackageUseListRelationFilter
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorListRelationFilter
  }, "id">

  export type SterilizationIndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    packageName?: SortOrder
    code?: SortOrder
    indicatorDate?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SterilizationIndicatorCountOrderByAggregateInput
    _avg?: SterilizationIndicatorAvgOrderByAggregateInput
    _max?: SterilizationIndicatorMaxOrderByAggregateInput
    _min?: SterilizationIndicatorMinOrderByAggregateInput
    _sum?: SterilizationIndicatorSumOrderByAggregateInput
  }

  export type SterilizationIndicatorScalarWhereWithAggregatesInput = {
    AND?: SterilizationIndicatorScalarWhereWithAggregatesInput | SterilizationIndicatorScalarWhereWithAggregatesInput[]
    OR?: SterilizationIndicatorScalarWhereWithAggregatesInput[]
    NOT?: SterilizationIndicatorScalarWhereWithAggregatesInput | SterilizationIndicatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SterilizationIndicator"> | number
    branchId?: IntWithAggregatesFilter<"SterilizationIndicator"> | number
    packageName?: StringWithAggregatesFilter<"SterilizationIndicator"> | string
    code?: StringWithAggregatesFilter<"SterilizationIndicator"> | string
    indicatorDate?: DateTimeWithAggregatesFilter<"SterilizationIndicator"> | Date | string
    specialistUserId?: IntWithAggregatesFilter<"SterilizationIndicator"> | number
    packageQuantity?: IntWithAggregatesFilter<"SterilizationIndicator"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SterilizationIndicator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SterilizationIndicator"> | Date | string
  }

  export type SterilizationIndicatorItemWhereInput = {
    AND?: SterilizationIndicatorItemWhereInput | SterilizationIndicatorItemWhereInput[]
    OR?: SterilizationIndicatorItemWhereInput[]
    NOT?: SterilizationIndicatorItemWhereInput | SterilizationIndicatorItemWhereInput[]
    id?: IntFilter<"SterilizationIndicatorItem"> | number
    indicatorId?: IntFilter<"SterilizationIndicatorItem"> | number
    itemId?: IntFilter<"SterilizationIndicatorItem"> | number
    indicator?: XOR<SterilizationIndicatorRelationFilter, SterilizationIndicatorWhereInput>
    item?: XOR<SterilizationItemRelationFilter, SterilizationItemWhereInput>
  }

  export type SterilizationIndicatorItemOrderByWithRelationInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
    indicator?: SterilizationIndicatorOrderByWithRelationInput
    item?: SterilizationItemOrderByWithRelationInput
  }

  export type SterilizationIndicatorItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    indicatorId_itemId?: SterilizationIndicatorItemIndicatorIdItemIdCompoundUniqueInput
    AND?: SterilizationIndicatorItemWhereInput | SterilizationIndicatorItemWhereInput[]
    OR?: SterilizationIndicatorItemWhereInput[]
    NOT?: SterilizationIndicatorItemWhereInput | SterilizationIndicatorItemWhereInput[]
    indicatorId?: IntFilter<"SterilizationIndicatorItem"> | number
    itemId?: IntFilter<"SterilizationIndicatorItem"> | number
    indicator?: XOR<SterilizationIndicatorRelationFilter, SterilizationIndicatorWhereInput>
    item?: XOR<SterilizationItemRelationFilter, SterilizationItemWhereInput>
  }, "id" | "indicatorId_itemId">

  export type SterilizationIndicatorItemOrderByWithAggregationInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
    _count?: SterilizationIndicatorItemCountOrderByAggregateInput
    _avg?: SterilizationIndicatorItemAvgOrderByAggregateInput
    _max?: SterilizationIndicatorItemMaxOrderByAggregateInput
    _min?: SterilizationIndicatorItemMinOrderByAggregateInput
    _sum?: SterilizationIndicatorItemSumOrderByAggregateInput
  }

  export type SterilizationIndicatorItemScalarWhereWithAggregatesInput = {
    AND?: SterilizationIndicatorItemScalarWhereWithAggregatesInput | SterilizationIndicatorItemScalarWhereWithAggregatesInput[]
    OR?: SterilizationIndicatorItemScalarWhereWithAggregatesInput[]
    NOT?: SterilizationIndicatorItemScalarWhereWithAggregatesInput | SterilizationIndicatorItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SterilizationIndicatorItem"> | number
    indicatorId?: IntWithAggregatesFilter<"SterilizationIndicatorItem"> | number
    itemId?: IntWithAggregatesFilter<"SterilizationIndicatorItem"> | number
  }

  export type EncounterSterilizationPackageUseWhereInput = {
    AND?: EncounterSterilizationPackageUseWhereInput | EncounterSterilizationPackageUseWhereInput[]
    OR?: EncounterSterilizationPackageUseWhereInput[]
    NOT?: EncounterSterilizationPackageUseWhereInput | EncounterSterilizationPackageUseWhereInput[]
    id?: IntFilter<"EncounterSterilizationPackageUse"> | number
    encounterId?: IntFilter<"EncounterSterilizationPackageUse"> | number
    indicatorId?: IntFilter<"EncounterSterilizationPackageUse"> | number
    usedQuantity?: IntFilter<"EncounterSterilizationPackageUse"> | number
    openedByUserId?: IntNullableFilter<"EncounterSterilizationPackageUse"> | number | null
    createdAt?: DateTimeFilter<"EncounterSterilizationPackageUse"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    indicator?: XOR<SterilizationIndicatorRelationFilter, SterilizationIndicatorWhereInput>
    openedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type EncounterSterilizationPackageUseOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    indicator?: SterilizationIndicatorOrderByWithRelationInput
    openedBy?: UserOrderByWithRelationInput
  }

  export type EncounterSterilizationPackageUseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterSterilizationPackageUseWhereInput | EncounterSterilizationPackageUseWhereInput[]
    OR?: EncounterSterilizationPackageUseWhereInput[]
    NOT?: EncounterSterilizationPackageUseWhereInput | EncounterSterilizationPackageUseWhereInput[]
    encounterId?: IntFilter<"EncounterSterilizationPackageUse"> | number
    indicatorId?: IntFilter<"EncounterSterilizationPackageUse"> | number
    usedQuantity?: IntFilter<"EncounterSterilizationPackageUse"> | number
    openedByUserId?: IntNullableFilter<"EncounterSterilizationPackageUse"> | number | null
    createdAt?: DateTimeFilter<"EncounterSterilizationPackageUse"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    indicator?: XOR<SterilizationIndicatorRelationFilter, SterilizationIndicatorWhereInput>
    openedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type EncounterSterilizationPackageUseOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EncounterSterilizationPackageUseCountOrderByAggregateInput
    _avg?: EncounterSterilizationPackageUseAvgOrderByAggregateInput
    _max?: EncounterSterilizationPackageUseMaxOrderByAggregateInput
    _min?: EncounterSterilizationPackageUseMinOrderByAggregateInput
    _sum?: EncounterSterilizationPackageUseSumOrderByAggregateInput
  }

  export type EncounterSterilizationPackageUseScalarWhereWithAggregatesInput = {
    AND?: EncounterSterilizationPackageUseScalarWhereWithAggregatesInput | EncounterSterilizationPackageUseScalarWhereWithAggregatesInput[]
    OR?: EncounterSterilizationPackageUseScalarWhereWithAggregatesInput[]
    NOT?: EncounterSterilizationPackageUseScalarWhereWithAggregatesInput | EncounterSterilizationPackageUseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterSterilizationPackageUse"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterSterilizationPackageUse"> | number
    indicatorId?: IntWithAggregatesFilter<"EncounterSterilizationPackageUse"> | number
    usedQuantity?: IntWithAggregatesFilter<"EncounterSterilizationPackageUse"> | number
    openedByUserId?: IntNullableWithAggregatesFilter<"EncounterSterilizationPackageUse"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EncounterSterilizationPackageUse"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    ovog?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    regNo?: StringNullableFilter<"User"> | string | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableFilter<"User"> | string | null
    stampImagePath?: StringNullableFilter<"User"> | string | null
    idPhotoPath?: StringNullableFilter<"User"> | string | null
    calendarOrder?: IntNullableFilter<"User"> | number | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounters?: EncounterListRelationFilter
    nurseEncounters?: EncounterListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    employeeBenefits?: EmployeeBenefitListRelationFilter
    createdLedgerEntries?: LedgerEntryListRelationFilter
    approvedLedgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
    createdEmployeeVouchers?: EmployeeVoucherListRelationFilter
    authorizationCodes?: AuthorizationCodeListRelationFilter
    sterilizationIndicators?: SterilizationIndicatorListRelationFilter
    openedSterilizationPackages?: EncounterSterilizationPackageUseListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    regNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    signatureImagePath?: SortOrderInput | SortOrder
    stampImagePath?: SortOrderInput | SortOrder
    idPhotoPath?: SortOrderInput | SortOrder
    calendarOrder?: SortOrderInput | SortOrder
    branch?: BranchOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    nurseEncounters?: EncounterOrderByRelationAggregateInput
    doctorSchedules?: DoctorScheduleOrderByRelationAggregateInput
    doctorBranches?: DoctorBranchOrderByRelationAggregateInput
    receptionSchedules?: ReceptionScheduleOrderByRelationAggregateInput
    receptionBranches?: ReceptionBranchOrderByRelationAggregateInput
    nurseSchedules?: NurseScheduleOrderByRelationAggregateInput
    nurseBranches?: NurseBranchOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    employeeBenefits?: EmployeeBenefitOrderByRelationAggregateInput
    createdLedgerEntries?: LedgerEntryOrderByRelationAggregateInput
    approvedLedgerEntries?: LedgerEntryOrderByRelationAggregateInput
    employeeVouchers?: EmployeeVoucherOrderByRelationAggregateInput
    createdEmployeeVouchers?: EmployeeVoucherOrderByRelationAggregateInput
    authorizationCodes?: AuthorizationCodeOrderByRelationAggregateInput
    sterilizationIndicators?: SterilizationIndicatorOrderByRelationAggregateInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    regNo?: string
    licenseNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    ovog?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableFilter<"User"> | string | null
    stampImagePath?: StringNullableFilter<"User"> | string | null
    idPhotoPath?: StringNullableFilter<"User"> | string | null
    calendarOrder?: IntNullableFilter<"User"> | number | null
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounters?: EncounterListRelationFilter
    nurseEncounters?: EncounterListRelationFilter
    doctorSchedules?: DoctorScheduleListRelationFilter
    doctorBranches?: DoctorBranchListRelationFilter
    receptionSchedules?: ReceptionScheduleListRelationFilter
    receptionBranches?: ReceptionBranchListRelationFilter
    nurseSchedules?: NurseScheduleListRelationFilter
    nurseBranches?: NurseBranchListRelationFilter
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    employeeBenefits?: EmployeeBenefitListRelationFilter
    createdLedgerEntries?: LedgerEntryListRelationFilter
    approvedLedgerEntries?: LedgerEntryListRelationFilter
    employeeVouchers?: EmployeeVoucherListRelationFilter
    createdEmployeeVouchers?: EmployeeVoucherListRelationFilter
    authorizationCodes?: AuthorizationCodeListRelationFilter
    sterilizationIndicators?: SterilizationIndicatorListRelationFilter
    openedSterilizationPackages?: EncounterSterilizationPackageUseListRelationFilter
  }, "id" | "email" | "regNo" | "licenseNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    branchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    phone?: SortOrderInput | SortOrder
    regNo?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    signatureImagePath?: SortOrderInput | SortOrder
    stampImagePath?: SortOrderInput | SortOrder
    idPhotoPath?: SortOrderInput | SortOrder
    calendarOrder?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    ovog?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    regNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    licenseNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableWithAggregatesFilter<"User"> | string | null
    stampImagePath?: StringNullableWithAggregatesFilter<"User"> | string | null
    idPhotoPath?: StringNullableWithAggregatesFilter<"User"> | string | null
    calendarOrder?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: IntFilter<"Patient"> | number
    regNo?: StringNullableFilter<"Patient"> | string | null
    ovog?: StringNullableFilter<"Patient"> | string | null
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    citizenship?: StringNullableFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branchId?: IntFilter<"Patient"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patientBook?: XOR<PatientBookNullableRelationFilter, PatientBookWhereInput> | null
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    regNo?: SortOrderInput | SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patientBook?: PatientBookOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    employeeBenefitUsages?: EmployeeBenefitUsageOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    regNo?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    ovog?: StringNullableFilter<"Patient"> | string | null
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    citizenship?: StringNullableFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branchId?: IntFilter<"Patient"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patientBook?: XOR<PatientBookNullableRelationFilter, PatientBookWhereInput> | null
    appointments?: AppointmentListRelationFilter
    bookings?: BookingListRelationFilter
    invoices?: InvoiceListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }, "id" | "regNo">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    regNo?: SortOrderInput | SortOrder
    ovog?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    citizenship?: SortOrderInput | SortOrder
    emergencyPhone?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Patient"> | number
    regNo?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    ovog?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    name?: StringWithAggregatesFilter<"Patient"> | string
    gender?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    bloodType?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    citizenship?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    branchId?: IntWithAggregatesFilter<"Patient"> | number
  }

  export type PatientBookWhereInput = {
    AND?: PatientBookWhereInput | PatientBookWhereInput[]
    OR?: PatientBookWhereInput[]
    NOT?: PatientBookWhereInput | PatientBookWhereInput[]
    id?: IntFilter<"PatientBook"> | number
    bookNumber?: StringFilter<"PatientBook"> | string
    patientId?: IntFilter<"PatientBook"> | number
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    encounters?: EncounterListRelationFilter
    visitCard?: XOR<VisitCardNullableRelationFilter, VisitCardWhereInput> | null
    orthoCard?: XOR<OrthoCardNullableRelationFilter, OrthoCardWhereInput> | null
  }

  export type PatientBookOrderByWithRelationInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
    patient?: PatientOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    visitCard?: VisitCardOrderByWithRelationInput
    orthoCard?: OrthoCardOrderByWithRelationInput
  }

  export type PatientBookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookNumber?: string
    patientId?: number
    AND?: PatientBookWhereInput | PatientBookWhereInput[]
    OR?: PatientBookWhereInput[]
    NOT?: PatientBookWhereInput | PatientBookWhereInput[]
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    encounters?: EncounterListRelationFilter
    visitCard?: XOR<VisitCardNullableRelationFilter, VisitCardWhereInput> | null
    orthoCard?: XOR<OrthoCardNullableRelationFilter, OrthoCardWhereInput> | null
  }, "id" | "bookNumber" | "patientId">

  export type PatientBookOrderByWithAggregationInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
    _count?: PatientBookCountOrderByAggregateInput
    _avg?: PatientBookAvgOrderByAggregateInput
    _max?: PatientBookMaxOrderByAggregateInput
    _min?: PatientBookMinOrderByAggregateInput
    _sum?: PatientBookSumOrderByAggregateInput
  }

  export type PatientBookScalarWhereWithAggregatesInput = {
    AND?: PatientBookScalarWhereWithAggregatesInput | PatientBookScalarWhereWithAggregatesInput[]
    OR?: PatientBookScalarWhereWithAggregatesInput[]
    NOT?: PatientBookScalarWhereWithAggregatesInput | PatientBookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PatientBook"> | number
    bookNumber?: StringWithAggregatesFilter<"PatientBook"> | string
    patientId?: IntWithAggregatesFilter<"PatientBook"> | number
  }

  export type VisitCardWhereInput = {
    AND?: VisitCardWhereInput | VisitCardWhereInput[]
    OR?: VisitCardWhereInput[]
    NOT?: VisitCardWhereInput | VisitCardWhereInput[]
    id?: IntFilter<"VisitCard"> | number
    patientBookId?: IntFilter<"VisitCard"> | number
    type?: EnumVisitCardTypeFilter<"VisitCard"> | $Enums.VisitCardType
    answers?: JsonFilter<"VisitCard">
    patientSignaturePath?: StringNullableFilter<"VisitCard"> | string | null
    signedAt?: DateTimeNullableFilter<"VisitCard"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitCard"> | Date | string
    updatedAt?: DateTimeFilter<"VisitCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }

  export type VisitCardOrderByWithRelationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientBook?: PatientBookOrderByWithRelationInput
  }

  export type VisitCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    patientBookId?: number
    AND?: VisitCardWhereInput | VisitCardWhereInput[]
    OR?: VisitCardWhereInput[]
    NOT?: VisitCardWhereInput | VisitCardWhereInput[]
    type?: EnumVisitCardTypeFilter<"VisitCard"> | $Enums.VisitCardType
    answers?: JsonFilter<"VisitCard">
    patientSignaturePath?: StringNullableFilter<"VisitCard"> | string | null
    signedAt?: DateTimeNullableFilter<"VisitCard"> | Date | string | null
    createdAt?: DateTimeFilter<"VisitCard"> | Date | string
    updatedAt?: DateTimeFilter<"VisitCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }, "id" | "patientBookId">

  export type VisitCardOrderByWithAggregationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VisitCardCountOrderByAggregateInput
    _avg?: VisitCardAvgOrderByAggregateInput
    _max?: VisitCardMaxOrderByAggregateInput
    _min?: VisitCardMinOrderByAggregateInput
    _sum?: VisitCardSumOrderByAggregateInput
  }

  export type VisitCardScalarWhereWithAggregatesInput = {
    AND?: VisitCardScalarWhereWithAggregatesInput | VisitCardScalarWhereWithAggregatesInput[]
    OR?: VisitCardScalarWhereWithAggregatesInput[]
    NOT?: VisitCardScalarWhereWithAggregatesInput | VisitCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VisitCard"> | number
    patientBookId?: IntWithAggregatesFilter<"VisitCard"> | number
    type?: EnumVisitCardTypeWithAggregatesFilter<"VisitCard"> | $Enums.VisitCardType
    answers?: JsonWithAggregatesFilter<"VisitCard">
    patientSignaturePath?: StringNullableWithAggregatesFilter<"VisitCard"> | string | null
    signedAt?: DateTimeNullableWithAggregatesFilter<"VisitCard"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisitCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VisitCard"> | Date | string
  }

  export type OrthoCardWhereInput = {
    AND?: OrthoCardWhereInput | OrthoCardWhereInput[]
    OR?: OrthoCardWhereInput[]
    NOT?: OrthoCardWhereInput | OrthoCardWhereInput[]
    id?: IntFilter<"OrthoCard"> | number
    patientBookId?: IntFilter<"OrthoCard"> | number
    data?: JsonFilter<"OrthoCard">
    createdAt?: DateTimeFilter<"OrthoCard"> | Date | string
    updatedAt?: DateTimeFilter<"OrthoCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }

  export type OrthoCardOrderByWithRelationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patientBook?: PatientBookOrderByWithRelationInput
  }

  export type OrthoCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    patientBookId?: number
    AND?: OrthoCardWhereInput | OrthoCardWhereInput[]
    OR?: OrthoCardWhereInput[]
    NOT?: OrthoCardWhereInput | OrthoCardWhereInput[]
    data?: JsonFilter<"OrthoCard">
    createdAt?: DateTimeFilter<"OrthoCard"> | Date | string
    updatedAt?: DateTimeFilter<"OrthoCard"> | Date | string
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
  }, "id" | "patientBookId">

  export type OrthoCardOrderByWithAggregationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrthoCardCountOrderByAggregateInput
    _avg?: OrthoCardAvgOrderByAggregateInput
    _max?: OrthoCardMaxOrderByAggregateInput
    _min?: OrthoCardMinOrderByAggregateInput
    _sum?: OrthoCardSumOrderByAggregateInput
  }

  export type OrthoCardScalarWhereWithAggregatesInput = {
    AND?: OrthoCardScalarWhereWithAggregatesInput | OrthoCardScalarWhereWithAggregatesInput[]
    OR?: OrthoCardScalarWhereWithAggregatesInput[]
    NOT?: OrthoCardScalarWhereWithAggregatesInput | OrthoCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrthoCard"> | number
    patientBookId?: IntWithAggregatesFilter<"OrthoCard"> | number
    data?: JsonWithAggregatesFilter<"OrthoCard">
    createdAt?: DateTimeWithAggregatesFilter<"OrthoCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrthoCard"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntNullableFilter<"Appointment"> | number | null
    branchId?: IntFilter<"Appointment"> | number
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntNullableFilter<"Appointment"> | number | null
    branchId?: IntFilter<"Appointment"> | number
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    patientId?: IntWithAggregatesFilter<"Appointment"> | number
    doctorId?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    branchId?: IntWithAggregatesFilter<"Appointment"> | number
    scheduledAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableWithAggregatesFilter<"Appointment"> | Date | string | null
    status?: StringWithAggregatesFilter<"Appointment"> | string
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    doctorId?: IntFilter<"Booking"> | number
    branchId?: IntFilter<"Booking"> | number
    patientId?: IntFilter<"Booking"> | number
    date?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    doctorId?: IntFilter<"Booking"> | number
    branchId?: IntFilter<"Booking"> | number
    patientId?: IntFilter<"Booking"> | number
    date?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    doctorId?: IntWithAggregatesFilter<"Booking"> | number
    branchId?: IntWithAggregatesFilter<"Booking"> | number
    patientId?: IntWithAggregatesFilter<"Booking"> | number
    date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    startTime?: StringWithAggregatesFilter<"Booking"> | string
    endTime?: StringWithAggregatesFilter<"Booking"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: IntFilter<"Encounter"> | number
    patientBookId?: IntFilter<"Encounter"> | number
    doctorId?: IntFilter<"Encounter"> | number
    visitDate?: DateTimeFilter<"Encounter"> | Date | string
    notes?: StringNullableFilter<"Encounter"> | string | null
    appointmentId?: IntNullableFilter<"Encounter"> | number | null
    nurseId?: IntNullableFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
    nurse?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    chartTeeth?: ChartToothListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    media?: MediaListRelationFilter
    encounterServices?: EncounterServiceListRelationFilter
    diagnoses?: EncounterDiagnosisListRelationFilter
    consents?: EncounterConsentListRelationFilter
    sterilizationPackageUses?: EncounterSterilizationPackageUseListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    nurseId?: SortOrderInput | SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    patientSignedAt?: SortOrderInput | SortOrder
    doctorSignaturePath?: SortOrderInput | SortOrder
    doctorSignedAt?: SortOrderInput | SortOrder
    patientBook?: PatientBookOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
    nurse?: UserOrderByWithRelationInput
    chartTeeth?: ChartToothOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    media?: MediaOrderByRelationAggregateInput
    encounterServices?: EncounterServiceOrderByRelationAggregateInput
    diagnoses?: EncounterDiagnosisOrderByRelationAggregateInput
    consents?: EncounterConsentOrderByRelationAggregateInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseOrderByRelationAggregateInput
    employeeBenefitUsages?: EmployeeBenefitUsageOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    patientBookId?: IntFilter<"Encounter"> | number
    doctorId?: IntFilter<"Encounter"> | number
    visitDate?: DateTimeFilter<"Encounter"> | Date | string
    notes?: StringNullableFilter<"Encounter"> | string | null
    appointmentId?: IntNullableFilter<"Encounter"> | number | null
    nurseId?: IntNullableFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    patientBook?: XOR<PatientBookRelationFilter, PatientBookWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
    nurse?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    chartTeeth?: ChartToothListRelationFilter
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    media?: MediaListRelationFilter
    encounterServices?: EncounterServiceListRelationFilter
    diagnoses?: EncounterDiagnosisListRelationFilter
    consents?: EncounterConsentListRelationFilter
    sterilizationPackageUses?: EncounterSterilizationPackageUseListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    nurseId?: SortOrderInput | SortOrder
    patientSignaturePath?: SortOrderInput | SortOrder
    patientSignedAt?: SortOrderInput | SortOrder
    doctorSignaturePath?: SortOrderInput | SortOrder
    doctorSignedAt?: SortOrderInput | SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _avg?: EncounterAvgOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
    _sum?: EncounterSumOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Encounter"> | number
    patientBookId?: IntWithAggregatesFilter<"Encounter"> | number
    doctorId?: IntWithAggregatesFilter<"Encounter"> | number
    visitDate?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    appointmentId?: IntNullableWithAggregatesFilter<"Encounter"> | number | null
    nurseId?: IntNullableWithAggregatesFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
  }

  export type EncounterConsentWhereInput = {
    AND?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    OR?: EncounterConsentWhereInput[]
    NOT?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    id?: IntFilter<"EncounterConsent"> | number
    encounterId?: IntFilter<"EncounterConsent"> | number
    type?: StringFilter<"EncounterConsent"> | string
    answers?: JsonFilter<"EncounterConsent">
    createdAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }

  export type EncounterConsentOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
  }

  export type EncounterConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encounterId_type?: EncounterConsentEncounterIdTypeCompoundUniqueInput
    AND?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    OR?: EncounterConsentWhereInput[]
    NOT?: EncounterConsentWhereInput | EncounterConsentWhereInput[]
    encounterId?: IntFilter<"EncounterConsent"> | number
    type?: StringFilter<"EncounterConsent"> | string
    answers?: JsonFilter<"EncounterConsent">
    createdAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }, "id" | "encounterId_type">

  export type EncounterConsentOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncounterConsentCountOrderByAggregateInput
    _avg?: EncounterConsentAvgOrderByAggregateInput
    _max?: EncounterConsentMaxOrderByAggregateInput
    _min?: EncounterConsentMinOrderByAggregateInput
    _sum?: EncounterConsentSumOrderByAggregateInput
  }

  export type EncounterConsentScalarWhereWithAggregatesInput = {
    AND?: EncounterConsentScalarWhereWithAggregatesInput | EncounterConsentScalarWhereWithAggregatesInput[]
    OR?: EncounterConsentScalarWhereWithAggregatesInput[]
    NOT?: EncounterConsentScalarWhereWithAggregatesInput | EncounterConsentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterConsent"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterConsent"> | number
    type?: StringWithAggregatesFilter<"EncounterConsent"> | string
    answers?: JsonWithAggregatesFilter<"EncounterConsent">
    createdAt?: DateTimeWithAggregatesFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EncounterConsent"> | Date | string
  }

  export type ChartToothWhereInput = {
    AND?: ChartToothWhereInput | ChartToothWhereInput[]
    OR?: ChartToothWhereInput[]
    NOT?: ChartToothWhereInput | ChartToothWhereInput[]
    id?: IntFilter<"ChartTooth"> | number
    toothCode?: StringFilter<"ChartTooth"> | string
    toothGroup?: StringNullableFilter<"ChartTooth"> | string | null
    status?: StringNullableFilter<"ChartTooth"> | string | null
    notes?: StringNullableFilter<"ChartTooth"> | string | null
    encounterId?: IntFilter<"ChartTooth"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    chartNotes?: ChartNoteListRelationFilter
  }

  export type ChartToothOrderByWithRelationInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    chartNotes?: ChartNoteOrderByRelationAggregateInput
  }

  export type ChartToothWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChartToothWhereInput | ChartToothWhereInput[]
    OR?: ChartToothWhereInput[]
    NOT?: ChartToothWhereInput | ChartToothWhereInput[]
    toothCode?: StringFilter<"ChartTooth"> | string
    toothGroup?: StringNullableFilter<"ChartTooth"> | string | null
    status?: StringNullableFilter<"ChartTooth"> | string | null
    notes?: StringNullableFilter<"ChartTooth"> | string | null
    encounterId?: IntFilter<"ChartTooth"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    chartNotes?: ChartNoteListRelationFilter
  }, "id">

  export type ChartToothOrderByWithAggregationInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    _count?: ChartToothCountOrderByAggregateInput
    _avg?: ChartToothAvgOrderByAggregateInput
    _max?: ChartToothMaxOrderByAggregateInput
    _min?: ChartToothMinOrderByAggregateInput
    _sum?: ChartToothSumOrderByAggregateInput
  }

  export type ChartToothScalarWhereWithAggregatesInput = {
    AND?: ChartToothScalarWhereWithAggregatesInput | ChartToothScalarWhereWithAggregatesInput[]
    OR?: ChartToothScalarWhereWithAggregatesInput[]
    NOT?: ChartToothScalarWhereWithAggregatesInput | ChartToothScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChartTooth"> | number
    toothCode?: StringWithAggregatesFilter<"ChartTooth"> | string
    toothGroup?: StringNullableWithAggregatesFilter<"ChartTooth"> | string | null
    status?: StringNullableWithAggregatesFilter<"ChartTooth"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ChartTooth"> | string | null
    encounterId?: IntWithAggregatesFilter<"ChartTooth"> | number
  }

  export type ChartNoteWhereInput = {
    AND?: ChartNoteWhereInput | ChartNoteWhereInput[]
    OR?: ChartNoteWhereInput[]
    NOT?: ChartNoteWhereInput | ChartNoteWhereInput[]
    id?: IntFilter<"ChartNote"> | number
    chartToothId?: IntFilter<"ChartNote"> | number
    description?: StringFilter<"ChartNote"> | string
    createdAt?: DateTimeFilter<"ChartNote"> | Date | string
    chartTooth?: XOR<ChartToothRelationFilter, ChartToothWhereInput>
  }

  export type ChartNoteOrderByWithRelationInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    chartTooth?: ChartToothOrderByWithRelationInput
  }

  export type ChartNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChartNoteWhereInput | ChartNoteWhereInput[]
    OR?: ChartNoteWhereInput[]
    NOT?: ChartNoteWhereInput | ChartNoteWhereInput[]
    chartToothId?: IntFilter<"ChartNote"> | number
    description?: StringFilter<"ChartNote"> | string
    createdAt?: DateTimeFilter<"ChartNote"> | Date | string
    chartTooth?: XOR<ChartToothRelationFilter, ChartToothWhereInput>
  }, "id">

  export type ChartNoteOrderByWithAggregationInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: ChartNoteCountOrderByAggregateInput
    _avg?: ChartNoteAvgOrderByAggregateInput
    _max?: ChartNoteMaxOrderByAggregateInput
    _min?: ChartNoteMinOrderByAggregateInput
    _sum?: ChartNoteSumOrderByAggregateInput
  }

  export type ChartNoteScalarWhereWithAggregatesInput = {
    AND?: ChartNoteScalarWhereWithAggregatesInput | ChartNoteScalarWhereWithAggregatesInput[]
    OR?: ChartNoteScalarWhereWithAggregatesInput[]
    NOT?: ChartNoteScalarWhereWithAggregatesInput | ChartNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChartNote"> | number
    chartToothId?: IntWithAggregatesFilter<"ChartNote"> | number
    description?: StringWithAggregatesFilter<"ChartNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChartNote"> | Date | string
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    id?: IntFilter<"Diagnosis"> | number
    code?: StringFilter<"Diagnosis"> | string
    name?: StringFilter<"Diagnosis"> | string
    description?: StringNullableFilter<"Diagnosis"> | string | null
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    problems?: DiagnosisProblemListRelationFilter
    encounters?: EncounterDiagnosisListRelationFilter
  }

  export type DiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    problems?: DiagnosisProblemOrderByRelationAggregateInput
    encounters?: EncounterDiagnosisOrderByRelationAggregateInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    name?: StringFilter<"Diagnosis"> | string
    description?: StringNullableFilter<"Diagnosis"> | string | null
    createdAt?: DateTimeFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeFilter<"Diagnosis"> | Date | string
    problems?: DiagnosisProblemListRelationFilter
    encounters?: EncounterDiagnosisListRelationFilter
  }, "id" | "code">

  export type DiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _avg?: DiagnosisAvgOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
    _sum?: DiagnosisSumOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diagnosis"> | number
    code?: StringWithAggregatesFilter<"Diagnosis"> | string
    name?: StringWithAggregatesFilter<"Diagnosis"> | string
    description?: StringNullableWithAggregatesFilter<"Diagnosis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
  }

  export type DiagnosisProblemWhereInput = {
    AND?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    OR?: DiagnosisProblemWhereInput[]
    NOT?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    id?: IntFilter<"DiagnosisProblem"> | number
    diagnosisId?: IntFilter<"DiagnosisProblem"> | number
    label?: StringFilter<"DiagnosisProblem"> | string
    order?: IntFilter<"DiagnosisProblem"> | number
    active?: BoolFilter<"DiagnosisProblem"> | boolean
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
  }

  export type DiagnosisProblemOrderByWithRelationInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
    diagnosis?: DiagnosisOrderByWithRelationInput
  }

  export type DiagnosisProblemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    OR?: DiagnosisProblemWhereInput[]
    NOT?: DiagnosisProblemWhereInput | DiagnosisProblemWhereInput[]
    diagnosisId?: IntFilter<"DiagnosisProblem"> | number
    label?: StringFilter<"DiagnosisProblem"> | string
    order?: IntFilter<"DiagnosisProblem"> | number
    active?: BoolFilter<"DiagnosisProblem"> | boolean
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
  }, "id">

  export type DiagnosisProblemOrderByWithAggregationInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
    _count?: DiagnosisProblemCountOrderByAggregateInput
    _avg?: DiagnosisProblemAvgOrderByAggregateInput
    _max?: DiagnosisProblemMaxOrderByAggregateInput
    _min?: DiagnosisProblemMinOrderByAggregateInput
    _sum?: DiagnosisProblemSumOrderByAggregateInput
  }

  export type DiagnosisProblemScalarWhereWithAggregatesInput = {
    AND?: DiagnosisProblemScalarWhereWithAggregatesInput | DiagnosisProblemScalarWhereWithAggregatesInput[]
    OR?: DiagnosisProblemScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisProblemScalarWhereWithAggregatesInput | DiagnosisProblemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DiagnosisProblem"> | number
    diagnosisId?: IntWithAggregatesFilter<"DiagnosisProblem"> | number
    label?: StringWithAggregatesFilter<"DiagnosisProblem"> | string
    order?: IntWithAggregatesFilter<"DiagnosisProblem"> | number
    active?: BoolWithAggregatesFilter<"DiagnosisProblem"> | boolean
  }

  export type EncounterDiagnosisWhereInput = {
    AND?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    OR?: EncounterDiagnosisWhereInput[]
    NOT?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    id?: IntFilter<"EncounterDiagnosis"> | number
    encounterId?: IntFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableFilter<"EncounterDiagnosis">
    note?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeFilter<"EncounterDiagnosis"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorListRelationFilter
  }

  export type EncounterDiagnosisOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    selectedProblemIds?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    diagnosis?: DiagnosisOrderByWithRelationInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorOrderByRelationAggregateInput
  }

  export type EncounterDiagnosisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    OR?: EncounterDiagnosisWhereInput[]
    NOT?: EncounterDiagnosisWhereInput | EncounterDiagnosisWhereInput[]
    encounterId?: IntFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableFilter<"EncounterDiagnosis">
    note?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeFilter<"EncounterDiagnosis"> | Date | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    diagnosis?: XOR<DiagnosisRelationFilter, DiagnosisWhereInput>
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorListRelationFilter
  }, "id">

  export type EncounterDiagnosisOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    selectedProblemIds?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EncounterDiagnosisCountOrderByAggregateInput
    _avg?: EncounterDiagnosisAvgOrderByAggregateInput
    _max?: EncounterDiagnosisMaxOrderByAggregateInput
    _min?: EncounterDiagnosisMinOrderByAggregateInput
    _sum?: EncounterDiagnosisSumOrderByAggregateInput
  }

  export type EncounterDiagnosisScalarWhereWithAggregatesInput = {
    AND?: EncounterDiagnosisScalarWhereWithAggregatesInput | EncounterDiagnosisScalarWhereWithAggregatesInput[]
    OR?: EncounterDiagnosisScalarWhereWithAggregatesInput[]
    NOT?: EncounterDiagnosisScalarWhereWithAggregatesInput | EncounterDiagnosisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterDiagnosis"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntWithAggregatesFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableWithAggregatesFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableWithAggregatesFilter<"EncounterDiagnosis">
    note?: StringNullableWithAggregatesFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EncounterDiagnosis"> | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorWhereInput = {
    AND?: EncounterDiagnosisSterilizationIndicatorWhereInput | EncounterDiagnosisSterilizationIndicatorWhereInput[]
    OR?: EncounterDiagnosisSterilizationIndicatorWhereInput[]
    NOT?: EncounterDiagnosisSterilizationIndicatorWhereInput | EncounterDiagnosisSterilizationIndicatorWhereInput[]
    id?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    encounterDiagnosisId?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    indicatorId?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    createdAt?: DateTimeFilter<"EncounterDiagnosisSterilizationIndicator"> | Date | string
    encounterDiagnosis?: XOR<EncounterDiagnosisRelationFilter, EncounterDiagnosisWhereInput>
    indicator?: XOR<SterilizationIndicatorRelationFilter, SterilizationIndicatorWhereInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorOrderByWithRelationInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
    createdAt?: SortOrder
    encounterDiagnosis?: EncounterDiagnosisOrderByWithRelationInput
    indicator?: SterilizationIndicatorOrderByWithRelationInput
  }

  export type EncounterDiagnosisSterilizationIndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterDiagnosisSterilizationIndicatorWhereInput | EncounterDiagnosisSterilizationIndicatorWhereInput[]
    OR?: EncounterDiagnosisSterilizationIndicatorWhereInput[]
    NOT?: EncounterDiagnosisSterilizationIndicatorWhereInput | EncounterDiagnosisSterilizationIndicatorWhereInput[]
    encounterDiagnosisId?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    indicatorId?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    createdAt?: DateTimeFilter<"EncounterDiagnosisSterilizationIndicator"> | Date | string
    encounterDiagnosis?: XOR<EncounterDiagnosisRelationFilter, EncounterDiagnosisWhereInput>
    indicator?: XOR<SterilizationIndicatorRelationFilter, SterilizationIndicatorWhereInput>
  }, "id">

  export type EncounterDiagnosisSterilizationIndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
    createdAt?: SortOrder
    _count?: EncounterDiagnosisSterilizationIndicatorCountOrderByAggregateInput
    _avg?: EncounterDiagnosisSterilizationIndicatorAvgOrderByAggregateInput
    _max?: EncounterDiagnosisSterilizationIndicatorMaxOrderByAggregateInput
    _min?: EncounterDiagnosisSterilizationIndicatorMinOrderByAggregateInput
    _sum?: EncounterDiagnosisSterilizationIndicatorSumOrderByAggregateInput
  }

  export type EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput = {
    AND?: EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput | EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput[]
    OR?: EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput[]
    NOT?: EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput | EncounterDiagnosisSterilizationIndicatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    encounterDiagnosisId?: IntWithAggregatesFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    indicatorId?: IntWithAggregatesFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EncounterDiagnosisSterilizationIndicator"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    code?: StringNullableFilter<"Service"> | string | null
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    description?: StringNullableFilter<"Service"> | string | null
    encounterServices?: EncounterServiceListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    encounterServices?: EncounterServiceOrderByRelationAggregateInput
    serviceBranches?: ServiceBranchOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    name?: StringFilter<"Service"> | string
    price?: FloatFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    description?: StringNullableFilter<"Service"> | string | null
    encounterServices?: EncounterServiceListRelationFilter
    serviceBranches?: ServiceBranchListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id" | "code">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrderInput | SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    code?: StringNullableWithAggregatesFilter<"Service"> | string | null
    category?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    name?: StringWithAggregatesFilter<"Service"> | string
    price?: FloatWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
  }

  export type ServiceBranchWhereInput = {
    AND?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    OR?: ServiceBranchWhereInput[]
    NOT?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    serviceId?: IntFilter<"ServiceBranch"> | number
    branchId?: IntFilter<"ServiceBranch"> | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ServiceBranchOrderByWithRelationInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ServiceBranchWhereUniqueInput = Prisma.AtLeast<{
    serviceId_branchId?: ServiceBranchServiceIdBranchIdCompoundUniqueInput
    AND?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    OR?: ServiceBranchWhereInput[]
    NOT?: ServiceBranchWhereInput | ServiceBranchWhereInput[]
    serviceId?: IntFilter<"ServiceBranch"> | number
    branchId?: IntFilter<"ServiceBranch"> | number
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "serviceId_branchId">

  export type ServiceBranchOrderByWithAggregationInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
    _count?: ServiceBranchCountOrderByAggregateInput
    _avg?: ServiceBranchAvgOrderByAggregateInput
    _max?: ServiceBranchMaxOrderByAggregateInput
    _min?: ServiceBranchMinOrderByAggregateInput
    _sum?: ServiceBranchSumOrderByAggregateInput
  }

  export type ServiceBranchScalarWhereWithAggregatesInput = {
    AND?: ServiceBranchScalarWhereWithAggregatesInput | ServiceBranchScalarWhereWithAggregatesInput[]
    OR?: ServiceBranchScalarWhereWithAggregatesInput[]
    NOT?: ServiceBranchScalarWhereWithAggregatesInput | ServiceBranchScalarWhereWithAggregatesInput[]
    serviceId?: IntWithAggregatesFilter<"ServiceBranch"> | number
    branchId?: IntWithAggregatesFilter<"ServiceBranch"> | number
  }

  export type EncounterServiceWhereInput = {
    AND?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    OR?: EncounterServiceWhereInput[]
    NOT?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    id?: IntFilter<"EncounterService"> | number
    encounterId?: IntFilter<"EncounterService"> | number
    serviceId?: IntFilter<"EncounterService"> | number
    quantity?: IntFilter<"EncounterService"> | number
    price?: FloatFilter<"EncounterService"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type EncounterServiceOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type EncounterServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    OR?: EncounterServiceWhereInput[]
    NOT?: EncounterServiceWhereInput | EncounterServiceWhereInput[]
    encounterId?: IntFilter<"EncounterService"> | number
    serviceId?: IntFilter<"EncounterService"> | number
    quantity?: IntFilter<"EncounterService"> | number
    price?: FloatFilter<"EncounterService"> | number
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "id">

  export type EncounterServiceOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: EncounterServiceCountOrderByAggregateInput
    _avg?: EncounterServiceAvgOrderByAggregateInput
    _max?: EncounterServiceMaxOrderByAggregateInput
    _min?: EncounterServiceMinOrderByAggregateInput
    _sum?: EncounterServiceSumOrderByAggregateInput
  }

  export type EncounterServiceScalarWhereWithAggregatesInput = {
    AND?: EncounterServiceScalarWhereWithAggregatesInput | EncounterServiceScalarWhereWithAggregatesInput[]
    OR?: EncounterServiceScalarWhereWithAggregatesInput[]
    NOT?: EncounterServiceScalarWhereWithAggregatesInput | EncounterServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterService"> | number
    encounterId?: IntWithAggregatesFilter<"EncounterService"> | number
    serviceId?: IntWithAggregatesFilter<"EncounterService"> | number
    quantity?: IntWithAggregatesFilter<"EncounterService"> | number
    price?: FloatWithAggregatesFilter<"EncounterService"> | number
  }

  export type ProcedureWhereInput = {
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    code?: StringFilter<"Procedure"> | string
    name?: StringFilter<"Procedure"> | string
    price?: FloatFilter<"Procedure"> | number
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ProcedureOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ProcedureWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: ProcedureWhereInput | ProcedureWhereInput[]
    OR?: ProcedureWhereInput[]
    NOT?: ProcedureWhereInput | ProcedureWhereInput[]
    name?: StringFilter<"Procedure"> | string
    price?: FloatFilter<"Procedure"> | number
    invoiceItems?: InvoiceItemListRelationFilter
  }, "code">

  export type ProcedureOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: ProcedureCountOrderByAggregateInput
    _avg?: ProcedureAvgOrderByAggregateInput
    _max?: ProcedureMaxOrderByAggregateInput
    _min?: ProcedureMinOrderByAggregateInput
    _sum?: ProcedureSumOrderByAggregateInput
  }

  export type ProcedureScalarWhereWithAggregatesInput = {
    AND?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    OR?: ProcedureScalarWhereWithAggregatesInput[]
    NOT?: ProcedureScalarWhereWithAggregatesInput | ProcedureScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Procedure"> | string
    name?: StringWithAggregatesFilter<"Procedure"> | string
    price?: FloatWithAggregatesFilter<"Procedure"> | number
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    branchId?: IntFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    code?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    category?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    stockMovements?: ProductStockMovementListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    stockMovements?: ProductStockMovementOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    branchId?: IntFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    category?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    stockMovements?: ProductStockMovementListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    code?: SortOrderInput | SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    branchId?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: IntWithAggregatesFilter<"Product"> | number
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    price?: FloatWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductStockMovementWhereInput = {
    AND?: ProductStockMovementWhereInput | ProductStockMovementWhereInput[]
    OR?: ProductStockMovementWhereInput[]
    NOT?: ProductStockMovementWhereInput | ProductStockMovementWhereInput[]
    id?: IntFilter<"ProductStockMovement"> | number
    branchId?: IntFilter<"ProductStockMovement"> | number
    productId?: IntFilter<"ProductStockMovement"> | number
    type?: EnumProductStockMovementTypeFilter<"ProductStockMovement"> | $Enums.ProductStockMovementType
    quantityDelta?: IntFilter<"ProductStockMovement"> | number
    invoiceId?: IntNullableFilter<"ProductStockMovement"> | number | null
    ledgerEntryId?: IntNullableFilter<"ProductStockMovement"> | number | null
    note?: StringNullableFilter<"ProductStockMovement"> | string | null
    createdAt?: DateTimeFilter<"ProductStockMovement"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductStockMovementOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    ledgerEntryId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductStockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductStockMovementWhereInput | ProductStockMovementWhereInput[]
    OR?: ProductStockMovementWhereInput[]
    NOT?: ProductStockMovementWhereInput | ProductStockMovementWhereInput[]
    branchId?: IntFilter<"ProductStockMovement"> | number
    productId?: IntFilter<"ProductStockMovement"> | number
    type?: EnumProductStockMovementTypeFilter<"ProductStockMovement"> | $Enums.ProductStockMovementType
    quantityDelta?: IntFilter<"ProductStockMovement"> | number
    invoiceId?: IntNullableFilter<"ProductStockMovement"> | number | null
    ledgerEntryId?: IntNullableFilter<"ProductStockMovement"> | number | null
    note?: StringNullableFilter<"ProductStockMovement"> | string | null
    createdAt?: DateTimeFilter<"ProductStockMovement"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductStockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    ledgerEntryId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductStockMovementCountOrderByAggregateInput
    _avg?: ProductStockMovementAvgOrderByAggregateInput
    _max?: ProductStockMovementMaxOrderByAggregateInput
    _min?: ProductStockMovementMinOrderByAggregateInput
    _sum?: ProductStockMovementSumOrderByAggregateInput
  }

  export type ProductStockMovementScalarWhereWithAggregatesInput = {
    AND?: ProductStockMovementScalarWhereWithAggregatesInput | ProductStockMovementScalarWhereWithAggregatesInput[]
    OR?: ProductStockMovementScalarWhereWithAggregatesInput[]
    NOT?: ProductStockMovementScalarWhereWithAggregatesInput | ProductStockMovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductStockMovement"> | number
    branchId?: IntWithAggregatesFilter<"ProductStockMovement"> | number
    productId?: IntWithAggregatesFilter<"ProductStockMovement"> | number
    type?: EnumProductStockMovementTypeWithAggregatesFilter<"ProductStockMovement"> | $Enums.ProductStockMovementType
    quantityDelta?: IntWithAggregatesFilter<"ProductStockMovement"> | number
    invoiceId?: IntNullableWithAggregatesFilter<"ProductStockMovement"> | number | null
    ledgerEntryId?: IntNullableWithAggregatesFilter<"ProductStockMovement"> | number | null
    note?: StringNullableWithAggregatesFilter<"ProductStockMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductStockMovement"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    branchId?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    products?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    branchId_name?: ProductCategoryBranchIdNameCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    branchId?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    products?: ProductListRelationFilter
  }, "id" | "branchId_name">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductCategory"> | number
    branchId?: IntWithAggregatesFilter<"ProductCategory"> | number
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: IntFilter<"Prescription"> | number
    encounterId?: IntFilter<"Prescription"> | number
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    doctorNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    patientNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    diagnosisSummary?: StringNullableFilter<"Prescription"> | string | null
    clinicNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    items?: PrescriptionItemListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrderInput | SortOrder
    patientNameSnapshot?: SortOrderInput | SortOrder
    diagnosisSummary?: SortOrderInput | SortOrder
    clinicNameSnapshot?: SortOrderInput | SortOrder
    encounter?: EncounterOrderByWithRelationInput
    items?: PrescriptionItemOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encounterId?: number
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    doctorNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    patientNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    diagnosisSummary?: StringNullableFilter<"Prescription"> | string | null
    clinicNameSnapshot?: StringNullableFilter<"Prescription"> | string | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    items?: PrescriptionItemListRelationFilter
  }, "id" | "encounterId">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrderInput | SortOrder
    patientNameSnapshot?: SortOrderInput | SortOrder
    diagnosisSummary?: SortOrderInput | SortOrder
    clinicNameSnapshot?: SortOrderInput | SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prescription"> | number
    encounterId?: IntWithAggregatesFilter<"Prescription"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    doctorNameSnapshot?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    patientNameSnapshot?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    diagnosisSummary?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    clinicNameSnapshot?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
  }

  export type PrescriptionItemWhereInput = {
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    id?: IntFilter<"PrescriptionItem"> | number
    prescriptionId?: IntFilter<"PrescriptionItem"> | number
    order?: IntFilter<"PrescriptionItem"> | number
    drugName?: StringFilter<"PrescriptionItem"> | string
    durationDays?: IntFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntFilter<"PrescriptionItem"> | number
    note?: StringNullableFilter<"PrescriptionItem"> | string | null
    prescription?: XOR<PrescriptionRelationFilter, PrescriptionWhereInput>
  }

  export type PrescriptionItemOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrderInput | SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type PrescriptionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    prescriptionId?: IntFilter<"PrescriptionItem"> | number
    order?: IntFilter<"PrescriptionItem"> | number
    drugName?: StringFilter<"PrescriptionItem"> | string
    durationDays?: IntFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntFilter<"PrescriptionItem"> | number
    note?: StringNullableFilter<"PrescriptionItem"> | string | null
    prescription?: XOR<PrescriptionRelationFilter, PrescriptionWhereInput>
  }, "id">

  export type PrescriptionItemOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: PrescriptionItemCountOrderByAggregateInput
    _avg?: PrescriptionItemAvgOrderByAggregateInput
    _max?: PrescriptionItemMaxOrderByAggregateInput
    _min?: PrescriptionItemMinOrderByAggregateInput
    _sum?: PrescriptionItemSumOrderByAggregateInput
  }

  export type PrescriptionItemScalarWhereWithAggregatesInput = {
    AND?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    OR?: PrescriptionItemScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    prescriptionId?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    order?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    drugName?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    durationDays?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntWithAggregatesFilter<"PrescriptionItem"> | number
    note?: StringNullableWithAggregatesFilter<"PrescriptionItem"> | string | null
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    branchId?: IntNullableFilter<"Invoice"> | number | null
    encounterId?: IntFilter<"Invoice"> | number
    patientId?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    items?: InvoiceItemListRelationFilter
    eBarimtReceipt?: XOR<EBarimtReceiptNullableRelationFilter, EBarimtReceiptWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
    payments?: PaymentListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    totalBeforeDiscount?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    statusLegacy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    eBarimtReceipt?: EBarimtReceiptOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    employeeBenefitUsages?: EmployeeBenefitUsageOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    encounterId?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    branchId?: IntNullableFilter<"Invoice"> | number | null
    patientId?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    items?: InvoiceItemListRelationFilter
    eBarimtReceipt?: XOR<EBarimtReceiptNullableRelationFilter, EBarimtReceiptWhereInput> | null
    ledgerEntries?: LedgerEntryListRelationFilter
    payments?: PaymentListRelationFilter
    employeeBenefitUsages?: EmployeeBenefitUsageListRelationFilter
  }, "id" | "encounterId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    encounterId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    totalAmount?: SortOrderInput | SortOrder
    totalBeforeDiscount?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    statusLegacy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    branchId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    encounterId?: IntWithAggregatesFilter<"Invoice"> | number
    patientId?: IntNullableWithAggregatesFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentWithAggregatesFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableFilter<"InvoiceItem"> | number | null
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    lineTotal?: FloatFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    procedure?: XOR<ProcedureNullableRelationFilter, ProcedureWhereInput> | null
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    procedureCode?: SortOrderInput | SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    procedure?: ProcedureOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableFilter<"InvoiceItem"> | number | null
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    lineTotal?: FloatFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    procedure?: XOR<ProcedureNullableRelationFilter, ProcedureWhereInput> | null
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    procedureCode?: SortOrderInput | SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InvoiceItem"> | number
    invoiceId?: IntWithAggregatesFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeWithAggregatesFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    productId?: IntNullableWithAggregatesFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    name?: StringWithAggregatesFilter<"InvoiceItem"> | string
    unitPrice?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    lineTotal?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceWithAggregatesFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    qpayTxnId?: StringNullableFilter<"Payment"> | string | null
    timestamp?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    qpayTxnId?: StringNullableFilter<"Payment"> | string | null
    timestamp?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    invoiceId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    method?: StringWithAggregatesFilter<"Payment"> | string
    qpayTxnId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type EBarimtReceiptWhereInput = {
    AND?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    OR?: EBarimtReceiptWhereInput[]
    NOT?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    id?: IntFilter<"EBarimtReceipt"> | number
    invoiceId?: IntFilter<"EBarimtReceipt"> | number
    receiptNumber?: StringFilter<"EBarimtReceipt"> | string
    timestamp?: DateTimeFilter<"EBarimtReceipt"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type EBarimtReceiptOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type EBarimtReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoiceId?: number
    receiptNumber?: string
    AND?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    OR?: EBarimtReceiptWhereInput[]
    NOT?: EBarimtReceiptWhereInput | EBarimtReceiptWhereInput[]
    timestamp?: DateTimeFilter<"EBarimtReceipt"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id" | "invoiceId" | "receiptNumber">

  export type EBarimtReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
    _count?: EBarimtReceiptCountOrderByAggregateInput
    _avg?: EBarimtReceiptAvgOrderByAggregateInput
    _max?: EBarimtReceiptMaxOrderByAggregateInput
    _min?: EBarimtReceiptMinOrderByAggregateInput
    _sum?: EBarimtReceiptSumOrderByAggregateInput
  }

  export type EBarimtReceiptScalarWhereWithAggregatesInput = {
    AND?: EBarimtReceiptScalarWhereWithAggregatesInput | EBarimtReceiptScalarWhereWithAggregatesInput[]
    OR?: EBarimtReceiptScalarWhereWithAggregatesInput[]
    NOT?: EBarimtReceiptScalarWhereWithAggregatesInput | EBarimtReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EBarimtReceipt"> | number
    invoiceId?: IntWithAggregatesFilter<"EBarimtReceipt"> | number
    receiptNumber?: StringWithAggregatesFilter<"EBarimtReceipt"> | string
    timestamp?: DateTimeWithAggregatesFilter<"EBarimtReceipt"> | Date | string
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: IntFilter<"LedgerEntry"> | number
    branchId?: IntFilter<"LedgerEntry"> | number
    patientId?: IntFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatFilter<"LedgerEntry"> | number
    createdById?: IntFilter<"LedgerEntry"> | number
    approvedById?: IntNullableFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approvalCode?: XOR<AuthorizationCodeNullableRelationFilter, AuthorizationCodeWhereInput> | null
    employeeVoucher?: XOR<EmployeeVoucherNullableRelationFilter, EmployeeVoucherWhereInput> | null
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvalCodeId?: SortOrderInput | SortOrder
    employeeVoucherId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    approvalCode?: AuthorizationCodeOrderByWithRelationInput
    employeeVoucher?: EmployeeVoucherOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    branchId?: IntFilter<"LedgerEntry"> | number
    patientId?: IntFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatFilter<"LedgerEntry"> | number
    createdById?: IntFilter<"LedgerEntry"> | number
    approvedById?: IntNullableFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    invoice?: XOR<InvoiceNullableRelationFilter, InvoiceWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approvalCode?: XOR<AuthorizationCodeNullableRelationFilter, AuthorizationCodeWhereInput> | null
    employeeVoucher?: XOR<EmployeeVoucherNullableRelationFilter, EmployeeVoucherWhereInput> | null
  }, "id">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvalCodeId?: SortOrderInput | SortOrder
    employeeVoucherId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LedgerEntry"> | number
    branchId?: IntWithAggregatesFilter<"LedgerEntry"> | number
    patientId?: IntWithAggregatesFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatWithAggregatesFilter<"LedgerEntry"> | number
    createdById?: IntWithAggregatesFilter<"LedgerEntry"> | number
    approvedById?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableWithAggregatesFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableWithAggregatesFilter<"LedgerEntry">
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
  }

  export type AuthorizationCodeWhereInput = {
    AND?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    OR?: AuthorizationCodeWhereInput[]
    NOT?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    id?: IntFilter<"AuthorizationCode"> | number
    code?: StringFilter<"AuthorizationCode"> | string
    purpose?: StringFilter<"AuthorizationCode"> | string
    isEnabled?: BoolFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableFilter<"AuthorizationCode"> | number | null
    usedCount?: IntFilter<"AuthorizationCode"> | number
    createdById?: IntFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
  }

  export type AuthorizationCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
  }

  export type AuthorizationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    OR?: AuthorizationCodeWhereInput[]
    NOT?: AuthorizationCodeWhereInput | AuthorizationCodeWhereInput[]
    purpose?: StringFilter<"AuthorizationCode"> | string
    isEnabled?: BoolFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableFilter<"AuthorizationCode"> | number | null
    usedCount?: IntFilter<"AuthorizationCode"> | number
    createdById?: IntFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
  }, "id" | "code">

  export type AuthorizationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthorizationCodeCountOrderByAggregateInput
    _avg?: AuthorizationCodeAvgOrderByAggregateInput
    _max?: AuthorizationCodeMaxOrderByAggregateInput
    _min?: AuthorizationCodeMinOrderByAggregateInput
    _sum?: AuthorizationCodeSumOrderByAggregateInput
  }

  export type AuthorizationCodeScalarWhereWithAggregatesInput = {
    AND?: AuthorizationCodeScalarWhereWithAggregatesInput | AuthorizationCodeScalarWhereWithAggregatesInput[]
    OR?: AuthorizationCodeScalarWhereWithAggregatesInput[]
    NOT?: AuthorizationCodeScalarWhereWithAggregatesInput | AuthorizationCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuthorizationCode"> | number
    code?: StringWithAggregatesFilter<"AuthorizationCode"> | string
    purpose?: StringWithAggregatesFilter<"AuthorizationCode"> | string
    isEnabled?: BoolWithAggregatesFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"AuthorizationCode"> | number | null
    usedCount?: IntWithAggregatesFilter<"AuthorizationCode"> | number
    createdById?: IntWithAggregatesFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthorizationCode"> | Date | string
  }

  export type EmployeeVoucherWhereInput = {
    AND?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    OR?: EmployeeVoucherWhereInput[]
    NOT?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    id?: IntFilter<"EmployeeVoucher"> | number
    branchId?: IntFilter<"EmployeeVoucher"> | number
    employeeId?: IntFilter<"EmployeeVoucher"> | number
    code?: StringFilter<"EmployeeVoucher"> | string
    status?: EnumEmployeeVoucherStatusFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatFilter<"EmployeeVoucher"> | number
    eligibility?: JsonFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonFilter<"EmployeeVoucher">
    createdAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntFilter<"EmployeeVoucher"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    employee?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmployeeVoucherOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    eligibility?: SortOrder
    allowedPatientIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    branch?: BranchOrderByWithRelationInput
    employee?: UserOrderByWithRelationInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type EmployeeVoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    OR?: EmployeeVoucherWhereInput[]
    NOT?: EmployeeVoucherWhereInput | EmployeeVoucherWhereInput[]
    branchId?: IntFilter<"EmployeeVoucher"> | number
    employeeId?: IntFilter<"EmployeeVoucher"> | number
    status?: EnumEmployeeVoucherStatusFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatFilter<"EmployeeVoucher"> | number
    eligibility?: JsonFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonFilter<"EmployeeVoucher">
    createdAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntFilter<"EmployeeVoucher"> | number
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    employee?: XOR<UserRelationFilter, UserWhereInput>
    ledgerEntries?: LedgerEntryListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type EmployeeVoucherOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    eligibility?: SortOrder
    allowedPatientIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: EmployeeVoucherCountOrderByAggregateInput
    _avg?: EmployeeVoucherAvgOrderByAggregateInput
    _max?: EmployeeVoucherMaxOrderByAggregateInput
    _min?: EmployeeVoucherMinOrderByAggregateInput
    _sum?: EmployeeVoucherSumOrderByAggregateInput
  }

  export type EmployeeVoucherScalarWhereWithAggregatesInput = {
    AND?: EmployeeVoucherScalarWhereWithAggregatesInput | EmployeeVoucherScalarWhereWithAggregatesInput[]
    OR?: EmployeeVoucherScalarWhereWithAggregatesInput[]
    NOT?: EmployeeVoucherScalarWhereWithAggregatesInput | EmployeeVoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
    branchId?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
    code?: StringWithAggregatesFilter<"EmployeeVoucher"> | string
    status?: EnumEmployeeVoucherStatusWithAggregatesFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatWithAggregatesFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatWithAggregatesFilter<"EmployeeVoucher"> | number
    eligibility?: JsonWithAggregatesFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonWithAggregatesFilter<"EmployeeVoucher">
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntWithAggregatesFilter<"EmployeeVoucher"> | number
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: IntFilter<"Media"> | number
    encounterId?: IntFilter<"Media"> | number
    filePath?: StringFilter<"Media"> | string
    toothCode?: StringNullableFilter<"Media"> | string | null
    type?: StringFilter<"Media"> | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    type?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    encounterId?: IntFilter<"Media"> | number
    filePath?: StringFilter<"Media"> | string
    toothCode?: StringNullableFilter<"Media"> | string | null
    type?: StringFilter<"Media"> | string
    encounter?: XOR<EncounterRelationFilter, EncounterWhereInput>
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Media"> | number
    encounterId?: IntWithAggregatesFilter<"Media"> | number
    filePath?: StringWithAggregatesFilter<"Media"> | string
    toothCode?: StringNullableWithAggregatesFilter<"Media"> | string | null
    type?: StringWithAggregatesFilter<"Media"> | string
  }

  export type DoctorScheduleWhereInput = {
    AND?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    OR?: DoctorScheduleWhereInput[]
    NOT?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    id?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    branchId?: IntFilter<"DoctorSchedule"> | number
    date?: DateTimeFilter<"DoctorSchedule"> | Date | string
    startTime?: StringFilter<"DoctorSchedule"> | string
    endTime?: StringFilter<"DoctorSchedule"> | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type DoctorScheduleOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type DoctorScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    doctorId_branchId_date?: DoctorScheduleDoctorIdBranchIdDateCompoundUniqueInput
    AND?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    OR?: DoctorScheduleWhereInput[]
    NOT?: DoctorScheduleWhereInput | DoctorScheduleWhereInput[]
    doctorId?: IntFilter<"DoctorSchedule"> | number
    branchId?: IntFilter<"DoctorSchedule"> | number
    date?: DateTimeFilter<"DoctorSchedule"> | Date | string
    startTime?: StringFilter<"DoctorSchedule"> | string
    endTime?: StringFilter<"DoctorSchedule"> | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "doctorId_branchId_date">

  export type DoctorScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: DoctorScheduleCountOrderByAggregateInput
    _avg?: DoctorScheduleAvgOrderByAggregateInput
    _max?: DoctorScheduleMaxOrderByAggregateInput
    _min?: DoctorScheduleMinOrderByAggregateInput
    _sum?: DoctorScheduleSumOrderByAggregateInput
  }

  export type DoctorScheduleScalarWhereWithAggregatesInput = {
    AND?: DoctorScheduleScalarWhereWithAggregatesInput | DoctorScheduleScalarWhereWithAggregatesInput[]
    OR?: DoctorScheduleScalarWhereWithAggregatesInput[]
    NOT?: DoctorScheduleScalarWhereWithAggregatesInput | DoctorScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    doctorId?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    branchId?: IntWithAggregatesFilter<"DoctorSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"DoctorSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"DoctorSchedule"> | string
    endTime?: StringWithAggregatesFilter<"DoctorSchedule"> | string
    note?: StringNullableWithAggregatesFilter<"DoctorSchedule"> | string | null
  }

  export type ReceptionScheduleWhereInput = {
    AND?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    OR?: ReceptionScheduleWhereInput[]
    NOT?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    id?: IntFilter<"ReceptionSchedule"> | number
    receptionId?: IntFilter<"ReceptionSchedule"> | number
    branchId?: IntFilter<"ReceptionSchedule"> | number
    date?: DateTimeFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringFilter<"ReceptionSchedule"> | string
    endTime?: StringFilter<"ReceptionSchedule"> | string
    note?: StringNullableFilter<"ReceptionSchedule"> | string | null
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ReceptionScheduleOrderByWithRelationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    reception?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ReceptionScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receptionId_branchId_date?: ReceptionScheduleReceptionIdBranchIdDateCompoundUniqueInput
    AND?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    OR?: ReceptionScheduleWhereInput[]
    NOT?: ReceptionScheduleWhereInput | ReceptionScheduleWhereInput[]
    receptionId?: IntFilter<"ReceptionSchedule"> | number
    branchId?: IntFilter<"ReceptionSchedule"> | number
    date?: DateTimeFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringFilter<"ReceptionSchedule"> | string
    endTime?: StringFilter<"ReceptionSchedule"> | string
    note?: StringNullableFilter<"ReceptionSchedule"> | string | null
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "receptionId_branchId_date">

  export type ReceptionScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: ReceptionScheduleCountOrderByAggregateInput
    _avg?: ReceptionScheduleAvgOrderByAggregateInput
    _max?: ReceptionScheduleMaxOrderByAggregateInput
    _min?: ReceptionScheduleMinOrderByAggregateInput
    _sum?: ReceptionScheduleSumOrderByAggregateInput
  }

  export type ReceptionScheduleScalarWhereWithAggregatesInput = {
    AND?: ReceptionScheduleScalarWhereWithAggregatesInput | ReceptionScheduleScalarWhereWithAggregatesInput[]
    OR?: ReceptionScheduleScalarWhereWithAggregatesInput[]
    NOT?: ReceptionScheduleScalarWhereWithAggregatesInput | ReceptionScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceptionSchedule"> | number
    receptionId?: IntWithAggregatesFilter<"ReceptionSchedule"> | number
    branchId?: IntWithAggregatesFilter<"ReceptionSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"ReceptionSchedule"> | string
    endTime?: StringWithAggregatesFilter<"ReceptionSchedule"> | string
    note?: StringNullableWithAggregatesFilter<"ReceptionSchedule"> | string | null
  }

  export type DoctorBranchWhereInput = {
    AND?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    OR?: DoctorBranchWhereInput[]
    NOT?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    id?: IntFilter<"DoctorBranch"> | number
    doctorId?: IntFilter<"DoctorBranch"> | number
    branchId?: IntFilter<"DoctorBranch"> | number
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type DoctorBranchOrderByWithRelationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    doctor?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type DoctorBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    doctorId_branchId?: DoctorBranchDoctorIdBranchIdCompoundUniqueInput
    AND?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    OR?: DoctorBranchWhereInput[]
    NOT?: DoctorBranchWhereInput | DoctorBranchWhereInput[]
    doctorId?: IntFilter<"DoctorBranch"> | number
    branchId?: IntFilter<"DoctorBranch"> | number
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "doctorId_branchId">

  export type DoctorBranchOrderByWithAggregationInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    _count?: DoctorBranchCountOrderByAggregateInput
    _avg?: DoctorBranchAvgOrderByAggregateInput
    _max?: DoctorBranchMaxOrderByAggregateInput
    _min?: DoctorBranchMinOrderByAggregateInput
    _sum?: DoctorBranchSumOrderByAggregateInput
  }

  export type DoctorBranchScalarWhereWithAggregatesInput = {
    AND?: DoctorBranchScalarWhereWithAggregatesInput | DoctorBranchScalarWhereWithAggregatesInput[]
    OR?: DoctorBranchScalarWhereWithAggregatesInput[]
    NOT?: DoctorBranchScalarWhereWithAggregatesInput | DoctorBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DoctorBranch"> | number
    doctorId?: IntWithAggregatesFilter<"DoctorBranch"> | number
    branchId?: IntWithAggregatesFilter<"DoctorBranch"> | number
  }

  export type ReceptionBranchWhereInput = {
    AND?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    OR?: ReceptionBranchWhereInput[]
    NOT?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    id?: IntFilter<"ReceptionBranch"> | number
    receptionId?: IntFilter<"ReceptionBranch"> | number
    branchId?: IntFilter<"ReceptionBranch"> | number
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type ReceptionBranchOrderByWithRelationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    reception?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type ReceptionBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receptionId_branchId?: ReceptionBranchReceptionIdBranchIdCompoundUniqueInput
    AND?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    OR?: ReceptionBranchWhereInput[]
    NOT?: ReceptionBranchWhereInput | ReceptionBranchWhereInput[]
    receptionId?: IntFilter<"ReceptionBranch"> | number
    branchId?: IntFilter<"ReceptionBranch"> | number
    reception?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "receptionId_branchId">

  export type ReceptionBranchOrderByWithAggregationInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    _count?: ReceptionBranchCountOrderByAggregateInput
    _avg?: ReceptionBranchAvgOrderByAggregateInput
    _max?: ReceptionBranchMaxOrderByAggregateInput
    _min?: ReceptionBranchMinOrderByAggregateInput
    _sum?: ReceptionBranchSumOrderByAggregateInput
  }

  export type ReceptionBranchScalarWhereWithAggregatesInput = {
    AND?: ReceptionBranchScalarWhereWithAggregatesInput | ReceptionBranchScalarWhereWithAggregatesInput[]
    OR?: ReceptionBranchScalarWhereWithAggregatesInput[]
    NOT?: ReceptionBranchScalarWhereWithAggregatesInput | ReceptionBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceptionBranch"> | number
    receptionId?: IntWithAggregatesFilter<"ReceptionBranch"> | number
    branchId?: IntWithAggregatesFilter<"ReceptionBranch"> | number
  }

  export type NurseBranchWhereInput = {
    AND?: NurseBranchWhereInput | NurseBranchWhereInput[]
    OR?: NurseBranchWhereInput[]
    NOT?: NurseBranchWhereInput | NurseBranchWhereInput[]
    id?: IntFilter<"NurseBranch"> | number
    nurseId?: IntFilter<"NurseBranch"> | number
    branchId?: IntFilter<"NurseBranch"> | number
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type NurseBranchOrderByWithRelationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    nurse?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type NurseBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nurseId_branchId?: NurseBranchNurseIdBranchIdCompoundUniqueInput
    AND?: NurseBranchWhereInput | NurseBranchWhereInput[]
    OR?: NurseBranchWhereInput[]
    NOT?: NurseBranchWhereInput | NurseBranchWhereInput[]
    nurseId?: IntFilter<"NurseBranch"> | number
    branchId?: IntFilter<"NurseBranch"> | number
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "nurseId_branchId">

  export type NurseBranchOrderByWithAggregationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    _count?: NurseBranchCountOrderByAggregateInput
    _avg?: NurseBranchAvgOrderByAggregateInput
    _max?: NurseBranchMaxOrderByAggregateInput
    _min?: NurseBranchMinOrderByAggregateInput
    _sum?: NurseBranchSumOrderByAggregateInput
  }

  export type NurseBranchScalarWhereWithAggregatesInput = {
    AND?: NurseBranchScalarWhereWithAggregatesInput | NurseBranchScalarWhereWithAggregatesInput[]
    OR?: NurseBranchScalarWhereWithAggregatesInput[]
    NOT?: NurseBranchScalarWhereWithAggregatesInput | NurseBranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NurseBranch"> | number
    nurseId?: IntWithAggregatesFilter<"NurseBranch"> | number
    branchId?: IntWithAggregatesFilter<"NurseBranch"> | number
  }

  export type NurseScheduleWhereInput = {
    AND?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    OR?: NurseScheduleWhereInput[]
    NOT?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    id?: IntFilter<"NurseSchedule"> | number
    nurseId?: IntFilter<"NurseSchedule"> | number
    branchId?: IntFilter<"NurseSchedule"> | number
    date?: DateTimeFilter<"NurseSchedule"> | Date | string
    startTime?: StringFilter<"NurseSchedule"> | string
    endTime?: StringFilter<"NurseSchedule"> | string
    note?: StringNullableFilter<"NurseSchedule"> | string | null
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type NurseScheduleOrderByWithRelationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    nurse?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type NurseScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nurseId_branchId_date?: NurseScheduleNurseIdBranchIdDateCompoundUniqueInput
    AND?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    OR?: NurseScheduleWhereInput[]
    NOT?: NurseScheduleWhereInput | NurseScheduleWhereInput[]
    nurseId?: IntFilter<"NurseSchedule"> | number
    branchId?: IntFilter<"NurseSchedule"> | number
    date?: DateTimeFilter<"NurseSchedule"> | Date | string
    startTime?: StringFilter<"NurseSchedule"> | string
    endTime?: StringFilter<"NurseSchedule"> | string
    note?: StringNullableFilter<"NurseSchedule"> | string | null
    nurse?: XOR<UserRelationFilter, UserWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "nurseId_branchId_date">

  export type NurseScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: NurseScheduleCountOrderByAggregateInput
    _avg?: NurseScheduleAvgOrderByAggregateInput
    _max?: NurseScheduleMaxOrderByAggregateInput
    _min?: NurseScheduleMinOrderByAggregateInput
    _sum?: NurseScheduleSumOrderByAggregateInput
  }

  export type NurseScheduleScalarWhereWithAggregatesInput = {
    AND?: NurseScheduleScalarWhereWithAggregatesInput | NurseScheduleScalarWhereWithAggregatesInput[]
    OR?: NurseScheduleScalarWhereWithAggregatesInput[]
    NOT?: NurseScheduleScalarWhereWithAggregatesInput | NurseScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NurseSchedule"> | number
    nurseId?: IntWithAggregatesFilter<"NurseSchedule"> | number
    branchId?: IntWithAggregatesFilter<"NurseSchedule"> | number
    date?: DateTimeWithAggregatesFilter<"NurseSchedule"> | Date | string
    startTime?: StringWithAggregatesFilter<"NurseSchedule"> | string
    endTime?: StringWithAggregatesFilter<"NurseSchedule"> | string
    note?: StringNullableWithAggregatesFilter<"NurseSchedule"> | string | null
  }

  export type PaymentMethodConfigWhereInput = {
    AND?: PaymentMethodConfigWhereInput | PaymentMethodConfigWhereInput[]
    OR?: PaymentMethodConfigWhereInput[]
    NOT?: PaymentMethodConfigWhereInput | PaymentMethodConfigWhereInput[]
    id?: IntFilter<"PaymentMethodConfig"> | number
    key?: StringFilter<"PaymentMethodConfig"> | string
    label?: StringFilter<"PaymentMethodConfig"> | string
    isActive?: BoolFilter<"PaymentMethodConfig"> | boolean
    sortOrder?: IntFilter<"PaymentMethodConfig"> | number
    createdAt?: DateTimeFilter<"PaymentMethodConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethodConfig"> | Date | string
    providers?: PaymentProviderConfigListRelationFilter
  }

  export type PaymentMethodConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    providers?: PaymentProviderConfigOrderByRelationAggregateInput
  }

  export type PaymentMethodConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: PaymentMethodConfigWhereInput | PaymentMethodConfigWhereInput[]
    OR?: PaymentMethodConfigWhereInput[]
    NOT?: PaymentMethodConfigWhereInput | PaymentMethodConfigWhereInput[]
    label?: StringFilter<"PaymentMethodConfig"> | string
    isActive?: BoolFilter<"PaymentMethodConfig"> | boolean
    sortOrder?: IntFilter<"PaymentMethodConfig"> | number
    createdAt?: DateTimeFilter<"PaymentMethodConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethodConfig"> | Date | string
    providers?: PaymentProviderConfigListRelationFilter
  }, "id" | "key">

  export type PaymentMethodConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodConfigCountOrderByAggregateInput
    _avg?: PaymentMethodConfigAvgOrderByAggregateInput
    _max?: PaymentMethodConfigMaxOrderByAggregateInput
    _min?: PaymentMethodConfigMinOrderByAggregateInput
    _sum?: PaymentMethodConfigSumOrderByAggregateInput
  }

  export type PaymentMethodConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodConfigScalarWhereWithAggregatesInput | PaymentMethodConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodConfigScalarWhereWithAggregatesInput | PaymentMethodConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentMethodConfig"> | number
    key?: StringWithAggregatesFilter<"PaymentMethodConfig"> | string
    label?: StringWithAggregatesFilter<"PaymentMethodConfig"> | string
    isActive?: BoolWithAggregatesFilter<"PaymentMethodConfig"> | boolean
    sortOrder?: IntWithAggregatesFilter<"PaymentMethodConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethodConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethodConfig"> | Date | string
  }

  export type PaymentProviderConfigWhereInput = {
    AND?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    OR?: PaymentProviderConfigWhereInput[]
    NOT?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    id?: IntFilter<"PaymentProviderConfig"> | number
    methodKey?: StringFilter<"PaymentProviderConfig"> | string
    name?: StringFilter<"PaymentProviderConfig"> | string
    isActive?: BoolFilter<"PaymentProviderConfig"> | boolean
    sortOrder?: IntFilter<"PaymentProviderConfig"> | number
    note?: StringNullableFilter<"PaymentProviderConfig"> | string | null
    createdAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    method?: XOR<PaymentMethodConfigRelationFilter, PaymentMethodConfigWhereInput>
  }

  export type PaymentProviderConfigOrderByWithRelationInput = {
    id?: SortOrder
    methodKey?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    method?: PaymentMethodConfigOrderByWithRelationInput
  }

  export type PaymentProviderConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    OR?: PaymentProviderConfigWhereInput[]
    NOT?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    methodKey?: StringFilter<"PaymentProviderConfig"> | string
    name?: StringFilter<"PaymentProviderConfig"> | string
    isActive?: BoolFilter<"PaymentProviderConfig"> | boolean
    sortOrder?: IntFilter<"PaymentProviderConfig"> | number
    note?: StringNullableFilter<"PaymentProviderConfig"> | string | null
    createdAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    method?: XOR<PaymentMethodConfigRelationFilter, PaymentMethodConfigWhereInput>
  }, "id">

  export type PaymentProviderConfigOrderByWithAggregationInput = {
    id?: SortOrder
    methodKey?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentProviderConfigCountOrderByAggregateInput
    _avg?: PaymentProviderConfigAvgOrderByAggregateInput
    _max?: PaymentProviderConfigMaxOrderByAggregateInput
    _min?: PaymentProviderConfigMinOrderByAggregateInput
    _sum?: PaymentProviderConfigSumOrderByAggregateInput
  }

  export type PaymentProviderConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentProviderConfigScalarWhereWithAggregatesInput | PaymentProviderConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentProviderConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentProviderConfigScalarWhereWithAggregatesInput | PaymentProviderConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentProviderConfig"> | number
    methodKey?: StringWithAggregatesFilter<"PaymentProviderConfig"> | string
    name?: StringWithAggregatesFilter<"PaymentProviderConfig"> | string
    isActive?: BoolWithAggregatesFilter<"PaymentProviderConfig"> | boolean
    sortOrder?: IntWithAggregatesFilter<"PaymentProviderConfig"> | number
    note?: StringNullableWithAggregatesFilter<"PaymentProviderConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentProviderConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentProviderConfig"> | Date | string
  }

  export type QPayIntentWhereInput = {
    AND?: QPayIntentWhereInput | QPayIntentWhereInput[]
    OR?: QPayIntentWhereInput[]
    NOT?: QPayIntentWhereInput | QPayIntentWhereInput[]
    id?: IntFilter<"QPayIntent"> | number
    environment?: StringFilter<"QPayIntent"> | string
    objectType?: StringFilter<"QPayIntent"> | string
    objectId?: IntFilter<"QPayIntent"> | number
    qpayInvoiceId?: StringFilter<"QPayIntent"> | string
    senderInvoiceNo?: StringFilter<"QPayIntent"> | string
    amount?: FloatFilter<"QPayIntent"> | number
    status?: StringFilter<"QPayIntent"> | string
    paidAmount?: FloatNullableFilter<"QPayIntent"> | number | null
    qpayPaymentId?: StringNullableFilter<"QPayIntent"> | string | null
    raw?: JsonNullableFilter<"QPayIntent">
    createdAt?: DateTimeFilter<"QPayIntent"> | Date | string
    updatedAt?: DateTimeFilter<"QPayIntent"> | Date | string
  }

  export type QPayIntentOrderByWithRelationInput = {
    id?: SortOrder
    environment?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    qpayInvoiceId?: SortOrder
    senderInvoiceNo?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    qpayPaymentId?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QPayIntentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    qpayInvoiceId?: string
    senderInvoiceNo?: string
    AND?: QPayIntentWhereInput | QPayIntentWhereInput[]
    OR?: QPayIntentWhereInput[]
    NOT?: QPayIntentWhereInput | QPayIntentWhereInput[]
    environment?: StringFilter<"QPayIntent"> | string
    objectType?: StringFilter<"QPayIntent"> | string
    objectId?: IntFilter<"QPayIntent"> | number
    amount?: FloatFilter<"QPayIntent"> | number
    status?: StringFilter<"QPayIntent"> | string
    paidAmount?: FloatNullableFilter<"QPayIntent"> | number | null
    qpayPaymentId?: StringNullableFilter<"QPayIntent"> | string | null
    raw?: JsonNullableFilter<"QPayIntent">
    createdAt?: DateTimeFilter<"QPayIntent"> | Date | string
    updatedAt?: DateTimeFilter<"QPayIntent"> | Date | string
  }, "id" | "qpayInvoiceId" | "senderInvoiceNo">

  export type QPayIntentOrderByWithAggregationInput = {
    id?: SortOrder
    environment?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    qpayInvoiceId?: SortOrder
    senderInvoiceNo?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    qpayPaymentId?: SortOrderInput | SortOrder
    raw?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QPayIntentCountOrderByAggregateInput
    _avg?: QPayIntentAvgOrderByAggregateInput
    _max?: QPayIntentMaxOrderByAggregateInput
    _min?: QPayIntentMinOrderByAggregateInput
    _sum?: QPayIntentSumOrderByAggregateInput
  }

  export type QPayIntentScalarWhereWithAggregatesInput = {
    AND?: QPayIntentScalarWhereWithAggregatesInput | QPayIntentScalarWhereWithAggregatesInput[]
    OR?: QPayIntentScalarWhereWithAggregatesInput[]
    NOT?: QPayIntentScalarWhereWithAggregatesInput | QPayIntentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QPayIntent"> | number
    environment?: StringWithAggregatesFilter<"QPayIntent"> | string
    objectType?: StringWithAggregatesFilter<"QPayIntent"> | string
    objectId?: IntWithAggregatesFilter<"QPayIntent"> | number
    qpayInvoiceId?: StringWithAggregatesFilter<"QPayIntent"> | string
    senderInvoiceNo?: StringWithAggregatesFilter<"QPayIntent"> | string
    amount?: FloatWithAggregatesFilter<"QPayIntent"> | number
    status?: StringWithAggregatesFilter<"QPayIntent"> | string
    paidAmount?: FloatNullableWithAggregatesFilter<"QPayIntent"> | number | null
    qpayPaymentId?: StringNullableWithAggregatesFilter<"QPayIntent"> | string | null
    raw?: JsonNullableWithAggregatesFilter<"QPayIntent">
    createdAt?: DateTimeWithAggregatesFilter<"QPayIntent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QPayIntent"> | Date | string
  }

  export type BranchCreateInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitCreateInput = {
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeBenefitsInput
    usages?: EmployeeBenefitUsageCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitUncheckedCreateInput = {
    id?: number
    employeeId: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeBenefitsNestedInput
    usages?: EmployeeBenefitUsageUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitCreateManyInput = {
    id?: number
    employeeId: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeBenefitUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageCreateInput = {
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
    employeeBenefit: EmployeeBenefitCreateNestedOneWithoutUsagesInput
    invoice: InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput
    encounter: EncounterCreateNestedOneWithoutEmployeeBenefitUsagesInput
    patient: PatientCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageUpdateInput = {
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeBenefit?: EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    patient?: PatientUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageCreateManyInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageUpdateManyMutationInput = {
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationItemCreateNestedManyWithoutCategoryInput
  }

  export type SterilizationCategoryUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type SterilizationCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationItemUpdateManyWithoutCategoryNestedInput
  }

  export type SterilizationCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SterilizationCategoryCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationItemCreateInput = {
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: SterilizationCategoryCreateNestedOneWithoutItemsInput
    indicatorItems?: SterilizationIndicatorItemCreateNestedManyWithoutItemInput
  }

  export type SterilizationItemUncheckedCreateInput = {
    id?: number
    categoryId: number
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicatorItems?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type SterilizationItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: SterilizationCategoryUpdateOneRequiredWithoutItemsNestedInput
    indicatorItems?: SterilizationIndicatorItemUpdateManyWithoutItemNestedInput
  }

  export type SterilizationItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicatorItems?: SterilizationIndicatorItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SterilizationItemCreateManyInput = {
    id?: number
    categoryId: number
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorCreateInput = {
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSterilizationIndicatorsInput
    specialist: UserCreateNestedOneWithoutSterilizationIndicatorsInput
    items?: SterilizationIndicatorItemCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUncheckedCreateInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUpdateInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    specialist?: UserUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    items?: SterilizationIndicatorItemUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorCreateManyInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationIndicatorUpdateManyMutationInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorItemCreateInput = {
    indicator: SterilizationIndicatorCreateNestedOneWithoutItemsInput
    item: SterilizationItemCreateNestedOneWithoutIndicatorItemsInput
  }

  export type SterilizationIndicatorItemUncheckedCreateInput = {
    id?: number
    indicatorId: number
    itemId: number
  }

  export type SterilizationIndicatorItemUpdateInput = {
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutItemsNestedInput
    item?: SterilizationItemUpdateOneRequiredWithoutIndicatorItemsNestedInput
  }

  export type SterilizationIndicatorItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type SterilizationIndicatorItemCreateManyInput = {
    id?: number
    indicatorId: number
    itemId: number
  }

  export type SterilizationIndicatorItemUpdateManyMutationInput = {

  }

  export type SterilizationIndicatorItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterSterilizationPackageUseCreateInput = {
    usedQuantity?: number
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutSterilizationPackageUsesInput
    indicator: SterilizationIndicatorCreateNestedOneWithoutUsesInput
    openedBy?: UserCreateNestedOneWithoutOpenedSterilizationPackagesInput
  }

  export type EncounterSterilizationPackageUseUncheckedCreateInput = {
    id?: number
    encounterId: number
    indicatorId: number
    usedQuantity?: number
    openedByUserId?: number | null
    createdAt?: Date | string
  }

  export type EncounterSterilizationPackageUseUpdateInput = {
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutSterilizationPackageUsesNestedInput
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutUsesNestedInput
    openedBy?: UserUpdateOneWithoutOpenedSterilizationPackagesNestedInput
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    openedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseCreateManyInput = {
    id?: number
    encounterId: number
    indicatorId: number
    usedQuantity?: number
    openedByUserId?: number | null
    createdAt?: Date | string
  }

  export type EncounterSterilizationPackageUseUpdateManyMutationInput = {
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    openedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PatientCreateInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
  }

  export type PatientUpdateManyMutationInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type PatientBookCreateInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateInput = {
    id?: number
    bookNumber: string
    patientId: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUpdateInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookCreateManyInput = {
    id?: number
    bookNumber: string
    patientId: number
  }

  export type PatientBookUpdateManyMutationInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
  }

  export type PatientBookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
  }

  export type VisitCardCreateInput = {
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook: PatientBookCreateNestedOneWithoutVisitCardInput
  }

  export type VisitCardUncheckedCreateInput = {
    id?: number
    patientBookId: number
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardUpdateInput = {
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUpdateOneRequiredWithoutVisitCardNestedInput
  }

  export type VisitCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCardCreateManyInput = {
    id?: number
    patientBookId: number
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardUpdateManyMutationInput = {
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook: PatientBookCreateNestedOneWithoutOrthoCardInput
  }

  export type OrthoCardUncheckedCreateInput = {
    id?: number
    patientBookId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUpdateOneRequiredWithoutOrthoCardNestedInput
  }

  export type OrthoCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardCreateManyInput = {
    id?: number
    patientBookId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type AppointmentUpdateManyMutationInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutBookingsInput
    branch: BranchCreateNestedOneWithoutBookingsInput
    patient: PatientCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    doctorId: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutBookingsNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: number
    doctorId: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterUpdateManyMutationInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterConsentCreateInput = {
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutConsentsInput
  }

  export type EncounterConsentUncheckedCreateInput = {
    id?: number
    encounterId: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type EncounterConsentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentCreateManyInput = {
    id?: number
    encounterId: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartToothCreateInput = {
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounter: EncounterCreateNestedOneWithoutChartTeethInput
    chartNotes?: ChartNoteCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothUncheckedCreateInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounterId: number
    chartNotes?: ChartNoteUncheckedCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothUpdateInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutChartTeethNestedInput
    chartNotes?: ChartNoteUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: IntFieldUpdateOperationsInput | number
    chartNotes?: ChartNoteUncheckedUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothCreateManyInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounterId: number
  }

  export type ChartToothUpdateManyMutationInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChartToothUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: IntFieldUpdateOperationsInput | number
  }

  export type ChartNoteCreateInput = {
    description: string
    createdAt?: Date | string
    chartTooth: ChartToothCreateNestedOneWithoutChartNotesInput
  }

  export type ChartNoteUncheckedCreateInput = {
    id?: number
    chartToothId: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartTooth?: ChartToothUpdateOneRequiredWithoutChartNotesNestedInput
  }

  export type ChartNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chartToothId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteCreateManyInput = {
    id?: number
    chartToothId: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chartToothId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemCreateNestedManyWithoutDiagnosisInput
    encounters?: EncounterDiagnosisCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemUncheckedCreateNestedManyWithoutDiagnosisInput
    encounters?: EncounterDiagnosisUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUpdateManyWithoutDiagnosisNestedInput
    encounters?: EncounterDiagnosisUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisNestedInput
    encounters?: EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisCreateManyInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiagnosisUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisProblemCreateInput = {
    label: string
    order?: number
    active?: boolean
    diagnosis: DiagnosisCreateNestedOneWithoutProblemsInput
  }

  export type DiagnosisProblemUncheckedCreateInput = {
    id?: number
    diagnosisId: number
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    diagnosis?: DiagnosisUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type DiagnosisProblemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemCreateManyInput = {
    id?: number
    diagnosisId: number
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterDiagnosisCreateInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDiagnosesInput
    diagnosis: DiagnosisCreateNestedOneWithoutEncountersInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutEncounterDiagnosisInput
  }

  export type EncounterDiagnosisUncheckedCreateInput = {
    id?: number
    encounterId: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutEncounterDiagnosisInput
  }

  export type EncounterDiagnosisUpdateInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDiagnosesNestedInput
    diagnosis?: DiagnosisUpdateOneRequiredWithoutEncountersNestedInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutEncounterDiagnosisNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutEncounterDiagnosisNestedInput
  }

  export type EncounterDiagnosisCreateManyInput = {
    id?: number
    encounterId: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisUpdateManyMutationInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateInput = {
    createdAt?: Date | string
    encounterDiagnosis: EncounterDiagnosisCreateNestedOneWithoutSterilizationIndicatorsInput
    indicator: SterilizationIndicatorCreateNestedOneWithoutEncounterDiagnosisLinksInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedCreateInput = {
    id?: number
    encounterDiagnosisId: number
    indicatorId: number
    createdAt?: Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterDiagnosis?: EncounterDiagnosisUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutEncounterDiagnosisLinksNestedInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterDiagnosisId?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateManyInput = {
    id?: number
    encounterDiagnosisId: number
    indicatorId: number
    createdAt?: Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterDiagnosisId?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
  }

  export type ServiceUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchCreateInput = {
    service: ServiceCreateNestedOneWithoutServiceBranchesInput
    branch: BranchCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateInput = {
    serviceId: number
    branchId: number
  }

  export type ServiceBranchUpdateInput = {
    service?: ServiceUpdateOneRequiredWithoutServiceBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceBranchCreateManyInput = {
    serviceId: number
    branchId: number
  }

  export type ServiceBranchUpdateManyMutationInput = {

  }

  export type ServiceBranchUncheckedUpdateManyInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterServiceCreateInput = {
    quantity?: number
    price: number
    encounter: EncounterCreateNestedOneWithoutEncounterServicesInput
    service: ServiceCreateNestedOneWithoutEncounterServicesInput
  }

  export type EncounterServiceUncheckedCreateInput = {
    id?: number
    encounterId: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    encounter?: EncounterUpdateOneRequiredWithoutEncounterServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutEncounterServicesNestedInput
  }

  export type EncounterServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceCreateManyInput = {
    id?: number
    encounterId: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcedureCreateInput = {
    code: string
    name: string
    price: number
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUncheckedCreateInput = {
    code: string
    name: string
    price: number
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProcedureInput
  }

  export type ProcedureUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    invoiceItems?: InvoiceItemUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProcedureNestedInput
  }

  export type ProcedureCreateManyInput = {
    code: string
    name: string
    price: number
  }

  export type ProcedureUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcedureUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductCreateInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    stockMovements?: ProductStockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    branchId: number
    categoryId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    stockMovements?: ProductStockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: ProductStockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    branchId: number
    categoryId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockMovementCreateInput = {
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductStockMovementsInput
    product: ProductCreateNestedOneWithoutStockMovementsInput
  }

  export type ProductStockMovementUncheckedCreateInput = {
    id?: number
    branchId: number
    productId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type ProductStockMovementUpdateInput = {
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductStockMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type ProductStockMovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockMovementCreateManyInput = {
    id?: number
    branchId: number
    productId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type ProductStockMovementUpdateManyMutationInput = {
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockMovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductCategoriesInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    branchId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductCategoriesNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    branchId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    encounter: EncounterCreateNestedOneWithoutPrescriptionInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: number
    encounterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutPrescriptionNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: number
    encounterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
  }

  export type PrescriptionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemCreateInput = {
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
    prescription: PrescriptionCreateNestedOneWithoutItemsInput
  }

  export type PrescriptionItemUncheckedCreateInput = {
    id?: number
    prescriptionId: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemCreateManyInput = {
    id?: number
    prescriptionId: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    prescriptionId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceCreateInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateManyInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateManyMutationInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type PaymentCreateInput = {
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    invoiceId: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    invoiceId: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptCreateInput = {
    receiptNumber: string
    timestamp?: Date | string
    invoice: InvoiceCreateNestedOneWithoutEBarimtReceiptInput
  }

  export type EBarimtReceiptUncheckedCreateInput = {
    id?: number
    invoiceId: number
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptUpdateInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutEBarimtReceiptNestedInput
  }

  export type EBarimtReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptCreateManyInput = {
    id?: number
    invoiceId: number
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptUpdateManyMutationInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateManyMutationInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorizationCodeCreateInput = {
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAuthorizationCodesInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeUncheckedCreateInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAuthorizationCodesNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeCreateManyInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorizationCodeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorizationCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherCreateInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherCreateManyInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type EmployeeVoucherUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type MediaCreateInput = {
    filePath: string
    toothCode?: string | null
    type: string
    encounter: EncounterCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: number
    encounterId: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaUpdateInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    encounter?: EncounterUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateManyInput = {
    id?: number
    encounterId: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaUpdateManyMutationInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorScheduleCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    doctor: UserCreateNestedOneWithoutDoctorSchedulesInput
    branch: BranchCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneRequiredWithoutDoctorSchedulesNestedInput
    branch?: BranchUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleCreateManyInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    reception: UserCreateNestedOneWithoutReceptionSchedulesInput
    branch: BranchCreateNestedOneWithoutReceptionSchedulesInput
  }

  export type ReceptionScheduleUncheckedCreateInput = {
    id?: number
    receptionId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reception?: UserUpdateOneRequiredWithoutReceptionSchedulesNestedInput
    branch?: BranchUpdateOneRequiredWithoutReceptionSchedulesNestedInput
  }

  export type ReceptionScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleCreateManyInput = {
    id?: number
    receptionId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorBranchCreateInput = {
    doctor: UserCreateNestedOneWithoutDoctorBranchesInput
    branch: BranchCreateNestedOneWithoutDoctorBranchesInput
  }

  export type DoctorBranchUncheckedCreateInput = {
    id?: number
    doctorId: number
    branchId: number
  }

  export type DoctorBranchUpdateInput = {
    doctor?: UserUpdateOneRequiredWithoutDoctorBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutDoctorBranchesNestedInput
  }

  export type DoctorBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchCreateManyInput = {
    id?: number
    doctorId: number
    branchId: number
  }

  export type DoctorBranchUpdateManyMutationInput = {

  }

  export type DoctorBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchCreateInput = {
    reception: UserCreateNestedOneWithoutReceptionBranchesInput
    branch: BranchCreateNestedOneWithoutReceptionBranchesInput
  }

  export type ReceptionBranchUncheckedCreateInput = {
    id?: number
    receptionId: number
    branchId: number
  }

  export type ReceptionBranchUpdateInput = {
    reception?: UserUpdateOneRequiredWithoutReceptionBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutReceptionBranchesNestedInput
  }

  export type ReceptionBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchCreateManyInput = {
    id?: number
    receptionId: number
    branchId: number
  }

  export type ReceptionBranchUpdateManyMutationInput = {

  }

  export type ReceptionBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchCreateInput = {
    nurse: UserCreateNestedOneWithoutNurseBranchesInput
    branch: BranchCreateNestedOneWithoutNurseBranchesInput
  }

  export type NurseBranchUncheckedCreateInput = {
    id?: number
    nurseId: number
    branchId: number
  }

  export type NurseBranchUpdateInput = {
    nurse?: UserUpdateOneRequiredWithoutNurseBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutNurseBranchesNestedInput
  }

  export type NurseBranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchCreateManyInput = {
    id?: number
    nurseId: number
    branchId: number
  }

  export type NurseBranchUpdateManyMutationInput = {

  }

  export type NurseBranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseScheduleCreateInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    nurse: UserCreateNestedOneWithoutNurseSchedulesInput
    branch: BranchCreateNestedOneWithoutNurseSchedulesInput
  }

  export type NurseScheduleUncheckedCreateInput = {
    id?: number
    nurseId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nurse?: UserUpdateOneRequiredWithoutNurseSchedulesNestedInput
    branch?: BranchUpdateOneRequiredWithoutNurseSchedulesNestedInput
  }

  export type NurseScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleCreateManyInput = {
    id?: number
    nurseId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodConfigCreateInput = {
    key: string
    label: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: PaymentProviderConfigCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodConfigUncheckedCreateInput = {
    id?: number
    key: string
    label: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: PaymentProviderConfigUncheckedCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: PaymentProviderConfigUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: PaymentProviderConfigUncheckedUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodConfigCreateManyInput = {
    id?: number
    key: string
    label: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigCreateInput = {
    name: string
    isActive?: boolean
    sortOrder?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    method: PaymentMethodConfigCreateNestedOneWithoutProvidersInput
  }

  export type PaymentProviderConfigUncheckedCreateInput = {
    id?: number
    methodKey: string
    name: string
    isActive?: boolean
    sortOrder?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: PaymentMethodConfigUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type PaymentProviderConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodKey?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigCreateManyInput = {
    id?: number
    methodKey: string
    name: string
    isActive?: boolean
    sortOrder?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    methodKey?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayIntentCreateInput = {
    environment: string
    objectType: string
    objectId: number
    qpayInvoiceId: string
    senderInvoiceNo: string
    amount: number
    status?: string
    paidAmount?: number | null
    qpayPaymentId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayIntentUncheckedCreateInput = {
    id?: number
    environment: string
    objectType: string
    objectId: number
    qpayInvoiceId: string
    senderInvoiceNo: string
    amount: number
    status?: string
    paidAmount?: number | null
    qpayPaymentId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayIntentUpdateInput = {
    environment?: StringFieldUpdateOperationsInput | string
    objectType?: StringFieldUpdateOperationsInput | string
    objectId?: IntFieldUpdateOperationsInput | number
    qpayInvoiceId?: StringFieldUpdateOperationsInput | string
    senderInvoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    qpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayIntentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    environment?: StringFieldUpdateOperationsInput | string
    objectType?: StringFieldUpdateOperationsInput | string
    objectId?: IntFieldUpdateOperationsInput | number
    qpayInvoiceId?: StringFieldUpdateOperationsInput | string
    senderInvoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    qpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayIntentCreateManyInput = {
    id?: number
    environment: string
    objectType: string
    objectId: number
    qpayInvoiceId: string
    senderInvoiceNo: string
    amount: number
    status?: string
    paidAmount?: number | null
    qpayPaymentId?: string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QPayIntentUpdateManyMutationInput = {
    environment?: StringFieldUpdateOperationsInput | string
    objectType?: StringFieldUpdateOperationsInput | string
    objectId?: IntFieldUpdateOperationsInput | number
    qpayInvoiceId?: StringFieldUpdateOperationsInput | string
    senderInvoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    qpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QPayIntentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    environment?: StringFieldUpdateOperationsInput | string
    objectType?: StringFieldUpdateOperationsInput | string
    objectId?: IntFieldUpdateOperationsInput | number
    qpayInvoiceId?: StringFieldUpdateOperationsInput | string
    senderInvoiceNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    qpayPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    raw?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type DoctorScheduleListRelationFilter = {
    every?: DoctorScheduleWhereInput
    some?: DoctorScheduleWhereInput
    none?: DoctorScheduleWhereInput
  }

  export type ServiceBranchListRelationFilter = {
    every?: ServiceBranchWhereInput
    some?: ServiceBranchWhereInput
    none?: ServiceBranchWhereInput
  }

  export type DoctorBranchListRelationFilter = {
    every?: DoctorBranchWhereInput
    some?: DoctorBranchWhereInput
    none?: DoctorBranchWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReceptionScheduleListRelationFilter = {
    every?: ReceptionScheduleWhereInput
    some?: ReceptionScheduleWhereInput
    none?: ReceptionScheduleWhereInput
  }

  export type ReceptionBranchListRelationFilter = {
    every?: ReceptionBranchWhereInput
    some?: ReceptionBranchWhereInput
    none?: ReceptionBranchWhereInput
  }

  export type NurseScheduleListRelationFilter = {
    every?: NurseScheduleWhereInput
    some?: NurseScheduleWhereInput
    none?: NurseScheduleWhereInput
  }

  export type NurseBranchListRelationFilter = {
    every?: NurseBranchWhereInput
    some?: NurseBranchWhereInput
    none?: NurseBranchWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type ProductStockMovementListRelationFilter = {
    every?: ProductStockMovementWhereInput
    some?: ProductStockMovementWhereInput
    none?: ProductStockMovementWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type EmployeeVoucherListRelationFilter = {
    every?: EmployeeVoucherWhereInput
    some?: EmployeeVoucherWhereInput
    none?: EmployeeVoucherWhereInput
  }

  export type SterilizationIndicatorListRelationFilter = {
    every?: SterilizationIndicatorWhereInput
    some?: SterilizationIndicatorWhereInput
    none?: SterilizationIndicatorWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceptionScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceptionBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NurseScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NurseBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductStockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeVoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SterilizationIndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeBenefitUsageListRelationFilter = {
    every?: EmployeeBenefitUsageWhereInput
    some?: EmployeeBenefitUsageWhereInput
    none?: EmployeeBenefitUsageWhereInput
  }

  export type EmployeeBenefitUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeBenefitCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeBenefitAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type EmployeeBenefitMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeBenefitMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeBenefitSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    branchId?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmployeeBenefitRelationFilter = {
    is?: EmployeeBenefitWhereInput
    isNot?: EmployeeBenefitWhereInput
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type EncounterRelationFilter = {
    is?: EncounterWhereInput
    isNot?: EncounterWhereInput
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type EmployeeBenefitUsageCountOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    patientBookNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeBenefitUsageAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
  }

  export type EmployeeBenefitUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    patientBookNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeBenefitUsageMinOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
    patientBookNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeBenefitUsageSumOrderByAggregateInput = {
    id?: SortOrder
    employeeBenefitId?: SortOrder
    invoiceId?: SortOrder
    encounterId?: SortOrder
    amountUsed?: SortOrder
    patientId?: SortOrder
  }

  export type SterilizationItemListRelationFilter = {
    every?: SterilizationItemWhereInput
    some?: SterilizationItemWhereInput
    none?: SterilizationItemWhereInput
  }

  export type SterilizationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SterilizationCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SterilizationCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SterilizationCategoryRelationFilter = {
    is?: SterilizationCategoryWhereInput
    isNot?: SterilizationCategoryWhereInput
  }

  export type SterilizationIndicatorItemListRelationFilter = {
    every?: SterilizationIndicatorItemWhereInput
    some?: SterilizationIndicatorItemWhereInput
    none?: SterilizationIndicatorItemWhereInput
  }

  export type SterilizationIndicatorItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SterilizationItemCategoryIdNameCompoundUniqueInput = {
    categoryId: number
    name: string
  }

  export type SterilizationItemCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationItemAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
  }

  export type SterilizationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationItemMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationItemSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    quantity?: SortOrder
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type EncounterSterilizationPackageUseListRelationFilter = {
    every?: EncounterSterilizationPackageUseWhereInput
    some?: EncounterSterilizationPackageUseWhereInput
    none?: EncounterSterilizationPackageUseWhereInput
  }

  export type EncounterDiagnosisSterilizationIndicatorListRelationFilter = {
    every?: EncounterDiagnosisSterilizationIndicatorWhereInput
    some?: EncounterDiagnosisSterilizationIndicatorWhereInput
    none?: EncounterDiagnosisSterilizationIndicatorWhereInput
  }

  export type EncounterSterilizationPackageUseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterDiagnosisSterilizationIndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SterilizationIndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    packageName?: SortOrder
    code?: SortOrder
    indicatorDate?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationIndicatorAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
  }

  export type SterilizationIndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    packageName?: SortOrder
    code?: SortOrder
    indicatorDate?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationIndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    packageName?: SortOrder
    code?: SortOrder
    indicatorDate?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SterilizationIndicatorSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    specialistUserId?: SortOrder
    packageQuantity?: SortOrder
  }

  export type SterilizationIndicatorRelationFilter = {
    is?: SterilizationIndicatorWhereInput
    isNot?: SterilizationIndicatorWhereInput
  }

  export type SterilizationItemRelationFilter = {
    is?: SterilizationItemWhereInput
    isNot?: SterilizationItemWhereInput
  }

  export type SterilizationIndicatorItemIndicatorIdItemIdCompoundUniqueInput = {
    indicatorId: number
    itemId: number
  }

  export type SterilizationIndicatorItemCountOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
  }

  export type SterilizationIndicatorItemAvgOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
  }

  export type SterilizationIndicatorItemMaxOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
  }

  export type SterilizationIndicatorItemMinOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
  }

  export type SterilizationIndicatorItemSumOrderByAggregateInput = {
    id?: SortOrder
    indicatorId?: SortOrder
    itemId?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EncounterSterilizationPackageUseCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterSterilizationPackageUseAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrder
  }

  export type EncounterSterilizationPackageUseMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterSterilizationPackageUseMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterSterilizationPackageUseSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    indicatorId?: SortOrder
    usedQuantity?: SortOrder
    openedByUserId?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type EmployeeBenefitListRelationFilter = {
    every?: EmployeeBenefitWhereInput
    some?: EmployeeBenefitWhereInput
    none?: EmployeeBenefitWhereInput
  }

  export type AuthorizationCodeListRelationFilter = {
    every?: AuthorizationCodeWhereInput
    some?: AuthorizationCodeWhereInput
    none?: AuthorizationCodeWhereInput
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeBenefitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorizationCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    regNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiryDate?: SortOrder
    signatureImagePath?: SortOrder
    stampImagePath?: SortOrder
    idPhotoPath?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    regNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiryDate?: SortOrder
    signatureImagePath?: SortOrder
    stampImagePath?: SortOrder
    idPhotoPath?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    role?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    phone?: SortOrder
    regNo?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiryDate?: SortOrder
    signatureImagePath?: SortOrder
    stampImagePath?: SortOrder
    idPhotoPath?: SortOrder
    calendarOrder?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    calendarOrder?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type PatientBookNullableRelationFilter = {
    is?: PatientBookWhereInput | null
    isNot?: PatientBookWhereInput | null
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bloodType?: SortOrder
    citizenship?: SortOrder
    emergencyPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bloodType?: SortOrder
    citizenship?: SortOrder
    emergencyPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    ovog?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    bloodType?: SortOrder
    citizenship?: SortOrder
    emergencyPhone?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchId?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type VisitCardNullableRelationFilter = {
    is?: VisitCardWhereInput | null
    isNot?: VisitCardWhereInput | null
  }

  export type OrthoCardNullableRelationFilter = {
    is?: OrthoCardWhereInput | null
    isNot?: OrthoCardWhereInput | null
  }

  export type PatientBookCountOrderByAggregateInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookMaxOrderByAggregateInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookMinOrderByAggregateInput = {
    id?: SortOrder
    bookNumber?: SortOrder
    patientId?: SortOrder
  }

  export type PatientBookSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
  }

  export type EnumVisitCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeFilter<$PrismaModel> | $Enums.VisitCardType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PatientBookRelationFilter = {
    is?: PatientBookWhereInput
    isNot?: PatientBookWhereInput
  }

  export type VisitCardCountOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    patientSignaturePath?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitCardAvgOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type VisitCardMaxOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    patientSignaturePath?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitCardMinOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    type?: SortOrder
    patientSignaturePath?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VisitCardSumOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type EnumVisitCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitCardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitCardTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitCardTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type OrthoCardCountOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrthoCardAvgOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type OrthoCardMaxOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrthoCardMinOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrthoCardSumOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    scheduledAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type AppointmentNullableRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type ChartToothListRelationFilter = {
    every?: ChartToothWhereInput
    some?: ChartToothWhereInput
    none?: ChartToothWhereInput
  }

  export type InvoiceNullableRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PrescriptionNullableRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type EncounterServiceListRelationFilter = {
    every?: EncounterServiceWhereInput
    some?: EncounterServiceWhereInput
    none?: EncounterServiceWhereInput
  }

  export type EncounterDiagnosisListRelationFilter = {
    every?: EncounterDiagnosisWhereInput
    some?: EncounterDiagnosisWhereInput
    none?: EncounterDiagnosisWhereInput
  }

  export type EncounterConsentListRelationFilter = {
    every?: EncounterConsentWhereInput
    some?: EncounterConsentWhereInput
    none?: EncounterConsentWhereInput
  }

  export type ChartToothOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterDiagnosisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
    patientSignaturePath?: SortOrder
    patientSignedAt?: SortOrder
    doctorSignaturePath?: SortOrder
    doctorSignedAt?: SortOrder
  }

  export type EncounterAvgOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
    patientSignaturePath?: SortOrder
    patientSignedAt?: SortOrder
    doctorSignaturePath?: SortOrder
    doctorSignedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    notes?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
    patientSignaturePath?: SortOrder
    patientSignedAt?: SortOrder
    doctorSignaturePath?: SortOrder
    doctorSignedAt?: SortOrder
  }

  export type EncounterSumOrderByAggregateInput = {
    id?: SortOrder
    patientBookId?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    nurseId?: SortOrder
  }

  export type EncounterConsentEncounterIdTypeCompoundUniqueInput = {
    encounterId: number
    type: string
  }

  export type EncounterConsentCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    answers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterConsentAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type EncounterConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterConsentMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterConsentSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartNoteListRelationFilter = {
    every?: ChartNoteWhereInput
    some?: ChartNoteWhereInput
    none?: ChartNoteWhereInput
  }

  export type ChartNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChartToothCountOrderByAggregateInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothMaxOrderByAggregateInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothMinOrderByAggregateInput = {
    id?: SortOrder
    toothCode?: SortOrder
    toothGroup?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type ChartToothRelationFilter = {
    is?: ChartToothWhereInput
    isNot?: ChartToothWhereInput
  }

  export type ChartNoteCountOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
  }

  export type ChartNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartNoteMinOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartNoteSumOrderByAggregateInput = {
    id?: SortOrder
    chartToothId?: SortOrder
  }

  export type DiagnosisProblemListRelationFilter = {
    every?: DiagnosisProblemWhereInput
    some?: DiagnosisProblemWhereInput
    none?: DiagnosisProblemWhereInput
  }

  export type DiagnosisProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiagnosisSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiagnosisRelationFilter = {
    is?: DiagnosisWhereInput
    isNot?: DiagnosisWhereInput
  }

  export type DiagnosisProblemCountOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
  }

  export type DiagnosisProblemAvgOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    order?: SortOrder
  }

  export type DiagnosisProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
  }

  export type DiagnosisProblemMinOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    label?: SortOrder
    order?: SortOrder
    active?: SortOrder
  }

  export type DiagnosisProblemSumOrderByAggregateInput = {
    id?: SortOrder
    diagnosisId?: SortOrder
    order?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EncounterDiagnosisCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrder
    selectedProblemIds?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
  }

  export type EncounterDiagnosisMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
    toothCode?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    diagnosisId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EncounterDiagnosisRelationFilter = {
    is?: EncounterDiagnosisWhereInput
    isNot?: EncounterDiagnosisWhereInput
  }

  export type EncounterDiagnosisSterilizationIndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisSterilizationIndicatorAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
  }

  export type EncounterDiagnosisSterilizationIndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisSterilizationIndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
    createdAt?: SortOrder
  }

  export type EncounterDiagnosisSterilizationIndicatorSumOrderByAggregateInput = {
    id?: SortOrder
    encounterDiagnosisId?: SortOrder
    indicatorId?: SortOrder
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceBranchServiceIdBranchIdCompoundUniqueInput = {
    serviceId: number
    branchId: number
  }

  export type ServiceBranchCountOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchAvgOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchMaxOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchMinOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type ServiceBranchSumOrderByAggregateInput = {
    serviceId?: SortOrder
    branchId?: SortOrder
  }

  export type EncounterServiceCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EncounterServiceSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ProcedureCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProcedureAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProcedureMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProcedureMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type ProcedureSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ProductCategoryRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
  }

  export type EnumProductStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStockMovementType | EnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStockMovementTypeFilter<$PrismaModel> | $Enums.ProductStockMovementType
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductStockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrder
    ledgerEntryId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductStockMovementAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrder
    ledgerEntryId?: SortOrder
  }

  export type ProductStockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrder
    ledgerEntryId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductStockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    type?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrder
    ledgerEntryId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductStockMovementSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    productId?: SortOrder
    quantityDelta?: SortOrder
    invoiceId?: SortOrder
    ledgerEntryId?: SortOrder
  }

  export type EnumProductStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStockMovementType | EnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductStockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumProductStockMovementTypeFilter<$PrismaModel>
  }

  export type ProductCategoryBranchIdNameCompoundUniqueInput = {
    branchId: number
    name: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
  }

  export type PrescriptionItemListRelationFilter = {
    every?: PrescriptionItemWhereInput
    some?: PrescriptionItemWhereInput
    none?: PrescriptionItemWhereInput
  }

  export type PrescriptionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrder
    patientNameSnapshot?: SortOrder
    diagnosisSummary?: SortOrder
    clinicNameSnapshot?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrder
    patientNameSnapshot?: SortOrder
    diagnosisSummary?: SortOrder
    clinicNameSnapshot?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorNameSnapshot?: SortOrder
    patientNameSnapshot?: SortOrder
    diagnosisSummary?: SortOrder
    clinicNameSnapshot?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type PrescriptionRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type PrescriptionItemCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrder
  }

  export type PrescriptionItemAvgOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
  }

  export type PrescriptionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrder
  }

  export type PrescriptionItemMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    drugName?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
    note?: SortOrder
  }

  export type PrescriptionItemSumOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    order?: SortOrder
    durationDays?: SortOrder
    quantityPerTake?: SortOrder
    frequencyPerDay?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumDiscountPercentFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentFilter<$PrismaModel> | $Enums.DiscountPercent
  }

  export type PatientNullableRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type EBarimtReceiptNullableRelationFilter = {
    is?: EBarimtReceiptWhereInput | null
    isNot?: EBarimtReceiptWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrder
    statusLegacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    finalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrder
    statusLegacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    discountPercent?: SortOrder
    finalAmount?: SortOrder
    statusLegacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    totalAmount?: SortOrder
    totalBeforeDiscount?: SortOrder
    finalAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDiscountPercentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentWithAggregatesFilter<$PrismaModel> | $Enums.DiscountPercent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountPercentFilter<$PrismaModel>
    _max?: NestedEnumDiscountPercentFilter<$PrismaModel>
  }

  export type EnumInvoiceItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeFilter<$PrismaModel> | $Enums.InvoiceItemType
  }

  export type EnumInvoiceItemSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceFilter<$PrismaModel> | $Enums.InvoiceItemSource
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ProcedureNullableRelationFilter = {
    is?: ProcedureWhereInput | null
    isNot?: ProcedureWhereInput | null
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    procedureCode?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    procedureCode?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    procedureCode?: SortOrder
    name?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    unitPrice?: SortOrder
    quantity?: SortOrder
    lineTotal?: SortOrder
  }

  export type EnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    qpayTxnId?: SortOrder
    timestamp?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
  }

  export type EBarimtReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
  }

  export type EBarimtReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
  }

  export type EBarimtReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
  }

  export type EBarimtReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    receiptNumber?: SortOrder
    timestamp?: SortOrder
  }

  export type EBarimtReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
  }

  export type EnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type AuthorizationCodeNullableRelationFilter = {
    is?: AuthorizationCodeWhereInput | null
    isNot?: AuthorizationCodeWhereInput | null
  }

  export type EmployeeVoucherNullableRelationFilter = {
    is?: EmployeeVoucherWhereInput | null
    isNot?: EmployeeVoucherWhereInput | null
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    approvalCodeId?: SortOrder
    employeeVoucherId?: SortOrder
  }

  export type EnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type AuthorizationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationCodeAvgOrderByAggregateInput = {
    id?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
  }

  export type AuthorizationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    purpose?: SortOrder
    isEnabled?: SortOrder
    expiresAt?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationCodeSumOrderByAggregateInput = {
    id?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    createdById?: SortOrder
  }

  export type EnumEmployeeVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
  }

  export type EmployeeVoucherCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    eligibility?: SortOrder
    allowedPatientIds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    code?: SortOrder
    status?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EmployeeVoucherSumOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    employeeId?: SortOrder
    balanceCap?: SortOrder
    usedAmount?: SortOrder
    createdById?: SortOrder
  }

  export type EnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrder
    type?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrder
    type?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
    filePath?: SortOrder
    toothCode?: SortOrder
    type?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    id?: SortOrder
    encounterId?: SortOrder
  }

  export type DoctorScheduleDoctorIdBranchIdDateCompoundUniqueInput = {
    doctorId: number
    branchId: number
    date: Date | string
  }

  export type DoctorScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type DoctorScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type DoctorScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type DoctorScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionScheduleReceptionIdBranchIdDateCompoundUniqueInput = {
    receptionId: number
    branchId: number
    date: Date | string
  }

  export type ReceptionScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type ReceptionScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type ReceptionScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type ReceptionScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchDoctorIdBranchIdCompoundUniqueInput = {
    doctorId: number
    branchId: number
  }

  export type DoctorBranchCountOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchMinOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type DoctorBranchSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchReceptionIdBranchIdCompoundUniqueInput = {
    receptionId: number
    branchId: number
  }

  export type ReceptionBranchCountOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchMinOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type ReceptionBranchSumOrderByAggregateInput = {
    id?: SortOrder
    receptionId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchNurseIdBranchIdCompoundUniqueInput = {
    nurseId: number
    branchId: number
  }

  export type NurseBranchCountOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchAvgOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchMinOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseBranchSumOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseScheduleNurseIdBranchIdDateCompoundUniqueInput = {
    nurseId: number
    branchId: number
    date: Date | string
  }

  export type NurseScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type NurseScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type NurseScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type NurseScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    note?: SortOrder
  }

  export type NurseScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    nurseId?: SortOrder
    branchId?: SortOrder
  }

  export type PaymentProviderConfigListRelationFilter = {
    every?: PaymentProviderConfigWhereInput
    some?: PaymentProviderConfigWhereInput
    none?: PaymentProviderConfigWhereInput
  }

  export type PaymentProviderConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type PaymentMethodConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    label?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodConfigSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type PaymentMethodConfigRelationFilter = {
    is?: PaymentMethodConfigWhereInput
    isNot?: PaymentMethodConfigWhereInput
  }

  export type PaymentProviderConfigCountOrderByAggregateInput = {
    id?: SortOrder
    methodKey?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type PaymentProviderConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    methodKey?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderConfigMinOrderByAggregateInput = {
    id?: SortOrder
    methodKey?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentProviderConfigSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type QPayIntentCountOrderByAggregateInput = {
    id?: SortOrder
    environment?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    qpayInvoiceId?: SortOrder
    senderInvoiceNo?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    qpayPaymentId?: SortOrder
    raw?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QPayIntentAvgOrderByAggregateInput = {
    id?: SortOrder
    objectId?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
  }

  export type QPayIntentMaxOrderByAggregateInput = {
    id?: SortOrder
    environment?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    qpayInvoiceId?: SortOrder
    senderInvoiceNo?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    qpayPaymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QPayIntentMinOrderByAggregateInput = {
    id?: SortOrder
    environment?: SortOrder
    objectType?: SortOrder
    objectId?: SortOrder
    qpayInvoiceId?: SortOrder
    senderInvoiceNo?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    qpayPaymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QPayIntentSumOrderByAggregateInput = {
    id?: SortOrder
    objectId?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type DoctorScheduleCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ServiceBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type DoctorBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReceptionScheduleCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCategoryCreateWithoutBranchInput, ProductCategoryUncheckedCreateWithoutBranchInput> | ProductCategoryCreateWithoutBranchInput[] | ProductCategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBranchInput | ProductCategoryCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCategoryCreateManyBranchInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductStockMovementCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductStockMovementCreateWithoutBranchInput, ProductStockMovementUncheckedCreateWithoutBranchInput> | ProductStockMovementCreateWithoutBranchInput[] | ProductStockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutBranchInput | ProductStockMovementCreateOrConnectWithoutBranchInput[]
    createMany?: ProductStockMovementCreateManyBranchInputEnvelope
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutBranchInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutBranchInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type SterilizationIndicatorCreateNestedManyWithoutBranchInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutBranchInput, SterilizationIndicatorUncheckedCreateWithoutBranchInput> | SterilizationIndicatorCreateWithoutBranchInput[] | SterilizationIndicatorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutBranchInput | SterilizationIndicatorCreateOrConnectWithoutBranchInput[]
    createMany?: SterilizationIndicatorCreateManyBranchInputEnvelope
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type ServiceBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type DoctorBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductCategoryCreateWithoutBranchInput, ProductCategoryUncheckedCreateWithoutBranchInput> | ProductCategoryCreateWithoutBranchInput[] | ProductCategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBranchInput | ProductCategoryCreateOrConnectWithoutBranchInput[]
    createMany?: ProductCategoryCreateManyBranchInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProductStockMovementCreateWithoutBranchInput, ProductStockMovementUncheckedCreateWithoutBranchInput> | ProductStockMovementCreateWithoutBranchInput[] | ProductStockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutBranchInput | ProductStockMovementCreateOrConnectWithoutBranchInput[]
    createMany?: ProductStockMovementCreateManyBranchInputEnvelope
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutBranchInput, SterilizationIndicatorUncheckedCreateWithoutBranchInput> | SterilizationIndicatorCreateWithoutBranchInput[] | SterilizationIndicatorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutBranchInput | SterilizationIndicatorCreateOrConnectWithoutBranchInput[]
    createMany?: SterilizationIndicatorCreateManyBranchInputEnvelope
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type DoctorScheduleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput | DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput | DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutBranchInput | DoctorScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ServiceBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutBranchInput | ServiceBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutBranchInput | ServiceBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutBranchInput | ServiceBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type DoctorBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutBranchInput | DoctorBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutBranchInput | DoctorBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutBranchInput | DoctorBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutBranchInput | AppointmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutBranchInput | AppointmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutBranchInput | AppointmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBranchInput | BookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBranchInput | BookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBranchInput | BookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReceptionScheduleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutBranchInput | ReceptionScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput | ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput | ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutBranchInput | ReceptionBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutBranchInput | NurseScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutBranchInput | NurseScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutBranchInput | NurseScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutBranchInput | NurseBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutBranchInput | NurseBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutBranchInput | NurseBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBranchInput | ProductUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBranchInput | ProductUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBranchInput | ProductUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutBranchInput, ProductCategoryUncheckedCreateWithoutBranchInput> | ProductCategoryCreateWithoutBranchInput[] | ProductCategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBranchInput | ProductCategoryCreateOrConnectWithoutBranchInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutBranchInput | ProductCategoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCategoryCreateManyBranchInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutBranchInput | ProductCategoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutBranchInput | ProductCategoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductStockMovementUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductStockMovementCreateWithoutBranchInput, ProductStockMovementUncheckedCreateWithoutBranchInput> | ProductStockMovementCreateWithoutBranchInput[] | ProductStockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutBranchInput | ProductStockMovementCreateOrConnectWithoutBranchInput[]
    upsert?: ProductStockMovementUpsertWithWhereUniqueWithoutBranchInput | ProductStockMovementUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductStockMovementCreateManyBranchInputEnvelope
    set?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    disconnect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    delete?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    update?: ProductStockMovementUpdateWithWhereUniqueWithoutBranchInput | ProductStockMovementUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductStockMovementUpdateManyWithWhereWithoutBranchInput | ProductStockMovementUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductStockMovementScalarWhereInput | ProductStockMovementScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutBranchInput | InvoiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutBranchInput | InvoiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutBranchInput | InvoiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutBranchInput | LedgerEntryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutBranchInput | LedgerEntryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutBranchInput | LedgerEntryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutBranchInput | EmployeeVoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type SterilizationIndicatorUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutBranchInput, SterilizationIndicatorUncheckedCreateWithoutBranchInput> | SterilizationIndicatorCreateWithoutBranchInput[] | SterilizationIndicatorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutBranchInput | SterilizationIndicatorCreateOrConnectWithoutBranchInput[]
    upsert?: SterilizationIndicatorUpsertWithWhereUniqueWithoutBranchInput | SterilizationIndicatorUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SterilizationIndicatorCreateManyBranchInputEnvelope
    set?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    disconnect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    delete?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    update?: SterilizationIndicatorUpdateWithWhereUniqueWithoutBranchInput | SterilizationIndicatorUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SterilizationIndicatorUpdateManyWithWhereWithoutBranchInput | SterilizationIndicatorUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SterilizationIndicatorScalarWhereInput | SterilizationIndicatorScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput> | DoctorScheduleCreateWithoutBranchInput[] | DoctorScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutBranchInput | DoctorScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput | DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorScheduleCreateManyBranchInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput | DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutBranchInput | DoctorScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput> | ServiceBranchCreateWithoutBranchInput[] | ServiceBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutBranchInput | ServiceBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutBranchInput | ServiceBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceBranchCreateManyBranchInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutBranchInput | ServiceBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutBranchInput | ServiceBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput> | DoctorBranchCreateWithoutBranchInput[] | DoctorBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutBranchInput | DoctorBranchCreateOrConnectWithoutBranchInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutBranchInput | DoctorBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DoctorBranchCreateManyBranchInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutBranchInput | DoctorBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutBranchInput | DoctorBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput> | AppointmentCreateWithoutBranchInput[] | AppointmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutBranchInput | AppointmentCreateOrConnectWithoutBranchInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutBranchInput | AppointmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AppointmentCreateManyBranchInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutBranchInput | AppointmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutBranchInput | AppointmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput> | BookingCreateWithoutBranchInput[] | BookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBranchInput | BookingCreateOrConnectWithoutBranchInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBranchInput | BookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookingCreateManyBranchInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBranchInput | BookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBranchInput | BookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput> | ReceptionScheduleCreateWithoutBranchInput[] | ReceptionScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutBranchInput | ReceptionScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionScheduleCreateManyBranchInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput | ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutBranchInput | ReceptionScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput> | ReceptionBranchCreateWithoutBranchInput[] | ReceptionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutBranchInput | ReceptionBranchCreateOrConnectWithoutBranchInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput | ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ReceptionBranchCreateManyBranchInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput | ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutBranchInput | ReceptionBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput> | NurseScheduleCreateWithoutBranchInput[] | NurseScheduleUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutBranchInput | NurseScheduleCreateOrConnectWithoutBranchInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutBranchInput | NurseScheduleUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseScheduleCreateManyBranchInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutBranchInput | NurseScheduleUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutBranchInput | NurseScheduleUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput> | NurseBranchCreateWithoutBranchInput[] | NurseBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutBranchInput | NurseBranchCreateOrConnectWithoutBranchInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutBranchInput | NurseBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: NurseBranchCreateManyBranchInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutBranchInput | NurseBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutBranchInput | NurseBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput> | ProductCreateWithoutBranchInput[] | ProductUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBranchInput | ProductCreateOrConnectWithoutBranchInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBranchInput | ProductUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCreateManyBranchInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBranchInput | ProductUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBranchInput | ProductUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutBranchInput, ProductCategoryUncheckedCreateWithoutBranchInput> | ProductCategoryCreateWithoutBranchInput[] | ProductCategoryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutBranchInput | ProductCategoryCreateOrConnectWithoutBranchInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutBranchInput | ProductCategoryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductCategoryCreateManyBranchInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutBranchInput | ProductCategoryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutBranchInput | ProductCategoryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProductStockMovementCreateWithoutBranchInput, ProductStockMovementUncheckedCreateWithoutBranchInput> | ProductStockMovementCreateWithoutBranchInput[] | ProductStockMovementUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutBranchInput | ProductStockMovementCreateOrConnectWithoutBranchInput[]
    upsert?: ProductStockMovementUpsertWithWhereUniqueWithoutBranchInput | ProductStockMovementUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProductStockMovementCreateManyBranchInputEnvelope
    set?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    disconnect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    delete?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    update?: ProductStockMovementUpdateWithWhereUniqueWithoutBranchInput | ProductStockMovementUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProductStockMovementUpdateManyWithWhereWithoutBranchInput | ProductStockMovementUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProductStockMovementScalarWhereInput | ProductStockMovementScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput> | InvoiceCreateWithoutBranchInput[] | InvoiceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutBranchInput | InvoiceCreateOrConnectWithoutBranchInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutBranchInput | InvoiceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: InvoiceCreateManyBranchInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutBranchInput | InvoiceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutBranchInput | InvoiceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput> | LedgerEntryCreateWithoutBranchInput[] | LedgerEntryUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBranchInput | LedgerEntryCreateOrConnectWithoutBranchInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutBranchInput | LedgerEntryUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LedgerEntryCreateManyBranchInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutBranchInput | LedgerEntryUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutBranchInput | LedgerEntryUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput> | EmployeeVoucherCreateWithoutBranchInput[] | EmployeeVoucherUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutBranchInput | EmployeeVoucherCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeVoucherCreateManyBranchInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput | EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutBranchInput | EmployeeVoucherUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutBranchInput, SterilizationIndicatorUncheckedCreateWithoutBranchInput> | SterilizationIndicatorCreateWithoutBranchInput[] | SterilizationIndicatorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutBranchInput | SterilizationIndicatorCreateOrConnectWithoutBranchInput[]
    upsert?: SterilizationIndicatorUpsertWithWhereUniqueWithoutBranchInput | SterilizationIndicatorUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SterilizationIndicatorCreateManyBranchInputEnvelope
    set?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    disconnect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    delete?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    update?: SterilizationIndicatorUpdateWithWhereUniqueWithoutBranchInput | SterilizationIndicatorUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SterilizationIndicatorUpdateManyWithWhereWithoutBranchInput | SterilizationIndicatorUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SterilizationIndicatorScalarWhereInput | SterilizationIndicatorScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeBenefitsInput = {
    create?: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeBenefitsInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeBenefitUsageCreateNestedManyWithoutEmployeeBenefitInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEmployeeBenefitInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutEmployeeBenefitsNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeBenefitsInput
    upsert?: UserUpsertWithoutEmployeeBenefitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeBenefitsInput, UserUpdateWithoutEmployeeBenefitsInput>, UserUncheckedUpdateWithoutEmployeeBenefitsInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithoutEmployeeBenefitNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput> | EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput | EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput[]
    createMany?: EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type EmployeeBenefitCreateNestedOneWithoutUsagesInput = {
    create?: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutUsagesInput
    connect?: EmployeeBenefitWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput = {
    create?: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEmployeeBenefitUsagesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutEmployeeBenefitUsagesInput = {
    create?: XOR<EncounterCreateWithoutEmployeeBenefitUsagesInput, EncounterUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutEmployeeBenefitUsagesInput
    connect?: EncounterWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutEmployeeBenefitUsagesInput = {
    create?: XOR<PatientCreateWithoutEmployeeBenefitUsagesInput, PatientUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEmployeeBenefitUsagesInput
    connect?: PatientWhereUniqueInput
  }

  export type EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutUsagesInput
    upsert?: EmployeeBenefitUpsertWithoutUsagesInput
    connect?: EmployeeBenefitWhereUniqueInput
    update?: XOR<XOR<EmployeeBenefitUpdateToOneWithWhereWithoutUsagesInput, EmployeeBenefitUpdateWithoutUsagesInput>, EmployeeBenefitUncheckedUpdateWithoutUsagesInput>
  }

  export type InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput = {
    create?: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEmployeeBenefitUsagesInput
    upsert?: InvoiceUpsertWithoutEmployeeBenefitUsagesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput, InvoiceUpdateWithoutEmployeeBenefitUsagesInput>, InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type EncounterUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput = {
    create?: XOR<EncounterCreateWithoutEmployeeBenefitUsagesInput, EncounterUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutEmployeeBenefitUsagesInput
    upsert?: EncounterUpsertWithoutEmployeeBenefitUsagesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput, EncounterUpdateWithoutEmployeeBenefitUsagesInput>, EncounterUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type PatientUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput = {
    create?: XOR<PatientCreateWithoutEmployeeBenefitUsagesInput, PatientUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEmployeeBenefitUsagesInput
    upsert?: PatientUpsertWithoutEmployeeBenefitUsagesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput, PatientUpdateWithoutEmployeeBenefitUsagesInput>, PatientUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type SterilizationItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SterilizationItemCreateWithoutCategoryInput, SterilizationItemUncheckedCreateWithoutCategoryInput> | SterilizationItemCreateWithoutCategoryInput[] | SterilizationItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SterilizationItemCreateOrConnectWithoutCategoryInput | SterilizationItemCreateOrConnectWithoutCategoryInput[]
    createMany?: SterilizationItemCreateManyCategoryInputEnvelope
    connect?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
  }

  export type SterilizationItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SterilizationItemCreateWithoutCategoryInput, SterilizationItemUncheckedCreateWithoutCategoryInput> | SterilizationItemCreateWithoutCategoryInput[] | SterilizationItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SterilizationItemCreateOrConnectWithoutCategoryInput | SterilizationItemCreateOrConnectWithoutCategoryInput[]
    createMany?: SterilizationItemCreateManyCategoryInputEnvelope
    connect?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
  }

  export type SterilizationItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SterilizationItemCreateWithoutCategoryInput, SterilizationItemUncheckedCreateWithoutCategoryInput> | SterilizationItemCreateWithoutCategoryInput[] | SterilizationItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SterilizationItemCreateOrConnectWithoutCategoryInput | SterilizationItemCreateOrConnectWithoutCategoryInput[]
    upsert?: SterilizationItemUpsertWithWhereUniqueWithoutCategoryInput | SterilizationItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SterilizationItemCreateManyCategoryInputEnvelope
    set?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    disconnect?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    delete?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    connect?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    update?: SterilizationItemUpdateWithWhereUniqueWithoutCategoryInput | SterilizationItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SterilizationItemUpdateManyWithWhereWithoutCategoryInput | SterilizationItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SterilizationItemScalarWhereInput | SterilizationItemScalarWhereInput[]
  }

  export type SterilizationItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SterilizationItemCreateWithoutCategoryInput, SterilizationItemUncheckedCreateWithoutCategoryInput> | SterilizationItemCreateWithoutCategoryInput[] | SterilizationItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SterilizationItemCreateOrConnectWithoutCategoryInput | SterilizationItemCreateOrConnectWithoutCategoryInput[]
    upsert?: SterilizationItemUpsertWithWhereUniqueWithoutCategoryInput | SterilizationItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SterilizationItemCreateManyCategoryInputEnvelope
    set?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    disconnect?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    delete?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    connect?: SterilizationItemWhereUniqueInput | SterilizationItemWhereUniqueInput[]
    update?: SterilizationItemUpdateWithWhereUniqueWithoutCategoryInput | SterilizationItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SterilizationItemUpdateManyWithWhereWithoutCategoryInput | SterilizationItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SterilizationItemScalarWhereInput | SterilizationItemScalarWhereInput[]
  }

  export type SterilizationCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<SterilizationCategoryCreateWithoutItemsInput, SterilizationCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SterilizationCategoryCreateOrConnectWithoutItemsInput
    connect?: SterilizationCategoryWhereUniqueInput
  }

  export type SterilizationIndicatorItemCreateNestedManyWithoutItemInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutItemInput, SterilizationIndicatorItemUncheckedCreateWithoutItemInput> | SterilizationIndicatorItemCreateWithoutItemInput[] | SterilizationIndicatorItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutItemInput | SterilizationIndicatorItemCreateOrConnectWithoutItemInput[]
    createMany?: SterilizationIndicatorItemCreateManyItemInputEnvelope
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
  }

  export type SterilizationIndicatorItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutItemInput, SterilizationIndicatorItemUncheckedCreateWithoutItemInput> | SterilizationIndicatorItemCreateWithoutItemInput[] | SterilizationIndicatorItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutItemInput | SterilizationIndicatorItemCreateOrConnectWithoutItemInput[]
    createMany?: SterilizationIndicatorItemCreateManyItemInputEnvelope
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
  }

  export type SterilizationCategoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SterilizationCategoryCreateWithoutItemsInput, SterilizationCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SterilizationCategoryCreateOrConnectWithoutItemsInput
    upsert?: SterilizationCategoryUpsertWithoutItemsInput
    connect?: SterilizationCategoryWhereUniqueInput
    update?: XOR<XOR<SterilizationCategoryUpdateToOneWithWhereWithoutItemsInput, SterilizationCategoryUpdateWithoutItemsInput>, SterilizationCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type SterilizationIndicatorItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutItemInput, SterilizationIndicatorItemUncheckedCreateWithoutItemInput> | SterilizationIndicatorItemCreateWithoutItemInput[] | SterilizationIndicatorItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutItemInput | SterilizationIndicatorItemCreateOrConnectWithoutItemInput[]
    upsert?: SterilizationIndicatorItemUpsertWithWhereUniqueWithoutItemInput | SterilizationIndicatorItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SterilizationIndicatorItemCreateManyItemInputEnvelope
    set?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    disconnect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    delete?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    update?: SterilizationIndicatorItemUpdateWithWhereUniqueWithoutItemInput | SterilizationIndicatorItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SterilizationIndicatorItemUpdateManyWithWhereWithoutItemInput | SterilizationIndicatorItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SterilizationIndicatorItemScalarWhereInput | SterilizationIndicatorItemScalarWhereInput[]
  }

  export type SterilizationIndicatorItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutItemInput, SterilizationIndicatorItemUncheckedCreateWithoutItemInput> | SterilizationIndicatorItemCreateWithoutItemInput[] | SterilizationIndicatorItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutItemInput | SterilizationIndicatorItemCreateOrConnectWithoutItemInput[]
    upsert?: SterilizationIndicatorItemUpsertWithWhereUniqueWithoutItemInput | SterilizationIndicatorItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SterilizationIndicatorItemCreateManyItemInputEnvelope
    set?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    disconnect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    delete?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    update?: SterilizationIndicatorItemUpdateWithWhereUniqueWithoutItemInput | SterilizationIndicatorItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SterilizationIndicatorItemUpdateManyWithWhereWithoutItemInput | SterilizationIndicatorItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SterilizationIndicatorItemScalarWhereInput | SterilizationIndicatorItemScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutSterilizationIndicatorsInput = {
    create?: XOR<BranchCreateWithoutSterilizationIndicatorsInput, BranchUncheckedCreateWithoutSterilizationIndicatorsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSterilizationIndicatorsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSterilizationIndicatorsInput = {
    create?: XOR<UserCreateWithoutSterilizationIndicatorsInput, UserUncheckedCreateWithoutSterilizationIndicatorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSterilizationIndicatorsInput
    connect?: UserWhereUniqueInput
  }

  export type SterilizationIndicatorItemCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput> | SterilizationIndicatorItemCreateWithoutIndicatorInput[] | SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput | SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput[]
    createMany?: SterilizationIndicatorItemCreateManyIndicatorInputEnvelope
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
  }

  export type EncounterSterilizationPackageUseCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput> | EncounterSterilizationPackageUseCreateWithoutIndicatorInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput | EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyIndicatorInputEnvelope
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInputEnvelope
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
  }

  export type SterilizationIndicatorItemUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput> | SterilizationIndicatorItemCreateWithoutIndicatorInput[] | SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput | SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput[]
    createMany?: SterilizationIndicatorItemCreateManyIndicatorInputEnvelope
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
  }

  export type EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput> | EncounterSterilizationPackageUseCreateWithoutIndicatorInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput | EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyIndicatorInputEnvelope
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutIndicatorInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInputEnvelope
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput = {
    create?: XOR<BranchCreateWithoutSterilizationIndicatorsInput, BranchUncheckedCreateWithoutSterilizationIndicatorsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSterilizationIndicatorsInput
    upsert?: BranchUpsertWithoutSterilizationIndicatorsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSterilizationIndicatorsInput, BranchUpdateWithoutSterilizationIndicatorsInput>, BranchUncheckedUpdateWithoutSterilizationIndicatorsInput>
  }

  export type UserUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput = {
    create?: XOR<UserCreateWithoutSterilizationIndicatorsInput, UserUncheckedCreateWithoutSterilizationIndicatorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSterilizationIndicatorsInput
    upsert?: UserUpsertWithoutSterilizationIndicatorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSterilizationIndicatorsInput, UserUpdateWithoutSterilizationIndicatorsInput>, UserUncheckedUpdateWithoutSterilizationIndicatorsInput>
  }

  export type SterilizationIndicatorItemUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput> | SterilizationIndicatorItemCreateWithoutIndicatorInput[] | SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput | SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput[]
    upsert?: SterilizationIndicatorItemUpsertWithWhereUniqueWithoutIndicatorInput | SterilizationIndicatorItemUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: SterilizationIndicatorItemCreateManyIndicatorInputEnvelope
    set?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    disconnect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    delete?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    update?: SterilizationIndicatorItemUpdateWithWhereUniqueWithoutIndicatorInput | SterilizationIndicatorItemUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: SterilizationIndicatorItemUpdateManyWithWhereWithoutIndicatorInput | SterilizationIndicatorItemUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: SterilizationIndicatorItemScalarWhereInput | SterilizationIndicatorItemScalarWhereInput[]
  }

  export type EncounterSterilizationPackageUseUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput> | EncounterSterilizationPackageUseCreateWithoutIndicatorInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput | EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput[]
    upsert?: EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutIndicatorInput | EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyIndicatorInputEnvelope
    set?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    disconnect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    delete?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    update?: EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutIndicatorInput | EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: EncounterSterilizationPackageUseUpdateManyWithWhereWithoutIndicatorInput | EncounterSterilizationPackageUseUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput[]
    upsert?: EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInputEnvelope
    set?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    disconnect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    delete?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    update?: EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput | EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
  }

  export type SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<SterilizationIndicatorItemCreateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput> | SterilizationIndicatorItemCreateWithoutIndicatorInput[] | SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput | SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput[]
    upsert?: SterilizationIndicatorItemUpsertWithWhereUniqueWithoutIndicatorInput | SterilizationIndicatorItemUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: SterilizationIndicatorItemCreateManyIndicatorInputEnvelope
    set?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    disconnect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    delete?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    connect?: SterilizationIndicatorItemWhereUniqueInput | SterilizationIndicatorItemWhereUniqueInput[]
    update?: SterilizationIndicatorItemUpdateWithWhereUniqueWithoutIndicatorInput | SterilizationIndicatorItemUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: SterilizationIndicatorItemUpdateManyWithWhereWithoutIndicatorInput | SterilizationIndicatorItemUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: SterilizationIndicatorItemScalarWhereInput | SterilizationIndicatorItemScalarWhereInput[]
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput> | EncounterSterilizationPackageUseCreateWithoutIndicatorInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput | EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput[]
    upsert?: EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutIndicatorInput | EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyIndicatorInputEnvelope
    set?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    disconnect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    delete?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    update?: EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutIndicatorInput | EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: EncounterSterilizationPackageUseUpdateManyWithWhereWithoutIndicatorInput | EncounterSterilizationPackageUseUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput[]
    upsert?: EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutIndicatorInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInputEnvelope
    set?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    disconnect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    delete?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    update?: EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutIndicatorInput[]
    updateMany?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutIndicatorInput | EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutIndicatorInput[]
    deleteMany?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput | EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
  }

  export type SterilizationIndicatorCreateNestedOneWithoutItemsInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutItemsInput, SterilizationIndicatorUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutItemsInput
    connect?: SterilizationIndicatorWhereUniqueInput
  }

  export type SterilizationItemCreateNestedOneWithoutIndicatorItemsInput = {
    create?: XOR<SterilizationItemCreateWithoutIndicatorItemsInput, SterilizationItemUncheckedCreateWithoutIndicatorItemsInput>
    connectOrCreate?: SterilizationItemCreateOrConnectWithoutIndicatorItemsInput
    connect?: SterilizationItemWhereUniqueInput
  }

  export type SterilizationIndicatorUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutItemsInput, SterilizationIndicatorUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutItemsInput
    upsert?: SterilizationIndicatorUpsertWithoutItemsInput
    connect?: SterilizationIndicatorWhereUniqueInput
    update?: XOR<XOR<SterilizationIndicatorUpdateToOneWithWhereWithoutItemsInput, SterilizationIndicatorUpdateWithoutItemsInput>, SterilizationIndicatorUncheckedUpdateWithoutItemsInput>
  }

  export type SterilizationItemUpdateOneRequiredWithoutIndicatorItemsNestedInput = {
    create?: XOR<SterilizationItemCreateWithoutIndicatorItemsInput, SterilizationItemUncheckedCreateWithoutIndicatorItemsInput>
    connectOrCreate?: SterilizationItemCreateOrConnectWithoutIndicatorItemsInput
    upsert?: SterilizationItemUpsertWithoutIndicatorItemsInput
    connect?: SterilizationItemWhereUniqueInput
    update?: XOR<XOR<SterilizationItemUpdateToOneWithWhereWithoutIndicatorItemsInput, SterilizationItemUpdateWithoutIndicatorItemsInput>, SterilizationItemUncheckedUpdateWithoutIndicatorItemsInput>
  }

  export type EncounterCreateNestedOneWithoutSterilizationPackageUsesInput = {
    create?: XOR<EncounterCreateWithoutSterilizationPackageUsesInput, EncounterUncheckedCreateWithoutSterilizationPackageUsesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutSterilizationPackageUsesInput
    connect?: EncounterWhereUniqueInput
  }

  export type SterilizationIndicatorCreateNestedOneWithoutUsesInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutUsesInput, SterilizationIndicatorUncheckedCreateWithoutUsesInput>
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutUsesInput
    connect?: SterilizationIndicatorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOpenedSterilizationPackagesInput = {
    create?: XOR<UserCreateWithoutOpenedSterilizationPackagesInput, UserUncheckedCreateWithoutOpenedSterilizationPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpenedSterilizationPackagesInput
    connect?: UserWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutSterilizationPackageUsesNestedInput = {
    create?: XOR<EncounterCreateWithoutSterilizationPackageUsesInput, EncounterUncheckedCreateWithoutSterilizationPackageUsesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutSterilizationPackageUsesInput
    upsert?: EncounterUpsertWithoutSterilizationPackageUsesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutSterilizationPackageUsesInput, EncounterUpdateWithoutSterilizationPackageUsesInput>, EncounterUncheckedUpdateWithoutSterilizationPackageUsesInput>
  }

  export type SterilizationIndicatorUpdateOneRequiredWithoutUsesNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutUsesInput, SterilizationIndicatorUncheckedCreateWithoutUsesInput>
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutUsesInput
    upsert?: SterilizationIndicatorUpsertWithoutUsesInput
    connect?: SterilizationIndicatorWhereUniqueInput
    update?: XOR<XOR<SterilizationIndicatorUpdateToOneWithWhereWithoutUsesInput, SterilizationIndicatorUpdateWithoutUsesInput>, SterilizationIndicatorUncheckedUpdateWithoutUsesInput>
  }

  export type UserUpdateOneWithoutOpenedSterilizationPackagesNestedInput = {
    create?: XOR<UserCreateWithoutOpenedSterilizationPackagesInput, UserUncheckedCreateWithoutOpenedSterilizationPackagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpenedSterilizationPackagesInput
    upsert?: UserUpsertWithoutOpenedSterilizationPackagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpenedSterilizationPackagesInput, UserUpdateWithoutOpenedSterilizationPackagesInput>, UserUncheckedUpdateWithoutOpenedSterilizationPackagesInput>
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutDoctorInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutNurseInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type DoctorScheduleCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type DoctorBranchCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type ReceptionScheduleCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutDoctorInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EmployeeBenefitCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type EmployeeVoucherCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type AuthorizationCodeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
  }

  export type SterilizationIndicatorCreateNestedManyWithoutSpecialistInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutSpecialistInput, SterilizationIndicatorUncheckedCreateWithoutSpecialistInput> | SterilizationIndicatorCreateWithoutSpecialistInput[] | SterilizationIndicatorUncheckedCreateWithoutSpecialistInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutSpecialistInput | SterilizationIndicatorCreateOrConnectWithoutSpecialistInput[]
    createMany?: SterilizationIndicatorCreateManySpecialistInputEnvelope
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
  }

  export type EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput> | EncounterSterilizationPackageUseCreateWithoutOpenedByInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput | EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyOpenedByInputEnvelope
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
  }

  export type DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
  }

  export type ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
  }

  export type ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
  }

  export type NurseScheduleUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
  }

  export type NurseBranchUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
  }

  export type AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
  }

  export type SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutSpecialistInput, SterilizationIndicatorUncheckedCreateWithoutSpecialistInput> | SterilizationIndicatorCreateWithoutSpecialistInput[] | SterilizationIndicatorUncheckedCreateWithoutSpecialistInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutSpecialistInput | SterilizationIndicatorCreateOrConnectWithoutSpecialistInput[]
    createMany?: SterilizationIndicatorCreateManySpecialistInputEnvelope
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
  }

  export type EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput> | EncounterSterilizationPackageUseCreateWithoutOpenedByInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput | EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyOpenedByInputEnvelope
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type EncounterUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutDoctorInput | EncounterUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutDoctorInput | EncounterUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutDoctorInput | EncounterUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutNurseNestedInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutNurseInput | EncounterUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutNurseInput | EncounterUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutNurseInput | EncounterUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type DoctorScheduleUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutDoctorInput | DoctorScheduleUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type DoctorBranchUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput | DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput | DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutDoctorInput | DoctorBranchUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type ReceptionScheduleUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput | ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutReceptionInput | ReceptionBranchUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutNurseInput | NurseScheduleUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutNurseInput | NurseScheduleUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutNurseInput | NurseScheduleUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutNurseInput | NurseBranchUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutNurseInput | NurseBranchUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutNurseInput | NurseBranchUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDoctorInput | BookingUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDoctorInput | BookingUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDoctorInput | BookingUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EmployeeBenefitUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    set?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    disconnect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    delete?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    update?: EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput | EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutCreatedByInput | LedgerEntryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovedByInput | LedgerEntryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput | EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type EmployeeVoucherUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput | EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type AuthorizationCodeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    set?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    disconnect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    delete?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    update?: AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput | AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
  }

  export type SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutSpecialistInput, SterilizationIndicatorUncheckedCreateWithoutSpecialistInput> | SterilizationIndicatorCreateWithoutSpecialistInput[] | SterilizationIndicatorUncheckedCreateWithoutSpecialistInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutSpecialistInput | SterilizationIndicatorCreateOrConnectWithoutSpecialistInput[]
    upsert?: SterilizationIndicatorUpsertWithWhereUniqueWithoutSpecialistInput | SterilizationIndicatorUpsertWithWhereUniqueWithoutSpecialistInput[]
    createMany?: SterilizationIndicatorCreateManySpecialistInputEnvelope
    set?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    disconnect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    delete?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    update?: SterilizationIndicatorUpdateWithWhereUniqueWithoutSpecialistInput | SterilizationIndicatorUpdateWithWhereUniqueWithoutSpecialistInput[]
    updateMany?: SterilizationIndicatorUpdateManyWithWhereWithoutSpecialistInput | SterilizationIndicatorUpdateManyWithWhereWithoutSpecialistInput[]
    deleteMany?: SterilizationIndicatorScalarWhereInput | SterilizationIndicatorScalarWhereInput[]
  }

  export type EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput> | EncounterSterilizationPackageUseCreateWithoutOpenedByInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput | EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput[]
    upsert?: EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutOpenedByInput | EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyOpenedByInputEnvelope
    set?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    disconnect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    delete?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    update?: EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutOpenedByInput | EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: EncounterSterilizationPackageUseUpdateManyWithWhereWithoutOpenedByInput | EncounterSterilizationPackageUseUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput> | EncounterCreateWithoutDoctorInput[] | EncounterUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutDoctorInput | EncounterCreateOrConnectWithoutDoctorInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutDoctorInput | EncounterUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: EncounterCreateManyDoctorInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutDoctorInput | EncounterUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutDoctorInput | EncounterUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput> | EncounterCreateWithoutNurseInput[] | EncounterUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutNurseInput | EncounterCreateOrConnectWithoutNurseInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutNurseInput | EncounterUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: EncounterCreateManyNurseInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutNurseInput | EncounterUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutNurseInput | EncounterUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput> | DoctorScheduleCreateWithoutDoctorInput[] | DoctorScheduleUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorScheduleCreateOrConnectWithoutDoctorInput | DoctorScheduleCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorScheduleCreateManyDoctorInputEnvelope
    set?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    disconnect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    delete?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    connect?: DoctorScheduleWhereUniqueInput | DoctorScheduleWhereUniqueInput[]
    update?: DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput | DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorScheduleUpdateManyWithWhereWithoutDoctorInput | DoctorScheduleUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
  }

  export type DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput> | DoctorBranchCreateWithoutDoctorInput[] | DoctorBranchUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorBranchCreateOrConnectWithoutDoctorInput | DoctorBranchCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput | DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorBranchCreateManyDoctorInputEnvelope
    set?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    disconnect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    delete?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    connect?: DoctorBranchWhereUniqueInput | DoctorBranchWhereUniqueInput[]
    update?: DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput | DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorBranchUpdateManyWithWhereWithoutDoctorInput | DoctorBranchUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput> | ReceptionScheduleCreateWithoutReceptionInput[] | ReceptionScheduleUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionScheduleCreateOrConnectWithoutReceptionInput | ReceptionScheduleCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionScheduleCreateManyReceptionInputEnvelope
    set?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    disconnect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    delete?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    connect?: ReceptionScheduleWhereUniqueInput | ReceptionScheduleWhereUniqueInput[]
    update?: ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput | ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput | ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput = {
    create?: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput> | ReceptionBranchCreateWithoutReceptionInput[] | ReceptionBranchUncheckedCreateWithoutReceptionInput[]
    connectOrCreate?: ReceptionBranchCreateOrConnectWithoutReceptionInput | ReceptionBranchCreateOrConnectWithoutReceptionInput[]
    upsert?: ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput[]
    createMany?: ReceptionBranchCreateManyReceptionInputEnvelope
    set?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    disconnect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    delete?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    connect?: ReceptionBranchWhereUniqueInput | ReceptionBranchWhereUniqueInput[]
    update?: ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput | ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput[]
    updateMany?: ReceptionBranchUpdateManyWithWhereWithoutReceptionInput | ReceptionBranchUpdateManyWithWhereWithoutReceptionInput[]
    deleteMany?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
  }

  export type NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput> | NurseScheduleCreateWithoutNurseInput[] | NurseScheduleUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseScheduleCreateOrConnectWithoutNurseInput | NurseScheduleCreateOrConnectWithoutNurseInput[]
    upsert?: NurseScheduleUpsertWithWhereUniqueWithoutNurseInput | NurseScheduleUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseScheduleCreateManyNurseInputEnvelope
    set?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    disconnect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    delete?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    connect?: NurseScheduleWhereUniqueInput | NurseScheduleWhereUniqueInput[]
    update?: NurseScheduleUpdateWithWhereUniqueWithoutNurseInput | NurseScheduleUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseScheduleUpdateManyWithWhereWithoutNurseInput | NurseScheduleUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
  }

  export type NurseBranchUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput> | NurseBranchCreateWithoutNurseInput[] | NurseBranchUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: NurseBranchCreateOrConnectWithoutNurseInput | NurseBranchCreateOrConnectWithoutNurseInput[]
    upsert?: NurseBranchUpsertWithWhereUniqueWithoutNurseInput | NurseBranchUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: NurseBranchCreateManyNurseInputEnvelope
    set?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    disconnect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    delete?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    connect?: NurseBranchWhereUniqueInput | NurseBranchWhereUniqueInput[]
    update?: NurseBranchUpdateWithWhereUniqueWithoutNurseInput | NurseBranchUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: NurseBranchUpdateManyWithWhereWithoutNurseInput | NurseBranchUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput> | BookingCreateWithoutDoctorInput[] | BookingUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDoctorInput | BookingCreateOrConnectWithoutDoctorInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDoctorInput | BookingUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: BookingCreateManyDoctorInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDoctorInput | BookingUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDoctorInput | BookingUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput> | EmployeeBenefitCreateWithoutEmployeeInput[] | EmployeeBenefitUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeBenefitCreateOrConnectWithoutEmployeeInput | EmployeeBenefitCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeBenefitCreateManyEmployeeInputEnvelope
    set?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    disconnect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    delete?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    connect?: EmployeeBenefitWhereUniqueInput | EmployeeBenefitWhereUniqueInput[]
    update?: EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput | EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput> | LedgerEntryCreateWithoutCreatedByInput[] | LedgerEntryUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutCreatedByInput | LedgerEntryCreateOrConnectWithoutCreatedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LedgerEntryCreateManyCreatedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput | LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutCreatedByInput | LedgerEntryUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput> | LedgerEntryCreateWithoutApprovedByInput[] | LedgerEntryUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovedByInput | LedgerEntryCreateOrConnectWithoutApprovedByInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: LedgerEntryCreateManyApprovedByInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovedByInput | LedgerEntryUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput> | EmployeeVoucherCreateWithoutEmployeeInput[] | EmployeeVoucherUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutEmployeeInput | EmployeeVoucherCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeVoucherCreateManyEmployeeInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput | EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput> | EmployeeVoucherCreateWithoutCreatedByInput[] | EmployeeVoucherUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutCreatedByInput | EmployeeVoucherCreateOrConnectWithoutCreatedByInput[]
    upsert?: EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EmployeeVoucherCreateManyCreatedByInputEnvelope
    set?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    disconnect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    delete?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    connect?: EmployeeVoucherWhereUniqueInput | EmployeeVoucherWhereUniqueInput[]
    update?: EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput | EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput | EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
  }

  export type AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput> | AuthorizationCodeCreateWithoutCreatedByInput[] | AuthorizationCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutCreatedByInput | AuthorizationCodeCreateOrConnectWithoutCreatedByInput[]
    upsert?: AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AuthorizationCodeCreateManyCreatedByInputEnvelope
    set?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    disconnect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    delete?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    connect?: AuthorizationCodeWhereUniqueInput | AuthorizationCodeWhereUniqueInput[]
    update?: AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput | AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput | AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
  }

  export type SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutSpecialistInput, SterilizationIndicatorUncheckedCreateWithoutSpecialistInput> | SterilizationIndicatorCreateWithoutSpecialistInput[] | SterilizationIndicatorUncheckedCreateWithoutSpecialistInput[]
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutSpecialistInput | SterilizationIndicatorCreateOrConnectWithoutSpecialistInput[]
    upsert?: SterilizationIndicatorUpsertWithWhereUniqueWithoutSpecialistInput | SterilizationIndicatorUpsertWithWhereUniqueWithoutSpecialistInput[]
    createMany?: SterilizationIndicatorCreateManySpecialistInputEnvelope
    set?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    disconnect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    delete?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    connect?: SterilizationIndicatorWhereUniqueInput | SterilizationIndicatorWhereUniqueInput[]
    update?: SterilizationIndicatorUpdateWithWhereUniqueWithoutSpecialistInput | SterilizationIndicatorUpdateWithWhereUniqueWithoutSpecialistInput[]
    updateMany?: SterilizationIndicatorUpdateManyWithWhereWithoutSpecialistInput | SterilizationIndicatorUpdateManyWithWhereWithoutSpecialistInput[]
    deleteMany?: SterilizationIndicatorScalarWhereInput | SterilizationIndicatorScalarWhereInput[]
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput> | EncounterSterilizationPackageUseCreateWithoutOpenedByInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput | EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput[]
    upsert?: EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutOpenedByInput | EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyOpenedByInputEnvelope
    set?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    disconnect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    delete?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    update?: EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutOpenedByInput | EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: EncounterSterilizationPackageUseUpdateManyWithWhereWithoutOpenedByInput | EncounterSterilizationPackageUseUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutPatientsInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientBookCreateNestedOneWithoutPatientInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    connect?: PatientBookWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutPatientInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutPatientInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageCreateNestedManyWithoutPatientInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutPatientInput, EmployeeBenefitUsageUncheckedCreateWithoutPatientInput> | EmployeeBenefitUsageCreateWithoutPatientInput[] | EmployeeBenefitUsageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutPatientInput | EmployeeBenefitUsageCreateOrConnectWithoutPatientInput[]
    createMany?: EmployeeBenefitUsageCreateManyPatientInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type PatientBookUncheckedCreateNestedOneWithoutPatientInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    connect?: PatientBookWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutPatientInput, EmployeeBenefitUsageUncheckedCreateWithoutPatientInput> | EmployeeBenefitUsageCreateWithoutPatientInput[] | EmployeeBenefitUsageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutPatientInput | EmployeeBenefitUsageCreateOrConnectWithoutPatientInput[]
    createMany?: EmployeeBenefitUsageCreateManyPatientInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    upsert?: BranchUpsertWithoutPatientsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPatientsInput, BranchUpdateWithoutPatientsInput>, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type PatientBookUpdateOneWithoutPatientNestedInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    upsert?: PatientBookUpsertWithoutPatientInput
    disconnect?: PatientBookWhereInput | boolean
    delete?: PatientBookWhereInput | boolean
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutPatientInput, PatientBookUpdateWithoutPatientInput>, PatientBookUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPatientInput | BookingUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPatientInput | BookingUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPatientInput | BookingUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutPatientInput | LedgerEntryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutPatientInput | LedgerEntryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutPatientInput | LedgerEntryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutPatientInput, EmployeeBenefitUsageUncheckedCreateWithoutPatientInput> | EmployeeBenefitUsageCreateWithoutPatientInput[] | EmployeeBenefitUsageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutPatientInput | EmployeeBenefitUsageCreateOrConnectWithoutPatientInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutPatientInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EmployeeBenefitUsageCreateManyPatientInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutPatientInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutPatientInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type PatientBookUncheckedUpdateOneWithoutPatientNestedInput = {
    create?: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutPatientInput
    upsert?: PatientBookUpsertWithoutPatientInput
    disconnect?: PatientBookWhereInput | boolean
    delete?: PatientBookWhereInput | boolean
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutPatientInput, PatientBookUpdateWithoutPatientInput>, PatientBookUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput> | BookingCreateWithoutPatientInput[] | BookingUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPatientInput | BookingCreateOrConnectWithoutPatientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPatientInput | BookingUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BookingCreateManyPatientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPatientInput | BookingUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPatientInput | BookingUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput> | LedgerEntryCreateWithoutPatientInput[] | LedgerEntryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutPatientInput | LedgerEntryCreateOrConnectWithoutPatientInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutPatientInput | LedgerEntryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LedgerEntryCreateManyPatientInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutPatientInput | LedgerEntryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutPatientInput | LedgerEntryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutPatientInput, EmployeeBenefitUsageUncheckedCreateWithoutPatientInput> | EmployeeBenefitUsageCreateWithoutPatientInput[] | EmployeeBenefitUsageUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutPatientInput | EmployeeBenefitUsageCreateOrConnectWithoutPatientInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutPatientInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EmployeeBenefitUsageCreateManyPatientInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutPatientInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutPatientInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientBookInput
    connect?: PatientWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutPatientBookInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type VisitCardCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    connect?: VisitCardWhereUniqueInput
  }

  export type OrthoCardCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    connect?: OrthoCardWhereUniqueInput
  }

  export type EncounterUncheckedCreateNestedManyWithoutPatientBookInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type VisitCardUncheckedCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    connect?: VisitCardWhereUniqueInput
  }

  export type OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    connect?: OrthoCardWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutPatientBookNestedInput = {
    create?: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPatientBookInput
    upsert?: PatientUpsertWithoutPatientBookInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPatientBookInput, PatientUpdateWithoutPatientBookInput>, PatientUncheckedUpdateWithoutPatientBookInput>
  }

  export type EncounterUpdateManyWithoutPatientBookNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientBookInput | EncounterUpsertWithWhereUniqueWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientBookInput | EncounterUpdateWithWhereUniqueWithoutPatientBookInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientBookInput | EncounterUpdateManyWithWhereWithoutPatientBookInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type VisitCardUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    upsert?: VisitCardUpsertWithoutPatientBookInput
    disconnect?: VisitCardWhereInput | boolean
    delete?: VisitCardWhereInput | boolean
    connect?: VisitCardWhereUniqueInput
    update?: XOR<XOR<VisitCardUpdateToOneWithWhereWithoutPatientBookInput, VisitCardUpdateWithoutPatientBookInput>, VisitCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type OrthoCardUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    upsert?: OrthoCardUpsertWithoutPatientBookInput
    disconnect?: OrthoCardWhereInput | boolean
    delete?: OrthoCardWhereInput | boolean
    connect?: OrthoCardWhereUniqueInput
    update?: XOR<XOR<OrthoCardUpdateToOneWithWhereWithoutPatientBookInput, OrthoCardUpdateWithoutPatientBookInput>, OrthoCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type EncounterUncheckedUpdateManyWithoutPatientBookNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput> | EncounterCreateWithoutPatientBookInput[] | EncounterUncheckedCreateWithoutPatientBookInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientBookInput | EncounterCreateOrConnectWithoutPatientBookInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientBookInput | EncounterUpsertWithWhereUniqueWithoutPatientBookInput[]
    createMany?: EncounterCreateManyPatientBookInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientBookInput | EncounterUpdateWithWhereUniqueWithoutPatientBookInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientBookInput | EncounterUpdateManyWithWhereWithoutPatientBookInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: VisitCardCreateOrConnectWithoutPatientBookInput
    upsert?: VisitCardUpsertWithoutPatientBookInput
    disconnect?: VisitCardWhereInput | boolean
    delete?: VisitCardWhereInput | boolean
    connect?: VisitCardWhereUniqueInput
    update?: XOR<XOR<VisitCardUpdateToOneWithWhereWithoutPatientBookInput, VisitCardUpdateWithoutPatientBookInput>, VisitCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput = {
    create?: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    connectOrCreate?: OrthoCardCreateOrConnectWithoutPatientBookInput
    upsert?: OrthoCardUpsertWithoutPatientBookInput
    disconnect?: OrthoCardWhereInput | boolean
    delete?: OrthoCardWhereInput | boolean
    connect?: OrthoCardWhereUniqueInput
    update?: XOR<XOR<OrthoCardUpdateToOneWithWhereWithoutPatientBookInput, OrthoCardUpdateWithoutPatientBookInput>, OrthoCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type PatientBookCreateNestedOneWithoutVisitCardInput = {
    create?: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutVisitCardInput
    connect?: PatientBookWhereUniqueInput
  }

  export type EnumVisitCardTypeFieldUpdateOperationsInput = {
    set?: $Enums.VisitCardType
  }

  export type PatientBookUpdateOneRequiredWithoutVisitCardNestedInput = {
    create?: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutVisitCardInput
    upsert?: PatientBookUpsertWithoutVisitCardInput
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutVisitCardInput, PatientBookUpdateWithoutVisitCardInput>, PatientBookUncheckedUpdateWithoutVisitCardInput>
  }

  export type PatientBookCreateNestedOneWithoutOrthoCardInput = {
    create?: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutOrthoCardInput
    connect?: PatientBookWhereUniqueInput
  }

  export type PatientBookUpdateOneRequiredWithoutOrthoCardNestedInput = {
    create?: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutOrthoCardInput
    upsert?: PatientBookUpsertWithoutOrthoCardInput
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutOrthoCardInput, PatientBookUpdateWithoutOrthoCardInput>, PatientBookUncheckedUpdateWithoutOrthoCardInput>
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAppointmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BranchUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAppointmentsInput
    upsert?: BranchUpsertWithoutAppointmentsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAppointmentsInput, BranchUpdateWithoutAppointmentsInput>, BranchUncheckedUpdateWithoutAppointmentsInput>
  }

  export type EncounterUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutAppointmentInput | EncounterUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutAppointmentInput | EncounterUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutAppointmentInput | EncounterUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput> | EncounterCreateWithoutAppointmentInput[] | EncounterUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutAppointmentInput | EncounterCreateOrConnectWithoutAppointmentInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutAppointmentInput | EncounterUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: EncounterCreateManyAppointmentInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutAppointmentInput | EncounterUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutAppointmentInput | EncounterUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutBookingsInput = {
    create?: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBookingsInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBookingsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type BranchUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBookingsInput
    upsert?: BranchUpsertWithoutBookingsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBookingsInput, BranchUpdateWithoutBookingsInput>, BranchUncheckedUpdateWithoutBookingsInput>
  }

  export type PatientUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutBookingsInput
    upsert?: PatientUpsertWithoutBookingsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutBookingsInput, PatientUpdateWithoutBookingsInput>, PatientUncheckedUpdateWithoutBookingsInput>
  }

  export type PatientBookCreateNestedOneWithoutEncountersInput = {
    create?: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutEncountersInput
    connect?: PatientBookWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEncountersInput = {
    create?: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncountersInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutEncountersInput = {
    create?: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEncountersInput
    connect?: AppointmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNurseEncountersInput = {
    create?: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseEncountersInput
    connect?: UserWhereUniqueInput
  }

  export type ChartToothCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutEncounterInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutEncounterInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutEncounterInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type EncounterServiceCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type EncounterDiagnosisCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type EncounterConsentCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
  }

  export type EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput> | EncounterSterilizationPackageUseCreateWithoutEncounterInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput | EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyEncounterInputEnvelope
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEncounterInput, EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput> | EmployeeBenefitUsageCreateWithoutEncounterInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput | EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput[]
    createMany?: EmployeeBenefitUsageCreateManyEncounterInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type ChartToothUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutEncounterInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PrescriptionUncheckedCreateNestedOneWithoutEncounterInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
  }

  export type EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput> | EncounterSterilizationPackageUseCreateWithoutEncounterInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput | EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyEncounterInputEnvelope
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEncounterInput, EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput> | EmployeeBenefitUsageCreateWithoutEncounterInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput | EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput[]
    createMany?: EmployeeBenefitUsageCreateManyEncounterInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type PatientBookUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientBookCreateOrConnectWithoutEncountersInput
    upsert?: PatientBookUpsertWithoutEncountersInput
    connect?: PatientBookWhereUniqueInput
    update?: XOR<XOR<PatientBookUpdateToOneWithWhereWithoutEncountersInput, PatientBookUpdateWithoutEncountersInput>, PatientBookUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEncountersInput
    upsert?: UserUpsertWithoutEncountersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEncountersInput, UserUpdateWithoutEncountersInput>, UserUncheckedUpdateWithoutEncountersInput>
  }

  export type AppointmentUpdateOneWithoutEncountersNestedInput = {
    create?: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutEncountersInput
    upsert?: AppointmentUpsertWithoutEncountersInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutEncountersInput, AppointmentUpdateWithoutEncountersInput>, AppointmentUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateOneWithoutNurseEncountersNestedInput = {
    create?: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseEncountersInput
    upsert?: UserUpsertWithoutNurseEncountersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseEncountersInput, UserUpdateWithoutNurseEncountersInput>, UserUncheckedUpdateWithoutNurseEncountersInput>
  }

  export type ChartToothUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    upsert?: ChartToothUpsertWithWhereUniqueWithoutEncounterInput | ChartToothUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    set?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    disconnect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    delete?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    update?: ChartToothUpdateWithWhereUniqueWithoutEncounterInput | ChartToothUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ChartToothUpdateManyWithWhereWithoutEncounterInput | ChartToothUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    upsert?: InvoiceUpsertWithoutEncounterInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEncounterInput, InvoiceUpdateWithoutEncounterInput>, InvoiceUncheckedUpdateWithoutEncounterInput>
  }

  export type PrescriptionUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    upsert?: PrescriptionUpsertWithoutEncounterInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutEncounterInput, PrescriptionUpdateWithoutEncounterInput>, PrescriptionUncheckedUpdateWithoutEncounterInput>
  }

  export type MediaUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutEncounterInput | MediaUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutEncounterInput | MediaUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutEncounterInput | MediaUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type EncounterServiceUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput | EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput | EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutEncounterInput | EncounterServiceUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type EncounterDiagnosisUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput | EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type EncounterConsentUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput | EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    set?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    disconnect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    delete?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    update?: EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput | EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterConsentUpdateManyWithWhereWithoutEncounterInput | EncounterConsentUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
  }

  export type EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput> | EncounterSterilizationPackageUseCreateWithoutEncounterInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput | EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutEncounterInput | EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyEncounterInputEnvelope
    set?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    disconnect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    delete?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    update?: EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutEncounterInput | EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterSterilizationPackageUseUpdateManyWithWhereWithoutEncounterInput | EncounterSterilizationPackageUseUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEncounterInput, EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput> | EmployeeBenefitUsageCreateWithoutEncounterInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput | EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEncounterInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EmployeeBenefitUsageCreateManyEncounterInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEncounterInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutEncounterInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type ChartToothUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput> | ChartToothCreateWithoutEncounterInput[] | ChartToothUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: ChartToothCreateOrConnectWithoutEncounterInput | ChartToothCreateOrConnectWithoutEncounterInput[]
    upsert?: ChartToothUpsertWithWhereUniqueWithoutEncounterInput | ChartToothUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: ChartToothCreateManyEncounterInputEnvelope
    set?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    disconnect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    delete?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    connect?: ChartToothWhereUniqueInput | ChartToothWhereUniqueInput[]
    update?: ChartToothUpdateWithWhereUniqueWithoutEncounterInput | ChartToothUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: ChartToothUpdateManyWithWhereWithoutEncounterInput | ChartToothUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEncounterInput
    upsert?: InvoiceUpsertWithoutEncounterInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEncounterInput, InvoiceUpdateWithoutEncounterInput>, InvoiceUncheckedUpdateWithoutEncounterInput>
  }

  export type PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput = {
    create?: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutEncounterInput
    upsert?: PrescriptionUpsertWithoutEncounterInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutEncounterInput, PrescriptionUpdateWithoutEncounterInput>, PrescriptionUncheckedUpdateWithoutEncounterInput>
  }

  export type MediaUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput> | MediaCreateWithoutEncounterInput[] | MediaUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutEncounterInput | MediaCreateOrConnectWithoutEncounterInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutEncounterInput | MediaUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: MediaCreateManyEncounterInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutEncounterInput | MediaUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutEncounterInput | MediaUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput> | EncounterServiceCreateWithoutEncounterInput[] | EncounterServiceUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutEncounterInput | EncounterServiceCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput | EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterServiceCreateManyEncounterInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput | EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutEncounterInput | EncounterServiceUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput> | EncounterDiagnosisCreateWithoutEncounterInput[] | EncounterDiagnosisUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutEncounterInput | EncounterDiagnosisCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterDiagnosisCreateManyEncounterInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput | EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput> | EncounterConsentCreateWithoutEncounterInput[] | EncounterConsentUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConsentCreateOrConnectWithoutEncounterInput | EncounterConsentCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput | EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterConsentCreateManyEncounterInputEnvelope
    set?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    disconnect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    delete?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    connect?: EncounterConsentWhereUniqueInput | EncounterConsentWhereUniqueInput[]
    update?: EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput | EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterConsentUpdateManyWithWhereWithoutEncounterInput | EncounterConsentUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterSterilizationPackageUseCreateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput> | EncounterSterilizationPackageUseCreateWithoutEncounterInput[] | EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput | EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutEncounterInput | EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterSterilizationPackageUseCreateManyEncounterInputEnvelope
    set?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    disconnect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    delete?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    connect?: EncounterSterilizationPackageUseWhereUniqueInput | EncounterSterilizationPackageUseWhereUniqueInput[]
    update?: EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutEncounterInput | EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterSterilizationPackageUseUpdateManyWithWhereWithoutEncounterInput | EncounterSterilizationPackageUseUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutEncounterInput, EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput> | EmployeeBenefitUsageCreateWithoutEncounterInput[] | EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput | EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEncounterInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EmployeeBenefitUsageCreateManyEncounterInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEncounterInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutEncounterInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutConsentsInput = {
    create?: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutConsentsInput
    connect?: EncounterWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutConsentsInput
    upsert?: EncounterUpsertWithoutConsentsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutConsentsInput, EncounterUpdateWithoutConsentsInput>, EncounterUncheckedUpdateWithoutConsentsInput>
  }

  export type EncounterCreateNestedOneWithoutChartTeethInput = {
    create?: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutChartTeethInput
    connect?: EncounterWhereUniqueInput
  }

  export type ChartNoteCreateNestedManyWithoutChartToothInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
  }

  export type ChartNoteUncheckedCreateNestedManyWithoutChartToothInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
  }

  export type EncounterUpdateOneRequiredWithoutChartTeethNestedInput = {
    create?: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutChartTeethInput
    upsert?: EncounterUpsertWithoutChartTeethInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutChartTeethInput, EncounterUpdateWithoutChartTeethInput>, EncounterUncheckedUpdateWithoutChartTeethInput>
  }

  export type ChartNoteUpdateManyWithoutChartToothNestedInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    upsert?: ChartNoteUpsertWithWhereUniqueWithoutChartToothInput | ChartNoteUpsertWithWhereUniqueWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    set?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    disconnect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    delete?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    update?: ChartNoteUpdateWithWhereUniqueWithoutChartToothInput | ChartNoteUpdateWithWhereUniqueWithoutChartToothInput[]
    updateMany?: ChartNoteUpdateManyWithWhereWithoutChartToothInput | ChartNoteUpdateManyWithWhereWithoutChartToothInput[]
    deleteMany?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
  }

  export type ChartNoteUncheckedUpdateManyWithoutChartToothNestedInput = {
    create?: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput> | ChartNoteCreateWithoutChartToothInput[] | ChartNoteUncheckedCreateWithoutChartToothInput[]
    connectOrCreate?: ChartNoteCreateOrConnectWithoutChartToothInput | ChartNoteCreateOrConnectWithoutChartToothInput[]
    upsert?: ChartNoteUpsertWithWhereUniqueWithoutChartToothInput | ChartNoteUpsertWithWhereUniqueWithoutChartToothInput[]
    createMany?: ChartNoteCreateManyChartToothInputEnvelope
    set?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    disconnect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    delete?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    connect?: ChartNoteWhereUniqueInput | ChartNoteWhereUniqueInput[]
    update?: ChartNoteUpdateWithWhereUniqueWithoutChartToothInput | ChartNoteUpdateWithWhereUniqueWithoutChartToothInput[]
    updateMany?: ChartNoteUpdateManyWithWhereWithoutChartToothInput | ChartNoteUpdateManyWithWhereWithoutChartToothInput[]
    deleteMany?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
  }

  export type ChartToothCreateNestedOneWithoutChartNotesInput = {
    create?: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
    connectOrCreate?: ChartToothCreateOrConnectWithoutChartNotesInput
    connect?: ChartToothWhereUniqueInput
  }

  export type ChartToothUpdateOneRequiredWithoutChartNotesNestedInput = {
    create?: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
    connectOrCreate?: ChartToothCreateOrConnectWithoutChartNotesInput
    upsert?: ChartToothUpsertWithoutChartNotesInput
    connect?: ChartToothWhereUniqueInput
    update?: XOR<XOR<ChartToothUpdateToOneWithWhereWithoutChartNotesInput, ChartToothUpdateWithoutChartNotesInput>, ChartToothUncheckedUpdateWithoutChartNotesInput>
  }

  export type DiagnosisProblemCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
  }

  export type EncounterDiagnosisCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type DiagnosisProblemUncheckedCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
  }

  export type EncounterDiagnosisUncheckedCreateNestedManyWithoutDiagnosisInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
  }

  export type DiagnosisProblemUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    upsert?: DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    set?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    disconnect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    delete?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    update?: DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput | DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
  }

  export type EncounterDiagnosisUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput | EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput> | DiagnosisProblemCreateWithoutDiagnosisInput[] | DiagnosisProblemUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: DiagnosisProblemCreateOrConnectWithoutDiagnosisInput | DiagnosisProblemCreateOrConnectWithoutDiagnosisInput[]
    upsert?: DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: DiagnosisProblemCreateManyDiagnosisInputEnvelope
    set?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    disconnect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    delete?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    connect?: DiagnosisProblemWhereUniqueInput | DiagnosisProblemWhereUniqueInput[]
    update?: DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput | DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput | DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput> | EncounterDiagnosisCreateWithoutDiagnosisInput[] | EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput | EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput[]
    upsert?: EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput[]
    createMany?: EncounterDiagnosisCreateManyDiagnosisInputEnvelope
    set?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    disconnect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    delete?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    connect?: EncounterDiagnosisWhereUniqueInput | EncounterDiagnosisWhereUniqueInput[]
    update?: EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput | EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput[]
    updateMany?: EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput | EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput[]
    deleteMany?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
  }

  export type DiagnosisCreateNestedOneWithoutProblemsInput = {
    create?: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutProblemsInput
    connect?: DiagnosisWhereUniqueInput
  }

  export type DiagnosisUpdateOneRequiredWithoutProblemsNestedInput = {
    create?: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutProblemsInput
    upsert?: DiagnosisUpsertWithoutProblemsInput
    connect?: DiagnosisWhereUniqueInput
    update?: XOR<XOR<DiagnosisUpdateToOneWithWhereWithoutProblemsInput, DiagnosisUpdateWithoutProblemsInput>, DiagnosisUncheckedUpdateWithoutProblemsInput>
  }

  export type EncounterCreateNestedOneWithoutDiagnosesInput = {
    create?: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutDiagnosesInput
    connect?: EncounterWhereUniqueInput
  }

  export type DiagnosisCreateNestedOneWithoutEncountersInput = {
    create?: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEncountersInput
    connect?: DiagnosisWhereUniqueInput
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutEncounterDiagnosisInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInputEnvelope
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutEncounterDiagnosisInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInputEnvelope
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
  }

  export type EncounterUpdateOneRequiredWithoutDiagnosesNestedInput = {
    create?: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutDiagnosesInput
    upsert?: EncounterUpsertWithoutDiagnosesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutDiagnosesInput, EncounterUpdateWithoutDiagnosesInput>, EncounterUncheckedUpdateWithoutDiagnosesInput>
  }

  export type DiagnosisUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: DiagnosisCreateOrConnectWithoutEncountersInput
    upsert?: DiagnosisUpsertWithoutEncountersInput
    connect?: DiagnosisWhereUniqueInput
    update?: XOR<XOR<DiagnosisUpdateToOneWithWhereWithoutEncountersInput, DiagnosisUpdateWithoutEncountersInput>, DiagnosisUncheckedUpdateWithoutEncountersInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutEncounterDiagnosisNestedInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput[]
    upsert?: EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutEncounterDiagnosisInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInputEnvelope
    set?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    disconnect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    delete?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    update?: EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutEncounterDiagnosisInput[]
    updateMany?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutEncounterDiagnosisInput[]
    deleteMany?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput | EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutEncounterDiagnosisNestedInput = {
    create?: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput> | EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput[] | EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput[]
    connectOrCreate?: EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput[]
    upsert?: EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutEncounterDiagnosisInput[]
    createMany?: EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInputEnvelope
    set?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    disconnect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    delete?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    connect?: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput | EncounterDiagnosisSterilizationIndicatorWhereUniqueInput[]
    update?: EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutEncounterDiagnosisInput[]
    updateMany?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutEncounterDiagnosisInput[]
    deleteMany?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput | EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
  }

  export type EncounterDiagnosisCreateNestedOneWithoutSterilizationIndicatorsInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutSterilizationIndicatorsInput, EncounterDiagnosisUncheckedCreateWithoutSterilizationIndicatorsInput>
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutSterilizationIndicatorsInput
    connect?: EncounterDiagnosisWhereUniqueInput
  }

  export type SterilizationIndicatorCreateNestedOneWithoutEncounterDiagnosisLinksInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisLinksInput>
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisLinksInput
    connect?: SterilizationIndicatorWhereUniqueInput
  }

  export type EncounterDiagnosisUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput = {
    create?: XOR<EncounterDiagnosisCreateWithoutSterilizationIndicatorsInput, EncounterDiagnosisUncheckedCreateWithoutSterilizationIndicatorsInput>
    connectOrCreate?: EncounterDiagnosisCreateOrConnectWithoutSterilizationIndicatorsInput
    upsert?: EncounterDiagnosisUpsertWithoutSterilizationIndicatorsInput
    connect?: EncounterDiagnosisWhereUniqueInput
    update?: XOR<XOR<EncounterDiagnosisUpdateToOneWithWhereWithoutSterilizationIndicatorsInput, EncounterDiagnosisUpdateWithoutSterilizationIndicatorsInput>, EncounterDiagnosisUncheckedUpdateWithoutSterilizationIndicatorsInput>
  }

  export type SterilizationIndicatorUpdateOneRequiredWithoutEncounterDiagnosisLinksNestedInput = {
    create?: XOR<SterilizationIndicatorCreateWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisLinksInput>
    connectOrCreate?: SterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisLinksInput
    upsert?: SterilizationIndicatorUpsertWithoutEncounterDiagnosisLinksInput
    connect?: SterilizationIndicatorWhereUniqueInput
    update?: XOR<XOR<SterilizationIndicatorUpdateToOneWithWhereWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUpdateWithoutEncounterDiagnosisLinksInput>, SterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisLinksInput>
  }

  export type EncounterServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type ServiceBranchCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EncounterServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
  }

  export type ServiceBranchUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EncounterServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutServiceInput | EncounterServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutServiceInput | EncounterServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutServiceInput | EncounterServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type ServiceBranchUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutServiceInput | ServiceBranchUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutServiceInput | ServiceBranchUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutServiceInput | ServiceBranchUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceInput | InvoiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput> | EncounterServiceCreateWithoutServiceInput[] | EncounterServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: EncounterServiceCreateOrConnectWithoutServiceInput | EncounterServiceCreateOrConnectWithoutServiceInput[]
    upsert?: EncounterServiceUpsertWithWhereUniqueWithoutServiceInput | EncounterServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: EncounterServiceCreateManyServiceInputEnvelope
    set?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    disconnect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    delete?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    connect?: EncounterServiceWhereUniqueInput | EncounterServiceWhereUniqueInput[]
    update?: EncounterServiceUpdateWithWhereUniqueWithoutServiceInput | EncounterServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: EncounterServiceUpdateManyWithWhereWithoutServiceInput | EncounterServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
  }

  export type ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput> | ServiceBranchCreateWithoutServiceInput[] | ServiceBranchUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceBranchCreateOrConnectWithoutServiceInput | ServiceBranchCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceBranchUpsertWithWhereUniqueWithoutServiceInput | ServiceBranchUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceBranchCreateManyServiceInputEnvelope
    set?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    disconnect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    delete?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    connect?: ServiceBranchWhereUniqueInput | ServiceBranchWhereUniqueInput[]
    update?: ServiceBranchUpdateWithWhereUniqueWithoutServiceInput | ServiceBranchUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceBranchUpdateManyWithWhereWithoutServiceInput | ServiceBranchUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceInput | InvoiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutServiceBranchesInput = {
    create?: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceBranchesInput
    connect?: ServiceWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutServiceBranchesInput = {
    create?: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutServiceBranchesNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceBranchesInput
    upsert?: ServiceUpsertWithoutServiceBranchesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceBranchesInput, ServiceUpdateWithoutServiceBranchesInput>, ServiceUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutServiceBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceBranchesInput
    upsert?: BranchUpsertWithoutServiceBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServiceBranchesInput, BranchUpdateWithoutServiceBranchesInput>, BranchUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type EncounterCreateNestedOneWithoutEncounterServicesInput = {
    create?: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterServicesInput
    connect?: EncounterWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutEncounterServicesInput = {
    create?: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEncounterServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutEncounterServicesNestedInput = {
    create?: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutEncounterServicesInput
    upsert?: EncounterUpsertWithoutEncounterServicesInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutEncounterServicesInput, EncounterUpdateWithoutEncounterServicesInput>, EncounterUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutEncounterServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEncounterServicesInput
    upsert?: ServiceUpsertWithoutEncounterServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutEncounterServicesInput, ServiceUpdateWithoutEncounterServicesInput>, ServiceUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type InvoiceItemCreateNestedManyWithoutProcedureInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProcedureInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput | InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput | InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProcedureInput | InvoiceItemUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProcedureNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput> | InvoiceItemCreateWithoutProcedureInput[] | InvoiceItemUncheckedCreateWithoutProcedureInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProcedureInput | InvoiceItemCreateOrConnectWithoutProcedureInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput | InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput[]
    createMany?: InvoiceItemCreateManyProcedureInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput | InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProcedureInput | InvoiceItemUpdateManyWithWhereWithoutProcedureInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutProductsInput = {
    create?: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductsInput
    connect?: BranchWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ProductStockMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockMovementCreateWithoutProductInput, ProductStockMovementUncheckedCreateWithoutProductInput> | ProductStockMovementCreateWithoutProductInput[] | ProductStockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutProductInput | ProductStockMovementCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockMovementCreateManyProductInputEnvelope
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ProductStockMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockMovementCreateWithoutProductInput, ProductStockMovementUncheckedCreateWithoutProductInput> | ProductStockMovementCreateWithoutProductInput[] | ProductStockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutProductInput | ProductStockMovementCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockMovementCreateManyProductInputEnvelope
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductsInput
    upsert?: BranchUpsertWithoutProductsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutProductsInput, BranchUpdateWithoutProductsInput>, BranchUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type InvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ProductStockMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockMovementCreateWithoutProductInput, ProductStockMovementUncheckedCreateWithoutProductInput> | ProductStockMovementCreateWithoutProductInput[] | ProductStockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutProductInput | ProductStockMovementCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockMovementUpsertWithWhereUniqueWithoutProductInput | ProductStockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockMovementCreateManyProductInputEnvelope
    set?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    disconnect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    delete?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    update?: ProductStockMovementUpdateWithWhereUniqueWithoutProductInput | ProductStockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockMovementUpdateManyWithWhereWithoutProductInput | ProductStockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockMovementScalarWhereInput | ProductStockMovementScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ProductStockMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockMovementCreateWithoutProductInput, ProductStockMovementUncheckedCreateWithoutProductInput> | ProductStockMovementCreateWithoutProductInput[] | ProductStockMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockMovementCreateOrConnectWithoutProductInput | ProductStockMovementCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockMovementUpsertWithWhereUniqueWithoutProductInput | ProductStockMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockMovementCreateManyProductInputEnvelope
    set?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    disconnect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    delete?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    connect?: ProductStockMovementWhereUniqueInput | ProductStockMovementWhereUniqueInput[]
    update?: ProductStockMovementUpdateWithWhereUniqueWithoutProductInput | ProductStockMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockMovementUpdateManyWithWhereWithoutProductInput | ProductStockMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockMovementScalarWhereInput | ProductStockMovementScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutProductStockMovementsInput = {
    create?: XOR<BranchCreateWithoutProductStockMovementsInput, BranchUncheckedCreateWithoutProductStockMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductStockMovementsInput
    connect?: BranchWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovementsInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumProductStockMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductStockMovementType
  }

  export type BranchUpdateOneRequiredWithoutProductStockMovementsNestedInput = {
    create?: XOR<BranchCreateWithoutProductStockMovementsInput, BranchUncheckedCreateWithoutProductStockMovementsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductStockMovementsInput
    upsert?: BranchUpsertWithoutProductStockMovementsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutProductStockMovementsInput, BranchUpdateWithoutProductStockMovementsInput>, BranchUncheckedUpdateWithoutProductStockMovementsInput>
  }

  export type ProductUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockMovementsInput
    upsert?: ProductUpsertWithoutStockMovementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockMovementsInput, ProductUpdateWithoutStockMovementsInput>, ProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type BranchCreateNestedOneWithoutProductCategoriesInput = {
    create?: XOR<BranchCreateWithoutProductCategoriesInput, BranchUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductCategoriesInput
    connect?: BranchWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutProductCategoriesNestedInput = {
    create?: XOR<BranchCreateWithoutProductCategoriesInput, BranchUncheckedCreateWithoutProductCategoriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProductCategoriesInput
    upsert?: BranchUpsertWithoutProductCategoriesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutProductCategoriesInput, BranchUpdateWithoutProductCategoriesInput>, BranchUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutPrescriptionInput = {
    create?: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutPrescriptionInput
    connect?: EncounterWhereUniqueInput
  }

  export type PrescriptionItemCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type EncounterUpdateOneRequiredWithoutPrescriptionNestedInput = {
    create?: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutPrescriptionInput
    upsert?: EncounterUpsertWithoutPrescriptionInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutPrescriptionInput, EncounterUpdateWithoutPrescriptionInput>, EncounterUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutItemsInput = {
    create?: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutItemsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutItemsInput
    upsert?: PrescriptionUpsertWithoutItemsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutItemsInput, PrescriptionUpdateWithoutItemsInput>, PrescriptionUncheckedUpdateWithoutItemsInput>
  }

  export type BranchCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInvoicesInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutInvoiceInput
    connect?: EncounterWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EBarimtReceiptCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    connect?: EBarimtReceiptWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    connect?: EBarimtReceiptWhereUniqueInput
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDiscountPercentFieldUpdateOperationsInput = {
    set?: $Enums.DiscountPercent
  }

  export type BranchUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutInvoicesInput
    upsert?: BranchUpsertWithoutInvoicesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutInvoicesInput, BranchUpdateWithoutInvoicesInput>, BranchUncheckedUpdateWithoutInvoicesInput>
  }

  export type EncounterUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutInvoiceInput
    upsert?: EncounterUpsertWithoutInvoiceInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutInvoiceInput, EncounterUpdateWithoutInvoiceInput>, EncounterUncheckedUpdateWithoutInvoiceInput>
  }

  export type PatientUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EBarimtReceiptUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    upsert?: EBarimtReceiptUpsertWithoutInvoiceInput
    disconnect?: EBarimtReceiptWhereInput | boolean
    delete?: EBarimtReceiptWhereInput | boolean
    connect?: EBarimtReceiptWhereUniqueInput
    update?: XOR<XOR<EBarimtReceiptUpdateToOneWithWhereWithoutInvoiceInput, EBarimtReceiptUpdateWithoutInvoiceInput>, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
  }

  export type LedgerEntryUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutInvoiceInput | LedgerEntryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: EBarimtReceiptCreateOrConnectWithoutInvoiceInput
    upsert?: EBarimtReceiptUpsertWithoutInvoiceInput
    disconnect?: EBarimtReceiptWhereInput | boolean
    delete?: EBarimtReceiptWhereInput | boolean
    connect?: EBarimtReceiptWhereUniqueInput
    update?: XOR<XOR<EBarimtReceiptUpdateToOneWithWhereWithoutInvoiceInput, EBarimtReceiptUpdateWithoutInvoiceInput>, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
  }

  export type LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput> | LedgerEntryCreateWithoutInvoiceInput[] | LedgerEntryUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutInvoiceInput | LedgerEntryCreateOrConnectWithoutInvoiceInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: LedgerEntryCreateManyInvoiceInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput | LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutInvoiceInput | LedgerEntryUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput> | EmployeeBenefitUsageCreateWithoutInvoiceInput[] | EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput | EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput[]
    upsert?: EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: EmployeeBenefitUsageCreateManyInvoiceInputEnvelope
    set?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    disconnect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    delete?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    connect?: EmployeeBenefitUsageWhereUniqueInput | EmployeeBenefitUsageWhereUniqueInput[]
    update?: EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput | EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput | EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProcedureCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProcedureWhereUniqueInput
  }

  export type EnumInvoiceItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceItemType
  }

  export type EnumInvoiceItemSourceFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceItemSource
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ServiceUpsertWithoutInvoiceItemsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput, ServiceUpdateWithoutInvoiceItemsInput>, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProductUpsertWithoutInvoiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInvoiceItemsInput, ProductUpdateWithoutInvoiceItemsInput>, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProcedureUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProcedureCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProcedureUpsertWithoutInvoiceItemsInput
    disconnect?: ProcedureWhereInput | boolean
    delete?: ProcedureWhereInput | boolean
    connect?: ProcedureWhereUniqueInput
    update?: XOR<XOR<ProcedureUpdateToOneWithWhereWithoutInvoiceItemsInput, ProcedureUpdateWithoutInvoiceItemsInput>, ProcedureUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceCreateNestedOneWithoutEBarimtReceiptInput = {
    create?: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEBarimtReceiptInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutEBarimtReceiptNestedInput = {
    create?: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEBarimtReceiptInput
    upsert?: InvoiceUpsertWithoutEBarimtReceiptInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEBarimtReceiptInput, InvoiceUpdateWithoutEBarimtReceiptInput>, InvoiceUncheckedUpdateWithoutEBarimtReceiptInput>
  }

  export type BranchCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLedgerEntriesInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLedgerEntriesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLedgerEntriesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedLedgerEntriesInput = {
    create?: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLedgerEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedLedgerEntriesInput = {
    create?: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLedgerEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutLedgerEntriesInput
    connect?: AuthorizationCodeWhereUniqueInput
  }

  export type EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutLedgerEntriesInput
    connect?: EmployeeVoucherWhereUniqueInput
  }

  export type EnumLedgerEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.LedgerEntryType
  }

  export type BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLedgerEntriesInput
    upsert?: BranchUpsertWithoutLedgerEntriesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutLedgerEntriesInput, BranchUpdateWithoutLedgerEntriesInput>, BranchUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLedgerEntriesInput
    upsert?: PatientUpsertWithoutLedgerEntriesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLedgerEntriesInput, PatientUpdateWithoutLedgerEntriesInput>, PatientUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type InvoiceUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLedgerEntriesInput
    upsert?: InvoiceUpsertWithoutLedgerEntriesInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLedgerEntriesInput, InvoiceUpdateWithoutLedgerEntriesInput>, InvoiceUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLedgerEntriesInput
    upsert?: UserUpsertWithoutCreatedLedgerEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLedgerEntriesInput, UserUpdateWithoutCreatedLedgerEntriesInput>, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
  }

  export type UserUpdateOneWithoutApprovedLedgerEntriesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLedgerEntriesInput
    upsert?: UserUpsertWithoutApprovedLedgerEntriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedLedgerEntriesInput, UserUpdateWithoutApprovedLedgerEntriesInput>, UserUncheckedUpdateWithoutApprovedLedgerEntriesInput>
  }

  export type AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: AuthorizationCodeCreateOrConnectWithoutLedgerEntriesInput
    upsert?: AuthorizationCodeUpsertWithoutLedgerEntriesInput
    disconnect?: AuthorizationCodeWhereInput | boolean
    delete?: AuthorizationCodeWhereInput | boolean
    connect?: AuthorizationCodeWhereUniqueInput
    update?: XOR<XOR<AuthorizationCodeUpdateToOneWithWhereWithoutLedgerEntriesInput, AuthorizationCodeUpdateWithoutLedgerEntriesInput>, AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput = {
    create?: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: EmployeeVoucherCreateOrConnectWithoutLedgerEntriesInput
    upsert?: EmployeeVoucherUpsertWithoutLedgerEntriesInput
    disconnect?: EmployeeVoucherWhereInput | boolean
    delete?: EmployeeVoucherWhereInput | boolean
    connect?: EmployeeVoucherWhereUniqueInput
    update?: XOR<XOR<EmployeeVoucherUpdateToOneWithWhereWithoutLedgerEntriesInput, EmployeeVoucherUpdateWithoutLedgerEntriesInput>, EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type UserCreateNestedOneWithoutAuthorizationCodesInput = {
    create?: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorizationCodesInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutApprovalCodeInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutApprovalCodeInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAuthorizationCodesNestedInput = {
    create?: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorizationCodesInput
    upsert?: UserUpsertWithoutAuthorizationCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorizationCodesInput, UserUpdateWithoutAuthorizationCodesInput>, UserUncheckedUpdateWithoutAuthorizationCodesInput>
  }

  export type LedgerEntryUpdateManyWithoutApprovalCodeNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput | LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovalCodeNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput> | LedgerEntryCreateWithoutApprovalCodeInput[] | LedgerEntryUncheckedCreateWithoutApprovalCodeInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutApprovalCodeInput | LedgerEntryCreateOrConnectWithoutApprovalCodeInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput[]
    createMany?: LedgerEntryCreateManyApprovalCodeInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput | LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput | LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEmployeeVouchersInput = {
    create?: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeeVouchersInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeVouchersInput = {
    create?: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedEmployeeVouchersInput = {
    create?: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedEmployeeVouchersInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type EnumEmployeeVoucherStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeVoucherStatus
  }

  export type BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput = {
    create?: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeeVouchersInput
    upsert?: BranchUpsertWithoutEmployeeVouchersInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEmployeeVouchersInput, BranchUpdateWithoutEmployeeVouchersInput>, BranchUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeVouchersInput
    upsert?: UserUpsertWithoutEmployeeVouchersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeVouchersInput, UserUpdateWithoutEmployeeVouchersInput>, UserUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput | LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedEmployeeVouchersInput
    upsert?: UserUpsertWithoutCreatedEmployeeVouchersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedEmployeeVouchersInput, UserUpdateWithoutCreatedEmployeeVouchersInput>, UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput>
  }

  export type LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput> | LedgerEntryCreateWithoutEmployeeVoucherInput[] | LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput | LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput[]
    createMany?: LedgerEntryCreateManyEmployeeVoucherInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput | LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput | LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutMediaInput = {
    create?: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutMediaInput
    connect?: EncounterWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutMediaInput
    upsert?: EncounterUpsertWithoutMediaInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutMediaInput, EncounterUpdateWithoutMediaInput>, EncounterUncheckedUpdateWithoutMediaInput>
  }

  export type UserCreateNestedOneWithoutDoctorSchedulesInput = {
    create?: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutDoctorSchedulesInput = {
    create?: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorSchedulesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDoctorSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorSchedulesInput
    upsert?: UserUpsertWithoutDoctorSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorSchedulesInput, UserUpdateWithoutDoctorSchedulesInput>, UserUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type BranchUpdateOneRequiredWithoutDoctorSchedulesNestedInput = {
    create?: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorSchedulesInput
    upsert?: BranchUpsertWithoutDoctorSchedulesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDoctorSchedulesInput, BranchUpdateWithoutDoctorSchedulesInput>, BranchUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type UserCreateNestedOneWithoutReceptionSchedulesInput = {
    create?: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutReceptionSchedulesInput = {
    create?: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionSchedulesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReceptionSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionSchedulesInput
    upsert?: UserUpsertWithoutReceptionSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceptionSchedulesInput, UserUpdateWithoutReceptionSchedulesInput>, UserUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type BranchUpdateOneRequiredWithoutReceptionSchedulesNestedInput = {
    create?: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionSchedulesInput
    upsert?: BranchUpsertWithoutReceptionSchedulesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutReceptionSchedulesInput, BranchUpdateWithoutReceptionSchedulesInput>, BranchUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type UserCreateNestedOneWithoutDoctorBranchesInput = {
    create?: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutDoctorBranchesInput = {
    create?: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDoctorBranchesNestedInput = {
    create?: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorBranchesInput
    upsert?: UserUpsertWithoutDoctorBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorBranchesInput, UserUpdateWithoutDoctorBranchesInput>, UserUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutDoctorBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDoctorBranchesInput
    upsert?: BranchUpsertWithoutDoctorBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDoctorBranchesInput, BranchUpdateWithoutDoctorBranchesInput>, BranchUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type UserCreateNestedOneWithoutReceptionBranchesInput = {
    create?: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutReceptionBranchesInput = {
    create?: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReceptionBranchesNestedInput = {
    create?: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceptionBranchesInput
    upsert?: UserUpsertWithoutReceptionBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceptionBranchesInput, UserUpdateWithoutReceptionBranchesInput>, UserUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutReceptionBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutReceptionBranchesInput
    upsert?: BranchUpsertWithoutReceptionBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutReceptionBranchesInput, BranchUpdateWithoutReceptionBranchesInput>, BranchUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type UserCreateNestedOneWithoutNurseBranchesInput = {
    create?: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseBranchesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutNurseBranchesInput = {
    create?: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNurseBranchesNestedInput = {
    create?: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseBranchesInput
    upsert?: UserUpsertWithoutNurseBranchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseBranchesInput, UserUpdateWithoutNurseBranchesInput>, UserUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutNurseBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseBranchesInput
    upsert?: BranchUpsertWithoutNurseBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutNurseBranchesInput, BranchUpdateWithoutNurseBranchesInput>, BranchUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type UserCreateNestedOneWithoutNurseSchedulesInput = {
    create?: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutNurseSchedulesInput = {
    create?: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseSchedulesInput
    connect?: BranchWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNurseSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNurseSchedulesInput
    upsert?: UserUpsertWithoutNurseSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNurseSchedulesInput, UserUpdateWithoutNurseSchedulesInput>, UserUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type BranchUpdateOneRequiredWithoutNurseSchedulesNestedInput = {
    create?: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutNurseSchedulesInput
    upsert?: BranchUpsertWithoutNurseSchedulesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutNurseSchedulesInput, BranchUpdateWithoutNurseSchedulesInput>, BranchUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type PaymentProviderConfigCreateNestedManyWithoutMethodInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutMethodInput, PaymentProviderConfigUncheckedCreateWithoutMethodInput> | PaymentProviderConfigCreateWithoutMethodInput[] | PaymentProviderConfigUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutMethodInput | PaymentProviderConfigCreateOrConnectWithoutMethodInput[]
    createMany?: PaymentProviderConfigCreateManyMethodInputEnvelope
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
  }

  export type PaymentProviderConfigUncheckedCreateNestedManyWithoutMethodInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutMethodInput, PaymentProviderConfigUncheckedCreateWithoutMethodInput> | PaymentProviderConfigCreateWithoutMethodInput[] | PaymentProviderConfigUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutMethodInput | PaymentProviderConfigCreateOrConnectWithoutMethodInput[]
    createMany?: PaymentProviderConfigCreateManyMethodInputEnvelope
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
  }

  export type PaymentProviderConfigUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutMethodInput, PaymentProviderConfigUncheckedCreateWithoutMethodInput> | PaymentProviderConfigCreateWithoutMethodInput[] | PaymentProviderConfigUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutMethodInput | PaymentProviderConfigCreateOrConnectWithoutMethodInput[]
    upsert?: PaymentProviderConfigUpsertWithWhereUniqueWithoutMethodInput | PaymentProviderConfigUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PaymentProviderConfigCreateManyMethodInputEnvelope
    set?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    disconnect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    delete?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    update?: PaymentProviderConfigUpdateWithWhereUniqueWithoutMethodInput | PaymentProviderConfigUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PaymentProviderConfigUpdateManyWithWhereWithoutMethodInput | PaymentProviderConfigUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
  }

  export type PaymentProviderConfigUncheckedUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutMethodInput, PaymentProviderConfigUncheckedCreateWithoutMethodInput> | PaymentProviderConfigCreateWithoutMethodInput[] | PaymentProviderConfigUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutMethodInput | PaymentProviderConfigCreateOrConnectWithoutMethodInput[]
    upsert?: PaymentProviderConfigUpsertWithWhereUniqueWithoutMethodInput | PaymentProviderConfigUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PaymentProviderConfigCreateManyMethodInputEnvelope
    set?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    disconnect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    delete?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    update?: PaymentProviderConfigUpdateWithWhereUniqueWithoutMethodInput | PaymentProviderConfigUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PaymentProviderConfigUpdateManyWithWhereWithoutMethodInput | PaymentProviderConfigUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
  }

  export type PaymentMethodConfigCreateNestedOneWithoutProvidersInput = {
    create?: XOR<PaymentMethodConfigCreateWithoutProvidersInput, PaymentMethodConfigUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: PaymentMethodConfigCreateOrConnectWithoutProvidersInput
    connect?: PaymentMethodConfigWhereUniqueInput
  }

  export type PaymentMethodConfigUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<PaymentMethodConfigCreateWithoutProvidersInput, PaymentMethodConfigUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: PaymentMethodConfigCreateOrConnectWithoutProvidersInput
    upsert?: PaymentMethodConfigUpsertWithoutProvidersInput
    connect?: PaymentMethodConfigWhereUniqueInput
    update?: XOR<XOR<PaymentMethodConfigUpdateToOneWithWhereWithoutProvidersInput, PaymentMethodConfigUpdateWithoutProvidersInput>, PaymentMethodConfigUncheckedUpdateWithoutProvidersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumVisitCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeFilter<$PrismaModel> | $Enums.VisitCardType
  }

  export type NestedEnumVisitCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitCardType | EnumVisitCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitCardType[] | ListEnumVisitCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitCardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitCardTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitCardTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProductStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStockMovementType | EnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStockMovementTypeFilter<$PrismaModel> | $Enums.ProductStockMovementType
  }

  export type NestedEnumProductStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStockMovementType | EnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStockMovementType[] | ListEnumProductStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductStockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumProductStockMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumDiscountPercentFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentFilter<$PrismaModel> | $Enums.DiscountPercent
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDiscountPercentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountPercent | EnumDiscountPercentFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountPercent[] | ListEnumDiscountPercentFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountPercentWithAggregatesFilter<$PrismaModel> | $Enums.DiscountPercent
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountPercentFilter<$PrismaModel>
    _max?: NestedEnumDiscountPercentFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeFilter<$PrismaModel> | $Enums.InvoiceItemType
  }

  export type NestedEnumInvoiceItemSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceFilter<$PrismaModel> | $Enums.InvoiceItemSource
  }

  export type NestedEnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemType | EnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemType[] | ListEnumInvoiceItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceItemSource | EnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceItemSource[] | ListEnumInvoiceItemSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceItemSourceWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceItemSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
    _max?: NestedEnumInvoiceItemSourceFilter<$PrismaModel>
  }

  export type NestedEnumLedgerEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeFilter<$PrismaModel> | $Enums.LedgerEntryType
  }

  export type NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryType | EnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryType[] | ListEnumLedgerEntryTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmployeeVoucherStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
  }

  export type NestedEnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeVoucherStatus | EnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeVoucherStatus[] | ListEnumEmployeeVoucherStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeVoucherStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeVoucherStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeVoucherStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutBranchInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutBranchInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBranchInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBranchInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientCreateManyBranchInputEnvelope = {
    data: PatientCreateManyBranchInput | PatientCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DoctorScheduleCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    doctor: UserCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateWithoutBranchInput = {
    id?: number
    doctorId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleCreateOrConnectWithoutBranchInput = {
    where: DoctorScheduleWhereUniqueInput
    create: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput>
  }

  export type DoctorScheduleCreateManyBranchInputEnvelope = {
    data: DoctorScheduleCreateManyBranchInput | DoctorScheduleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBranchCreateWithoutBranchInput = {
    service: ServiceCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateWithoutBranchInput = {
    serviceId: number
  }

  export type ServiceBranchCreateOrConnectWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    create: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput>
  }

  export type ServiceBranchCreateManyBranchInputEnvelope = {
    data: ServiceBranchCreateManyBranchInput | ServiceBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DoctorBranchCreateWithoutBranchInput = {
    doctor: UserCreateNestedOneWithoutDoctorBranchesInput
  }

  export type DoctorBranchUncheckedCreateWithoutBranchInput = {
    id?: number
    doctorId: number
  }

  export type DoctorBranchCreateOrConnectWithoutBranchInput = {
    where: DoctorBranchWhereUniqueInput
    create: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput>
  }

  export type DoctorBranchCreateManyBranchInputEnvelope = {
    data: DoctorBranchCreateManyBranchInput | DoctorBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutBranchInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutBranchInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput>
  }

  export type AppointmentCreateManyBranchInputEnvelope = {
    data: AppointmentCreateManyBranchInput | AppointmentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutBookingsInput
    patient: PatientCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutBranchInput = {
    id?: number
    doctorId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutBranchInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput>
  }

  export type BookingCreateManyBranchInputEnvelope = {
    data: BookingCreateManyBranchInput | BookingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionScheduleCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    reception: UserCreateNestedOneWithoutReceptionSchedulesInput
  }

  export type ReceptionScheduleUncheckedCreateWithoutBranchInput = {
    id?: number
    receptionId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleCreateOrConnectWithoutBranchInput = {
    where: ReceptionScheduleWhereUniqueInput
    create: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionScheduleCreateManyBranchInputEnvelope = {
    data: ReceptionScheduleCreateManyBranchInput | ReceptionScheduleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionBranchCreateWithoutBranchInput = {
    reception: UserCreateNestedOneWithoutReceptionBranchesInput
  }

  export type ReceptionBranchUncheckedCreateWithoutBranchInput = {
    id?: number
    receptionId: number
  }

  export type ReceptionBranchCreateOrConnectWithoutBranchInput = {
    where: ReceptionBranchWhereUniqueInput
    create: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionBranchCreateManyBranchInputEnvelope = {
    data: ReceptionBranchCreateManyBranchInput | ReceptionBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type NurseScheduleCreateWithoutBranchInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    nurse: UserCreateNestedOneWithoutNurseSchedulesInput
  }

  export type NurseScheduleUncheckedCreateWithoutBranchInput = {
    id?: number
    nurseId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleCreateOrConnectWithoutBranchInput = {
    where: NurseScheduleWhereUniqueInput
    create: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput>
  }

  export type NurseScheduleCreateManyBranchInputEnvelope = {
    data: NurseScheduleCreateManyBranchInput | NurseScheduleCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type NurseBranchCreateWithoutBranchInput = {
    nurse: UserCreateNestedOneWithoutNurseBranchesInput
  }

  export type NurseBranchUncheckedCreateWithoutBranchInput = {
    id?: number
    nurseId: number
  }

  export type NurseBranchCreateOrConnectWithoutBranchInput = {
    where: NurseBranchWhereUniqueInput
    create: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput>
  }

  export type NurseBranchCreateManyBranchInputEnvelope = {
    data: NurseBranchCreateManyBranchInput | NurseBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutBranchInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    stockMovements?: ProductStockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBranchInput = {
    id?: number
    categoryId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBranchInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput>
  }

  export type ProductCreateManyBranchInputEnvelope = {
    data: ProductCreateManyBranchInput | ProductCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutBranchInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutBranchInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutBranchInput, ProductCategoryUncheckedCreateWithoutBranchInput>
  }

  export type ProductCategoryCreateManyBranchInputEnvelope = {
    data: ProductCategoryCreateManyBranchInput | ProductCategoryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockMovementCreateWithoutBranchInput = {
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutStockMovementsInput
  }

  export type ProductStockMovementUncheckedCreateWithoutBranchInput = {
    id?: number
    productId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type ProductStockMovementCreateOrConnectWithoutBranchInput = {
    where: ProductStockMovementWhereUniqueInput
    create: XOR<ProductStockMovementCreateWithoutBranchInput, ProductStockMovementUncheckedCreateWithoutBranchInput>
  }

  export type ProductStockMovementCreateManyBranchInputEnvelope = {
    data: ProductStockMovementCreateManyBranchInput | ProductStockMovementCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutBranchInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutBranchInput = {
    id?: number
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput>
  }

  export type InvoiceCreateManyBranchInputEnvelope = {
    data: InvoiceCreateManyBranchInput | InvoiceCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutBranchInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutBranchInput = {
    id?: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutBranchInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput>
  }

  export type LedgerEntryCreateManyBranchInputEnvelope = {
    data: LedgerEntryCreateManyBranchInput | LedgerEntryCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeVoucherCreateWithoutBranchInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutBranchInput = {
    id?: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherCreateOrConnectWithoutBranchInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeVoucherCreateManyBranchInputEnvelope = {
    data: EmployeeVoucherCreateManyBranchInput | EmployeeVoucherCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SterilizationIndicatorCreateWithoutBranchInput = {
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    specialist: UserCreateNestedOneWithoutSterilizationIndicatorsInput
    items?: SterilizationIndicatorItemCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUncheckedCreateWithoutBranchInput = {
    id?: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorCreateOrConnectWithoutBranchInput = {
    where: SterilizationIndicatorWhereUniqueInput
    create: XOR<SterilizationIndicatorCreateWithoutBranchInput, SterilizationIndicatorUncheckedCreateWithoutBranchInput>
  }

  export type SterilizationIndicatorCreateManyBranchInputEnvelope = {
    data: SterilizationIndicatorCreateManyBranchInput | SterilizationIndicatorCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    ovog?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    branchId?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    phone?: StringNullableFilter<"User"> | string | null
    regNo?: StringNullableFilter<"User"> | string | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    licenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    signatureImagePath?: StringNullableFilter<"User"> | string | null
    stampImagePath?: StringNullableFilter<"User"> | string | null
    idPhotoPath?: StringNullableFilter<"User"> | string | null
    calendarOrder?: IntNullableFilter<"User"> | number | null
  }

  export type PatientUpsertWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
  }

  export type PatientUpdateManyWithWhereWithoutBranchInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutBranchInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: IntFilter<"Patient"> | number
    regNo?: StringNullableFilter<"Patient"> | string | null
    ovog?: StringNullableFilter<"Patient"> | string | null
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    bloodType?: StringNullableFilter<"Patient"> | string | null
    citizenship?: StringNullableFilter<"Patient"> | string | null
    emergencyPhone?: StringNullableFilter<"Patient"> | string | null
    notes?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branchId?: IntFilter<"Patient"> | number
  }

  export type DoctorScheduleUpsertWithWhereUniqueWithoutBranchInput = {
    where: DoctorScheduleWhereUniqueInput
    update: XOR<DoctorScheduleUpdateWithoutBranchInput, DoctorScheduleUncheckedUpdateWithoutBranchInput>
    create: XOR<DoctorScheduleCreateWithoutBranchInput, DoctorScheduleUncheckedCreateWithoutBranchInput>
  }

  export type DoctorScheduleUpdateWithWhereUniqueWithoutBranchInput = {
    where: DoctorScheduleWhereUniqueInput
    data: XOR<DoctorScheduleUpdateWithoutBranchInput, DoctorScheduleUncheckedUpdateWithoutBranchInput>
  }

  export type DoctorScheduleUpdateManyWithWhereWithoutBranchInput = {
    where: DoctorScheduleScalarWhereInput
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyWithoutBranchInput>
  }

  export type DoctorScheduleScalarWhereInput = {
    AND?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
    OR?: DoctorScheduleScalarWhereInput[]
    NOT?: DoctorScheduleScalarWhereInput | DoctorScheduleScalarWhereInput[]
    id?: IntFilter<"DoctorSchedule"> | number
    doctorId?: IntFilter<"DoctorSchedule"> | number
    branchId?: IntFilter<"DoctorSchedule"> | number
    date?: DateTimeFilter<"DoctorSchedule"> | Date | string
    startTime?: StringFilter<"DoctorSchedule"> | string
    endTime?: StringFilter<"DoctorSchedule"> | string
    note?: StringNullableFilter<"DoctorSchedule"> | string | null
  }

  export type ServiceBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    update: XOR<ServiceBranchUpdateWithoutBranchInput, ServiceBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<ServiceBranchCreateWithoutBranchInput, ServiceBranchUncheckedCreateWithoutBranchInput>
  }

  export type ServiceBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: ServiceBranchWhereUniqueInput
    data: XOR<ServiceBranchUpdateWithoutBranchInput, ServiceBranchUncheckedUpdateWithoutBranchInput>
  }

  export type ServiceBranchUpdateManyWithWhereWithoutBranchInput = {
    where: ServiceBranchScalarWhereInput
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type ServiceBranchScalarWhereInput = {
    AND?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
    OR?: ServiceBranchScalarWhereInput[]
    NOT?: ServiceBranchScalarWhereInput | ServiceBranchScalarWhereInput[]
    serviceId?: IntFilter<"ServiceBranch"> | number
    branchId?: IntFilter<"ServiceBranch"> | number
  }

  export type DoctorBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: DoctorBranchWhereUniqueInput
    update: XOR<DoctorBranchUpdateWithoutBranchInput, DoctorBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<DoctorBranchCreateWithoutBranchInput, DoctorBranchUncheckedCreateWithoutBranchInput>
  }

  export type DoctorBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: DoctorBranchWhereUniqueInput
    data: XOR<DoctorBranchUpdateWithoutBranchInput, DoctorBranchUncheckedUpdateWithoutBranchInput>
  }

  export type DoctorBranchUpdateManyWithWhereWithoutBranchInput = {
    where: DoctorBranchScalarWhereInput
    data: XOR<DoctorBranchUpdateManyMutationInput, DoctorBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type DoctorBranchScalarWhereInput = {
    AND?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
    OR?: DoctorBranchScalarWhereInput[]
    NOT?: DoctorBranchScalarWhereInput | DoctorBranchScalarWhereInput[]
    id?: IntFilter<"DoctorBranch"> | number
    doctorId?: IntFilter<"DoctorBranch"> | number
    branchId?: IntFilter<"DoctorBranch"> | number
  }

  export type AppointmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutBranchInput, AppointmentUncheckedUpdateWithoutBranchInput>
    create: XOR<AppointmentCreateWithoutBranchInput, AppointmentUncheckedCreateWithoutBranchInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutBranchInput, AppointmentUncheckedUpdateWithoutBranchInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutBranchInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    patientId?: IntFilter<"Appointment"> | number
    doctorId?: IntNullableFilter<"Appointment"> | number | null
    branchId?: IntFilter<"Appointment"> | number
    scheduledAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeNullableFilter<"Appointment"> | Date | string | null
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutBranchInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBranchInput, BookingUncheckedUpdateWithoutBranchInput>
    create: XOR<BookingCreateWithoutBranchInput, BookingUncheckedCreateWithoutBranchInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBranchInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBranchInput, BookingUncheckedUpdateWithoutBranchInput>
  }

  export type BookingUpdateManyWithWhereWithoutBranchInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBranchInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    doctorId?: IntFilter<"Booking"> | number
    branchId?: IntFilter<"Booking"> | number
    patientId?: IntFilter<"Booking"> | number
    date?: DateTimeFilter<"Booking"> | Date | string
    startTime?: StringFilter<"Booking"> | string
    endTime?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    note?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ReceptionScheduleUpsertWithWhereUniqueWithoutBranchInput = {
    where: ReceptionScheduleWhereUniqueInput
    update: XOR<ReceptionScheduleUpdateWithoutBranchInput, ReceptionScheduleUncheckedUpdateWithoutBranchInput>
    create: XOR<ReceptionScheduleCreateWithoutBranchInput, ReceptionScheduleUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionScheduleUpdateWithWhereUniqueWithoutBranchInput = {
    where: ReceptionScheduleWhereUniqueInput
    data: XOR<ReceptionScheduleUpdateWithoutBranchInput, ReceptionScheduleUncheckedUpdateWithoutBranchInput>
  }

  export type ReceptionScheduleUpdateManyWithWhereWithoutBranchInput = {
    where: ReceptionScheduleScalarWhereInput
    data: XOR<ReceptionScheduleUpdateManyMutationInput, ReceptionScheduleUncheckedUpdateManyWithoutBranchInput>
  }

  export type ReceptionScheduleScalarWhereInput = {
    AND?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
    OR?: ReceptionScheduleScalarWhereInput[]
    NOT?: ReceptionScheduleScalarWhereInput | ReceptionScheduleScalarWhereInput[]
    id?: IntFilter<"ReceptionSchedule"> | number
    receptionId?: IntFilter<"ReceptionSchedule"> | number
    branchId?: IntFilter<"ReceptionSchedule"> | number
    date?: DateTimeFilter<"ReceptionSchedule"> | Date | string
    startTime?: StringFilter<"ReceptionSchedule"> | string
    endTime?: StringFilter<"ReceptionSchedule"> | string
    note?: StringNullableFilter<"ReceptionSchedule"> | string | null
  }

  export type ReceptionBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: ReceptionBranchWhereUniqueInput
    update: XOR<ReceptionBranchUpdateWithoutBranchInput, ReceptionBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<ReceptionBranchCreateWithoutBranchInput, ReceptionBranchUncheckedCreateWithoutBranchInput>
  }

  export type ReceptionBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: ReceptionBranchWhereUniqueInput
    data: XOR<ReceptionBranchUpdateWithoutBranchInput, ReceptionBranchUncheckedUpdateWithoutBranchInput>
  }

  export type ReceptionBranchUpdateManyWithWhereWithoutBranchInput = {
    where: ReceptionBranchScalarWhereInput
    data: XOR<ReceptionBranchUpdateManyMutationInput, ReceptionBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type ReceptionBranchScalarWhereInput = {
    AND?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
    OR?: ReceptionBranchScalarWhereInput[]
    NOT?: ReceptionBranchScalarWhereInput | ReceptionBranchScalarWhereInput[]
    id?: IntFilter<"ReceptionBranch"> | number
    receptionId?: IntFilter<"ReceptionBranch"> | number
    branchId?: IntFilter<"ReceptionBranch"> | number
  }

  export type NurseScheduleUpsertWithWhereUniqueWithoutBranchInput = {
    where: NurseScheduleWhereUniqueInput
    update: XOR<NurseScheduleUpdateWithoutBranchInput, NurseScheduleUncheckedUpdateWithoutBranchInput>
    create: XOR<NurseScheduleCreateWithoutBranchInput, NurseScheduleUncheckedCreateWithoutBranchInput>
  }

  export type NurseScheduleUpdateWithWhereUniqueWithoutBranchInput = {
    where: NurseScheduleWhereUniqueInput
    data: XOR<NurseScheduleUpdateWithoutBranchInput, NurseScheduleUncheckedUpdateWithoutBranchInput>
  }

  export type NurseScheduleUpdateManyWithWhereWithoutBranchInput = {
    where: NurseScheduleScalarWhereInput
    data: XOR<NurseScheduleUpdateManyMutationInput, NurseScheduleUncheckedUpdateManyWithoutBranchInput>
  }

  export type NurseScheduleScalarWhereInput = {
    AND?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
    OR?: NurseScheduleScalarWhereInput[]
    NOT?: NurseScheduleScalarWhereInput | NurseScheduleScalarWhereInput[]
    id?: IntFilter<"NurseSchedule"> | number
    nurseId?: IntFilter<"NurseSchedule"> | number
    branchId?: IntFilter<"NurseSchedule"> | number
    date?: DateTimeFilter<"NurseSchedule"> | Date | string
    startTime?: StringFilter<"NurseSchedule"> | string
    endTime?: StringFilter<"NurseSchedule"> | string
    note?: StringNullableFilter<"NurseSchedule"> | string | null
  }

  export type NurseBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: NurseBranchWhereUniqueInput
    update: XOR<NurseBranchUpdateWithoutBranchInput, NurseBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<NurseBranchCreateWithoutBranchInput, NurseBranchUncheckedCreateWithoutBranchInput>
  }

  export type NurseBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: NurseBranchWhereUniqueInput
    data: XOR<NurseBranchUpdateWithoutBranchInput, NurseBranchUncheckedUpdateWithoutBranchInput>
  }

  export type NurseBranchUpdateManyWithWhereWithoutBranchInput = {
    where: NurseBranchScalarWhereInput
    data: XOR<NurseBranchUpdateManyMutationInput, NurseBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type NurseBranchScalarWhereInput = {
    AND?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
    OR?: NurseBranchScalarWhereInput[]
    NOT?: NurseBranchScalarWhereInput | NurseBranchScalarWhereInput[]
    id?: IntFilter<"NurseBranch"> | number
    nurseId?: IntFilter<"NurseBranch"> | number
    branchId?: IntFilter<"NurseBranch"> | number
  }

  export type ProductUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBranchInput, ProductUncheckedUpdateWithoutBranchInput>
    create: XOR<ProductCreateWithoutBranchInput, ProductUncheckedCreateWithoutBranchInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBranchInput, ProductUncheckedUpdateWithoutBranchInput>
  }

  export type ProductUpdateManyWithWhereWithoutBranchInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBranchInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    branchId?: IntFilter<"Product"> | number
    categoryId?: IntFilter<"Product"> | number
    code?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    price?: FloatFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    description?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutBranchInput, ProductCategoryUncheckedUpdateWithoutBranchInput>
    create: XOR<ProductCategoryCreateWithoutBranchInput, ProductCategoryUncheckedCreateWithoutBranchInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutBranchInput, ProductCategoryUncheckedUpdateWithoutBranchInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutBranchInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutBranchInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    branchId?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type ProductStockMovementUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProductStockMovementWhereUniqueInput
    update: XOR<ProductStockMovementUpdateWithoutBranchInput, ProductStockMovementUncheckedUpdateWithoutBranchInput>
    create: XOR<ProductStockMovementCreateWithoutBranchInput, ProductStockMovementUncheckedCreateWithoutBranchInput>
  }

  export type ProductStockMovementUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProductStockMovementWhereUniqueInput
    data: XOR<ProductStockMovementUpdateWithoutBranchInput, ProductStockMovementUncheckedUpdateWithoutBranchInput>
  }

  export type ProductStockMovementUpdateManyWithWhereWithoutBranchInput = {
    where: ProductStockMovementScalarWhereInput
    data: XOR<ProductStockMovementUpdateManyMutationInput, ProductStockMovementUncheckedUpdateManyWithoutBranchInput>
  }

  export type ProductStockMovementScalarWhereInput = {
    AND?: ProductStockMovementScalarWhereInput | ProductStockMovementScalarWhereInput[]
    OR?: ProductStockMovementScalarWhereInput[]
    NOT?: ProductStockMovementScalarWhereInput | ProductStockMovementScalarWhereInput[]
    id?: IntFilter<"ProductStockMovement"> | number
    branchId?: IntFilter<"ProductStockMovement"> | number
    productId?: IntFilter<"ProductStockMovement"> | number
    type?: EnumProductStockMovementTypeFilter<"ProductStockMovement"> | $Enums.ProductStockMovementType
    quantityDelta?: IntFilter<"ProductStockMovement"> | number
    invoiceId?: IntNullableFilter<"ProductStockMovement"> | number | null
    ledgerEntryId?: IntNullableFilter<"ProductStockMovement"> | number | null
    note?: StringNullableFilter<"ProductStockMovement"> | string | null
    createdAt?: DateTimeFilter<"ProductStockMovement"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutBranchInput, InvoiceUncheckedUpdateWithoutBranchInput>
    create: XOR<InvoiceCreateWithoutBranchInput, InvoiceUncheckedCreateWithoutBranchInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutBranchInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutBranchInput, InvoiceUncheckedUpdateWithoutBranchInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutBranchInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutBranchInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    branchId?: IntNullableFilter<"Invoice"> | number | null
    encounterId?: IntFilter<"Invoice"> | number
    patientId?: IntNullableFilter<"Invoice"> | number | null
    totalAmount?: FloatNullableFilter<"Invoice"> | number | null
    totalBeforeDiscount?: FloatNullableFilter<"Invoice"> | number | null
    discountPercent?: EnumDiscountPercentFilter<"Invoice"> | $Enums.DiscountPercent
    finalAmount?: FloatNullableFilter<"Invoice"> | number | null
    statusLegacy?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutBranchInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutBranchInput, LedgerEntryUncheckedUpdateWithoutBranchInput>
    create: XOR<LedgerEntryCreateWithoutBranchInput, LedgerEntryUncheckedCreateWithoutBranchInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutBranchInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutBranchInput, LedgerEntryUncheckedUpdateWithoutBranchInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutBranchInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutBranchInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: IntFilter<"LedgerEntry"> | number
    branchId?: IntFilter<"LedgerEntry"> | number
    patientId?: IntFilter<"LedgerEntry"> | number
    invoiceId?: IntNullableFilter<"LedgerEntry"> | number | null
    type?: EnumLedgerEntryTypeFilter<"LedgerEntry"> | $Enums.LedgerEntryType
    amount?: FloatFilter<"LedgerEntry"> | number
    createdById?: IntFilter<"LedgerEntry"> | number
    approvedById?: IntNullableFilter<"LedgerEntry"> | number | null
    approvalCodeId?: IntNullableFilter<"LedgerEntry"> | number | null
    employeeVoucherId?: IntNullableFilter<"LedgerEntry"> | number | null
    meta?: JsonNullableFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
  }

  export type EmployeeVoucherUpsertWithWhereUniqueWithoutBranchInput = {
    where: EmployeeVoucherWhereUniqueInput
    update: XOR<EmployeeVoucherUpdateWithoutBranchInput, EmployeeVoucherUncheckedUpdateWithoutBranchInput>
    create: XOR<EmployeeVoucherCreateWithoutBranchInput, EmployeeVoucherUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeVoucherUpdateWithWhereUniqueWithoutBranchInput = {
    where: EmployeeVoucherWhereUniqueInput
    data: XOR<EmployeeVoucherUpdateWithoutBranchInput, EmployeeVoucherUncheckedUpdateWithoutBranchInput>
  }

  export type EmployeeVoucherUpdateManyWithWhereWithoutBranchInput = {
    where: EmployeeVoucherScalarWhereInput
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyWithoutBranchInput>
  }

  export type EmployeeVoucherScalarWhereInput = {
    AND?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
    OR?: EmployeeVoucherScalarWhereInput[]
    NOT?: EmployeeVoucherScalarWhereInput | EmployeeVoucherScalarWhereInput[]
    id?: IntFilter<"EmployeeVoucher"> | number
    branchId?: IntFilter<"EmployeeVoucher"> | number
    employeeId?: IntFilter<"EmployeeVoucher"> | number
    code?: StringFilter<"EmployeeVoucher"> | string
    status?: EnumEmployeeVoucherStatusFilter<"EmployeeVoucher"> | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFilter<"EmployeeVoucher"> | number
    usedAmount?: FloatFilter<"EmployeeVoucher"> | number
    eligibility?: JsonFilter<"EmployeeVoucher">
    allowedPatientIds?: JsonFilter<"EmployeeVoucher">
    createdAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeVoucher"> | Date | string
    createdById?: IntFilter<"EmployeeVoucher"> | number
  }

  export type SterilizationIndicatorUpsertWithWhereUniqueWithoutBranchInput = {
    where: SterilizationIndicatorWhereUniqueInput
    update: XOR<SterilizationIndicatorUpdateWithoutBranchInput, SterilizationIndicatorUncheckedUpdateWithoutBranchInput>
    create: XOR<SterilizationIndicatorCreateWithoutBranchInput, SterilizationIndicatorUncheckedCreateWithoutBranchInput>
  }

  export type SterilizationIndicatorUpdateWithWhereUniqueWithoutBranchInput = {
    where: SterilizationIndicatorWhereUniqueInput
    data: XOR<SterilizationIndicatorUpdateWithoutBranchInput, SterilizationIndicatorUncheckedUpdateWithoutBranchInput>
  }

  export type SterilizationIndicatorUpdateManyWithWhereWithoutBranchInput = {
    where: SterilizationIndicatorScalarWhereInput
    data: XOR<SterilizationIndicatorUpdateManyMutationInput, SterilizationIndicatorUncheckedUpdateManyWithoutBranchInput>
  }

  export type SterilizationIndicatorScalarWhereInput = {
    AND?: SterilizationIndicatorScalarWhereInput | SterilizationIndicatorScalarWhereInput[]
    OR?: SterilizationIndicatorScalarWhereInput[]
    NOT?: SterilizationIndicatorScalarWhereInput | SterilizationIndicatorScalarWhereInput[]
    id?: IntFilter<"SterilizationIndicator"> | number
    branchId?: IntFilter<"SterilizationIndicator"> | number
    packageName?: StringFilter<"SterilizationIndicator"> | string
    code?: StringFilter<"SterilizationIndicator"> | string
    indicatorDate?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    specialistUserId?: IntFilter<"SterilizationIndicator"> | number
    packageQuantity?: IntFilter<"SterilizationIndicator"> | number
    createdAt?: DateTimeFilter<"SterilizationIndicator"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationIndicator"> | Date | string
  }

  export type UserCreateWithoutEmployeeBenefitsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutEmployeeBenefitsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutEmployeeBenefitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
  }

  export type EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput = {
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput
    encounter: EncounterCreateNestedOneWithoutEmployeeBenefitUsagesInput
    patient: PatientCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput = {
    id?: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateOrConnectWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    create: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageCreateManyEmployeeBenefitInputEnvelope = {
    data: EmployeeBenefitUsageCreateManyEmployeeBenefitInput | EmployeeBenefitUsageCreateManyEmployeeBenefitInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeBenefitsInput = {
    update: XOR<UserUpdateWithoutEmployeeBenefitsInput, UserUncheckedUpdateWithoutEmployeeBenefitsInput>
    create: XOR<UserCreateWithoutEmployeeBenefitsInput, UserUncheckedCreateWithoutEmployeeBenefitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeBenefitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeBenefitsInput, UserUncheckedUpdateWithoutEmployeeBenefitsInput>
  }

  export type UserUpdateWithoutEmployeeBenefitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeBenefitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    update: XOR<EmployeeBenefitUsageUpdateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedUpdateWithoutEmployeeBenefitInput>
    create: XOR<EmployeeBenefitUsageCreateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedCreateWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    data: XOR<EmployeeBenefitUsageUpdateWithoutEmployeeBenefitInput, EmployeeBenefitUsageUncheckedUpdateWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithWhereWithoutEmployeeBenefitInput = {
    where: EmployeeBenefitUsageScalarWhereInput
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitInput>
  }

  export type EmployeeBenefitUsageScalarWhereInput = {
    AND?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
    OR?: EmployeeBenefitUsageScalarWhereInput[]
    NOT?: EmployeeBenefitUsageScalarWhereInput | EmployeeBenefitUsageScalarWhereInput[]
    id?: IntFilter<"EmployeeBenefitUsage"> | number
    employeeBenefitId?: IntFilter<"EmployeeBenefitUsage"> | number
    invoiceId?: IntFilter<"EmployeeBenefitUsage"> | number
    encounterId?: IntFilter<"EmployeeBenefitUsage"> | number
    amountUsed?: IntFilter<"EmployeeBenefitUsage"> | number
    patientId?: IntFilter<"EmployeeBenefitUsage"> | number
    patientBookNumber?: StringNullableFilter<"EmployeeBenefitUsage"> | string | null
    createdAt?: DateTimeFilter<"EmployeeBenefitUsage"> | Date | string
  }

  export type EmployeeBenefitCreateWithoutUsagesInput = {
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeBenefitsInput
  }

  export type EmployeeBenefitUncheckedCreateWithoutUsagesInput = {
    id?: number
    employeeId: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeBenefitCreateOrConnectWithoutUsagesInput = {
    where: EmployeeBenefitWhereUniqueInput
    create: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
  }

  export type InvoiceCreateWithoutEmployeeBenefitUsagesInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEmployeeBenefitUsagesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
  }

  export type EncounterCreateWithoutEmployeeBenefitUsagesInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutEmployeeBenefitUsagesInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutEmployeeBenefitUsagesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutEmployeeBenefitUsagesInput, EncounterUncheckedCreateWithoutEmployeeBenefitUsagesInput>
  }

  export type PatientCreateWithoutEmployeeBenefitUsagesInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEmployeeBenefitUsagesInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEmployeeBenefitUsagesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEmployeeBenefitUsagesInput, PatientUncheckedCreateWithoutEmployeeBenefitUsagesInput>
  }

  export type EmployeeBenefitUpsertWithoutUsagesInput = {
    update: XOR<EmployeeBenefitUpdateWithoutUsagesInput, EmployeeBenefitUncheckedUpdateWithoutUsagesInput>
    create: XOR<EmployeeBenefitCreateWithoutUsagesInput, EmployeeBenefitUncheckedCreateWithoutUsagesInput>
    where?: EmployeeBenefitWhereInput
  }

  export type EmployeeBenefitUpdateToOneWithWhereWithoutUsagesInput = {
    where?: EmployeeBenefitWhereInput
    data: XOR<EmployeeBenefitUpdateWithoutUsagesInput, EmployeeBenefitUncheckedUpdateWithoutUsagesInput>
  }

  export type EmployeeBenefitUpdateWithoutUsagesInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeBenefitsNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateWithoutUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutEmployeeBenefitUsagesInput = {
    update: XOR<InvoiceUpdateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
    create: XOR<InvoiceCreateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEmployeeBenefitUsagesInput, InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type InvoiceUpdateWithoutEmployeeBenefitUsagesInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEmployeeBenefitUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type EncounterUpsertWithoutEmployeeBenefitUsagesInput = {
    update: XOR<EncounterUpdateWithoutEmployeeBenefitUsagesInput, EncounterUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
    create: XOR<EncounterCreateWithoutEmployeeBenefitUsagesInput, EncounterUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutEmployeeBenefitUsagesInput, EncounterUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type EncounterUpdateWithoutEmployeeBenefitUsagesInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutEmployeeBenefitUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type PatientUpsertWithoutEmployeeBenefitUsagesInput = {
    update: XOR<PatientUpdateWithoutEmployeeBenefitUsagesInput, PatientUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
    create: XOR<PatientCreateWithoutEmployeeBenefitUsagesInput, PatientUncheckedCreateWithoutEmployeeBenefitUsagesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEmployeeBenefitUsagesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEmployeeBenefitUsagesInput, PatientUncheckedUpdateWithoutEmployeeBenefitUsagesInput>
  }

  export type PatientUpdateWithoutEmployeeBenefitUsagesInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEmployeeBenefitUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type SterilizationItemCreateWithoutCategoryInput = {
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicatorItems?: SterilizationIndicatorItemCreateNestedManyWithoutItemInput
  }

  export type SterilizationItemUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicatorItems?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type SterilizationItemCreateOrConnectWithoutCategoryInput = {
    where: SterilizationItemWhereUniqueInput
    create: XOR<SterilizationItemCreateWithoutCategoryInput, SterilizationItemUncheckedCreateWithoutCategoryInput>
  }

  export type SterilizationItemCreateManyCategoryInputEnvelope = {
    data: SterilizationItemCreateManyCategoryInput | SterilizationItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SterilizationItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SterilizationItemWhereUniqueInput
    update: XOR<SterilizationItemUpdateWithoutCategoryInput, SterilizationItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<SterilizationItemCreateWithoutCategoryInput, SterilizationItemUncheckedCreateWithoutCategoryInput>
  }

  export type SterilizationItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SterilizationItemWhereUniqueInput
    data: XOR<SterilizationItemUpdateWithoutCategoryInput, SterilizationItemUncheckedUpdateWithoutCategoryInput>
  }

  export type SterilizationItemUpdateManyWithWhereWithoutCategoryInput = {
    where: SterilizationItemScalarWhereInput
    data: XOR<SterilizationItemUpdateManyMutationInput, SterilizationItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SterilizationItemScalarWhereInput = {
    AND?: SterilizationItemScalarWhereInput | SterilizationItemScalarWhereInput[]
    OR?: SterilizationItemScalarWhereInput[]
    NOT?: SterilizationItemScalarWhereInput | SterilizationItemScalarWhereInput[]
    id?: IntFilter<"SterilizationItem"> | number
    categoryId?: IntFilter<"SterilizationItem"> | number
    name?: StringFilter<"SterilizationItem"> | string
    quantity?: IntFilter<"SterilizationItem"> | number
    createdAt?: DateTimeFilter<"SterilizationItem"> | Date | string
    updatedAt?: DateTimeFilter<"SterilizationItem"> | Date | string
  }

  export type SterilizationCategoryCreateWithoutItemsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationCategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationCategoryCreateOrConnectWithoutItemsInput = {
    where: SterilizationCategoryWhereUniqueInput
    create: XOR<SterilizationCategoryCreateWithoutItemsInput, SterilizationCategoryUncheckedCreateWithoutItemsInput>
  }

  export type SterilizationIndicatorItemCreateWithoutItemInput = {
    indicator: SterilizationIndicatorCreateNestedOneWithoutItemsInput
  }

  export type SterilizationIndicatorItemUncheckedCreateWithoutItemInput = {
    id?: number
    indicatorId: number
  }

  export type SterilizationIndicatorItemCreateOrConnectWithoutItemInput = {
    where: SterilizationIndicatorItemWhereUniqueInput
    create: XOR<SterilizationIndicatorItemCreateWithoutItemInput, SterilizationIndicatorItemUncheckedCreateWithoutItemInput>
  }

  export type SterilizationIndicatorItemCreateManyItemInputEnvelope = {
    data: SterilizationIndicatorItemCreateManyItemInput | SterilizationIndicatorItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SterilizationCategoryUpsertWithoutItemsInput = {
    update: XOR<SterilizationCategoryUpdateWithoutItemsInput, SterilizationCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<SterilizationCategoryCreateWithoutItemsInput, SterilizationCategoryUncheckedCreateWithoutItemsInput>
    where?: SterilizationCategoryWhereInput
  }

  export type SterilizationCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: SterilizationCategoryWhereInput
    data: XOR<SterilizationCategoryUpdateWithoutItemsInput, SterilizationCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type SterilizationCategoryUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationCategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorItemUpsertWithWhereUniqueWithoutItemInput = {
    where: SterilizationIndicatorItemWhereUniqueInput
    update: XOR<SterilizationIndicatorItemUpdateWithoutItemInput, SterilizationIndicatorItemUncheckedUpdateWithoutItemInput>
    create: XOR<SterilizationIndicatorItemCreateWithoutItemInput, SterilizationIndicatorItemUncheckedCreateWithoutItemInput>
  }

  export type SterilizationIndicatorItemUpdateWithWhereUniqueWithoutItemInput = {
    where: SterilizationIndicatorItemWhereUniqueInput
    data: XOR<SterilizationIndicatorItemUpdateWithoutItemInput, SterilizationIndicatorItemUncheckedUpdateWithoutItemInput>
  }

  export type SterilizationIndicatorItemUpdateManyWithWhereWithoutItemInput = {
    where: SterilizationIndicatorItemScalarWhereInput
    data: XOR<SterilizationIndicatorItemUpdateManyMutationInput, SterilizationIndicatorItemUncheckedUpdateManyWithoutItemInput>
  }

  export type SterilizationIndicatorItemScalarWhereInput = {
    AND?: SterilizationIndicatorItemScalarWhereInput | SterilizationIndicatorItemScalarWhereInput[]
    OR?: SterilizationIndicatorItemScalarWhereInput[]
    NOT?: SterilizationIndicatorItemScalarWhereInput | SterilizationIndicatorItemScalarWhereInput[]
    id?: IntFilter<"SterilizationIndicatorItem"> | number
    indicatorId?: IntFilter<"SterilizationIndicatorItem"> | number
    itemId?: IntFilter<"SterilizationIndicatorItem"> | number
  }

  export type BranchCreateWithoutSterilizationIndicatorsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSterilizationIndicatorsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSterilizationIndicatorsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSterilizationIndicatorsInput, BranchUncheckedCreateWithoutSterilizationIndicatorsInput>
  }

  export type UserCreateWithoutSterilizationIndicatorsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutSterilizationIndicatorsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutSterilizationIndicatorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSterilizationIndicatorsInput, UserUncheckedCreateWithoutSterilizationIndicatorsInput>
  }

  export type SterilizationIndicatorItemCreateWithoutIndicatorInput = {
    item: SterilizationItemCreateNestedOneWithoutIndicatorItemsInput
  }

  export type SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput = {
    id?: number
    itemId: number
  }

  export type SterilizationIndicatorItemCreateOrConnectWithoutIndicatorInput = {
    where: SterilizationIndicatorItemWhereUniqueInput
    create: XOR<SterilizationIndicatorItemCreateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput>
  }

  export type SterilizationIndicatorItemCreateManyIndicatorInputEnvelope = {
    data: SterilizationIndicatorItemCreateManyIndicatorInput | SterilizationIndicatorItemCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type EncounterSterilizationPackageUseCreateWithoutIndicatorInput = {
    usedQuantity?: number
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutSterilizationPackageUsesInput
    openedBy?: UserCreateNestedOneWithoutOpenedSterilizationPackagesInput
  }

  export type EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput = {
    id?: number
    encounterId: number
    usedQuantity?: number
    openedByUserId?: number | null
    createdAt?: Date | string
  }

  export type EncounterSterilizationPackageUseCreateOrConnectWithoutIndicatorInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    create: XOR<EncounterSterilizationPackageUseCreateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput>
  }

  export type EncounterSterilizationPackageUseCreateManyIndicatorInputEnvelope = {
    data: EncounterSterilizationPackageUseCreateManyIndicatorInput | EncounterSterilizationPackageUseCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput = {
    createdAt?: Date | string
    encounterDiagnosis: EncounterDiagnosisCreateNestedOneWithoutSterilizationIndicatorsInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput = {
    id?: number
    encounterDiagnosisId: number
    createdAt?: Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutIndicatorInput = {
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    create: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInputEnvelope = {
    data: EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInput | EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutSterilizationIndicatorsInput = {
    update: XOR<BranchUpdateWithoutSterilizationIndicatorsInput, BranchUncheckedUpdateWithoutSterilizationIndicatorsInput>
    create: XOR<BranchCreateWithoutSterilizationIndicatorsInput, BranchUncheckedCreateWithoutSterilizationIndicatorsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSterilizationIndicatorsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSterilizationIndicatorsInput, BranchUncheckedUpdateWithoutSterilizationIndicatorsInput>
  }

  export type BranchUpdateWithoutSterilizationIndicatorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSterilizationIndicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutSterilizationIndicatorsInput = {
    update: XOR<UserUpdateWithoutSterilizationIndicatorsInput, UserUncheckedUpdateWithoutSterilizationIndicatorsInput>
    create: XOR<UserCreateWithoutSterilizationIndicatorsInput, UserUncheckedCreateWithoutSterilizationIndicatorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSterilizationIndicatorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSterilizationIndicatorsInput, UserUncheckedUpdateWithoutSterilizationIndicatorsInput>
  }

  export type UserUpdateWithoutSterilizationIndicatorsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSterilizationIndicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type SterilizationIndicatorItemUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: SterilizationIndicatorItemWhereUniqueInput
    update: XOR<SterilizationIndicatorItemUpdateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedUpdateWithoutIndicatorInput>
    create: XOR<SterilizationIndicatorItemCreateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedCreateWithoutIndicatorInput>
  }

  export type SterilizationIndicatorItemUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: SterilizationIndicatorItemWhereUniqueInput
    data: XOR<SterilizationIndicatorItemUpdateWithoutIndicatorInput, SterilizationIndicatorItemUncheckedUpdateWithoutIndicatorInput>
  }

  export type SterilizationIndicatorItemUpdateManyWithWhereWithoutIndicatorInput = {
    where: SterilizationIndicatorItemScalarWhereInput
    data: XOR<SterilizationIndicatorItemUpdateManyMutationInput, SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    update: XOR<EncounterSterilizationPackageUseUpdateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedUpdateWithoutIndicatorInput>
    create: XOR<EncounterSterilizationPackageUseCreateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedCreateWithoutIndicatorInput>
  }

  export type EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    data: XOR<EncounterSterilizationPackageUseUpdateWithoutIndicatorInput, EncounterSterilizationPackageUseUncheckedUpdateWithoutIndicatorInput>
  }

  export type EncounterSterilizationPackageUseUpdateManyWithWhereWithoutIndicatorInput = {
    where: EncounterSterilizationPackageUseScalarWhereInput
    data: XOR<EncounterSterilizationPackageUseUpdateManyMutationInput, EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type EncounterSterilizationPackageUseScalarWhereInput = {
    AND?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
    OR?: EncounterSterilizationPackageUseScalarWhereInput[]
    NOT?: EncounterSterilizationPackageUseScalarWhereInput | EncounterSterilizationPackageUseScalarWhereInput[]
    id?: IntFilter<"EncounterSterilizationPackageUse"> | number
    encounterId?: IntFilter<"EncounterSterilizationPackageUse"> | number
    indicatorId?: IntFilter<"EncounterSterilizationPackageUse"> | number
    usedQuantity?: IntFilter<"EncounterSterilizationPackageUse"> | number
    openedByUserId?: IntNullableFilter<"EncounterSterilizationPackageUse"> | number | null
    createdAt?: DateTimeFilter<"EncounterSterilizationPackageUse"> | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutIndicatorInput = {
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    update: XOR<EncounterDiagnosisSterilizationIndicatorUpdateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateWithoutIndicatorInput>
    create: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutIndicatorInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutIndicatorInput = {
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    data: XOR<EncounterDiagnosisSterilizationIndicatorUpdateWithoutIndicatorInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateWithoutIndicatorInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutIndicatorInput = {
    where: EncounterDiagnosisSterilizationIndicatorScalarWhereInput
    data: XOR<EncounterDiagnosisSterilizationIndicatorUpdateManyMutationInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorScalarWhereInput = {
    AND?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput | EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
    OR?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
    NOT?: EncounterDiagnosisSterilizationIndicatorScalarWhereInput | EncounterDiagnosisSterilizationIndicatorScalarWhereInput[]
    id?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    encounterDiagnosisId?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    indicatorId?: IntFilter<"EncounterDiagnosisSterilizationIndicator"> | number
    createdAt?: DateTimeFilter<"EncounterDiagnosisSterilizationIndicator"> | Date | string
  }

  export type SterilizationIndicatorCreateWithoutItemsInput = {
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSterilizationIndicatorsInput
    specialist: UserCreateNestedOneWithoutSterilizationIndicatorsInput
    uses?: EncounterSterilizationPackageUseCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUncheckedCreateWithoutItemsInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    uses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorCreateOrConnectWithoutItemsInput = {
    where: SterilizationIndicatorWhereUniqueInput
    create: XOR<SterilizationIndicatorCreateWithoutItemsInput, SterilizationIndicatorUncheckedCreateWithoutItemsInput>
  }

  export type SterilizationItemCreateWithoutIndicatorItemsInput = {
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: SterilizationCategoryCreateNestedOneWithoutItemsInput
  }

  export type SterilizationItemUncheckedCreateWithoutIndicatorItemsInput = {
    id?: number
    categoryId: number
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationItemCreateOrConnectWithoutIndicatorItemsInput = {
    where: SterilizationItemWhereUniqueInput
    create: XOR<SterilizationItemCreateWithoutIndicatorItemsInput, SterilizationItemUncheckedCreateWithoutIndicatorItemsInput>
  }

  export type SterilizationIndicatorUpsertWithoutItemsInput = {
    update: XOR<SterilizationIndicatorUpdateWithoutItemsInput, SterilizationIndicatorUncheckedUpdateWithoutItemsInput>
    create: XOR<SterilizationIndicatorCreateWithoutItemsInput, SterilizationIndicatorUncheckedCreateWithoutItemsInput>
    where?: SterilizationIndicatorWhereInput
  }

  export type SterilizationIndicatorUpdateToOneWithWhereWithoutItemsInput = {
    where?: SterilizationIndicatorWhereInput
    data: XOR<SterilizationIndicatorUpdateWithoutItemsInput, SterilizationIndicatorUncheckedUpdateWithoutItemsInput>
  }

  export type SterilizationIndicatorUpdateWithoutItemsInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    specialist?: UserUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    uses?: EncounterSterilizationPackageUseUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationItemUpsertWithoutIndicatorItemsInput = {
    update: XOR<SterilizationItemUpdateWithoutIndicatorItemsInput, SterilizationItemUncheckedUpdateWithoutIndicatorItemsInput>
    create: XOR<SterilizationItemCreateWithoutIndicatorItemsInput, SterilizationItemUncheckedCreateWithoutIndicatorItemsInput>
    where?: SterilizationItemWhereInput
  }

  export type SterilizationItemUpdateToOneWithWhereWithoutIndicatorItemsInput = {
    where?: SterilizationItemWhereInput
    data: XOR<SterilizationItemUpdateWithoutIndicatorItemsInput, SterilizationItemUncheckedUpdateWithoutIndicatorItemsInput>
  }

  export type SterilizationItemUpdateWithoutIndicatorItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: SterilizationCategoryUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SterilizationItemUncheckedUpdateWithoutIndicatorItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateWithoutSterilizationPackageUsesInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutSterilizationPackageUsesInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutSterilizationPackageUsesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutSterilizationPackageUsesInput, EncounterUncheckedCreateWithoutSterilizationPackageUsesInput>
  }

  export type SterilizationIndicatorCreateWithoutUsesInput = {
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSterilizationIndicatorsInput
    specialist: UserCreateNestedOneWithoutSterilizationIndicatorsInput
    items?: SterilizationIndicatorItemCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUncheckedCreateWithoutUsesInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorCreateOrConnectWithoutUsesInput = {
    where: SterilizationIndicatorWhereUniqueInput
    create: XOR<SterilizationIndicatorCreateWithoutUsesInput, SterilizationIndicatorUncheckedCreateWithoutUsesInput>
  }

  export type UserCreateWithoutOpenedSterilizationPackagesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
  }

  export type UserUncheckedCreateWithoutOpenedSterilizationPackagesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
  }

  export type UserCreateOrConnectWithoutOpenedSterilizationPackagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpenedSterilizationPackagesInput, UserUncheckedCreateWithoutOpenedSterilizationPackagesInput>
  }

  export type EncounterUpsertWithoutSterilizationPackageUsesInput = {
    update: XOR<EncounterUpdateWithoutSterilizationPackageUsesInput, EncounterUncheckedUpdateWithoutSterilizationPackageUsesInput>
    create: XOR<EncounterCreateWithoutSterilizationPackageUsesInput, EncounterUncheckedCreateWithoutSterilizationPackageUsesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutSterilizationPackageUsesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutSterilizationPackageUsesInput, EncounterUncheckedUpdateWithoutSterilizationPackageUsesInput>
  }

  export type EncounterUpdateWithoutSterilizationPackageUsesInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutSterilizationPackageUsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type SterilizationIndicatorUpsertWithoutUsesInput = {
    update: XOR<SterilizationIndicatorUpdateWithoutUsesInput, SterilizationIndicatorUncheckedUpdateWithoutUsesInput>
    create: XOR<SterilizationIndicatorCreateWithoutUsesInput, SterilizationIndicatorUncheckedCreateWithoutUsesInput>
    where?: SterilizationIndicatorWhereInput
  }

  export type SterilizationIndicatorUpdateToOneWithWhereWithoutUsesInput = {
    where?: SterilizationIndicatorWhereInput
    data: XOR<SterilizationIndicatorUpdateWithoutUsesInput, SterilizationIndicatorUncheckedUpdateWithoutUsesInput>
  }

  export type SterilizationIndicatorUpdateWithoutUsesInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    specialist?: UserUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    items?: SterilizationIndicatorItemUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateWithoutUsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type UserUpsertWithoutOpenedSterilizationPackagesInput = {
    update: XOR<UserUpdateWithoutOpenedSterilizationPackagesInput, UserUncheckedUpdateWithoutOpenedSterilizationPackagesInput>
    create: XOR<UserCreateWithoutOpenedSterilizationPackagesInput, UserUncheckedCreateWithoutOpenedSterilizationPackagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpenedSterilizationPackagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpenedSterilizationPackagesInput, UserUncheckedUpdateWithoutOpenedSterilizationPackagesInput>
  }

  export type UserUpdateWithoutOpenedSterilizationPackagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
  }

  export type UserUncheckedUpdateWithoutOpenedSterilizationPackagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
  }

  export type BranchCreateWithoutUsersInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type EncounterCreateWithoutDoctorInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientBookId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutDoctorInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput>
  }

  export type EncounterCreateManyDoctorInputEnvelope = {
    data: EncounterCreateManyDoctorInput | EncounterCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutNurseInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutNurseInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutNurseInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput>
  }

  export type EncounterCreateManyNurseInputEnvelope = {
    data: EncounterCreateManyNurseInput | EncounterCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type DoctorScheduleCreateWithoutDoctorInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    branch: BranchCreateNestedOneWithoutDoctorSchedulesInput
  }

  export type DoctorScheduleUncheckedCreateWithoutDoctorInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorScheduleCreateOrConnectWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    create: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorScheduleCreateManyDoctorInputEnvelope = {
    data: DoctorScheduleCreateManyDoctorInput | DoctorScheduleCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DoctorBranchCreateWithoutDoctorInput = {
    branch: BranchCreateNestedOneWithoutDoctorBranchesInput
  }

  export type DoctorBranchUncheckedCreateWithoutDoctorInput = {
    id?: number
    branchId: number
  }

  export type DoctorBranchCreateOrConnectWithoutDoctorInput = {
    where: DoctorBranchWhereUniqueInput
    create: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorBranchCreateManyDoctorInputEnvelope = {
    data: DoctorBranchCreateManyDoctorInput | DoctorBranchCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionScheduleCreateWithoutReceptionInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    branch: BranchCreateNestedOneWithoutReceptionSchedulesInput
  }

  export type ReceptionScheduleUncheckedCreateWithoutReceptionInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionScheduleCreateOrConnectWithoutReceptionInput = {
    where: ReceptionScheduleWhereUniqueInput
    create: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionScheduleCreateManyReceptionInputEnvelope = {
    data: ReceptionScheduleCreateManyReceptionInput | ReceptionScheduleCreateManyReceptionInput[]
    skipDuplicates?: boolean
  }

  export type ReceptionBranchCreateWithoutReceptionInput = {
    branch: BranchCreateNestedOneWithoutReceptionBranchesInput
  }

  export type ReceptionBranchUncheckedCreateWithoutReceptionInput = {
    id?: number
    branchId: number
  }

  export type ReceptionBranchCreateOrConnectWithoutReceptionInput = {
    where: ReceptionBranchWhereUniqueInput
    create: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionBranchCreateManyReceptionInputEnvelope = {
    data: ReceptionBranchCreateManyReceptionInput | ReceptionBranchCreateManyReceptionInput[]
    skipDuplicates?: boolean
  }

  export type NurseScheduleCreateWithoutNurseInput = {
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
    branch: BranchCreateNestedOneWithoutNurseSchedulesInput
  }

  export type NurseScheduleUncheckedCreateWithoutNurseInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseScheduleCreateOrConnectWithoutNurseInput = {
    where: NurseScheduleWhereUniqueInput
    create: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput>
  }

  export type NurseScheduleCreateManyNurseInputEnvelope = {
    data: NurseScheduleCreateManyNurseInput | NurseScheduleCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type NurseBranchCreateWithoutNurseInput = {
    branch: BranchCreateNestedOneWithoutNurseBranchesInput
  }

  export type NurseBranchUncheckedCreateWithoutNurseInput = {
    id?: number
    branchId: number
  }

  export type NurseBranchCreateOrConnectWithoutNurseInput = {
    where: NurseBranchWhereUniqueInput
    create: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput>
  }

  export type NurseBranchCreateManyNurseInputEnvelope = {
    data: NurseBranchCreateManyNurseInput | NurseBranchCreateManyNurseInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDoctorInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: number
    patientId: number
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutDoctorInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBookingsInput
    patient: PatientCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutDoctorInput = {
    id?: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutDoctorInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput>
  }

  export type BookingCreateManyDoctorInputEnvelope = {
    data: BookingCreateManyDoctorInput | BookingCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeBenefitCreateWithoutEmployeeInput = {
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: EmployeeBenefitUsageCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitUncheckedCreateWithoutEmployeeInput = {
    id?: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEmployeeBenefitInput
  }

  export type EmployeeBenefitCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeBenefitWhereUniqueInput
    create: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeBenefitCreateManyEmployeeInputEnvelope = {
    data: EmployeeBenefitCreateManyEmployeeInput | EmployeeBenefitCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutCreatedByInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutCreatedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutCreatedByInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput>
  }

  export type LedgerEntryCreateManyCreatedByInputEnvelope = {
    data: LedgerEntryCreateManyCreatedByInput | LedgerEntryCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutApprovedByInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutApprovedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutApprovedByInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput>
  }

  export type LedgerEntryCreateManyApprovedByInputEnvelope = {
    data: LedgerEntryCreateManyApprovedByInput | LedgerEntryCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeVoucherCreateWithoutEmployeeInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutEmployeeInput = {
    id?: number
    branchId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeVoucherCreateManyEmployeeInputEnvelope = {
    data: EmployeeVoucherCreateManyEmployeeInput | EmployeeVoucherCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeVoucherCreateWithoutCreatedByInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutCreatedByInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutEmployeeVoucherInput
  }

  export type EmployeeVoucherCreateOrConnectWithoutCreatedByInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput>
  }

  export type EmployeeVoucherCreateManyCreatedByInputEnvelope = {
    data: EmployeeVoucherCreateManyCreatedByInput | EmployeeVoucherCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuthorizationCodeCreateWithoutCreatedByInput = {
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeUncheckedCreateWithoutCreatedByInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovalCodeInput
  }

  export type AuthorizationCodeCreateOrConnectWithoutCreatedByInput = {
    where: AuthorizationCodeWhereUniqueInput
    create: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput>
  }

  export type AuthorizationCodeCreateManyCreatedByInputEnvelope = {
    data: AuthorizationCodeCreateManyCreatedByInput | AuthorizationCodeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SterilizationIndicatorCreateWithoutSpecialistInput = {
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSterilizationIndicatorsInput
    items?: SterilizationIndicatorItemCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUncheckedCreateWithoutSpecialistInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutIndicatorInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorCreateOrConnectWithoutSpecialistInput = {
    where: SterilizationIndicatorWhereUniqueInput
    create: XOR<SterilizationIndicatorCreateWithoutSpecialistInput, SterilizationIndicatorUncheckedCreateWithoutSpecialistInput>
  }

  export type SterilizationIndicatorCreateManySpecialistInputEnvelope = {
    data: SterilizationIndicatorCreateManySpecialistInput | SterilizationIndicatorCreateManySpecialistInput[]
    skipDuplicates?: boolean
  }

  export type EncounterSterilizationPackageUseCreateWithoutOpenedByInput = {
    usedQuantity?: number
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutSterilizationPackageUsesInput
    indicator: SterilizationIndicatorCreateNestedOneWithoutUsesInput
  }

  export type EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput = {
    id?: number
    encounterId: number
    indicatorId: number
    usedQuantity?: number
    createdAt?: Date | string
  }

  export type EncounterSterilizationPackageUseCreateOrConnectWithoutOpenedByInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    create: XOR<EncounterSterilizationPackageUseCreateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput>
  }

  export type EncounterSterilizationPackageUseCreateManyOpenedByInputEnvelope = {
    data: EncounterSterilizationPackageUseCreateManyOpenedByInput | EncounterSterilizationPackageUseCreateManyOpenedByInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutDoctorInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutDoctorInput, EncounterUncheckedUpdateWithoutDoctorInput>
    create: XOR<EncounterCreateWithoutDoctorInput, EncounterUncheckedCreateWithoutDoctorInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutDoctorInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutDoctorInput, EncounterUncheckedUpdateWithoutDoctorInput>
  }

  export type EncounterUpdateManyWithWhereWithoutDoctorInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutDoctorInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: IntFilter<"Encounter"> | number
    patientBookId?: IntFilter<"Encounter"> | number
    doctorId?: IntFilter<"Encounter"> | number
    visitDate?: DateTimeFilter<"Encounter"> | Date | string
    notes?: StringNullableFilter<"Encounter"> | string | null
    appointmentId?: IntNullableFilter<"Encounter"> | number | null
    nurseId?: IntNullableFilter<"Encounter"> | number | null
    patientSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    patientSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    doctorSignaturePath?: StringNullableFilter<"Encounter"> | string | null
    doctorSignedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
  }

  export type EncounterUpsertWithWhereUniqueWithoutNurseInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutNurseInput, EncounterUncheckedUpdateWithoutNurseInput>
    create: XOR<EncounterCreateWithoutNurseInput, EncounterUncheckedCreateWithoutNurseInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutNurseInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutNurseInput, EncounterUncheckedUpdateWithoutNurseInput>
  }

  export type EncounterUpdateManyWithWhereWithoutNurseInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutNurseInput>
  }

  export type DoctorScheduleUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    update: XOR<DoctorScheduleUpdateWithoutDoctorInput, DoctorScheduleUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorScheduleCreateWithoutDoctorInput, DoctorScheduleUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorScheduleUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorScheduleWhereUniqueInput
    data: XOR<DoctorScheduleUpdateWithoutDoctorInput, DoctorScheduleUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorScheduleUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorScheduleScalarWhereInput
    data: XOR<DoctorScheduleUpdateManyMutationInput, DoctorScheduleUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorBranchUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorBranchWhereUniqueInput
    update: XOR<DoctorBranchUpdateWithoutDoctorInput, DoctorBranchUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorBranchCreateWithoutDoctorInput, DoctorBranchUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorBranchUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorBranchWhereUniqueInput
    data: XOR<DoctorBranchUpdateWithoutDoctorInput, DoctorBranchUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorBranchUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorBranchScalarWhereInput
    data: XOR<DoctorBranchUpdateManyMutationInput, DoctorBranchUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ReceptionScheduleUpsertWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionScheduleWhereUniqueInput
    update: XOR<ReceptionScheduleUpdateWithoutReceptionInput, ReceptionScheduleUncheckedUpdateWithoutReceptionInput>
    create: XOR<ReceptionScheduleCreateWithoutReceptionInput, ReceptionScheduleUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionScheduleUpdateWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionScheduleWhereUniqueInput
    data: XOR<ReceptionScheduleUpdateWithoutReceptionInput, ReceptionScheduleUncheckedUpdateWithoutReceptionInput>
  }

  export type ReceptionScheduleUpdateManyWithWhereWithoutReceptionInput = {
    where: ReceptionScheduleScalarWhereInput
    data: XOR<ReceptionScheduleUpdateManyMutationInput, ReceptionScheduleUncheckedUpdateManyWithoutReceptionInput>
  }

  export type ReceptionBranchUpsertWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionBranchWhereUniqueInput
    update: XOR<ReceptionBranchUpdateWithoutReceptionInput, ReceptionBranchUncheckedUpdateWithoutReceptionInput>
    create: XOR<ReceptionBranchCreateWithoutReceptionInput, ReceptionBranchUncheckedCreateWithoutReceptionInput>
  }

  export type ReceptionBranchUpdateWithWhereUniqueWithoutReceptionInput = {
    where: ReceptionBranchWhereUniqueInput
    data: XOR<ReceptionBranchUpdateWithoutReceptionInput, ReceptionBranchUncheckedUpdateWithoutReceptionInput>
  }

  export type ReceptionBranchUpdateManyWithWhereWithoutReceptionInput = {
    where: ReceptionBranchScalarWhereInput
    data: XOR<ReceptionBranchUpdateManyMutationInput, ReceptionBranchUncheckedUpdateManyWithoutReceptionInput>
  }

  export type NurseScheduleUpsertWithWhereUniqueWithoutNurseInput = {
    where: NurseScheduleWhereUniqueInput
    update: XOR<NurseScheduleUpdateWithoutNurseInput, NurseScheduleUncheckedUpdateWithoutNurseInput>
    create: XOR<NurseScheduleCreateWithoutNurseInput, NurseScheduleUncheckedCreateWithoutNurseInput>
  }

  export type NurseScheduleUpdateWithWhereUniqueWithoutNurseInput = {
    where: NurseScheduleWhereUniqueInput
    data: XOR<NurseScheduleUpdateWithoutNurseInput, NurseScheduleUncheckedUpdateWithoutNurseInput>
  }

  export type NurseScheduleUpdateManyWithWhereWithoutNurseInput = {
    where: NurseScheduleScalarWhereInput
    data: XOR<NurseScheduleUpdateManyMutationInput, NurseScheduleUncheckedUpdateManyWithoutNurseInput>
  }

  export type NurseBranchUpsertWithWhereUniqueWithoutNurseInput = {
    where: NurseBranchWhereUniqueInput
    update: XOR<NurseBranchUpdateWithoutNurseInput, NurseBranchUncheckedUpdateWithoutNurseInput>
    create: XOR<NurseBranchCreateWithoutNurseInput, NurseBranchUncheckedCreateWithoutNurseInput>
  }

  export type NurseBranchUpdateWithWhereUniqueWithoutNurseInput = {
    where: NurseBranchWhereUniqueInput
    data: XOR<NurseBranchUpdateWithoutNurseInput, NurseBranchUncheckedUpdateWithoutNurseInput>
  }

  export type NurseBranchUpdateManyWithWhereWithoutNurseInput = {
    where: NurseBranchScalarWhereInput
    data: XOR<NurseBranchUpdateManyMutationInput, NurseBranchUncheckedUpdateManyWithoutNurseInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutDoctorInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutDoctorInput, BookingUncheckedUpdateWithoutDoctorInput>
    create: XOR<BookingCreateWithoutDoctorInput, BookingUncheckedCreateWithoutDoctorInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutDoctorInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutDoctorInput, BookingUncheckedUpdateWithoutDoctorInput>
  }

  export type BookingUpdateManyWithWhereWithoutDoctorInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutDoctorInput>
  }

  export type EmployeeBenefitUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeBenefitWhereUniqueInput
    update: XOR<EmployeeBenefitUpdateWithoutEmployeeInput, EmployeeBenefitUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeBenefitCreateWithoutEmployeeInput, EmployeeBenefitUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeBenefitUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeBenefitWhereUniqueInput
    data: XOR<EmployeeBenefitUpdateWithoutEmployeeInput, EmployeeBenefitUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeBenefitUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeBenefitScalarWhereInput
    data: XOR<EmployeeBenefitUpdateManyMutationInput, EmployeeBenefitUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeBenefitScalarWhereInput = {
    AND?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
    OR?: EmployeeBenefitScalarWhereInput[]
    NOT?: EmployeeBenefitScalarWhereInput | EmployeeBenefitScalarWhereInput[]
    id?: IntFilter<"EmployeeBenefit"> | number
    employeeId?: IntFilter<"EmployeeBenefit"> | number
    code?: StringFilter<"EmployeeBenefit"> | string
    branchId?: IntNullableFilter<"EmployeeBenefit"> | number | null
    initialAmount?: IntFilter<"EmployeeBenefit"> | number
    remainingAmount?: IntFilter<"EmployeeBenefit"> | number
    fromDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    toDate?: DateTimeNullableFilter<"EmployeeBenefit"> | Date | string | null
    isActive?: BoolFilter<"EmployeeBenefit"> | boolean
    createdAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeBenefit"> | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutCreatedByInput, LedgerEntryUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LedgerEntryCreateWithoutCreatedByInput, LedgerEntryUncheckedCreateWithoutCreatedByInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutCreatedByInput, LedgerEntryUncheckedUpdateWithoutCreatedByInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutCreatedByInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutApprovedByInput, LedgerEntryUncheckedUpdateWithoutApprovedByInput>
    create: XOR<LedgerEntryCreateWithoutApprovedByInput, LedgerEntryUncheckedCreateWithoutApprovedByInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutApprovedByInput, LedgerEntryUncheckedUpdateWithoutApprovedByInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutApprovedByInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type EmployeeVoucherUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeVoucherWhereUniqueInput
    update: XOR<EmployeeVoucherUpdateWithoutEmployeeInput, EmployeeVoucherUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeVoucherCreateWithoutEmployeeInput, EmployeeVoucherUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeVoucherUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeVoucherWhereUniqueInput
    data: XOR<EmployeeVoucherUpdateWithoutEmployeeInput, EmployeeVoucherUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeVoucherUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeVoucherScalarWhereInput
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeVoucherUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EmployeeVoucherWhereUniqueInput
    update: XOR<EmployeeVoucherUpdateWithoutCreatedByInput, EmployeeVoucherUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EmployeeVoucherCreateWithoutCreatedByInput, EmployeeVoucherUncheckedCreateWithoutCreatedByInput>
  }

  export type EmployeeVoucherUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EmployeeVoucherWhereUniqueInput
    data: XOR<EmployeeVoucherUpdateWithoutCreatedByInput, EmployeeVoucherUncheckedUpdateWithoutCreatedByInput>
  }

  export type EmployeeVoucherUpdateManyWithWhereWithoutCreatedByInput = {
    where: EmployeeVoucherScalarWhereInput
    data: XOR<EmployeeVoucherUpdateManyMutationInput, EmployeeVoucherUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuthorizationCodeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AuthorizationCodeWhereUniqueInput
    update: XOR<AuthorizationCodeUpdateWithoutCreatedByInput, AuthorizationCodeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AuthorizationCodeCreateWithoutCreatedByInput, AuthorizationCodeUncheckedCreateWithoutCreatedByInput>
  }

  export type AuthorizationCodeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AuthorizationCodeWhereUniqueInput
    data: XOR<AuthorizationCodeUpdateWithoutCreatedByInput, AuthorizationCodeUncheckedUpdateWithoutCreatedByInput>
  }

  export type AuthorizationCodeUpdateManyWithWhereWithoutCreatedByInput = {
    where: AuthorizationCodeScalarWhereInput
    data: XOR<AuthorizationCodeUpdateManyMutationInput, AuthorizationCodeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AuthorizationCodeScalarWhereInput = {
    AND?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
    OR?: AuthorizationCodeScalarWhereInput[]
    NOT?: AuthorizationCodeScalarWhereInput | AuthorizationCodeScalarWhereInput[]
    id?: IntFilter<"AuthorizationCode"> | number
    code?: StringFilter<"AuthorizationCode"> | string
    purpose?: StringFilter<"AuthorizationCode"> | string
    isEnabled?: BoolFilter<"AuthorizationCode"> | boolean
    expiresAt?: DateTimeNullableFilter<"AuthorizationCode"> | Date | string | null
    maxUses?: IntNullableFilter<"AuthorizationCode"> | number | null
    usedCount?: IntFilter<"AuthorizationCode"> | number
    createdById?: IntFilter<"AuthorizationCode"> | number
    createdAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
    updatedAt?: DateTimeFilter<"AuthorizationCode"> | Date | string
  }

  export type SterilizationIndicatorUpsertWithWhereUniqueWithoutSpecialistInput = {
    where: SterilizationIndicatorWhereUniqueInput
    update: XOR<SterilizationIndicatorUpdateWithoutSpecialistInput, SterilizationIndicatorUncheckedUpdateWithoutSpecialistInput>
    create: XOR<SterilizationIndicatorCreateWithoutSpecialistInput, SterilizationIndicatorUncheckedCreateWithoutSpecialistInput>
  }

  export type SterilizationIndicatorUpdateWithWhereUniqueWithoutSpecialistInput = {
    where: SterilizationIndicatorWhereUniqueInput
    data: XOR<SterilizationIndicatorUpdateWithoutSpecialistInput, SterilizationIndicatorUncheckedUpdateWithoutSpecialistInput>
  }

  export type SterilizationIndicatorUpdateManyWithWhereWithoutSpecialistInput = {
    where: SterilizationIndicatorScalarWhereInput
    data: XOR<SterilizationIndicatorUpdateManyMutationInput, SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistInput>
  }

  export type EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutOpenedByInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    update: XOR<EncounterSterilizationPackageUseUpdateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedUpdateWithoutOpenedByInput>
    create: XOR<EncounterSterilizationPackageUseCreateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedCreateWithoutOpenedByInput>
  }

  export type EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutOpenedByInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    data: XOR<EncounterSterilizationPackageUseUpdateWithoutOpenedByInput, EncounterSterilizationPackageUseUncheckedUpdateWithoutOpenedByInput>
  }

  export type EncounterSterilizationPackageUseUpdateManyWithWhereWithoutOpenedByInput = {
    where: EncounterSterilizationPackageUseScalarWhereInput
    data: XOR<EncounterSterilizationPackageUseUpdateManyMutationInput, EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByInput>
  }

  export type BranchCreateWithoutPatientsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPatientsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPatientsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
  }

  export type PatientBookCreateWithoutPatientInput = {
    bookNumber: string
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutPatientInput = {
    id?: number
    bookNumber: string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutPatientInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateWithoutPatientInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
    encounters?: EncounterCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutPatientInput = {
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutBookingsInput
    branch: BranchCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPatientInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutPatientInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput>
  }

  export type BookingCreateManyPatientInputEnvelope = {
    data: BookingCreateManyPatientInput | BookingCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutPatientInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutPatientInput = {
    id?: number
    branchId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutPatientInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput>
  }

  export type LedgerEntryCreateManyPatientInputEnvelope = {
    data: LedgerEntryCreateManyPatientInput | LedgerEntryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeBenefitUsageCreateWithoutPatientInput = {
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
    employeeBenefit: EmployeeBenefitCreateNestedOneWithoutUsagesInput
    invoice: InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput
    encounter: EncounterCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateWithoutPatientInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateOrConnectWithoutPatientInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    create: XOR<EmployeeBenefitUsageCreateWithoutPatientInput, EmployeeBenefitUsageUncheckedCreateWithoutPatientInput>
  }

  export type EmployeeBenefitUsageCreateManyPatientInputEnvelope = {
    data: EmployeeBenefitUsageCreateManyPatientInput | EmployeeBenefitUsageCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutPatientsInput = {
    update: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPatientsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type BranchUpdateWithoutPatientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientBookUpsertWithoutPatientInput = {
    update: XOR<PatientBookUpdateWithoutPatientInput, PatientBookUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientBookCreateWithoutPatientInput, PatientBookUncheckedCreateWithoutPatientInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutPatientInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutPatientInput, PatientBookUncheckedUpdateWithoutPatientInput>
  }

  export type PatientBookUpdateWithoutPatientInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutPatientInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPatientInput, BookingUncheckedUpdateWithoutPatientInput>
    create: XOR<BookingCreateWithoutPatientInput, BookingUncheckedCreateWithoutPatientInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPatientInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPatientInput, BookingUncheckedUpdateWithoutPatientInput>
  }

  export type BookingUpdateManyWithWhereWithoutPatientInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutPatientInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutPatientInput, LedgerEntryUncheckedUpdateWithoutPatientInput>
    create: XOR<LedgerEntryCreateWithoutPatientInput, LedgerEntryUncheckedCreateWithoutPatientInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutPatientInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutPatientInput, LedgerEntryUncheckedUpdateWithoutPatientInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutPatientInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutPatientInput>
  }

  export type EmployeeBenefitUsageUpsertWithWhereUniqueWithoutPatientInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    update: XOR<EmployeeBenefitUsageUpdateWithoutPatientInput, EmployeeBenefitUsageUncheckedUpdateWithoutPatientInput>
    create: XOR<EmployeeBenefitUsageCreateWithoutPatientInput, EmployeeBenefitUsageUncheckedCreateWithoutPatientInput>
  }

  export type EmployeeBenefitUsageUpdateWithWhereUniqueWithoutPatientInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    data: XOR<EmployeeBenefitUsageUpdateWithoutPatientInput, EmployeeBenefitUsageUncheckedUpdateWithoutPatientInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithWhereWithoutPatientInput = {
    where: EmployeeBenefitUsageScalarWhereInput
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientCreateWithoutPatientBookInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPatientBookInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPatientBookInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
  }

  export type EncounterCreateWithoutPatientBookInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPatientBookInput = {
    id?: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPatientBookInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput>
  }

  export type EncounterCreateManyPatientBookInputEnvelope = {
    data: EncounterCreateManyPatientBookInput | EncounterCreateManyPatientBookInput[]
    skipDuplicates?: boolean
  }

  export type VisitCardCreateWithoutPatientBookInput = {
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardUncheckedCreateWithoutPatientBookInput = {
    id?: number
    type: $Enums.VisitCardType
    answers: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: string | null
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VisitCardCreateOrConnectWithoutPatientBookInput = {
    where: VisitCardWhereUniqueInput
    create: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
  }

  export type OrthoCardCreateWithoutPatientBookInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardUncheckedCreateWithoutPatientBookInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrthoCardCreateOrConnectWithoutPatientBookInput = {
    where: OrthoCardWhereUniqueInput
    create: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
  }

  export type PatientUpsertWithoutPatientBookInput = {
    update: XOR<PatientUpdateWithoutPatientBookInput, PatientUncheckedUpdateWithoutPatientBookInput>
    create: XOR<PatientCreateWithoutPatientBookInput, PatientUncheckedCreateWithoutPatientBookInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPatientBookInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPatientBookInput, PatientUncheckedUpdateWithoutPatientBookInput>
  }

  export type PatientUpdateWithoutPatientBookInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutPatientBookInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPatientBookInput, EncounterUncheckedUpdateWithoutPatientBookInput>
    create: XOR<EncounterCreateWithoutPatientBookInput, EncounterUncheckedCreateWithoutPatientBookInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPatientBookInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPatientBookInput, EncounterUncheckedUpdateWithoutPatientBookInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPatientBookInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPatientBookInput>
  }

  export type VisitCardUpsertWithoutPatientBookInput = {
    update: XOR<VisitCardUpdateWithoutPatientBookInput, VisitCardUncheckedUpdateWithoutPatientBookInput>
    create: XOR<VisitCardCreateWithoutPatientBookInput, VisitCardUncheckedCreateWithoutPatientBookInput>
    where?: VisitCardWhereInput
  }

  export type VisitCardUpdateToOneWithWhereWithoutPatientBookInput = {
    where?: VisitCardWhereInput
    data: XOR<VisitCardUpdateWithoutPatientBookInput, VisitCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type VisitCardUpdateWithoutPatientBookInput = {
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisitCardUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumVisitCardTypeFieldUpdateOperationsInput | $Enums.VisitCardType
    answers?: JsonNullValueInput | InputJsonValue
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardUpsertWithoutPatientBookInput = {
    update: XOR<OrthoCardUpdateWithoutPatientBookInput, OrthoCardUncheckedUpdateWithoutPatientBookInput>
    create: XOR<OrthoCardCreateWithoutPatientBookInput, OrthoCardUncheckedCreateWithoutPatientBookInput>
    where?: OrthoCardWhereInput
  }

  export type OrthoCardUpdateToOneWithWhereWithoutPatientBookInput = {
    where?: OrthoCardWhereInput
    data: XOR<OrthoCardUpdateWithoutPatientBookInput, OrthoCardUncheckedUpdateWithoutPatientBookInput>
  }

  export type OrthoCardUpdateWithoutPatientBookInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrthoCardUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientBookCreateWithoutVisitCardInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutVisitCardInput = {
    id?: number
    bookNumber: string
    patientId: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutVisitCardInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
  }

  export type PatientBookUpsertWithoutVisitCardInput = {
    update: XOR<PatientBookUpdateWithoutVisitCardInput, PatientBookUncheckedUpdateWithoutVisitCardInput>
    create: XOR<PatientBookCreateWithoutVisitCardInput, PatientBookUncheckedCreateWithoutVisitCardInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutVisitCardInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutVisitCardInput, PatientBookUncheckedUpdateWithoutVisitCardInput>
  }

  export type PatientBookUpdateWithoutVisitCardInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutVisitCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookCreateWithoutOrthoCardInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    encounters?: EncounterCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutOrthoCardInput = {
    id?: number
    bookNumber: string
    patientId: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientBookInput
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutOrthoCardInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
  }

  export type PatientBookUpsertWithoutOrthoCardInput = {
    update: XOR<PatientBookUpdateWithoutOrthoCardInput, PatientBookUncheckedUpdateWithoutOrthoCardInput>
    create: XOR<PatientBookCreateWithoutOrthoCardInput, PatientBookUncheckedCreateWithoutOrthoCardInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutOrthoCardInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutOrthoCardInput, PatientBookUncheckedUpdateWithoutOrthoCardInput>
  }

  export type PatientBookUpdateWithoutOrthoCardInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    encounters?: EncounterUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutOrthoCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutPatientBookNestedInput
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientCreateWithoutAppointmentsInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type BranchCreateWithoutAppointmentsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAppointmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
  }

  export type EncounterCreateWithoutAppointmentInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutAppointmentInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
  }

  export type EncounterCreateManyAppointmentInputEnvelope = {
    data: EncounterCreateManyAppointmentInput | EncounterCreateManyAppointmentInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutAppointmentsInput = {
    update: XOR<BranchUpdateWithoutAppointmentsInput, BranchUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<BranchCreateWithoutAppointmentsInput, BranchUncheckedCreateWithoutAppointmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAppointmentsInput, BranchUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BranchUpdateWithoutAppointmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutAppointmentInput, EncounterUncheckedUpdateWithoutAppointmentInput>
    create: XOR<EncounterCreateWithoutAppointmentInput, EncounterUncheckedCreateWithoutAppointmentInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutAppointmentInput, EncounterUncheckedUpdateWithoutAppointmentInput>
  }

  export type EncounterUpdateManyWithWhereWithoutAppointmentInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type UserCreateWithoutBookingsInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type BranchCreateWithoutBookingsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBookingsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
  }

  export type PatientCreateWithoutBookingsInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBookingsInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBookingsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutBookingsInput = {
    update: XOR<BranchUpdateWithoutBookingsInput, BranchUncheckedUpdateWithoutBookingsInput>
    create: XOR<BranchCreateWithoutBookingsInput, BranchUncheckedCreateWithoutBookingsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBookingsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBookingsInput, BranchUncheckedUpdateWithoutBookingsInput>
  }

  export type BranchUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutBookingsInput = {
    update: XOR<PatientUpdateWithoutBookingsInput, PatientUncheckedUpdateWithoutBookingsInput>
    create: XOR<PatientCreateWithoutBookingsInput, PatientUncheckedCreateWithoutBookingsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutBookingsInput, PatientUncheckedUpdateWithoutBookingsInput>
  }

  export type PatientUpdateWithoutBookingsInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientBookCreateWithoutEncountersInput = {
    bookNumber: string
    patient: PatientCreateNestedOneWithoutPatientBookInput
    visitCard?: VisitCardCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookUncheckedCreateWithoutEncountersInput = {
    id?: number
    bookNumber: string
    patientId: number
    visitCard?: VisitCardUncheckedCreateNestedOneWithoutPatientBookInput
    orthoCard?: OrthoCardUncheckedCreateNestedOneWithoutPatientBookInput
  }

  export type PatientBookCreateOrConnectWithoutEncountersInput = {
    where: PatientBookWhereUniqueInput
    create: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
  }

  export type UserCreateWithoutEncountersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutEncountersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutEncountersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
  }

  export type AppointmentCreateWithoutEncountersInput = {
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor?: UserCreateNestedOneWithoutAppointmentsInput
    branch: BranchCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutEncountersInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type AppointmentCreateOrConnectWithoutEncountersInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
  }

  export type UserCreateWithoutNurseEncountersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutNurseEncountersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutNurseEncountersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
  }

  export type ChartToothCreateWithoutEncounterInput = {
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    chartNotes?: ChartNoteCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothUncheckedCreateWithoutEncounterInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    chartNotes?: ChartNoteUncheckedCreateNestedManyWithoutChartToothInput
  }

  export type ChartToothCreateOrConnectWithoutEncounterInput = {
    where: ChartToothWhereUniqueInput
    create: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput>
  }

  export type ChartToothCreateManyEncounterInputEnvelope = {
    data: ChartToothCreateManyEncounterInput | ChartToothCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutEncounterInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEncounterInput = {
    id?: number
    branchId?: number | null
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEncounterInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
  }

  export type PrescriptionCreateWithoutEncounterInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutEncounterInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutEncounterInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
  }

  export type MediaCreateWithoutEncounterInput = {
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaUncheckedCreateWithoutEncounterInput = {
    id?: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type MediaCreateOrConnectWithoutEncounterInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput>
  }

  export type MediaCreateManyEncounterInputEnvelope = {
    data: MediaCreateManyEncounterInput | MediaCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterServiceCreateWithoutEncounterInput = {
    quantity?: number
    price: number
    service: ServiceCreateNestedOneWithoutEncounterServicesInput
  }

  export type EncounterServiceUncheckedCreateWithoutEncounterInput = {
    id?: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceCreateOrConnectWithoutEncounterInput = {
    where: EncounterServiceWhereUniqueInput
    create: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterServiceCreateManyEncounterInputEnvelope = {
    data: EncounterServiceCreateManyEncounterInput | EncounterServiceCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterDiagnosisCreateWithoutEncounterInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    diagnosis: DiagnosisCreateNestedOneWithoutEncountersInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutEncounterDiagnosisInput
  }

  export type EncounterDiagnosisUncheckedCreateWithoutEncounterInput = {
    id?: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutEncounterDiagnosisInput
  }

  export type EncounterDiagnosisCreateOrConnectWithoutEncounterInput = {
    where: EncounterDiagnosisWhereUniqueInput
    create: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterDiagnosisCreateManyEncounterInputEnvelope = {
    data: EncounterDiagnosisCreateManyEncounterInput | EncounterDiagnosisCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterConsentCreateWithoutEncounterInput = {
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentUncheckedCreateWithoutEncounterInput = {
    id?: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterConsentCreateOrConnectWithoutEncounterInput = {
    where: EncounterConsentWhereUniqueInput
    create: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterConsentCreateManyEncounterInputEnvelope = {
    data: EncounterConsentCreateManyEncounterInput | EncounterConsentCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EncounterSterilizationPackageUseCreateWithoutEncounterInput = {
    usedQuantity?: number
    createdAt?: Date | string
    indicator: SterilizationIndicatorCreateNestedOneWithoutUsesInput
    openedBy?: UserCreateNestedOneWithoutOpenedSterilizationPackagesInput
  }

  export type EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput = {
    id?: number
    indicatorId: number
    usedQuantity?: number
    openedByUserId?: number | null
    createdAt?: Date | string
  }

  export type EncounterSterilizationPackageUseCreateOrConnectWithoutEncounterInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    create: XOR<EncounterSterilizationPackageUseCreateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterSterilizationPackageUseCreateManyEncounterInputEnvelope = {
    data: EncounterSterilizationPackageUseCreateManyEncounterInput | EncounterSterilizationPackageUseCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeBenefitUsageCreateWithoutEncounterInput = {
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
    employeeBenefit: EmployeeBenefitCreateNestedOneWithoutUsagesInput
    invoice: InvoiceCreateNestedOneWithoutEmployeeBenefitUsagesInput
    patient: PatientCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateOrConnectWithoutEncounterInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    create: XOR<EmployeeBenefitUsageCreateWithoutEncounterInput, EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput>
  }

  export type EmployeeBenefitUsageCreateManyEncounterInputEnvelope = {
    data: EmployeeBenefitUsageCreateManyEncounterInput | EmployeeBenefitUsageCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type PatientBookUpsertWithoutEncountersInput = {
    update: XOR<PatientBookUpdateWithoutEncountersInput, PatientBookUncheckedUpdateWithoutEncountersInput>
    create: XOR<PatientBookCreateWithoutEncountersInput, PatientBookUncheckedCreateWithoutEncountersInput>
    where?: PatientBookWhereInput
  }

  export type PatientBookUpdateToOneWithWhereWithoutEncountersInput = {
    where?: PatientBookWhereInput
    data: XOR<PatientBookUpdateWithoutEncountersInput, PatientBookUncheckedUpdateWithoutEncountersInput>
  }

  export type PatientBookUpdateWithoutEncountersInput = {
    bookNumber?: StringFieldUpdateOperationsInput | string
    patient?: PatientUpdateOneRequiredWithoutPatientBookNestedInput
    visitCard?: VisitCardUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUpdateOneWithoutPatientBookNestedInput
  }

  export type PatientBookUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookNumber?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    visitCard?: VisitCardUncheckedUpdateOneWithoutPatientBookNestedInput
    orthoCard?: OrthoCardUncheckedUpdateOneWithoutPatientBookNestedInput
  }

  export type UserUpsertWithoutEncountersInput = {
    update: XOR<UserUpdateWithoutEncountersInput, UserUncheckedUpdateWithoutEncountersInput>
    create: XOR<UserCreateWithoutEncountersInput, UserUncheckedCreateWithoutEncountersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEncountersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEncountersInput, UserUncheckedUpdateWithoutEncountersInput>
  }

  export type UserUpdateWithoutEncountersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type AppointmentUpsertWithoutEncountersInput = {
    update: XOR<AppointmentUpdateWithoutEncountersInput, AppointmentUncheckedUpdateWithoutEncountersInput>
    create: XOR<AppointmentCreateWithoutEncountersInput, AppointmentUncheckedCreateWithoutEncountersInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutEncountersInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutEncountersInput, AppointmentUncheckedUpdateWithoutEncountersInput>
  }

  export type AppointmentUpdateWithoutEncountersInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutNurseEncountersInput = {
    update: XOR<UserUpdateWithoutNurseEncountersInput, UserUncheckedUpdateWithoutNurseEncountersInput>
    create: XOR<UserCreateWithoutNurseEncountersInput, UserUncheckedCreateWithoutNurseEncountersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseEncountersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseEncountersInput, UserUncheckedUpdateWithoutNurseEncountersInput>
  }

  export type UserUpdateWithoutNurseEncountersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type ChartToothUpsertWithWhereUniqueWithoutEncounterInput = {
    where: ChartToothWhereUniqueInput
    update: XOR<ChartToothUpdateWithoutEncounterInput, ChartToothUncheckedUpdateWithoutEncounterInput>
    create: XOR<ChartToothCreateWithoutEncounterInput, ChartToothUncheckedCreateWithoutEncounterInput>
  }

  export type ChartToothUpdateWithWhereUniqueWithoutEncounterInput = {
    where: ChartToothWhereUniqueInput
    data: XOR<ChartToothUpdateWithoutEncounterInput, ChartToothUncheckedUpdateWithoutEncounterInput>
  }

  export type ChartToothUpdateManyWithWhereWithoutEncounterInput = {
    where: ChartToothScalarWhereInput
    data: XOR<ChartToothUpdateManyMutationInput, ChartToothUncheckedUpdateManyWithoutEncounterInput>
  }

  export type ChartToothScalarWhereInput = {
    AND?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
    OR?: ChartToothScalarWhereInput[]
    NOT?: ChartToothScalarWhereInput | ChartToothScalarWhereInput[]
    id?: IntFilter<"ChartTooth"> | number
    toothCode?: StringFilter<"ChartTooth"> | string
    toothGroup?: StringNullableFilter<"ChartTooth"> | string | null
    status?: StringNullableFilter<"ChartTooth"> | string | null
    notes?: StringNullableFilter<"ChartTooth"> | string | null
    encounterId?: IntFilter<"ChartTooth"> | number
  }

  export type InvoiceUpsertWithoutEncounterInput = {
    update: XOR<InvoiceUpdateWithoutEncounterInput, InvoiceUncheckedUpdateWithoutEncounterInput>
    create: XOR<InvoiceCreateWithoutEncounterInput, InvoiceUncheckedCreateWithoutEncounterInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEncounterInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEncounterInput, InvoiceUncheckedUpdateWithoutEncounterInput>
  }

  export type InvoiceUpdateWithoutEncounterInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PrescriptionUpsertWithoutEncounterInput = {
    update: XOR<PrescriptionUpdateWithoutEncounterInput, PrescriptionUncheckedUpdateWithoutEncounterInput>
    create: XOR<PrescriptionCreateWithoutEncounterInput, PrescriptionUncheckedCreateWithoutEncounterInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutEncounterInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutEncounterInput, PrescriptionUncheckedUpdateWithoutEncounterInput>
  }

  export type PrescriptionUpdateWithoutEncounterInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutEncounterInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutEncounterInput, MediaUncheckedUpdateWithoutEncounterInput>
    create: XOR<MediaCreateWithoutEncounterInput, MediaUncheckedCreateWithoutEncounterInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutEncounterInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutEncounterInput, MediaUncheckedUpdateWithoutEncounterInput>
  }

  export type MediaUpdateManyWithWhereWithoutEncounterInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutEncounterInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: IntFilter<"Media"> | number
    encounterId?: IntFilter<"Media"> | number
    filePath?: StringFilter<"Media"> | string
    toothCode?: StringNullableFilter<"Media"> | string | null
    type?: StringFilter<"Media"> | string
  }

  export type EncounterServiceUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterServiceWhereUniqueInput
    update: XOR<EncounterServiceUpdateWithoutEncounterInput, EncounterServiceUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterServiceCreateWithoutEncounterInput, EncounterServiceUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterServiceUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterServiceWhereUniqueInput
    data: XOR<EncounterServiceUpdateWithoutEncounterInput, EncounterServiceUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterServiceUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterServiceScalarWhereInput
    data: XOR<EncounterServiceUpdateManyMutationInput, EncounterServiceUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterServiceScalarWhereInput = {
    AND?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
    OR?: EncounterServiceScalarWhereInput[]
    NOT?: EncounterServiceScalarWhereInput | EncounterServiceScalarWhereInput[]
    id?: IntFilter<"EncounterService"> | number
    encounterId?: IntFilter<"EncounterService"> | number
    serviceId?: IntFilter<"EncounterService"> | number
    quantity?: IntFilter<"EncounterService"> | number
    price?: FloatFilter<"EncounterService"> | number
  }

  export type EncounterDiagnosisUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterDiagnosisWhereUniqueInput
    update: XOR<EncounterDiagnosisUpdateWithoutEncounterInput, EncounterDiagnosisUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterDiagnosisCreateWithoutEncounterInput, EncounterDiagnosisUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterDiagnosisUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterDiagnosisWhereUniqueInput
    data: XOR<EncounterDiagnosisUpdateWithoutEncounterInput, EncounterDiagnosisUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterDiagnosisUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterDiagnosisScalarWhereInput
    data: XOR<EncounterDiagnosisUpdateManyMutationInput, EncounterDiagnosisUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterDiagnosisScalarWhereInput = {
    AND?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
    OR?: EncounterDiagnosisScalarWhereInput[]
    NOT?: EncounterDiagnosisScalarWhereInput | EncounterDiagnosisScalarWhereInput[]
    id?: IntFilter<"EncounterDiagnosis"> | number
    encounterId?: IntFilter<"EncounterDiagnosis"> | number
    diagnosisId?: IntFilter<"EncounterDiagnosis"> | number
    toothCode?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    selectedProblemIds?: JsonNullableFilter<"EncounterDiagnosis">
    note?: StringNullableFilter<"EncounterDiagnosis"> | string | null
    createdAt?: DateTimeFilter<"EncounterDiagnosis"> | Date | string
  }

  export type EncounterConsentUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterConsentWhereUniqueInput
    update: XOR<EncounterConsentUpdateWithoutEncounterInput, EncounterConsentUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterConsentCreateWithoutEncounterInput, EncounterConsentUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterConsentUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterConsentWhereUniqueInput
    data: XOR<EncounterConsentUpdateWithoutEncounterInput, EncounterConsentUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterConsentUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterConsentScalarWhereInput
    data: XOR<EncounterConsentUpdateManyMutationInput, EncounterConsentUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterConsentScalarWhereInput = {
    AND?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
    OR?: EncounterConsentScalarWhereInput[]
    NOT?: EncounterConsentScalarWhereInput | EncounterConsentScalarWhereInput[]
    id?: IntFilter<"EncounterConsent"> | number
    encounterId?: IntFilter<"EncounterConsent"> | number
    type?: StringFilter<"EncounterConsent"> | string
    answers?: JsonFilter<"EncounterConsent">
    createdAt?: DateTimeFilter<"EncounterConsent"> | Date | string
    updatedAt?: DateTimeFilter<"EncounterConsent"> | Date | string
  }

  export type EncounterSterilizationPackageUseUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    update: XOR<EncounterSterilizationPackageUseUpdateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterSterilizationPackageUseCreateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterSterilizationPackageUseUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterSterilizationPackageUseWhereUniqueInput
    data: XOR<EncounterSterilizationPackageUseUpdateWithoutEncounterInput, EncounterSterilizationPackageUseUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterSterilizationPackageUseUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterSterilizationPackageUseScalarWhereInput
    data: XOR<EncounterSterilizationPackageUseUpdateManyMutationInput, EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EmployeeBenefitUsageUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    update: XOR<EmployeeBenefitUsageUpdateWithoutEncounterInput, EmployeeBenefitUsageUncheckedUpdateWithoutEncounterInput>
    create: XOR<EmployeeBenefitUsageCreateWithoutEncounterInput, EmployeeBenefitUsageUncheckedCreateWithoutEncounterInput>
  }

  export type EmployeeBenefitUsageUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    data: XOR<EmployeeBenefitUsageUpdateWithoutEncounterInput, EmployeeBenefitUsageUncheckedUpdateWithoutEncounterInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithWhereWithoutEncounterInput = {
    where: EmployeeBenefitUsageScalarWhereInput
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterCreateWithoutConsentsInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutConsentsInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutConsentsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
  }

  export type EncounterUpsertWithoutConsentsInput = {
    update: XOR<EncounterUpdateWithoutConsentsInput, EncounterUncheckedUpdateWithoutConsentsInput>
    create: XOR<EncounterCreateWithoutConsentsInput, EncounterUncheckedCreateWithoutConsentsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutConsentsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutConsentsInput, EncounterUncheckedUpdateWithoutConsentsInput>
  }

  export type EncounterUpdateWithoutConsentsInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutConsentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateWithoutChartTeethInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutChartTeethInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutChartTeethInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
  }

  export type ChartNoteCreateWithoutChartToothInput = {
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUncheckedCreateWithoutChartToothInput = {
    id?: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteCreateOrConnectWithoutChartToothInput = {
    where: ChartNoteWhereUniqueInput
    create: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput>
  }

  export type ChartNoteCreateManyChartToothInputEnvelope = {
    data: ChartNoteCreateManyChartToothInput | ChartNoteCreateManyChartToothInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutChartTeethInput = {
    update: XOR<EncounterUpdateWithoutChartTeethInput, EncounterUncheckedUpdateWithoutChartTeethInput>
    create: XOR<EncounterCreateWithoutChartTeethInput, EncounterUncheckedCreateWithoutChartTeethInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutChartTeethInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutChartTeethInput, EncounterUncheckedUpdateWithoutChartTeethInput>
  }

  export type EncounterUpdateWithoutChartTeethInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutChartTeethInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type ChartNoteUpsertWithWhereUniqueWithoutChartToothInput = {
    where: ChartNoteWhereUniqueInput
    update: XOR<ChartNoteUpdateWithoutChartToothInput, ChartNoteUncheckedUpdateWithoutChartToothInput>
    create: XOR<ChartNoteCreateWithoutChartToothInput, ChartNoteUncheckedCreateWithoutChartToothInput>
  }

  export type ChartNoteUpdateWithWhereUniqueWithoutChartToothInput = {
    where: ChartNoteWhereUniqueInput
    data: XOR<ChartNoteUpdateWithoutChartToothInput, ChartNoteUncheckedUpdateWithoutChartToothInput>
  }

  export type ChartNoteUpdateManyWithWhereWithoutChartToothInput = {
    where: ChartNoteScalarWhereInput
    data: XOR<ChartNoteUpdateManyMutationInput, ChartNoteUncheckedUpdateManyWithoutChartToothInput>
  }

  export type ChartNoteScalarWhereInput = {
    AND?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
    OR?: ChartNoteScalarWhereInput[]
    NOT?: ChartNoteScalarWhereInput | ChartNoteScalarWhereInput[]
    id?: IntFilter<"ChartNote"> | number
    chartToothId?: IntFilter<"ChartNote"> | number
    description?: StringFilter<"ChartNote"> | string
    createdAt?: DateTimeFilter<"ChartNote"> | Date | string
  }

  export type ChartToothCreateWithoutChartNotesInput = {
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounter: EncounterCreateNestedOneWithoutChartTeethInput
  }

  export type ChartToothUncheckedCreateWithoutChartNotesInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
    encounterId: number
  }

  export type ChartToothCreateOrConnectWithoutChartNotesInput = {
    where: ChartToothWhereUniqueInput
    create: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
  }

  export type ChartToothUpsertWithoutChartNotesInput = {
    update: XOR<ChartToothUpdateWithoutChartNotesInput, ChartToothUncheckedUpdateWithoutChartNotesInput>
    create: XOR<ChartToothCreateWithoutChartNotesInput, ChartToothUncheckedCreateWithoutChartNotesInput>
    where?: ChartToothWhereInput
  }

  export type ChartToothUpdateToOneWithWhereWithoutChartNotesInput = {
    where?: ChartToothWhereInput
    data: XOR<ChartToothUpdateWithoutChartNotesInput, ChartToothUncheckedUpdateWithoutChartNotesInput>
  }

  export type ChartToothUpdateWithoutChartNotesInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutChartTeethNestedInput
  }

  export type ChartToothUncheckedUpdateWithoutChartNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounterId?: IntFieldUpdateOperationsInput | number
  }

  export type DiagnosisProblemCreateWithoutDiagnosisInput = {
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemUncheckedCreateWithoutDiagnosisInput = {
    id?: number
    label: string
    order?: number
    active?: boolean
  }

  export type DiagnosisProblemCreateOrConnectWithoutDiagnosisInput = {
    where: DiagnosisProblemWhereUniqueInput
    create: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput>
  }

  export type DiagnosisProblemCreateManyDiagnosisInputEnvelope = {
    data: DiagnosisProblemCreateManyDiagnosisInput | DiagnosisProblemCreateManyDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type EncounterDiagnosisCreateWithoutDiagnosisInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDiagnosesInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorCreateNestedManyWithoutEncounterDiagnosisInput
  }

  export type EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput = {
    id?: number
    encounterId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUncheckedCreateNestedManyWithoutEncounterDiagnosisInput
  }

  export type EncounterDiagnosisCreateOrConnectWithoutDiagnosisInput = {
    where: EncounterDiagnosisWhereUniqueInput
    create: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput>
  }

  export type EncounterDiagnosisCreateManyDiagnosisInputEnvelope = {
    data: EncounterDiagnosisCreateManyDiagnosisInput | EncounterDiagnosisCreateManyDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisProblemUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: DiagnosisProblemWhereUniqueInput
    update: XOR<DiagnosisProblemUpdateWithoutDiagnosisInput, DiagnosisProblemUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<DiagnosisProblemCreateWithoutDiagnosisInput, DiagnosisProblemUncheckedCreateWithoutDiagnosisInput>
  }

  export type DiagnosisProblemUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: DiagnosisProblemWhereUniqueInput
    data: XOR<DiagnosisProblemUpdateWithoutDiagnosisInput, DiagnosisProblemUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DiagnosisProblemUpdateManyWithWhereWithoutDiagnosisInput = {
    where: DiagnosisProblemScalarWhereInput
    data: XOR<DiagnosisProblemUpdateManyMutationInput, DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisInput>
  }

  export type DiagnosisProblemScalarWhereInput = {
    AND?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
    OR?: DiagnosisProblemScalarWhereInput[]
    NOT?: DiagnosisProblemScalarWhereInput | DiagnosisProblemScalarWhereInput[]
    id?: IntFilter<"DiagnosisProblem"> | number
    diagnosisId?: IntFilter<"DiagnosisProblem"> | number
    label?: StringFilter<"DiagnosisProblem"> | string
    order?: IntFilter<"DiagnosisProblem"> | number
    active?: BoolFilter<"DiagnosisProblem"> | boolean
  }

  export type EncounterDiagnosisUpsertWithWhereUniqueWithoutDiagnosisInput = {
    where: EncounterDiagnosisWhereUniqueInput
    update: XOR<EncounterDiagnosisUpdateWithoutDiagnosisInput, EncounterDiagnosisUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<EncounterDiagnosisCreateWithoutDiagnosisInput, EncounterDiagnosisUncheckedCreateWithoutDiagnosisInput>
  }

  export type EncounterDiagnosisUpdateWithWhereUniqueWithoutDiagnosisInput = {
    where: EncounterDiagnosisWhereUniqueInput
    data: XOR<EncounterDiagnosisUpdateWithoutDiagnosisInput, EncounterDiagnosisUncheckedUpdateWithoutDiagnosisInput>
  }

  export type EncounterDiagnosisUpdateManyWithWhereWithoutDiagnosisInput = {
    where: EncounterDiagnosisScalarWhereInput
    data: XOR<EncounterDiagnosisUpdateManyMutationInput, EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisInput>
  }

  export type DiagnosisCreateWithoutProblemsInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterDiagnosisCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutProblemsInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterDiagnosisUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisCreateOrConnectWithoutProblemsInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
  }

  export type DiagnosisUpsertWithoutProblemsInput = {
    update: XOR<DiagnosisUpdateWithoutProblemsInput, DiagnosisUncheckedUpdateWithoutProblemsInput>
    create: XOR<DiagnosisCreateWithoutProblemsInput, DiagnosisUncheckedCreateWithoutProblemsInput>
    where?: DiagnosisWhereInput
  }

  export type DiagnosisUpdateToOneWithWhereWithoutProblemsInput = {
    where?: DiagnosisWhereInput
    data: XOR<DiagnosisUpdateWithoutProblemsInput, DiagnosisUncheckedUpdateWithoutProblemsInput>
  }

  export type DiagnosisUpdateWithoutProblemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterDiagnosisUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutProblemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type EncounterCreateWithoutDiagnosesInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutDiagnosesInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutDiagnosesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
  }

  export type DiagnosisCreateWithoutEncountersInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutEncountersInput = {
    id?: number
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    problems?: DiagnosisProblemUncheckedCreateNestedManyWithoutDiagnosisInput
  }

  export type DiagnosisCreateOrConnectWithoutEncountersInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput = {
    createdAt?: Date | string
    indicator: SterilizationIndicatorCreateNestedOneWithoutEncounterDiagnosisLinksInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput = {
    id?: number
    indicatorId: number
    createdAt?: Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisInput = {
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    create: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInputEnvelope = {
    data: EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInput | EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutDiagnosesInput = {
    update: XOR<EncounterUpdateWithoutDiagnosesInput, EncounterUncheckedUpdateWithoutDiagnosesInput>
    create: XOR<EncounterCreateWithoutDiagnosesInput, EncounterUncheckedCreateWithoutDiagnosesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutDiagnosesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutDiagnosesInput, EncounterUncheckedUpdateWithoutDiagnosesInput>
  }

  export type EncounterUpdateWithoutDiagnosesInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutDiagnosesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type DiagnosisUpsertWithoutEncountersInput = {
    update: XOR<DiagnosisUpdateWithoutEncountersInput, DiagnosisUncheckedUpdateWithoutEncountersInput>
    create: XOR<DiagnosisCreateWithoutEncountersInput, DiagnosisUncheckedCreateWithoutEncountersInput>
    where?: DiagnosisWhereInput
  }

  export type DiagnosisUpdateToOneWithWhereWithoutEncountersInput = {
    where?: DiagnosisWhereInput
    data: XOR<DiagnosisUpdateWithoutEncountersInput, DiagnosisUncheckedUpdateWithoutEncountersInput>
  }

  export type DiagnosisUpdateWithoutEncountersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUpdateManyWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problems?: DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisNestedInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUpsertWithWhereUniqueWithoutEncounterDiagnosisInput = {
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    update: XOR<EncounterDiagnosisSterilizationIndicatorUpdateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisInput>
    create: XOR<EncounterDiagnosisSterilizationIndicatorCreateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateWithWhereUniqueWithoutEncounterDiagnosisInput = {
    where: EncounterDiagnosisSterilizationIndicatorWhereUniqueInput
    data: XOR<EncounterDiagnosisSterilizationIndicatorUpdateWithoutEncounterDiagnosisInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisInput>
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateManyWithWhereWithoutEncounterDiagnosisInput = {
    where: EncounterDiagnosisSterilizationIndicatorScalarWhereInput
    data: XOR<EncounterDiagnosisSterilizationIndicatorUpdateManyMutationInput, EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutEncounterDiagnosisInput>
  }

  export type EncounterDiagnosisCreateWithoutSterilizationIndicatorsInput = {
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
    encounter: EncounterCreateNestedOneWithoutDiagnosesInput
    diagnosis: DiagnosisCreateNestedOneWithoutEncountersInput
  }

  export type EncounterDiagnosisUncheckedCreateWithoutSterilizationIndicatorsInput = {
    id?: number
    encounterId: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisCreateOrConnectWithoutSterilizationIndicatorsInput = {
    where: EncounterDiagnosisWhereUniqueInput
    create: XOR<EncounterDiagnosisCreateWithoutSterilizationIndicatorsInput, EncounterDiagnosisUncheckedCreateWithoutSterilizationIndicatorsInput>
  }

  export type SterilizationIndicatorCreateWithoutEncounterDiagnosisLinksInput = {
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSterilizationIndicatorsInput
    specialist: UserCreateNestedOneWithoutSterilizationIndicatorsInput
    items?: SterilizationIndicatorItemCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisLinksInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SterilizationIndicatorItemUncheckedCreateNestedManyWithoutIndicatorInput
    uses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutIndicatorInput
  }

  export type SterilizationIndicatorCreateOrConnectWithoutEncounterDiagnosisLinksInput = {
    where: SterilizationIndicatorWhereUniqueInput
    create: XOR<SterilizationIndicatorCreateWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisLinksInput>
  }

  export type EncounterDiagnosisUpsertWithoutSterilizationIndicatorsInput = {
    update: XOR<EncounterDiagnosisUpdateWithoutSterilizationIndicatorsInput, EncounterDiagnosisUncheckedUpdateWithoutSterilizationIndicatorsInput>
    create: XOR<EncounterDiagnosisCreateWithoutSterilizationIndicatorsInput, EncounterDiagnosisUncheckedCreateWithoutSterilizationIndicatorsInput>
    where?: EncounterDiagnosisWhereInput
  }

  export type EncounterDiagnosisUpdateToOneWithWhereWithoutSterilizationIndicatorsInput = {
    where?: EncounterDiagnosisWhereInput
    data: XOR<EncounterDiagnosisUpdateWithoutSterilizationIndicatorsInput, EncounterDiagnosisUncheckedUpdateWithoutSterilizationIndicatorsInput>
  }

  export type EncounterDiagnosisUpdateWithoutSterilizationIndicatorsInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDiagnosesNestedInput
    diagnosis?: DiagnosisUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateWithoutSterilizationIndicatorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorUpsertWithoutEncounterDiagnosisLinksInput = {
    update: XOR<SterilizationIndicatorUpdateWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisLinksInput>
    create: XOR<SterilizationIndicatorCreateWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUncheckedCreateWithoutEncounterDiagnosisLinksInput>
    where?: SterilizationIndicatorWhereInput
  }

  export type SterilizationIndicatorUpdateToOneWithWhereWithoutEncounterDiagnosisLinksInput = {
    where?: SterilizationIndicatorWhereInput
    data: XOR<SterilizationIndicatorUpdateWithoutEncounterDiagnosisLinksInput, SterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisLinksInput>
  }

  export type SterilizationIndicatorUpdateWithoutEncounterDiagnosisLinksInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    specialist?: UserUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    items?: SterilizationIndicatorItemUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type EncounterServiceCreateWithoutServiceInput = {
    quantity?: number
    price: number
    encounter: EncounterCreateNestedOneWithoutEncounterServicesInput
  }

  export type EncounterServiceUncheckedCreateWithoutServiceInput = {
    id?: number
    encounterId: number
    quantity?: number
    price: number
  }

  export type EncounterServiceCreateOrConnectWithoutServiceInput = {
    where: EncounterServiceWhereUniqueInput
    create: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput>
  }

  export type EncounterServiceCreateManyServiceInputEnvelope = {
    data: EncounterServiceCreateManyServiceInput | EncounterServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceBranchCreateWithoutServiceInput = {
    branch: BranchCreateNestedOneWithoutServiceBranchesInput
  }

  export type ServiceBranchUncheckedCreateWithoutServiceInput = {
    branchId: number
  }

  export type ServiceBranchCreateOrConnectWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    create: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBranchCreateManyServiceInputEnvelope = {
    data: ServiceBranchCreateManyServiceInput | ServiceBranchCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutServiceInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutServiceInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceItemCreateManyServiceInputEnvelope = {
    data: InvoiceItemCreateManyServiceInput | InvoiceItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type EncounterServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: EncounterServiceWhereUniqueInput
    update: XOR<EncounterServiceUpdateWithoutServiceInput, EncounterServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<EncounterServiceCreateWithoutServiceInput, EncounterServiceUncheckedCreateWithoutServiceInput>
  }

  export type EncounterServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: EncounterServiceWhereUniqueInput
    data: XOR<EncounterServiceUpdateWithoutServiceInput, EncounterServiceUncheckedUpdateWithoutServiceInput>
  }

  export type EncounterServiceUpdateManyWithWhereWithoutServiceInput = {
    where: EncounterServiceScalarWhereInput
    data: XOR<EncounterServiceUpdateManyMutationInput, EncounterServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceBranchUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    update: XOR<ServiceBranchUpdateWithoutServiceInput, ServiceBranchUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceBranchCreateWithoutServiceInput, ServiceBranchUncheckedCreateWithoutServiceInput>
  }

  export type ServiceBranchUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceBranchWhereUniqueInput
    data: XOR<ServiceBranchUpdateWithoutServiceInput, ServiceBranchUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceBranchUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceBranchScalarWhereInput
    data: XOR<ServiceBranchUpdateManyMutationInput, ServiceBranchUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>
    create: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutServiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: IntFilter<"InvoiceItem"> | number
    invoiceId?: IntFilter<"InvoiceItem"> | number
    itemType?: EnumInvoiceItemTypeFilter<"InvoiceItem"> | $Enums.InvoiceItemType
    serviceId?: IntNullableFilter<"InvoiceItem"> | number | null
    productId?: IntNullableFilter<"InvoiceItem"> | number | null
    procedureCode?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    quantity?: IntFilter<"InvoiceItem"> | number
    lineTotal?: FloatFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    source?: EnumInvoiceItemSourceFilter<"InvoiceItem"> | $Enums.InvoiceItemSource
  }

  export type ServiceCreateWithoutServiceBranchesInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceBranchesInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceBranchesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
  }

  export type BranchCreateWithoutServiceBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServiceBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServiceBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
  }

  export type ServiceUpsertWithoutServiceBranchesInput = {
    update: XOR<ServiceUpdateWithoutServiceBranchesInput, ServiceUncheckedUpdateWithoutServiceBranchesInput>
    create: XOR<ServiceCreateWithoutServiceBranchesInput, ServiceUncheckedCreateWithoutServiceBranchesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceBranchesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceBranchesInput, ServiceUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type ServiceUpdateWithoutServiceBranchesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BranchUpsertWithoutServiceBranchesInput = {
    update: XOR<BranchUpdateWithoutServiceBranchesInput, BranchUncheckedUpdateWithoutServiceBranchesInput>
    create: XOR<BranchCreateWithoutServiceBranchesInput, BranchUncheckedCreateWithoutServiceBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServiceBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServiceBranchesInput, BranchUncheckedUpdateWithoutServiceBranchesInput>
  }

  export type BranchUpdateWithoutServiceBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServiceBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterCreateWithoutEncounterServicesInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutEncounterServicesInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutEncounterServicesInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
  }

  export type ServiceCreateWithoutEncounterServicesInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    serviceBranches?: ServiceBranchCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutEncounterServicesInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutEncounterServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
  }

  export type EncounterUpsertWithoutEncounterServicesInput = {
    update: XOR<EncounterUpdateWithoutEncounterServicesInput, EncounterUncheckedUpdateWithoutEncounterServicesInput>
    create: XOR<EncounterCreateWithoutEncounterServicesInput, EncounterUncheckedCreateWithoutEncounterServicesInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutEncounterServicesInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutEncounterServicesInput, EncounterUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type EncounterUpdateWithoutEncounterServicesInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutEncounterServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type ServiceUpsertWithoutEncounterServicesInput = {
    update: XOR<ServiceUpdateWithoutEncounterServicesInput, ServiceUncheckedUpdateWithoutEncounterServicesInput>
    create: XOR<ServiceCreateWithoutEncounterServicesInput, ServiceUncheckedCreateWithoutEncounterServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutEncounterServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutEncounterServicesInput, ServiceUncheckedUpdateWithoutEncounterServicesInput>
  }

  export type ServiceUpdateWithoutEncounterServicesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceBranches?: ServiceBranchUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutEncounterServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type InvoiceItemCreateWithoutProcedureInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutProcedureInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutProcedureInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput>
  }

  export type InvoiceItemCreateManyProcedureInputEnvelope = {
    data: InvoiceItemCreateManyProcedureInput | InvoiceItemCreateManyProcedureInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProcedureInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProcedureInput, InvoiceItemUncheckedUpdateWithoutProcedureInput>
    create: XOR<InvoiceItemCreateWithoutProcedureInput, InvoiceItemUncheckedCreateWithoutProcedureInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProcedureInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProcedureInput, InvoiceItemUncheckedUpdateWithoutProcedureInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProcedureInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProcedureInput>
  }

  export type BranchCreateWithoutProductsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutProductsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    branchId: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type InvoiceItemCreateWithoutProductInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutProductInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemCreateManyProductInputEnvelope = {
    data: InvoiceItemCreateManyProductInput | InvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockMovementCreateWithoutProductInput = {
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductStockMovementsInput
  }

  export type ProductStockMovementUncheckedCreateWithoutProductInput = {
    id?: number
    branchId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type ProductStockMovementCreateOrConnectWithoutProductInput = {
    where: ProductStockMovementWhereUniqueInput
    create: XOR<ProductStockMovementCreateWithoutProductInput, ProductStockMovementUncheckedCreateWithoutProductInput>
  }

  export type ProductStockMovementCreateManyProductInputEnvelope = {
    data: ProductStockMovementCreateManyProductInput | ProductStockMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutProductsInput = {
    update: XOR<BranchUpdateWithoutProductsInput, BranchUncheckedUpdateWithoutProductsInput>
    create: XOR<BranchCreateWithoutProductsInput, BranchUncheckedCreateWithoutProductsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutProductsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutProductsInput, BranchUncheckedUpdateWithoutProductsInput>
  }

  export type BranchUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductStockMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductStockMovementWhereUniqueInput
    update: XOR<ProductStockMovementUpdateWithoutProductInput, ProductStockMovementUncheckedUpdateWithoutProductInput>
    create: XOR<ProductStockMovementCreateWithoutProductInput, ProductStockMovementUncheckedCreateWithoutProductInput>
  }

  export type ProductStockMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductStockMovementWhereUniqueInput
    data: XOR<ProductStockMovementUpdateWithoutProductInput, ProductStockMovementUncheckedUpdateWithoutProductInput>
  }

  export type ProductStockMovementUpdateManyWithWhereWithoutProductInput = {
    where: ProductStockMovementScalarWhereInput
    data: XOR<ProductStockMovementUpdateManyMutationInput, ProductStockMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type BranchCreateWithoutProductStockMovementsInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutProductStockMovementsInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutProductStockMovementsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutProductStockMovementsInput, BranchUncheckedCreateWithoutProductStockMovementsInput>
  }

  export type ProductCreateWithoutStockMovementsInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockMovementsInput = {
    id?: number
    branchId: number
    categoryId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockMovementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
  }

  export type BranchUpsertWithoutProductStockMovementsInput = {
    update: XOR<BranchUpdateWithoutProductStockMovementsInput, BranchUncheckedUpdateWithoutProductStockMovementsInput>
    create: XOR<BranchCreateWithoutProductStockMovementsInput, BranchUncheckedCreateWithoutProductStockMovementsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutProductStockMovementsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutProductStockMovementsInput, BranchUncheckedUpdateWithoutProductStockMovementsInput>
  }

  export type BranchUpdateWithoutProductStockMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutProductStockMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ProductUpsertWithoutStockMovementsInput = {
    update: XOR<ProductUpdateWithoutStockMovementsInput, ProductUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<ProductCreateWithoutStockMovementsInput, ProductUncheckedCreateWithoutStockMovementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockMovementsInput, ProductUncheckedUpdateWithoutStockMovementsInput>
  }

  export type ProductUpdateWithoutStockMovementsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BranchCreateWithoutProductCategoriesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutProductCategoriesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutProductCategoriesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutProductCategoriesInput, BranchUncheckedCreateWithoutProductCategoriesInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductsInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    stockMovements?: ProductStockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    branchId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    stockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutProductCategoriesInput = {
    update: XOR<BranchUpdateWithoutProductCategoriesInput, BranchUncheckedUpdateWithoutProductCategoriesInput>
    create: XOR<BranchCreateWithoutProductCategoriesInput, BranchUncheckedCreateWithoutProductCategoriesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutProductCategoriesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutProductCategoriesInput, BranchUncheckedUpdateWithoutProductCategoriesInput>
  }

  export type BranchUpdateWithoutProductCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutProductCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EncounterCreateWithoutPrescriptionInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPrescriptionInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateWithoutPrescriptionInput = {
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionItemCreateManyPrescriptionInput | PrescriptionItemCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutPrescriptionInput = {
    update: XOR<EncounterUpdateWithoutPrescriptionInput, EncounterUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<EncounterCreateWithoutPrescriptionInput, EncounterUncheckedCreateWithoutPrescriptionInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutPrescriptionInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutPrescriptionInput, EncounterUncheckedUpdateWithoutPrescriptionInput>
  }

  export type EncounterUpdateWithoutPrescriptionInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionItemScalarWhereInput = {
    AND?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    OR?: PrescriptionItemScalarWhereInput[]
    NOT?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    id?: IntFilter<"PrescriptionItem"> | number
    prescriptionId?: IntFilter<"PrescriptionItem"> | number
    order?: IntFilter<"PrescriptionItem"> | number
    drugName?: StringFilter<"PrescriptionItem"> | string
    durationDays?: IntFilter<"PrescriptionItem"> | number
    quantityPerTake?: IntFilter<"PrescriptionItem"> | number
    frequencyPerDay?: IntFilter<"PrescriptionItem"> | number
    note?: StringNullableFilter<"PrescriptionItem"> | string | null
  }

  export type PrescriptionCreateWithoutItemsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
    encounter: EncounterCreateNestedOneWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutItemsInput = {
    id?: number
    encounterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorNameSnapshot?: string | null
    patientNameSnapshot?: string | null
    diagnosisSummary?: string | null
    clinicNameSnapshot?: string | null
  }

  export type PrescriptionCreateOrConnectWithoutItemsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
  }

  export type PrescriptionUpsertWithoutItemsInput = {
    update: XOR<PrescriptionUpdateWithoutItemsInput, PrescriptionUncheckedUpdateWithoutItemsInput>
    create: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutItemsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutItemsInput, PrescriptionUncheckedUpdateWithoutItemsInput>
  }

  export type PrescriptionUpdateWithoutItemsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    encounter?: EncounterUpdateOneRequiredWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    patientNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosisSummary?: NullableStringFieldUpdateOperationsInput | string | null
    clinicNameSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BranchCreateWithoutInvoicesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutInvoicesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
  }

  export type EncounterCreateWithoutInvoiceInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    media?: MediaCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutInvoiceInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    media?: MediaUncheckedCreateNestedManyWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutInvoiceInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
  }

  export type PatientCreateWithoutInvoicesInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    itemType: $Enums.InvoiceItemType
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
    service?: ServiceCreateNestedOneWithoutInvoiceItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    procedure?: ProcedureCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EBarimtReceiptCreateWithoutInvoiceInput = {
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptUncheckedCreateWithoutInvoiceInput = {
    id?: number
    receiptNumber: string
    timestamp?: Date | string
  }

  export type EBarimtReceiptCreateOrConnectWithoutInvoiceInput = {
    where: EBarimtReceiptWhereUniqueInput
    create: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
  }

  export type LedgerEntryCreateWithoutInvoiceInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutInvoiceInput = {
    id?: number
    branchId: number
    patientId: number
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutInvoiceInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput>
  }

  export type LedgerEntryCreateManyInvoiceInputEnvelope = {
    data: LedgerEntryCreateManyInvoiceInput | LedgerEntryCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeBenefitUsageCreateWithoutInvoiceInput = {
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
    employeeBenefit: EmployeeBenefitCreateNestedOneWithoutUsagesInput
    encounter: EncounterCreateNestedOneWithoutEmployeeBenefitUsagesInput
    patient: PatientCreateNestedOneWithoutEmployeeBenefitUsagesInput
  }

  export type EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput = {
    id?: number
    employeeBenefitId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateOrConnectWithoutInvoiceInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    create: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput>
  }

  export type EmployeeBenefitUsageCreateManyInvoiceInputEnvelope = {
    data: EmployeeBenefitUsageCreateManyInvoiceInput | EmployeeBenefitUsageCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutInvoicesInput = {
    update: XOR<BranchUpdateWithoutInvoicesInput, BranchUncheckedUpdateWithoutInvoicesInput>
    create: XOR<BranchCreateWithoutInvoicesInput, BranchUncheckedCreateWithoutInvoicesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutInvoicesInput, BranchUncheckedUpdateWithoutInvoicesInput>
  }

  export type BranchUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithoutInvoiceInput = {
    update: XOR<EncounterUpdateWithoutInvoiceInput, EncounterUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EncounterCreateWithoutInvoiceInput, EncounterUncheckedCreateWithoutInvoiceInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutInvoiceInput, EncounterUncheckedUpdateWithoutInvoiceInput>
  }

  export type EncounterUpdateWithoutInvoiceInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type EBarimtReceiptUpsertWithoutInvoiceInput = {
    update: XOR<EBarimtReceiptUpdateWithoutInvoiceInput, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EBarimtReceiptCreateWithoutInvoiceInput, EBarimtReceiptUncheckedCreateWithoutInvoiceInput>
    where?: EBarimtReceiptWhereInput
  }

  export type EBarimtReceiptUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: EBarimtReceiptWhereInput
    data: XOR<EBarimtReceiptUpdateWithoutInvoiceInput, EBarimtReceiptUncheckedUpdateWithoutInvoiceInput>
  }

  export type EBarimtReceiptUpdateWithoutInvoiceInput = {
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EBarimtReceiptUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptNumber?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutInvoiceInput, LedgerEntryUncheckedUpdateWithoutInvoiceInput>
    create: XOR<LedgerEntryCreateWithoutInvoiceInput, LedgerEntryUncheckedCreateWithoutInvoiceInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutInvoiceInput, LedgerEntryUncheckedUpdateWithoutInvoiceInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutInvoiceInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    invoiceId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    qpayTxnId?: StringNullableFilter<"Payment"> | string | null
    timestamp?: DateTimeFilter<"Payment"> | Date | string
  }

  export type EmployeeBenefitUsageUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    update: XOR<EmployeeBenefitUsageUpdateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EmployeeBenefitUsageCreateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedCreateWithoutInvoiceInput>
  }

  export type EmployeeBenefitUsageUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: EmployeeBenefitUsageWhereUniqueInput
    data: XOR<EmployeeBenefitUsageUpdateWithoutInvoiceInput, EmployeeBenefitUsageUncheckedUpdateWithoutInvoiceInput>
  }

  export type EmployeeBenefitUsageUpdateManyWithWhereWithoutInvoiceInput = {
    where: EmployeeBenefitUsageScalarWhereInput
    data: XOR<EmployeeBenefitUsageUpdateManyMutationInput, EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCreateWithoutInvoiceItemsInput = {
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    code?: string | null
    category: $Enums.ServiceCategory
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutServiceInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ProductCreateWithoutInvoiceItemsInput = {
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    stockMovements?: ProductStockMovementCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInvoiceItemsInput = {
    id?: number
    branchId: number
    categoryId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ProcedureCreateWithoutInvoiceItemsInput = {
    code: string
    name: string
    price: number
  }

  export type ProcedureUncheckedCreateWithoutInvoiceItemsInput = {
    code: string
    name: string
    price: number
  }

  export type ProcedureCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProcedureWhereUniqueInput
    create: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ServiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<ServiceUpdateWithoutInvoiceItemsInput, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutInvoiceItemsInput, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ServiceUpdateWithoutInvoiceItemsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutServiceNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProductUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateWithoutInvoiceItemsInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    stockMovements?: ProductStockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockMovements?: ProductStockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProcedureUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProcedureUpdateWithoutInvoiceItemsInput, ProcedureUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProcedureCreateWithoutInvoiceItemsInput, ProcedureUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProcedureWhereInput
  }

  export type ProcedureUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProcedureWhereInput
    data: XOR<ProcedureUpdateWithoutInvoiceItemsInput, ProcedureUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProcedureUpdateWithoutInvoiceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ProcedureUncheckedUpdateWithoutInvoiceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutEBarimtReceiptInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEBarimtReceiptInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEBarimtReceiptInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
  }

  export type InvoiceUpsertWithoutEBarimtReceiptInput = {
    update: XOR<InvoiceUpdateWithoutEBarimtReceiptInput, InvoiceUncheckedUpdateWithoutEBarimtReceiptInput>
    create: XOR<InvoiceCreateWithoutEBarimtReceiptInput, InvoiceUncheckedCreateWithoutEBarimtReceiptInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEBarimtReceiptInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEBarimtReceiptInput, InvoiceUncheckedUpdateWithoutEBarimtReceiptInput>
  }

  export type InvoiceUpdateWithoutEBarimtReceiptInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEBarimtReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type BranchCreateWithoutLedgerEntriesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutLedgerEntriesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type PatientCreateWithoutLedgerEntriesInput = {
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    patientBook?: PatientBookCreateNestedOneWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    bookings?: BookingCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branchId: number
    patientBook?: PatientBookUncheckedCreateNestedOneWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    bookings?: BookingUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLedgerEntriesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type InvoiceCreateWithoutLedgerEntriesInput = {
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutInvoicesInput
    encounter: EncounterCreateNestedOneWithoutInvoiceInput
    patient?: PatientCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptCreateNestedOneWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eBarimtReceipt?: EBarimtReceiptUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLedgerEntriesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type UserCreateWithoutCreatedLedgerEntriesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutCreatedLedgerEntriesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutCreatedLedgerEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
  }

  export type UserCreateWithoutApprovedLedgerEntriesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutApprovedLedgerEntriesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutApprovedLedgerEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
  }

  export type AuthorizationCodeCreateWithoutLedgerEntriesInput = {
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAuthorizationCodesInput
  }

  export type AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdById: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorizationCodeCreateOrConnectWithoutLedgerEntriesInput = {
    where: AuthorizationCodeWhereUniqueInput
    create: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type EmployeeVoucherCreateWithoutLedgerEntriesInput = {
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEmployeeVouchersInput
    employee: UserCreateNestedOneWithoutEmployeeVouchersInput
    createdBy: UserCreateNestedOneWithoutCreatedEmployeeVouchersInput
  }

  export type EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type EmployeeVoucherCreateOrConnectWithoutLedgerEntriesInput = {
    where: EmployeeVoucherWhereUniqueInput
    create: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type BranchUpsertWithoutLedgerEntriesInput = {
    update: XOR<BranchUpdateWithoutLedgerEntriesInput, BranchUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<BranchCreateWithoutLedgerEntriesInput, BranchUncheckedCreateWithoutLedgerEntriesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutLedgerEntriesInput, BranchUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type BranchUpdateWithoutLedgerEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutLedgerEntriesInput = {
    update: XOR<PatientUpdateWithoutLedgerEntriesInput, PatientUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<PatientCreateWithoutLedgerEntriesInput, PatientUncheckedCreateWithoutLedgerEntriesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLedgerEntriesInput, PatientUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type PatientUpdateWithoutLedgerEntriesInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchId?: IntFieldUpdateOperationsInput | number
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceUpsertWithoutLedgerEntriesInput = {
    update: XOR<InvoiceUpdateWithoutLedgerEntriesInput, InvoiceUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<InvoiceCreateWithoutLedgerEntriesInput, InvoiceUncheckedCreateWithoutLedgerEntriesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLedgerEntriesInput, InvoiceUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type InvoiceUpdateWithoutLedgerEntriesInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type UserUpsertWithoutCreatedLedgerEntriesInput = {
    update: XOR<UserUpdateWithoutCreatedLedgerEntriesInput, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
    create: XOR<UserCreateWithoutCreatedLedgerEntriesInput, UserUncheckedCreateWithoutCreatedLedgerEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLedgerEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLedgerEntriesInput, UserUncheckedUpdateWithoutCreatedLedgerEntriesInput>
  }

  export type UserUpdateWithoutCreatedLedgerEntriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUpsertWithoutApprovedLedgerEntriesInput = {
    update: XOR<UserUpdateWithoutApprovedLedgerEntriesInput, UserUncheckedUpdateWithoutApprovedLedgerEntriesInput>
    create: XOR<UserCreateWithoutApprovedLedgerEntriesInput, UserUncheckedCreateWithoutApprovedLedgerEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedLedgerEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedLedgerEntriesInput, UserUncheckedUpdateWithoutApprovedLedgerEntriesInput>
  }

  export type UserUpdateWithoutApprovedLedgerEntriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type AuthorizationCodeUpsertWithoutLedgerEntriesInput = {
    update: XOR<AuthorizationCodeUpdateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<AuthorizationCodeCreateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedCreateWithoutLedgerEntriesInput>
    where?: AuthorizationCodeWhereInput
  }

  export type AuthorizationCodeUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: AuthorizationCodeWhereInput
    data: XOR<AuthorizationCodeUpdateWithoutLedgerEntriesInput, AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type AuthorizationCodeUpdateWithoutLedgerEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAuthorizationCodesNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUpsertWithoutLedgerEntriesInput = {
    update: XOR<EmployeeVoucherUpdateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<EmployeeVoucherCreateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedCreateWithoutLedgerEntriesInput>
    where?: EmployeeVoucherWhereInput
  }

  export type EmployeeVoucherUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: EmployeeVoucherWhereInput
    data: XOR<EmployeeVoucherUpdateWithoutLedgerEntriesInput, EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type EmployeeVoucherUpdateWithoutLedgerEntriesInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutAuthorizationCodesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutAuthorizationCodesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutAuthorizationCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
  }

  export type LedgerEntryCreateWithoutApprovalCodeInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    employeeVoucher?: EmployeeVoucherCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutApprovalCodeInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutApprovalCodeInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput>
  }

  export type LedgerEntryCreateManyApprovalCodeInputEnvelope = {
    data: LedgerEntryCreateManyApprovalCodeInput | LedgerEntryCreateManyApprovalCodeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAuthorizationCodesInput = {
    update: XOR<UserUpdateWithoutAuthorizationCodesInput, UserUncheckedUpdateWithoutAuthorizationCodesInput>
    create: XOR<UserCreateWithoutAuthorizationCodesInput, UserUncheckedCreateWithoutAuthorizationCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorizationCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorizationCodesInput, UserUncheckedUpdateWithoutAuthorizationCodesInput>
  }

  export type UserUpdateWithoutAuthorizationCodesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorizationCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutApprovalCodeInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutApprovalCodeInput, LedgerEntryUncheckedUpdateWithoutApprovalCodeInput>
    create: XOR<LedgerEntryCreateWithoutApprovalCodeInput, LedgerEntryUncheckedCreateWithoutApprovalCodeInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutApprovalCodeInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutApprovalCodeInput, LedgerEntryUncheckedUpdateWithoutApprovalCodeInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutApprovalCodeInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutApprovalCodeInput>
  }

  export type BranchCreateWithoutEmployeeVouchersInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEmployeeVouchersInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEmployeeVouchersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
  }

  export type UserCreateWithoutEmployeeVouchersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutEmployeeVouchersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutEmployeeVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
  }

  export type LedgerEntryCreateWithoutEmployeeVoucherInput = {
    type: $Enums.LedgerEntryType
    amount: number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutLedgerEntriesInput
    patient: PatientCreateNestedOneWithoutLedgerEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutLedgerEntriesInput
    createdBy: UserCreateNestedOneWithoutCreatedLedgerEntriesInput
    approvedBy?: UserCreateNestedOneWithoutApprovedLedgerEntriesInput
    approvalCode?: AuthorizationCodeCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateOrConnectWithoutEmployeeVoucherInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput>
  }

  export type LedgerEntryCreateManyEmployeeVoucherInputEnvelope = {
    data: LedgerEntryCreateManyEmployeeVoucherInput | LedgerEntryCreateManyEmployeeVoucherInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedEmployeeVouchersInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutCreatedEmployeeVouchersInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutCreatedEmployeeVouchersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
  }

  export type BranchUpsertWithoutEmployeeVouchersInput = {
    update: XOR<BranchUpdateWithoutEmployeeVouchersInput, BranchUncheckedUpdateWithoutEmployeeVouchersInput>
    create: XOR<BranchCreateWithoutEmployeeVouchersInput, BranchUncheckedCreateWithoutEmployeeVouchersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEmployeeVouchersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEmployeeVouchersInput, BranchUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type BranchUpdateWithoutEmployeeVouchersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEmployeeVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutEmployeeVouchersInput = {
    update: XOR<UserUpdateWithoutEmployeeVouchersInput, UserUncheckedUpdateWithoutEmployeeVouchersInput>
    create: XOR<UserCreateWithoutEmployeeVouchersInput, UserUncheckedCreateWithoutEmployeeVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeVouchersInput, UserUncheckedUpdateWithoutEmployeeVouchersInput>
  }

  export type UserUpdateWithoutEmployeeVouchersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutEmployeeVoucherInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutEmployeeVoucherInput, LedgerEntryUncheckedUpdateWithoutEmployeeVoucherInput>
    create: XOR<LedgerEntryCreateWithoutEmployeeVoucherInput, LedgerEntryUncheckedCreateWithoutEmployeeVoucherInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutEmployeeVoucherInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutEmployeeVoucherInput, LedgerEntryUncheckedUpdateWithoutEmployeeVoucherInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutEmployeeVoucherInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherInput>
  }

  export type UserUpsertWithoutCreatedEmployeeVouchersInput = {
    update: XOR<UserUpdateWithoutCreatedEmployeeVouchersInput, UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput>
    create: XOR<UserCreateWithoutCreatedEmployeeVouchersInput, UserUncheckedCreateWithoutCreatedEmployeeVouchersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedEmployeeVouchersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedEmployeeVouchersInput, UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput>
  }

  export type UserUpdateWithoutCreatedEmployeeVouchersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedEmployeeVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type EncounterCreateWithoutMediaInput = {
    visitDate: Date | string
    notes?: string | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    patientBook: PatientBookCreateNestedOneWithoutEncountersInput
    doctor: UserCreateNestedOneWithoutEncountersInput
    appointment?: AppointmentCreateNestedOneWithoutEncountersInput
    nurse?: UserCreateNestedOneWithoutNurseEncountersInput
    chartTeeth?: ChartToothCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionCreateNestedOneWithoutEncounterInput
    encounterServices?: EncounterServiceCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutMediaInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
    chartTeeth?: ChartToothUncheckedCreateNestedManyWithoutEncounterInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutEncounterInput
    prescription?: PrescriptionUncheckedCreateNestedOneWithoutEncounterInput
    encounterServices?: EncounterServiceUncheckedCreateNestedManyWithoutEncounterInput
    diagnoses?: EncounterDiagnosisUncheckedCreateNestedManyWithoutEncounterInput
    consents?: EncounterConsentUncheckedCreateNestedManyWithoutEncounterInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutEncounterInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutMediaInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
  }

  export type EncounterUpsertWithoutMediaInput = {
    update: XOR<EncounterUpdateWithoutMediaInput, EncounterUncheckedUpdateWithoutMediaInput>
    create: XOR<EncounterCreateWithoutMediaInput, EncounterUncheckedCreateWithoutMediaInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutMediaInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutMediaInput, EncounterUncheckedUpdateWithoutMediaInput>
  }

  export type EncounterUpdateWithoutMediaInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type UserCreateWithoutDoctorSchedulesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutDoctorSchedulesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutDoctorSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
  }

  export type BranchCreateWithoutDoctorSchedulesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDoctorSchedulesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDoctorSchedulesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
  }

  export type UserUpsertWithoutDoctorSchedulesInput = {
    update: XOR<UserUpdateWithoutDoctorSchedulesInput, UserUncheckedUpdateWithoutDoctorSchedulesInput>
    create: XOR<UserCreateWithoutDoctorSchedulesInput, UserUncheckedCreateWithoutDoctorSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorSchedulesInput, UserUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type UserUpdateWithoutDoctorSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutDoctorSchedulesInput = {
    update: XOR<BranchUpdateWithoutDoctorSchedulesInput, BranchUncheckedUpdateWithoutDoctorSchedulesInput>
    create: XOR<BranchCreateWithoutDoctorSchedulesInput, BranchUncheckedCreateWithoutDoctorSchedulesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDoctorSchedulesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDoctorSchedulesInput, BranchUncheckedUpdateWithoutDoctorSchedulesInput>
  }

  export type BranchUpdateWithoutDoctorSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDoctorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutReceptionSchedulesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutReceptionSchedulesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutReceptionSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
  }

  export type BranchCreateWithoutReceptionSchedulesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutReceptionSchedulesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutReceptionSchedulesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
  }

  export type UserUpsertWithoutReceptionSchedulesInput = {
    update: XOR<UserUpdateWithoutReceptionSchedulesInput, UserUncheckedUpdateWithoutReceptionSchedulesInput>
    create: XOR<UserCreateWithoutReceptionSchedulesInput, UserUncheckedCreateWithoutReceptionSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceptionSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceptionSchedulesInput, UserUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type UserUpdateWithoutReceptionSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceptionSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutReceptionSchedulesInput = {
    update: XOR<BranchUpdateWithoutReceptionSchedulesInput, BranchUncheckedUpdateWithoutReceptionSchedulesInput>
    create: XOR<BranchCreateWithoutReceptionSchedulesInput, BranchUncheckedCreateWithoutReceptionSchedulesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutReceptionSchedulesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutReceptionSchedulesInput, BranchUncheckedUpdateWithoutReceptionSchedulesInput>
  }

  export type BranchUpdateWithoutReceptionSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutReceptionSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutDoctorBranchesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutDoctorBranchesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutDoctorBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
  }

  export type BranchCreateWithoutDoctorBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDoctorBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDoctorBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
  }

  export type UserUpsertWithoutDoctorBranchesInput = {
    update: XOR<UserUpdateWithoutDoctorBranchesInput, UserUncheckedUpdateWithoutDoctorBranchesInput>
    create: XOR<UserCreateWithoutDoctorBranchesInput, UserUncheckedCreateWithoutDoctorBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorBranchesInput, UserUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type UserUpdateWithoutDoctorBranchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutDoctorBranchesInput = {
    update: XOR<BranchUpdateWithoutDoctorBranchesInput, BranchUncheckedUpdateWithoutDoctorBranchesInput>
    create: XOR<BranchCreateWithoutDoctorBranchesInput, BranchUncheckedCreateWithoutDoctorBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDoctorBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDoctorBranchesInput, BranchUncheckedUpdateWithoutDoctorBranchesInput>
  }

  export type BranchUpdateWithoutDoctorBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDoctorBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutReceptionBranchesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutReceptionBranchesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutReceptionBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
  }

  export type BranchCreateWithoutReceptionBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutReceptionBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutReceptionBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
  }

  export type UserUpsertWithoutReceptionBranchesInput = {
    update: XOR<UserUpdateWithoutReceptionBranchesInput, UserUncheckedUpdateWithoutReceptionBranchesInput>
    create: XOR<UserCreateWithoutReceptionBranchesInput, UserUncheckedCreateWithoutReceptionBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceptionBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceptionBranchesInput, UserUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type UserUpdateWithoutReceptionBranchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceptionBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutReceptionBranchesInput = {
    update: XOR<BranchUpdateWithoutReceptionBranchesInput, BranchUncheckedUpdateWithoutReceptionBranchesInput>
    create: XOR<BranchCreateWithoutReceptionBranchesInput, BranchUncheckedCreateWithoutReceptionBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutReceptionBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutReceptionBranchesInput, BranchUncheckedUpdateWithoutReceptionBranchesInput>
  }

  export type BranchUpdateWithoutReceptionBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutReceptionBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutNurseBranchesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutNurseBranchesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutNurseBranchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
  }

  export type BranchCreateWithoutNurseBranchesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutNurseBranchesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseSchedules?: NurseScheduleUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutNurseBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
  }

  export type UserUpsertWithoutNurseBranchesInput = {
    update: XOR<UserUpdateWithoutNurseBranchesInput, UserUncheckedUpdateWithoutNurseBranchesInput>
    create: XOR<UserCreateWithoutNurseBranchesInput, UserUncheckedCreateWithoutNurseBranchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseBranchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseBranchesInput, UserUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type UserUpdateWithoutNurseBranchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutNurseBranchesInput = {
    update: XOR<BranchUpdateWithoutNurseBranchesInput, BranchUncheckedUpdateWithoutNurseBranchesInput>
    create: XOR<BranchCreateWithoutNurseBranchesInput, BranchUncheckedCreateWithoutNurseBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutNurseBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutNurseBranchesInput, BranchUncheckedUpdateWithoutNurseBranchesInput>
  }

  export type BranchUpdateWithoutNurseBranchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutNurseBranchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserCreateWithoutNurseSchedulesInput = {
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    encounters?: EncounterCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutReceptionInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutNurseInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    bookings?: BookingCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseCreateNestedManyWithoutOpenedByInput
  }

  export type UserUncheckedCreateWithoutNurseSchedulesInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    branchId?: number | null
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
    encounters?: EncounterUncheckedCreateNestedManyWithoutDoctorInput
    nurseEncounters?: EncounterUncheckedCreateNestedManyWithoutNurseInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutDoctorInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutDoctorInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutReceptionInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutReceptionInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutNurseInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    bookings?: BookingUncheckedCreateNestedManyWithoutDoctorInput
    employeeBenefits?: EmployeeBenefitUncheckedCreateNestedManyWithoutEmployeeInput
    createdLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutCreatedByInput
    approvedLedgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutApprovedByInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutEmployeeInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutCreatedByInput
    authorizationCodes?: AuthorizationCodeUncheckedCreateNestedManyWithoutCreatedByInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutSpecialistInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedCreateNestedManyWithoutOpenedByInput
  }

  export type UserCreateOrConnectWithoutNurseSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
  }

  export type BranchCreateWithoutNurseSchedulesInput = {
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchCreateNestedManyWithoutBranchInput
    appointments?: AppointmentCreateNestedManyWithoutBranchInput
    bookings?: BookingCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchCreateNestedManyWithoutBranchInput
    products?: ProductCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementCreateNestedManyWithoutBranchInput
    invoices?: InvoiceCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutNurseSchedulesInput = {
    id?: number
    name: string
    address?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    doctorSchedules?: DoctorScheduleUncheckedCreateNestedManyWithoutBranchInput
    serviceBranches?: ServiceBranchUncheckedCreateNestedManyWithoutBranchInput
    doctorBranches?: DoctorBranchUncheckedCreateNestedManyWithoutBranchInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutBranchInput
    bookings?: BookingUncheckedCreateNestedManyWithoutBranchInput
    receptionSchedules?: ReceptionScheduleUncheckedCreateNestedManyWithoutBranchInput
    receptionBranches?: ReceptionBranchUncheckedCreateNestedManyWithoutBranchInput
    nurseBranches?: NurseBranchUncheckedCreateNestedManyWithoutBranchInput
    products?: ProductUncheckedCreateNestedManyWithoutBranchInput
    productCategories?: ProductCategoryUncheckedCreateNestedManyWithoutBranchInput
    productStockMovements?: ProductStockMovementUncheckedCreateNestedManyWithoutBranchInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutBranchInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBranchInput
    employeeVouchers?: EmployeeVoucherUncheckedCreateNestedManyWithoutBranchInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutNurseSchedulesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
  }

  export type UserUpsertWithoutNurseSchedulesInput = {
    update: XOR<UserUpdateWithoutNurseSchedulesInput, UserUncheckedUpdateWithoutNurseSchedulesInput>
    create: XOR<UserCreateWithoutNurseSchedulesInput, UserUncheckedCreateWithoutNurseSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNurseSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNurseSchedulesInput, UserUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type UserUpdateWithoutNurseSchedulesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNurseSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type BranchUpsertWithoutNurseSchedulesInput = {
    update: XOR<BranchUpdateWithoutNurseSchedulesInput, BranchUncheckedUpdateWithoutNurseSchedulesInput>
    create: XOR<BranchCreateWithoutNurseSchedulesInput, BranchUncheckedCreateWithoutNurseSchedulesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutNurseSchedulesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutNurseSchedulesInput, BranchUncheckedUpdateWithoutNurseSchedulesInput>
  }

  export type BranchUpdateWithoutNurseSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUpdateManyWithoutBranchNestedInput
    bookings?: BookingUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutBranchNestedInput
    products?: ProductUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutNurseSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutBranchNestedInput
    serviceBranches?: ServiceBranchUncheckedUpdateManyWithoutBranchNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutBranchNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutBranchNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutBranchNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutBranchNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutBranchNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutBranchNestedInput
    products?: ProductUncheckedUpdateManyWithoutBranchNestedInput
    productCategories?: ProductCategoryUncheckedUpdateManyWithoutBranchNestedInput
    productStockMovements?: ProductStockMovementUncheckedUpdateManyWithoutBranchNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutBranchNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBranchNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutBranchNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PaymentProviderConfigCreateWithoutMethodInput = {
    name: string
    isActive?: boolean
    sortOrder?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigUncheckedCreateWithoutMethodInput = {
    id?: number
    name: string
    isActive?: boolean
    sortOrder?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigCreateOrConnectWithoutMethodInput = {
    where: PaymentProviderConfigWhereUniqueInput
    create: XOR<PaymentProviderConfigCreateWithoutMethodInput, PaymentProviderConfigUncheckedCreateWithoutMethodInput>
  }

  export type PaymentProviderConfigCreateManyMethodInputEnvelope = {
    data: PaymentProviderConfigCreateManyMethodInput | PaymentProviderConfigCreateManyMethodInput[]
    skipDuplicates?: boolean
  }

  export type PaymentProviderConfigUpsertWithWhereUniqueWithoutMethodInput = {
    where: PaymentProviderConfigWhereUniqueInput
    update: XOR<PaymentProviderConfigUpdateWithoutMethodInput, PaymentProviderConfigUncheckedUpdateWithoutMethodInput>
    create: XOR<PaymentProviderConfigCreateWithoutMethodInput, PaymentProviderConfigUncheckedCreateWithoutMethodInput>
  }

  export type PaymentProviderConfigUpdateWithWhereUniqueWithoutMethodInput = {
    where: PaymentProviderConfigWhereUniqueInput
    data: XOR<PaymentProviderConfigUpdateWithoutMethodInput, PaymentProviderConfigUncheckedUpdateWithoutMethodInput>
  }

  export type PaymentProviderConfigUpdateManyWithWhereWithoutMethodInput = {
    where: PaymentProviderConfigScalarWhereInput
    data: XOR<PaymentProviderConfigUpdateManyMutationInput, PaymentProviderConfigUncheckedUpdateManyWithoutMethodInput>
  }

  export type PaymentProviderConfigScalarWhereInput = {
    AND?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
    OR?: PaymentProviderConfigScalarWhereInput[]
    NOT?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
    id?: IntFilter<"PaymentProviderConfig"> | number
    methodKey?: StringFilter<"PaymentProviderConfig"> | string
    name?: StringFilter<"PaymentProviderConfig"> | string
    isActive?: BoolFilter<"PaymentProviderConfig"> | boolean
    sortOrder?: IntFilter<"PaymentProviderConfig"> | number
    note?: StringNullableFilter<"PaymentProviderConfig"> | string | null
    createdAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
  }

  export type PaymentMethodConfigCreateWithoutProvidersInput = {
    key: string
    label: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodConfigUncheckedCreateWithoutProvidersInput = {
    id?: number
    key: string
    label: string
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodConfigCreateOrConnectWithoutProvidersInput = {
    where: PaymentMethodConfigWhereUniqueInput
    create: XOR<PaymentMethodConfigCreateWithoutProvidersInput, PaymentMethodConfigUncheckedCreateWithoutProvidersInput>
  }

  export type PaymentMethodConfigUpsertWithoutProvidersInput = {
    update: XOR<PaymentMethodConfigUpdateWithoutProvidersInput, PaymentMethodConfigUncheckedUpdateWithoutProvidersInput>
    create: XOR<PaymentMethodConfigCreateWithoutProvidersInput, PaymentMethodConfigUncheckedCreateWithoutProvidersInput>
    where?: PaymentMethodConfigWhereInput
  }

  export type PaymentMethodConfigUpdateToOneWithWhereWithoutProvidersInput = {
    where?: PaymentMethodConfigWhereInput
    data: XOR<PaymentMethodConfigUpdateWithoutProvidersInput, PaymentMethodConfigUncheckedUpdateWithoutProvidersInput>
  }

  export type PaymentMethodConfigUpdateWithoutProvidersInput = {
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodConfigUncheckedUpdateWithoutProvidersInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: number
    email: string
    password: string
    ovog?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    phone?: string | null
    regNo?: string | null
    licenseNumber?: string | null
    licenseExpiryDate?: Date | string | null
    signatureImagePath?: string | null
    stampImagePath?: string | null
    idPhotoPath?: string | null
    calendarOrder?: number | null
  }

  export type PatientCreateManyBranchInput = {
    id?: number
    regNo?: string | null
    ovog?: string | null
    name: string
    gender?: string | null
    birthDate?: Date | string | null
    phone?: string | null
    address?: string | null
    bloodType?: string | null
    citizenship?: string | null
    emergencyPhone?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorScheduleCreateManyBranchInput = {
    id?: number
    doctorId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ServiceBranchCreateManyBranchInput = {
    serviceId: number
  }

  export type DoctorBranchCreateManyBranchInput = {
    id?: number
    doctorId: number
  }

  export type AppointmentCreateManyBranchInput = {
    id?: number
    patientId: number
    doctorId?: number | null
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type BookingCreateManyBranchInput = {
    id?: number
    doctorId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceptionScheduleCreateManyBranchInput = {
    id?: number
    receptionId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionBranchCreateManyBranchInput = {
    id?: number
    receptionId: number
  }

  export type NurseScheduleCreateManyBranchInput = {
    id?: number
    nurseId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseBranchCreateManyBranchInput = {
    id?: number
    nurseId: number
  }

  export type ProductCreateManyBranchInput = {
    id?: number
    categoryId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateManyBranchInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductStockMovementCreateManyBranchInput = {
    id?: number
    productId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type InvoiceCreateManyBranchInput = {
    id?: number
    encounterId: number
    patientId?: number | null
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyBranchInput = {
    id?: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmployeeVoucherCreateManyBranchInput = {
    id?: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type SterilizationIndicatorCreateManyBranchInput = {
    id?: number
    packageName: string
    code: string
    indicatorDate: Date | string
    specialistUserId: number
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
    encounters?: EncounterUncheckedUpdateManyWithoutDoctorNestedInput
    nurseEncounters?: EncounterUncheckedUpdateManyWithoutNurseNestedInput
    doctorSchedules?: DoctorScheduleUncheckedUpdateManyWithoutDoctorNestedInput
    doctorBranches?: DoctorBranchUncheckedUpdateManyWithoutDoctorNestedInput
    receptionSchedules?: ReceptionScheduleUncheckedUpdateManyWithoutReceptionNestedInput
    receptionBranches?: ReceptionBranchUncheckedUpdateManyWithoutReceptionNestedInput
    nurseSchedules?: NurseScheduleUncheckedUpdateManyWithoutNurseNestedInput
    nurseBranches?: NurseBranchUncheckedUpdateManyWithoutNurseNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutDoctorNestedInput
    employeeBenefits?: EmployeeBenefitUncheckedUpdateManyWithoutEmployeeNestedInput
    createdLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutCreatedByNestedInput
    approvedLedgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovedByNestedInput
    employeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutEmployeeNestedInput
    createdEmployeeVouchers?: EmployeeVoucherUncheckedUpdateManyWithoutCreatedByNestedInput
    authorizationCodes?: AuthorizationCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    sterilizationIndicators?: SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistNestedInput
    openedSterilizationPackages?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signatureImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    stampImagePath?: NullableStringFieldUpdateOperationsInput | string | null
    idPhotoPath?: NullableStringFieldUpdateOperationsInput | string | null
    calendarOrder?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PatientUpdateWithoutBranchInput = {
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    bookings?: BookingUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientBook?: PatientBookUncheckedUpdateOneWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutPatientNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: NullableStringFieldUpdateOperationsInput | string | null
    ovog?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    citizenship?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorScheduleUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceBranchUpdateWithoutBranchInput = {
    service?: ServiceUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateWithoutBranchInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceBranchUncheckedUpdateManyWithoutBranchInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchUpdateWithoutBranchInput = {
    doctor?: UserUpdateOneRequiredWithoutDoctorBranchesNestedInput
  }

  export type DoctorBranchUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentUpdateWithoutBranchInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutBookingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceptionScheduleUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    reception?: UserUpdateOneRequiredWithoutReceptionSchedulesNestedInput
  }

  export type ReceptionScheduleUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionBranchUpdateWithoutBranchInput = {
    reception?: UserUpdateOneRequiredWithoutReceptionBranchesNestedInput
  }

  export type ReceptionBranchUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    receptionId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseScheduleUpdateWithoutBranchInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nurse?: UserUpdateOneRequiredWithoutNurseSchedulesNestedInput
  }

  export type NurseScheduleUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseBranchUpdateWithoutBranchInput = {
    nurse?: UserUpdateOneRequiredWithoutNurseBranchesNestedInput
  }

  export type NurseBranchUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    nurseId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutBranchInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    stockMovements?: ProductStockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: ProductStockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockMovementUpdateWithoutBranchInput = {
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type ProductStockMovementUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockMovementUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutBranchInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: PatientUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    patientId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutBranchInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUpdateWithoutBranchInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type SterilizationIndicatorUpdateWithoutBranchInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialist?: UserUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    items?: SterilizationIndicatorItemUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialistUserId?: IntFieldUpdateOperationsInput | number
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageCreateManyEmployeeBenefitInput = {
    id?: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageUpdateWithoutEmployeeBenefitInput = {
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    patient?: PatientUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateWithoutEmployeeBenefitInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationItemCreateManyCategoryInput = {
    id?: number
    name: string
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationItemUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicatorItems?: SterilizationIndicatorItemUpdateManyWithoutItemNestedInput
  }

  export type SterilizationItemUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicatorItems?: SterilizationIndicatorItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SterilizationItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorItemCreateManyItemInput = {
    id?: number
    indicatorId: number
  }

  export type SterilizationIndicatorItemUpdateWithoutItemInput = {
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SterilizationIndicatorItemUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
  }

  export type SterilizationIndicatorItemUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
  }

  export type SterilizationIndicatorItemCreateManyIndicatorInput = {
    id?: number
    itemId: number
  }

  export type EncounterSterilizationPackageUseCreateManyIndicatorInput = {
    id?: number
    encounterId: number
    usedQuantity?: number
    openedByUserId?: number | null
    createdAt?: Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateManyIndicatorInput = {
    id?: number
    encounterDiagnosisId: number
    createdAt?: Date | string
  }

  export type SterilizationIndicatorItemUpdateWithoutIndicatorInput = {
    item?: SterilizationItemUpdateOneRequiredWithoutIndicatorItemsNestedInput
  }

  export type SterilizationIndicatorItemUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterSterilizationPackageUseUpdateWithoutIndicatorInput = {
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutSterilizationPackageUsesNestedInput
    openedBy?: UserUpdateOneWithoutOpenedSterilizationPackagesNestedInput
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    openedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    openedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateWithoutIndicatorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounterDiagnosis?: EncounterDiagnosisUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterDiagnosisId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterDiagnosisId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyDoctorInput = {
    id?: number
    patientBookId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterCreateManyNurseInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type DoctorScheduleCreateManyDoctorInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type DoctorBranchCreateManyDoctorInput = {
    id?: number
    branchId: number
  }

  export type ReceptionScheduleCreateManyReceptionInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type ReceptionBranchCreateManyReceptionInput = {
    id?: number
    branchId: number
  }

  export type NurseScheduleCreateManyNurseInput = {
    id?: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    note?: string | null
  }

  export type NurseBranchCreateManyNurseInput = {
    id?: number
    branchId: number
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: number
    patientId: number
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type BookingCreateManyDoctorInput = {
    id?: number
    branchId: number
    patientId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeBenefitCreateManyEmployeeInput = {
    id?: number
    code: string
    branchId?: number | null
    initialAmount: number
    remainingAmount: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyCreatedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryCreateManyApprovedByInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmployeeVoucherCreateManyEmployeeInput = {
    id?: number
    branchId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: number
  }

  export type EmployeeVoucherCreateManyCreatedByInput = {
    id?: number
    branchId: number
    employeeId: number
    code: string
    status?: $Enums.EmployeeVoucherStatus
    balanceCap: number
    usedAmount?: number
    eligibility: JsonNullValueInput | InputJsonValue
    allowedPatientIds: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorizationCodeCreateManyCreatedByInput = {
    id?: number
    code: string
    purpose: string
    isEnabled?: boolean
    expiresAt?: Date | string | null
    maxUses?: number | null
    usedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SterilizationIndicatorCreateManySpecialistInput = {
    id?: number
    branchId: number
    packageName: string
    code: string
    indicatorDate: Date | string
    packageQuantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterSterilizationPackageUseCreateManyOpenedByInput = {
    id?: number
    encounterId: number
    indicatorId: number
    usedQuantity?: number
    createdAt?: Date | string
  }

  export type EncounterUpdateWithoutDoctorInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterUpdateWithoutNurseInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorScheduleUpdateWithoutDoctorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutDoctorSchedulesNestedInput
  }

  export type DoctorScheduleUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorScheduleUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorBranchUpdateWithoutDoctorInput = {
    branch?: BranchUpdateOneRequiredWithoutDoctorBranchesNestedInput
  }

  export type DoctorBranchUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type DoctorBranchUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionScheduleUpdateWithoutReceptionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutReceptionSchedulesNestedInput
  }

  export type ReceptionScheduleUncheckedUpdateWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionScheduleUncheckedUpdateManyWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceptionBranchUpdateWithoutReceptionInput = {
    branch?: BranchUpdateOneRequiredWithoutReceptionBranchesNestedInput
  }

  export type ReceptionBranchUncheckedUpdateWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ReceptionBranchUncheckedUpdateManyWithoutReceptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseScheduleUpdateWithoutNurseInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    branch?: BranchUpdateOneRequiredWithoutNurseSchedulesNestedInput
  }

  export type NurseScheduleUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseScheduleUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NurseBranchUpdateWithoutNurseInput = {
    branch?: BranchUpdateOneRequiredWithoutNurseBranchesNestedInput
  }

  export type NurseBranchUncheckedUpdateWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type NurseBranchUncheckedUpdateManyWithoutNurseInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutDoctorInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBookingsNestedInput
    patient?: PatientUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUpdateWithoutEmployeeInput = {
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: EmployeeBenefitUsageUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEmployeeBenefitNestedInput
  }

  export type EmployeeBenefitUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    initialAmount?: IntFieldUpdateOperationsInput | number
    remainingAmount?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutCreatedByInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutApprovedByInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeVoucherUpdateWithoutEmployeeInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedEmployeeVouchersNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeVoucherUpdateWithoutCreatedByInput = {
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    employee?: UserUpdateOneRequiredWithoutEmployeeVouchersNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherNestedInput
  }

  export type EmployeeVoucherUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    status?: EnumEmployeeVoucherStatusFieldUpdateOperationsInput | $Enums.EmployeeVoucherStatus
    balanceCap?: FloatFieldUpdateOperationsInput | number
    usedAmount?: FloatFieldUpdateOperationsInput | number
    eligibility?: JsonNullValueInput | InputJsonValue
    allowedPatientIds?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorizationCodeUpdateWithoutCreatedByInput = {
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutApprovalCodeNestedInput
  }

  export type AuthorizationCodeUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SterilizationIndicatorUpdateWithoutSpecialistInput = {
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSterilizationIndicatorsNestedInput
    items?: SterilizationIndicatorItemUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateWithoutSpecialistInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SterilizationIndicatorItemUncheckedUpdateManyWithoutIndicatorNestedInput
    uses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutIndicatorNestedInput
    encounterDiagnosisLinks?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutIndicatorNestedInput
  }

  export type SterilizationIndicatorUncheckedUpdateManyWithoutSpecialistInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    packageName?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    indicatorDate?: DateTimeFieldUpdateOperationsInput | Date | string
    packageQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseUpdateWithoutOpenedByInput = {
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutSterilizationPackageUsesNestedInput
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutUsesNestedInput
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateWithoutOpenedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyWithoutOpenedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: number
    doctorId?: number | null
    branchId: number
    scheduledAt: Date | string
    endAt?: Date | string | null
    status?: string
    notes?: string | null
  }

  export type BookingCreateManyPatientInput = {
    id?: number
    doctorId: number
    branchId: number
    date: Date | string
    startTime: string
    endTime: string
    status?: $Enums.BookingStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: number
    branchId?: number | null
    encounterId: number
    totalAmount?: number | null
    totalBeforeDiscount?: number | null
    discountPercent?: $Enums.DiscountPercent
    finalAmount?: number | null
    statusLegacy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LedgerEntryCreateManyPatientInput = {
    id?: number
    branchId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateManyPatientInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    encounterId: number
    amountUsed: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneWithoutAppointmentsNestedInput
    branch?: BranchUpdateOneRequiredWithoutAppointmentsNestedInput
    encounters?: EncounterUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    encounters?: EncounterUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    branchId?: IntFieldUpdateOperationsInput | number
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutPatientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutBookingsNestedInput
    branch?: BranchUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutInvoicesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutInvoiceNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eBarimtReceipt?: EBarimtReceiptUncheckedUpdateOneWithoutInvoiceNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    encounterId?: IntFieldUpdateOperationsInput | number
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalBeforeDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercent?: EnumDiscountPercentFieldUpdateOperationsInput | $Enums.DiscountPercent
    finalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    statusLegacy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutPatientInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUpdateWithoutPatientInput = {
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeBenefit?: EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyPatientBookInput = {
    id?: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    appointmentId?: number | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterUpdateWithoutPatientBookInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    appointment?: AppointmentUpdateOneWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPatientBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EncounterCreateManyAppointmentInput = {
    id?: number
    patientBookId: number
    doctorId: number
    visitDate: Date | string
    notes?: string | null
    nurseId?: number | null
    patientSignaturePath?: string | null
    patientSignedAt?: Date | string | null
    doctorSignaturePath?: string | null
    doctorSignedAt?: Date | string | null
  }

  export type EncounterUpdateWithoutAppointmentInput = {
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientBook?: PatientBookUpdateOneRequiredWithoutEncountersNestedInput
    doctor?: UserUpdateOneRequiredWithoutEncountersNestedInput
    nurse?: UserUpdateOneWithoutNurseEncountersNestedInput
    chartTeeth?: ChartToothUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUpdateOneWithoutEncounterNestedInput
    media?: MediaUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chartTeeth?: ChartToothUncheckedUpdateManyWithoutEncounterNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutEncounterNestedInput
    prescription?: PrescriptionUncheckedUpdateOneWithoutEncounterNestedInput
    media?: MediaUncheckedUpdateManyWithoutEncounterNestedInput
    encounterServices?: EncounterServiceUncheckedUpdateManyWithoutEncounterNestedInput
    diagnoses?: EncounterDiagnosisUncheckedUpdateManyWithoutEncounterNestedInput
    consents?: EncounterConsentUncheckedUpdateManyWithoutEncounterNestedInput
    sterilizationPackageUses?: EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterNestedInput
    employeeBenefitUsages?: EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientBookId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    nurseId?: NullableIntFieldUpdateOperationsInput | number | null
    patientSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    patientSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorSignaturePath?: NullableStringFieldUpdateOperationsInput | string | null
    doctorSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChartToothCreateManyEncounterInput = {
    id?: number
    toothCode: string
    toothGroup?: string | null
    status?: string | null
    notes?: string | null
  }

  export type MediaCreateManyEncounterInput = {
    id?: number
    filePath: string
    toothCode?: string | null
    type: string
  }

  export type EncounterServiceCreateManyEncounterInput = {
    id?: number
    serviceId: number
    quantity?: number
    price: number
  }

  export type EncounterDiagnosisCreateManyEncounterInput = {
    id?: number
    diagnosisId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type EncounterConsentCreateManyEncounterInput = {
    id?: number
    type: string
    answers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterSterilizationPackageUseCreateManyEncounterInput = {
    id?: number
    indicatorId: number
    usedQuantity?: number
    openedByUserId?: number | null
    createdAt?: Date | string
  }

  export type EmployeeBenefitUsageCreateManyEncounterInput = {
    id?: number
    employeeBenefitId: number
    invoiceId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type ChartToothUpdateWithoutEncounterInput = {
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    chartNotes?: ChartNoteUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    chartNotes?: ChartNoteUncheckedUpdateManyWithoutChartToothNestedInput
  }

  export type ChartToothUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    toothCode?: StringFieldUpdateOperationsInput | string
    toothGroup?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaUpdateWithoutEncounterInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterServiceUpdateWithoutEncounterInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    service?: ServiceUpdateOneRequiredWithoutEncounterServicesNestedInput
  }

  export type EncounterServiceUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterDiagnosisUpdateWithoutEncounterInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diagnosis?: DiagnosisUpdateOneRequiredWithoutEncountersNestedInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutEncounterDiagnosisNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutEncounterDiagnosisNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    diagnosisId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUpdateWithoutEncounterInput = {
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterConsentUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseUpdateWithoutEncounterInput = {
    usedQuantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutUsesNestedInput
    openedBy?: UserUpdateOneWithoutOpenedSterilizationPackagesNestedInput
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    openedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterSterilizationPackageUseUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    usedQuantity?: IntFieldUpdateOperationsInput | number
    openedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUpdateWithoutEncounterInput = {
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeBenefit?: EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    patient?: PatientUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteCreateManyChartToothInput = {
    id?: number
    description: string
    createdAt?: Date | string
  }

  export type ChartNoteUpdateWithoutChartToothInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteUncheckedUpdateWithoutChartToothInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartNoteUncheckedUpdateManyWithoutChartToothInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisProblemCreateManyDiagnosisInput = {
    id?: number
    label: string
    order?: number
    active?: boolean
  }

  export type EncounterDiagnosisCreateManyDiagnosisInput = {
    id?: number
    encounterId: number
    toothCode?: string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: string | null
    createdAt?: Date | string
  }

  export type DiagnosisProblemUpdateWithoutDiagnosisInput = {
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemUncheckedUpdateWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiagnosisProblemUncheckedUpdateManyWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterDiagnosisUpdateWithoutDiagnosisInput = {
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneRequiredWithoutDiagnosesNestedInput
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUpdateManyWithoutEncounterDiagnosisNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sterilizationIndicators?: EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutEncounterDiagnosisNestedInput
  }

  export type EncounterDiagnosisUncheckedUpdateManyWithoutDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    toothCode?: NullableStringFieldUpdateOperationsInput | string | null
    selectedProblemIds?: NullableJsonNullValueInput | InputJsonValue
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorCreateManyEncounterDiagnosisInput = {
    id?: number
    indicatorId: number
    createdAt?: Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUpdateWithoutEncounterDiagnosisInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicator?: SterilizationIndicatorUpdateOneRequiredWithoutEncounterDiagnosisLinksNestedInput
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateWithoutEncounterDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterDiagnosisSterilizationIndicatorUncheckedUpdateManyWithoutEncounterDiagnosisInput = {
    id?: IntFieldUpdateOperationsInput | number
    indicatorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterServiceCreateManyServiceInput = {
    id?: number
    encounterId: number
    quantity?: number
    price: number
  }

  export type ServiceBranchCreateManyServiceInput = {
    branchId: number
  }

  export type InvoiceItemCreateManyServiceInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type EncounterServiceUpdateWithoutServiceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    encounter?: EncounterUpdateOneRequiredWithoutEncounterServicesNestedInput
  }

  export type EncounterServiceUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type EncounterServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiceBranchUpdateWithoutServiceInput = {
    branch?: BranchUpdateOneRequiredWithoutServiceBranchesNestedInput
  }

  export type ServiceBranchUncheckedUpdateWithoutServiceInput = {
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type ServiceBranchUncheckedUpdateManyWithoutServiceInput = {
    branchId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUpdateWithoutServiceInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateManyProcedureInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type InvoiceItemUpdateWithoutProcedureInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProcedureInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProcedureInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemCreateManyProductInput = {
    id?: number
    invoiceId: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type ProductStockMovementCreateManyProductInput = {
    id?: number
    branchId: number
    type: $Enums.ProductStockMovementType
    quantityDelta: number
    invoiceId?: number | null
    ledgerEntryId?: number | null
    note?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutProductInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type ProductStockMovementUpdateWithoutProductInput = {
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductStockMovementsNestedInput
  }

  export type ProductStockMovementUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockMovementUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    type?: EnumProductStockMovementTypeFieldUpdateOperationsInput | $Enums.ProductStockMovementType
    quantityDelta?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    ledgerEntryId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    branchId: number
    code?: string | null
    name: string
    price: number
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProductsNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    stockMovements?: ProductStockMovementUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    stockMovements?: ProductStockMovementUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionItemCreateManyPrescriptionInput = {
    id?: number
    order: number
    drugName: string
    durationDays: number
    quantityPerTake: number
    frequencyPerDay: number
    note?: string | null
  }

  export type PrescriptionItemUpdateWithoutPrescriptionInput = {
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    drugName?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    quantityPerTake?: IntFieldUpdateOperationsInput | number
    frequencyPerDay?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: number
    itemType: $Enums.InvoiceItemType
    serviceId?: number | null
    productId?: number | null
    procedureCode?: string | null
    name: string
    unitPrice: number
    quantity?: number
    lineTotal: number
    createdAt?: Date | string
    source?: $Enums.InvoiceItemSource
  }

  export type LedgerEntryCreateManyInvoiceInput = {
    id?: number
    branchId: number
    patientId: number
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: number
    amount: number
    method: string
    qpayTxnId?: string | null
    timestamp: Date | string
  }

  export type EmployeeBenefitUsageCreateManyInvoiceInput = {
    id?: number
    employeeBenefitId: number
    encounterId: number
    amountUsed: number
    patientId: number
    patientBookNumber?: string | null
    createdAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
    service?: ServiceUpdateOneWithoutInvoiceItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    procedure?: ProcedureUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemType?: EnumInvoiceItemTypeFieldUpdateOperationsInput | $Enums.InvoiceItemType
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    procedureCode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: EnumInvoiceItemSourceFieldUpdateOperationsInput | $Enums.InvoiceItemSource
  }

  export type LedgerEntryUpdateWithoutInvoiceInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    qpayTxnId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUpdateWithoutInvoiceInput = {
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeBenefit?: EmployeeBenefitUpdateOneRequiredWithoutUsagesNestedInput
    encounter?: EncounterUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
    patient?: PatientUpdateOneRequiredWithoutEmployeeBenefitUsagesNestedInput
  }

  export type EmployeeBenefitUsageUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeBenefitUsageUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeBenefitId?: IntFieldUpdateOperationsInput | number
    encounterId?: IntFieldUpdateOperationsInput | number
    amountUsed?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    patientBookNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyApprovalCodeInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    employeeVoucherId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutApprovalCodeInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    employeeVoucher?: EmployeeVoucherUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutApprovalCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutApprovalCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    employeeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateManyEmployeeVoucherInput = {
    id?: number
    branchId: number
    patientId: number
    invoiceId?: number | null
    type: $Enums.LedgerEntryType
    amount: number
    createdById: number
    approvedById?: number | null
    approvalCodeId?: number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LedgerEntryUpdateWithoutEmployeeVoucherInput = {
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLedgerEntriesNestedInput
    patient?: PatientUpdateOneRequiredWithoutLedgerEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutLedgerEntriesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedLedgerEntriesNestedInput
    approvedBy?: UserUpdateOneWithoutApprovedLedgerEntriesNestedInput
    approvalCode?: AuthorizationCodeUpdateOneWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateWithoutEmployeeVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUncheckedUpdateManyWithoutEmployeeVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    branchId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    invoiceId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumLedgerEntryTypeFieldUpdateOperationsInput | $Enums.LedgerEntryType
    amount?: FloatFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    approvedById?: NullableIntFieldUpdateOperationsInput | number | null
    approvalCodeId?: NullableIntFieldUpdateOperationsInput | number | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigCreateManyMethodInput = {
    id?: number
    name: string
    isActive?: boolean
    sortOrder?: number
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigUpdateWithoutMethodInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUncheckedUpdateWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUncheckedUpdateManyWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeBenefitCountOutputTypeDefaultArgs instead
     */
    export type EmployeeBenefitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeBenefitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationCategoryCountOutputTypeDefaultArgs instead
     */
    export type SterilizationCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationItemCountOutputTypeDefaultArgs instead
     */
    export type SterilizationItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationIndicatorCountOutputTypeDefaultArgs instead
     */
    export type SterilizationIndicatorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationIndicatorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientBookCountOutputTypeDefaultArgs instead
     */
    export type PatientBookCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientBookCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentCountOutputTypeDefaultArgs instead
     */
    export type AppointmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterCountOutputTypeDefaultArgs instead
     */
    export type EncounterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartToothCountOutputTypeDefaultArgs instead
     */
    export type ChartToothCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartToothCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisCountOutputTypeDefaultArgs instead
     */
    export type DiagnosisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDiagnosisCountOutputTypeDefaultArgs instead
     */
    export type EncounterDiagnosisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDiagnosisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedureCountOutputTypeDefaultArgs instead
     */
    export type ProcedureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCategoryCountOutputTypeDefaultArgs instead
     */
    export type ProductCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionCountOutputTypeDefaultArgs instead
     */
    export type PrescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthorizationCodeCountOutputTypeDefaultArgs instead
     */
    export type AuthorizationCodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthorizationCodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeVoucherCountOutputTypeDefaultArgs instead
     */
    export type EmployeeVoucherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeVoucherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentMethodConfigCountOutputTypeDefaultArgs instead
     */
    export type PaymentMethodConfigCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentMethodConfigCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeBenefitDefaultArgs instead
     */
    export type EmployeeBenefitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeBenefitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeBenefitUsageDefaultArgs instead
     */
    export type EmployeeBenefitUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeBenefitUsageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationCategoryDefaultArgs instead
     */
    export type SterilizationCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationItemDefaultArgs instead
     */
    export type SterilizationItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationIndicatorDefaultArgs instead
     */
    export type SterilizationIndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationIndicatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SterilizationIndicatorItemDefaultArgs instead
     */
    export type SterilizationIndicatorItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SterilizationIndicatorItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterSterilizationPackageUseDefaultArgs instead
     */
    export type EncounterSterilizationPackageUseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterSterilizationPackageUseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientBookDefaultArgs instead
     */
    export type PatientBookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientBookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisitCardDefaultArgs instead
     */
    export type VisitCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisitCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrthoCardDefaultArgs instead
     */
    export type OrthoCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrthoCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDefaultArgs instead
     */
    export type EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterConsentDefaultArgs instead
     */
    export type EncounterConsentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterConsentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartToothDefaultArgs instead
     */
    export type ChartToothArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartToothDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartNoteDefaultArgs instead
     */
    export type ChartNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisDefaultArgs instead
     */
    export type DiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisProblemDefaultArgs instead
     */
    export type DiagnosisProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisProblemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDiagnosisDefaultArgs instead
     */
    export type EncounterDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDiagnosisSterilizationIndicatorDefaultArgs instead
     */
    export type EncounterDiagnosisSterilizationIndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDiagnosisSterilizationIndicatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceBranchDefaultArgs instead
     */
    export type ServiceBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterServiceDefaultArgs instead
     */
    export type EncounterServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedureDefaultArgs instead
     */
    export type ProcedureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductStockMovementDefaultArgs instead
     */
    export type ProductStockMovementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductStockMovementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCategoryDefaultArgs instead
     */
    export type ProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionDefaultArgs instead
     */
    export type PrescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionItemDefaultArgs instead
     */
    export type PrescriptionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EBarimtReceiptDefaultArgs instead
     */
    export type EBarimtReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EBarimtReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LedgerEntryDefaultArgs instead
     */
    export type LedgerEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LedgerEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthorizationCodeDefaultArgs instead
     */
    export type AuthorizationCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthorizationCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeVoucherDefaultArgs instead
     */
    export type EmployeeVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeVoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorScheduleDefaultArgs instead
     */
    export type DoctorScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceptionScheduleDefaultArgs instead
     */
    export type ReceptionScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceptionScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorBranchDefaultArgs instead
     */
    export type DoctorBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceptionBranchDefaultArgs instead
     */
    export type ReceptionBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceptionBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NurseBranchDefaultArgs instead
     */
    export type NurseBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NurseBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NurseScheduleDefaultArgs instead
     */
    export type NurseScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NurseScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentMethodConfigDefaultArgs instead
     */
    export type PaymentMethodConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentMethodConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentProviderConfigDefaultArgs instead
     */
    export type PaymentProviderConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentProviderConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QPayIntentDefaultArgs instead
     */
    export type QPayIntentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QPayIntentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}