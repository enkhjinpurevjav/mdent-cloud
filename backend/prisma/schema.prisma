// ==========================================================
// M DENT SOFTWARE — COMPLETE OVERVIEW → PRISMA SCHEMA
// Mon Family Dental Clinic System
// ==========================================================

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ==========================================================
// ENUMS
// ==========================================================
enum UserRole {
  admin
  doctor
  receptionist
  accountant
  nurse
  manager
  xray
}

enum ServiceCategory {
  ORTHODONTIC_TREATMENT // гажиг заслын эмчилгээ
  IMAGING // зураг авах
  DEFECT_CORRECTION // согог засал
  ADULT_TREATMENT // том хүний эмчилгээ
  WHITENING // цайруулалт
  CHILD_TREATMENT // хүүхдийн эмчилгээ
  SURGERY // мэс засал
  PREVIOUS // өмнөх үлдэгдэл тэмдэглэгч (marker only – excluded from income)
}

enum VisitCardType {
  ADULT
  CHILD
}

enum ProductStockMovementType {
  ADJUSTMENT // manual change from inventory page (+/-)
  SALE // created when paid ledger entry is created
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// NEW: discount levels explicitly constrained
enum DiscountPercent {
  ZERO // 0%
  FIVE // 5%
  TEN // 10%
}

// NEW: invoice status enum
enum InvoiceStatus {
  UNPAID
  PARTIAL
  PAID
  INSURANCE_PENDING
}

// NEW: invoice line type (service vs product)
enum InvoiceItemType {
  SERVICE
  PRODUCT
}

enum InvoiceItemSource {
  ENCOUNTER
  MANUAL
}

// NEW: ledger entry type – full financial truth
enum LedgerEntryType {
  CASH
  QPAY
  POS
  FIN_APP
  BOOKING_ADVANCE
  INSURANCE_PENDING
  INSURANCE_SETTLED
  EMPLOYEE_VOUCHER
  BARTER
  REFUND
}

// NEW: employee voucher status
enum EmployeeVoucherStatus {
  ACTIVE
  DISABLED
  EXPIRED
}

// ==========================================================
// BRANCHES (Multi-Branch Support)
// ==========================================================
model Branch {
  id        Int      @id @default(autoincrement())
  name      String
  address   String?
  createdAt DateTime @default(now())

  users              User[]
  patients           Patient[]
  doctorSchedules    DoctorSchedule[]
  serviceBranches    ServiceBranch[]
  doctorBranches     DoctorBranch[]
  appointments       Appointment[]
  bookings           Booking[]
  receptionSchedules ReceptionSchedule[]
  receptionBranches  ReceptionBranch[]
  nurseSchedules     NurseSchedule[]
  nurseBranches      NurseBranch[]

  // NEW: products (retail) belong to a branch
  products Product[]

  // ✅ ADD THESE TWO LINES (back-relations)
  productCategories     ProductCategory[]
  productStockMovements ProductStockMovement[]

  // NEW: invoices created in this branch
  invoices Invoice[]

  // NEW: ledger entries in this branch
  ledgerEntries LedgerEntry[]

  // NEW: employee voucher benefit pools in this branch
  employeeVouchers        EmployeeVoucher[]
  sterilizationIndicators SterilizationIndicator[] @relation("BranchSterilizationIndicators")
  
  // NEW: v1 sterilization relations
  sterilizationItems       SterilizationItem[]       @relation("BranchSterilizationItems")
  autoclaveMachines        AutoclaveMachine[]        @relation("BranchAutoclaveMachines")
  autoclaveCycles          AutoclaveCycle[]          @relation("BranchAutoclaveCycles")
  burSterilizationCycles   BurSterilizationCycle[]   @relation("BranchBurCycles")
  sterilizationMismatches  SterilizationMismatch[]   @relation("BranchSterilizationMismatches")
  adjustmentConsumptions   SterilizationAdjustmentConsumption[] @relation("BranchAdjustmentConsumptions")
  disinfectionLogs DisinfectionLog[] @relation("BranchDisinfectionLogs")
  sterilizationReturns SterilizationReturn[] @relation("BranchSterilizationReturns")
  sterilizationDisposals   SterilizationDisposal[]   @relation("BranchSterilizationDisposals")
}

model EmployeeBenefit {
  id              Int       @id @default(autoincrement())
  employeeId      Int
  code            String    @unique // код, reception оруулна
  branchId        Int? // хүсвэл салбараар хязгаарлаж болно
  initialAmount   Int // нийт олгосон дүн (₮)
  remainingAmount Int // үлдэгдэл дүн (₮)
  fromDate        DateTime? // хүчинтэй эхлэх огноо
  toDate          DateTime? // хүчинтэй дуусах огноо
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  employee User                   @relation(fields: [employeeId], references: [id])
  usages   EmployeeBenefitUsage[]
}

model EmployeeBenefitUsage {
  id                Int @id @default(autoincrement())
  employeeBenefitId Int
  invoiceId         Int
  encounterId       Int
  amountUsed        Int
  patientId         Int

  // NEW: snapshot for finance (Картын дугаар)
  patientBookNumber String?

  createdAt DateTime @default(now())

  employeeBenefit EmployeeBenefit @relation(fields: [employeeBenefitId], references: [id])
  invoice         Invoice         @relation(fields: [invoiceId], references: [id])

  // These two require opposite fields on Encounter + Patient:
  encounter Encounter @relation(fields: [encounterId], references: [id])
  patient   Patient   @relation(fields: [patientId], references: [id])

  @@index([employeeBenefitId])
  @@index([invoiceId])
  @@index([encounterId])
  @@index([patientId])
}

model SterilizationItem {
  id             Int      @id @default(autoincrement())
  branchId       Int      // Branch-scoped tool master
  name           String
  baselineAmount Int      @default(1)  // baseline amount per branch
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  branch         Branch                       @relation("BranchSterilizationItems", fields: [branchId], references: [id])
  indicatorItems SterilizationIndicatorItem[] @relation("SterilizationItemIndicatorItems")
  cycleToolLines AutoclaveCycleToolLine[]     // Links to autoclave cycles
  
  // v1 sterilization relations
  draftAttachments       SterilizationDraftAttachment[]       @relation("DraftAttachmentTool")
  mismatches             SterilizationMismatch[]              @relation("ToolMismatches")
  adjustmentConsumptions SterilizationAdjustmentConsumption[] @relation("ToolAdjustments")

  @@unique([branchId, name])  // Tool name must be unique within a branch
  @@index([branchId])
  returnLines SterilizationReturnLine[] @relation("SterilizationReturnLineTool")
}

enum SterilizationIndicatorStatus {
  ACTIVE
  USED
  EXPIRED
  CANCELLED
}

// NEW: Autoclave cycle result
enum AutoclaveCycleResult {
  PASS
  FAIL
}

// NEW: Sterilization mismatch status
enum SterilizationMismatchStatus {
  UNRESOLVED
  RESOLVED
}

model SterilizationReturn {
  id       Int      @id @default(autoincrement())
  branchId Int
  date     DateTime // store as local midnight for the selected calendar date
  time     String   // "HH:mm"

  doctorId  Int
  nurseName String
  notes     String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch Branch @relation("BranchSterilizationReturns", fields: [branchId], references: [id])
  doctor User   @relation("DoctorSterilizationReturns", fields: [doctorId], references: [id])

  lines SterilizationReturnLine[]

  @@index([branchId])
  @@index([date])
  @@index([doctorId])
}

model SterilizationReturnLine {
  id          Int @id @default(autoincrement())
  returnId    Int
  toolId      Int
  returnedQty Int

  createdAt DateTime @default(now())

  ret  SterilizationReturn @relation(fields: [returnId], references: [id], onDelete: Cascade)
  tool SterilizationItem   @relation("SterilizationReturnLineTool", fields: [toolId], references: [id])

  @@unique([returnId, toolId])
  @@index([returnId])
  @@index([toolId])
}

model SterilizationIndicator {
  id       Int @id @default(autoincrement())
  branchId Int

  packageName String
  code        String

  indicatorDate    DateTime
  specialistUserId Int

  packageQuantity Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch     Branch @relation("BranchSterilizationIndicators", fields: [branchId], references: [id])
  specialist User   @relation("UserSterilizationIndicators", fields: [specialistUserId], references: [id])

  items                   SterilizationIndicatorItem[]
  uses                    EncounterSterilizationPackageUse[]
  encounterDiagnosisLinks EncounterDiagnosisSterilizationIndicator[]

  @@index([branchId, indicatorDate])
  @@index([code])
}

model SterilizationIndicatorItem {
  id          Int @id @default(autoincrement())
  indicatorId Int
  itemId      Int

  indicator SterilizationIndicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)
  item      SterilizationItem      @relation("SterilizationItemIndicatorItems", fields: [itemId], references: [id])

  @@unique([indicatorId, itemId])
  @@index([indicatorId])
  @@index([itemId])
}

model EncounterSterilizationPackageUse {
  id           Int @id @default(autoincrement())
  encounterId  Int
  indicatorId  Int
  usedQuantity Int @default(1)

  openedByUserId Int?
  createdAt      DateTime @default(now())

  encounter Encounter              @relation("EncounterSterilizationUses", fields: [encounterId], references: [id], onDelete: Cascade)
  indicator SterilizationIndicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)
  openedBy  User?                  @relation("UserOpenedSterilizationPackages", fields: [openedByUserId], references: [id])

  @@index([encounterId])
  @@index([indicatorId])
}

// NEW: Autoclave Machine (v1 sterilization)
model AutoclaveMachine {
  id            Int      @id @default(autoincrement())
  branchId      Int
  machineNumber String   // Machine identifier
  name          String?  // Optional machine name/description
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch Branch @relation("BranchAutoclaveMachines", fields: [branchId], references: [id])

  @@unique([branchId, machineNumber]) // Unique machine number per branch
  @@index([branchId])
}

// NEW: Autoclave Cycle (v1 sterilization)
model AutoclaveCycle {
  id                      Int      @id @default(autoincrement())
  branchId                Int
  code                    String   // Cycle number / indicator label (e.g., T-975) - unique per branch
  sterilizationRunNumber  String?  // Run counter per machine (Ариутгалын дугаар)
  machineNumber           String   // Machine number (from AutoclaveMachine)
  startedAt               DateTime? // When cycle started
  pressure                String?  // Pressure value (stored as string with spaces, e.g., "90 230")
  temperature             Float?   // Temperature value
  finishedAt              DateTime? // When cycle finished
  removedFromAutoclaveAt  DateTime? // When removed from autoclave
  completedAt             DateTime // Completion timestamp (for backward compatibility)
  result                  AutoclaveCycleResult // PASS or FAIL
  operator                String   // Operator/nurse name (free text for now)
  notes                   String?  @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch    Branch                   @relation("BranchAutoclaveCycles", fields: [branchId], references: [id])
  toolLines AutoclaveCycleToolLine[] // Multiple tool lines per cycle
  draftAttachments SterilizationDraftAttachment[]

  @@unique([branchId, code]) // One cycle per (branch, code)
  @@index([branchId])
  @@index([code])
  @@index([result])
}

// NEW: Tool lines under an autoclave cycle
model AutoclaveCycleToolLine {
  id          Int @id @default(autoincrement())
  cycleId     Int
  toolId      Int // References SterilizationItem
  producedQty Int // Quantity produced in this cycle for this tool
  
  createdAt DateTime @default(now())

  cycle AutoclaveCycle     @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  tool  SterilizationItem  @relation(fields: [toolId], references: [id])
  finalizedUsages SterilizationFinalizedUsage[]
  disposalLines   SterilizationDisposalLine[]
  draftAttachments SterilizationDraftAttachment[] // NEW: Reverse relation for toolLineId

  @@unique([cycleId, toolId]) // Unique within (cycle, tool)
  @@index([cycleId])
  @@index([toolId])
}

// NEW: Bur Sterilization Cycle (compliance-only tracking, no encounter linkage)
model BurSterilizationCycle {
  id                      Int      @id @default(autoincrement())
  branchId                Int
  code                    String   // Cycle code - unique per branch
  sterilizationRunNumber  String   // Run counter per machine (Ариутгалын дугаар)
  machineId               Int      // Reference to AutoclaveMachine ID (not machineNumber)
  startedAt               DateTime
  pressure                String?  // Pressure value (stored as string with spaces, e.g., "90 230")
  temperature             Float?   // Temperature value (optional)
  finishedAt              DateTime
  removedFromAutoclaveAt  DateTime? // When removed from autoclave (optional)
  result                  AutoclaveCycleResult // PASS or FAIL
  operator                String   // Operator/nurse name (free text)
  notes                   String?  @db.Text
  fastBurQty              Int      @default(0) // Fast bur quantity
  slowBurQty              Int      @default(0) // Slow bur quantity
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch  Branch @relation("BranchBurCycles", fields: [branchId], references: [id])

  @@unique([branchId, code]) // One cycle per (branch, code)
  @@unique([machineId, sterilizationRunNumber]) // Unique run number per machine
  @@index([branchId])
  @@index([machineId])
  @@index([result])
  @@index([startedAt])
}

model DisinfectionLog {
  id        Int      @id @default(autoincrement())
  branchId  Int
  date      DateTime // store as local midnight for the chosen calendar date
  startTime String   // "HH:mm"
  endTime   String   // "HH:mm"

  rinsedWithDistilledWater Boolean @default(true)
  driedInUVCabinet         Boolean @default(false)

  nurseName String
  notes     String?  @db.Text

  // Fixed 13 tool qty columns (0 allowed)
  qtyPolishingRubber      Int @default(0) // Өнгөлгөөний резин
  qtyBrush                Int @default(0) // Браш
  qtyCup                  Int @default(0) // Хундага
  qtyLine                 Int @default(0) // Шугам
  qtyShoeCutter           Int @default(0) // Гута тасдагч
  qtyPlasticMedicineTray  Int @default(0) // Эмийн хуванцар тавиур
  qtyPlasticSpatula       Int @default(0) // Хуванцар шпатель
  qtyTongueDepressor      Int @default(0) // Хэл дарагч
  qtyMouthOpener          Int @default(0) // Ам тэлэгч
  qtyRootmeterTip         Int @default(0) // Рутмерийн хошуу
  qtyTighteningTip        Int @default(0) // Чангалагч хошуу
  qtyBurContainer         Int @default(0) // Борын сав
  qtyPlasticSpoon         Int @default(0) // Хуванцар халбага

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch Branch @relation("BranchDisinfectionLogs", fields: [branchId], references: [id])

  @@index([branchId])
  @@index([date])
}
// NEW: Draft attachments (before encounter close)
model SterilizationDraftAttachment {
  id                   Int      @id @default(autoincrement())
  encounterDiagnosisId Int      // Links to diagnosis row
  cycleId              Int      // References the autoclave cycle
  toolId               Int      // References the tool
  toolLineId           Int?     // NEW: References AutoclaveCycleToolLine (nullable for Phase 1)
  requestedQty         Int      @default(1) // How many requested
  
  createdAt DateTime @default(now())

  encounterDiagnosis EncounterDiagnosis      @relation(fields: [encounterDiagnosisId], references: [id], onDelete: Cascade)
  cycle              AutoclaveCycle          @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  tool               SterilizationItem       @relation("DraftAttachmentTool", fields: [toolId], references: [id])
  toolLine           AutoclaveCycleToolLine? @relation(fields: [toolLineId], references: [id])

  @@index([encounterDiagnosisId])
  @@index([cycleId])
  @@index([toolId])
  @@index([toolLineId])
}

// NEW: Finalized usage (after encounter close)
model SterilizationFinalizedUsage {
  id          Int      @id @default(autoincrement())
  encounterId Int
  toolLineId  Int      // References AutoclaveCycleToolLine
  usedQty     Int      // Quantity actually used/finalized
  
  createdAt DateTime @default(now())

  encounter Encounter              @relation("EncounterFinalizedSterilization", fields: [encounterId], references: [id], onDelete: Cascade)
  toolLine  AutoclaveCycleToolLine @relation(fields: [toolLineId], references: [id])

  @@index([encounterId])
  @@index([toolLineId])
}

// NEW: Sterilization mismatches (insufficient availability)
model SterilizationMismatch {
  id          Int      @id @default(autoincrement())
  encounterId Int
  branchId    Int
  toolId      Int      // Tool that had mismatch
  code        String   // Cycle code
  requiredQty Int      // How much was required
  finalizedQty Int     // How much was finalized (available)
  mismatchQty Int      // Difference (required - finalized)
  status      SterilizationMismatchStatus @default(UNRESOLVED)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  encounter   Encounter             @relation("EncounterSterilizationMismatches", fields: [encounterId], references: [id], onDelete: Cascade)
  branch      Branch                @relation("BranchSterilizationMismatches", fields: [branchId], references: [id])
  tool        SterilizationItem     @relation("ToolMismatches", fields: [toolId], references: [id])
  adjustments SterilizationAdjustmentConsumption[]

  @@index([encounterId])
  @@index([status])
  @@index([branchId])
}

// NEW: Manual adjustment consumption (mismatch resolution)
model SterilizationAdjustmentConsumption {
  id           Int      @id @default(autoincrement())
  mismatchId   Int      // Link to mismatch that was resolved
  encounterId  Int
  branchId     Int
  toolId       Int
  code         String   // Cycle code (for tracking even if not in stock)
  quantity     Int      // Adjustment quantity
  resolvedByUserId Int? // User who resolved (nullable until auth)
  resolvedByName String // Fallback name
  note         String?  @db.Text
  resolvedAt   DateTime @default(now())

  mismatch   SterilizationMismatch @relation(fields: [mismatchId], references: [id], onDelete: Cascade)
  encounter  Encounter             @relation("EncounterAdjustmentConsumptions", fields: [encounterId], references: [id], onDelete: Cascade)
  branch     Branch                @relation("BranchAdjustmentConsumptions", fields: [branchId], references: [id])
  tool       SterilizationItem     @relation("ToolAdjustments", fields: [toolId], references: [id])
  resolvedBy User?                 @relation("UserAdjustmentResolutions", fields: [resolvedByUserId], references: [id])

  @@index([mismatchId])
  @@index([encounterId])
  @@index([branchId])
  @@index([toolId])
  @@index([resolvedByUserId])
}

// NEW: Sterilization Disposal (tracking disposed/discarded tools)
model SterilizationDisposal {
  id              Int      @id @default(autoincrement())
  branchId        Int
  disposedAt      DateTime
  disposedByName  String   // Free text for who disposed
  reason          String?  @db.Text // Optional reason for disposal
  notes           String?  @db.Text // Optional notes
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch Branch                      @relation("BranchSterilizationDisposals", fields: [branchId], references: [id])
  lines  SterilizationDisposalLine[]

  @@index([branchId])
  @@index([disposedAt])
}

// NEW: Sterilization Disposal Line (links disposal to specific tool lines)
model SterilizationDisposalLine {
  id         Int @id @default(autoincrement())
  disposalId Int
  toolLineId Int // References AutoclaveCycleToolLine
  quantity   Int // Quantity disposed
  
  createdAt DateTime @default(now())

  disposal SterilizationDisposal  @relation(fields: [disposalId], references: [id], onDelete: Cascade)
  toolLine AutoclaveCycleToolLine @relation(fields: [toolLineId], references: [id])

  @@index([disposalId])
  @@index([toolLineId])
}

// ==========================================================
// USERS (Doctors, Nurses, Admin, etc.)
// ==========================================================
model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  password    String
  ovog        String?
  name        String?
  role        UserRole @default(receptionist)
  
  branchId    Int?
  branch      Branch? @relation(fields: [branchId], references: [id])
  
  createdAt   DateTime @default(now())
  
  encounters      Encounter[] @relation("DoctorEncounters")
  nurseEncounters Encounter[] @relation("NurseEncounters")
  
  phone              String?
  regNo              String?   @unique
  licenseNumber      String?   @unique
  licenseExpiryDate  DateTime?
  signatureImagePath String?
  stampImagePath     String?
  idPhotoPath        String?

  doctorSchedules DoctorSchedule[]
  doctorBranches  DoctorBranch[]

  receptionSchedules ReceptionSchedule[]
  receptionBranches ReceptionBranch[]

  nurseSchedules NurseSchedule[]
  nurseBranches NurseBranch[]

  appointments        Appointment[]
  createdAppointments Appointment[] @relation("AppointmentCreator")
  cancelledAppointments Appointment[] @relation("AppointmentCanceller")
  bookings            Booking[]
  employeeBenefits    EmployeeBenefit[]

  calendarOrder    Int?

  createdLedgerEntries  LedgerEntry[] @relation("LedgerCreatedBy")
  approvedLedgerEntries LedgerEntry[] @relation("LedgerApprovedBy")

  employeeVouchers        EmployeeVoucher[] @relation("EmployeeVoucherEmployee")
  createdEmployeeVouchers EmployeeVoucher[] @relation("EmployeeVoucherCreatedBy")

  authorizationCodes          AuthorizationCode[]
  sterilizationIndicators     SterilizationIndicator[]           @relation("UserSterilizationIndicators")
  openedSterilizationPackages EncounterSterilizationPackageUse[] @relation("UserOpenedSterilizationPackages")

  sterilizationReturns SterilizationReturn[] @relation("DoctorSterilizationReturns")
  
  // NEW: v1 sterilization adjustment resolutions
  adjustmentResolutions SterilizationAdjustmentConsumption[] @relation("UserAdjustmentResolutions")

  // Doctor commission configuration
  generalPct  Float @default(0) // General treatment commission %
  monthlyGoalAmountMnt Float @default(0) // Monthly revenue goal in Mongolian Tugriks (MNT)
  commissionConfig DoctorCommissionConfig?
}

// ==========================================================
// PATIENTS & DIGITAL HISTORY BOOK
// ==========================================================
model Patient {
  id             Int       @id @default(autoincrement())
  regNo          String?   @unique
  ovog           String?
  name           String
  gender         String?
  birthDate      DateTime?
  phone          String?
  email          String?
  address        String?
  workPlace      String?
  bloodType      String?
  citizenship    String?   @default("Mongolian")
  emergencyPhone String?
  notes          String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  patientBook  PatientBook?
  appointments Appointment[]
  bookings     Booking[]

  // NEW: invoices that reference this patient (from Invoice.patient)
  invoices Invoice[]

  // NEW: financial movements related to this patient
  ledgerEntries         LedgerEntry[]
  employeeBenefitUsages EmployeeBenefitUsage[]
}

// ==========================================================
// DIGITAL HISTORY BOOK & ORTHO CARD
// ==========================================================
model PatientBook {
  id         Int    @id @default(autoincrement())
  bookNumber String @unique

  patientId Int     @unique
  patient   Patient @relation(fields: [patientId], references: [id])

  encounters Encounter[]

  visitCards VisitCard[] // Changed from one-to-one to one-to-many
  visitCardSharedSignature VisitCardSharedSignature?
  orthoCard  OrthoCard?
}

model VisitCard {
  id            Int         @id @default(autoincrement())
  patientBookId Int
  patientBook   PatientBook @relation(fields: [patientBookId], references: [id])

  type    VisitCardType
  answers Json

  patientSignaturePath String?
  signedAt             DateTime?
  savedAt              DateTime? // Timestamp when form is saved (Хадгалах button)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([patientBookId, type])
}

model VisitCardSharedSignature {
  id            Int         @id @default(autoincrement())
  patientBookId Int         @unique
  patientBook   PatientBook @relation(fields: [patientBookId], references: [id])

  filePath String
  signedAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OrthoCard {
  id            Int         @id @default(autoincrement())
  patientBookId Int         @unique
  patientBook   PatientBook @relation(fields: [patientBookId], references: [id])

  data Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ==========================================================
// APPOINTMENTS & BOOKINGS
// ==========================================================
model Appointment {
  id Int @id @default(autoincrement())

  patientId Int
  doctorId  Int?
  branchId  Int

  scheduledAt DateTime
  endAt       DateTime?
  status      String    @default("booked")
  notes       String?

  // Provenance tracking for deletion permissions
  createdByUserId   Int?
  source            String? // e.g., 'FOLLOW_UP_ENCOUNTER', 'CALENDAR'
  sourceEncounterId Int?

  // Cancellation audit fields
  cancelledAt       DateTime?
  cancelledByUserId Int?

  patient         Patient    @relation(fields: [patientId], references: [id])
  doctor          User?      @relation(fields: [doctorId], references: [id])
  branch          Branch     @relation(fields: [branchId], references: [id])
  createdBy       User?      @relation("AppointmentCreator", fields: [createdByUserId], references: [id])
  sourceEncounter Encounter? @relation("SourceEncounter", fields: [sourceEncounterId], references: [id])
  cancelledBy     User?      @relation("AppointmentCanceller", fields: [cancelledByUserId], references: [id])

  encounters Encounter[]

  @@index([branchId, scheduledAt])
}

model Booking {
  id        Int           @id @default(autoincrement())
  doctorId  Int
  branchId  Int
  patientId Int
  date      DateTime
  startTime String
  endTime   String
  status    BookingStatus @default(PENDING)
  note      String?       @db.Text

  doctor  User    @relation(fields: [doctorId], references: [id])
  branch  Branch  @relation(fields: [branchId], references: [id])
  patient Patient @relation(fields: [patientId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ==========================================================
// ENCOUNTERS, DIAGNOSES, CHARTING
// ==========================================================
model Encounter {
  id            Int      @id @default(autoincrement())
  patientBookId Int
  doctorId      Int
  visitDate     DateTime
  notes         String?
  appointmentId Int?

  patientBook PatientBook  @relation(fields: [patientBookId], references: [id])
  doctor      User         @relation("DoctorEncounters", fields: [doctorId], references: [id])
  appointment Appointment? @relation(fields: [appointmentId], references: [id])

  nurseId Int?
  nurse   User? @relation("NurseEncounters", fields: [nurseId], references: [id])

  // Shared consent signatures for all consent forms
  patientSignaturePath String?
  patientSignedAt      DateTime?
  doctorSignaturePath  String?
  doctorSignedAt       DateTime?

  chartTeeth               ChartTooth[]
  invoice                  Invoice?
  prescription             Prescription?
  media                    Media[]
  encounterServices        EncounterService[]
  diagnoses                EncounterDiagnosis[]
  consents                 EncounterConsent[]
  sterilizationPackageUses EncounterSterilizationPackageUse[] @relation("EncounterSterilizationUses")
  employeeBenefitUsages    EmployeeBenefitUsage[]
  sourceAppointments       Appointment[]                      @relation("SourceEncounter")
  
  // NEW: v1 sterilization relations
  finalizedSterilization    SterilizationFinalizedUsage[]       @relation("EncounterFinalizedSterilization")
  sterilizationMismatches   SterilizationMismatch[]             @relation("EncounterSterilizationMismatches")
  adjustmentConsumptions    SterilizationAdjustmentConsumption[] @relation("EncounterAdjustmentConsumptions")
}

model EncounterConsent {
  id Int @id @default(autoincrement())

  encounterId Int
  type        String
  answers     Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  encounter Encounter @relation(fields: [encounterId], references: [id])

  @@unique([encounterId, type]) // ✅ one per type per encounter
  @@index([encounterId])
}

model ChartTooth {
  id         Int     @id @default(autoincrement())
  toothCode  String
  toothGroup String?
  status     String?
  notes      String?

  encounterId Int
  encounter   Encounter @relation(fields: [encounterId], references: [id])

  chartNotes ChartNote[]
}

model ChartNote {
  id           Int      @id @default(autoincrement())
  chartToothId Int
  description  String
  createdAt    DateTime @default(now())

  chartTooth ChartTooth @relation(fields: [chartToothId], references: [id])
}

model Diagnosis {
  id          Int      @id @default(autoincrement())
  code        String   @unique
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  problems   DiagnosisProblem[]
  encounters EncounterDiagnosis[]
}

model DiagnosisProblem {
  id          Int     @id @default(autoincrement())
  diagnosisId Int
  label       String
  order       Int     @default(0)
  active      Boolean @default(true)

  diagnosis Diagnosis @relation(fields: [diagnosisId], references: [id])
}

model EncounterDiagnosis {
  id                 Int     @id @default(autoincrement())
  encounterId        Int
  diagnosisId        Int?          // ✅ allow empty diagnosis row
  toothCode          String?
  selectedProblemIds Json?
  note               String?

  encounter Encounter @relation(fields: [encounterId], references: [id])

  // ✅ must be optional too
  diagnosis Diagnosis? @relation(fields: [diagnosisId], references: [id])

  createdAt               DateTime                                   @default(now())
  sterilizationIndicators EncounterDiagnosisSterilizationIndicator[]
  draftAttachments        SterilizationDraftAttachment[]  // NEW: v1 draft attachments
  problemTexts            EncounterDiagnosisProblemText[]
}

model EncounterDiagnosisSterilizationIndicator {
  id                   Int      @id @default(autoincrement())
  encounterDiagnosisId Int
  indicatorId          Int
  createdAt            DateTime @default(now())

  encounterDiagnosis EncounterDiagnosis     @relation(fields: [encounterDiagnosisId], references: [id], onDelete: Cascade)
  indicator          SterilizationIndicator @relation(fields: [indicatorId], references: [id], onDelete: Cascade)

  @@index([encounterDiagnosisId])
  @@index([indicatorId])
}

model EncounterDiagnosisProblemText {
  id                   Int      @id @default(autoincrement())
  encounterDiagnosisId Int
  text                 String   @db.Text
  order                Int      @default(0)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  encounterDiagnosis EncounterDiagnosis @relation(fields: [encounterDiagnosisId], references: [id], onDelete: Cascade)

  @@index([encounterDiagnosisId])
}

// ==========================================================
// SERVICES, PROCEDURES, PRODUCTS
// ==========================================================
model Service {
  id          Int             @id @default(autoincrement())
  code        String?         @unique
  category    ServiceCategory
  name        String
  price       Float
  isActive    Boolean         @default(true)
  description String?

  encounterServices EncounterService[]
  serviceBranches   ServiceBranch[]
  invoiceItems      InvoiceItem[]
}

model ServiceBranch {
  serviceId Int
  branchId  Int

  service Service @relation(fields: [serviceId], references: [id])
  branch  Branch  @relation(fields: [branchId], references: [id])

  @@id([serviceId, branchId])
}

model EncounterService {
  id          Int @id @default(autoincrement())
  encounterId Int
  serviceId   Int
  encounter Encounter @relation(fields: [encounterId], references: [id])
  service   Service   @relation(fields: [serviceId], references: [id])

  quantity Int   @default(1)
  price    Float

  // NEW:
  meta  Json?                   // store { assignedTo: "DOCTOR" | "NURSE" }
  texts EncounterServiceText[]
}

model EncounterServiceText {
  id                 Int      @id @default(autoincrement())
  encounterServiceId Int
  text               String   @db.Text
  order              Int      @default(0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  encounterService EncounterService @relation(fields: [encounterServiceId], references: [id], onDelete: Cascade)

  @@index([encounterServiceId])
}

// Optional legacy Procedure catalog – wired to InvoiceItem
model Procedure {
  code  String @id
  name  String
  price Float

  // If you use this, also link InvoiceItem.procedure
  invoiceItems InvoiceItem[]
}

// NEW: Product catalog (retail)
model Product {
  id         Int @id @default(autoincrement())
  branchId   Int
  categoryId Int

  code        String? @unique
  name        String
  price       Float
  isActive    Boolean @default(true)
  description String?

  branch   Branch          @relation(fields: [branchId], references: [id])
  category ProductCategory @relation(fields: [categoryId], references: [id])

  invoiceItems   InvoiceItem[]
  stockMovements ProductStockMovement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([branchId, isActive])
  @@index([categoryId])
}

model ProductStockMovement {
  id        Int @id @default(autoincrement())
  branchId  Int
  productId Int

  type          ProductStockMovementType
  quantityDelta Int // positive or negative

  // optional references for SALE
  invoiceId     Int?
  ledgerEntryId Int?

  note      String?
  createdAt DateTime @default(now())

  branch  Branch  @relation(fields: [branchId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  @@index([branchId])
  @@index([productId])
  @@index([type])
  @@index([invoiceId])
  @@index([ledgerEntryId])
}

model ProductCategory {
  id        Int      @id @default(autoincrement())
  branchId  Int
  name      String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branch   Branch    @relation(fields: [branchId], references: [id])
  products Product[]

  @@unique([branchId, name])
  @@index([branchId])
}

// ==========================================================
// PRESCRIPTIONS
// ==========================================================
model Prescription {
  id          Int       @id @default(autoincrement())
  encounter   Encounter @relation(fields: [encounterId], references: [id])
  encounterId Int       @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  doctorNameSnapshot  String?
  patientNameSnapshot String?
  diagnosisSummary    String?
  clinicNameSnapshot  String?

  items PrescriptionItem[]
}

model PrescriptionItem {
  id             Int          @id @default(autoincrement())
  prescription   Prescription @relation(fields: [prescriptionId], references: [id])
  prescriptionId Int

  order Int

  drugName        String
  durationDays    Int
  quantityPerTake Int
  frequencyPerDay Int
  note            String?

  @@index([prescriptionId])
}

// ==========================================================
// INVOICES, INVOICE ITEMS, E-BARIMT, LEGACY PAYMENT
// ==========================================================
model Invoice {
  id Int @id @default(autoincrement())
  
  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  encounterId Int @unique
  encounter   Encounter @relation(fields: [encounterId], references: [id])

  patientId Int?
  patient   Patient? @relation(fields: [patientId], references: [id])

  items InvoiceItem[]

  totalAmount Float @default(0)
  totalBeforeDiscount Float
  discountPercent DiscountPercent @default(ZERO)
  collectionDiscountAmount Float @default(0)
  finalAmount Float @default(0)

  statusLegacy String? @map("status")

  eBarimtReceipt EBarimtReceipt?

  ledgerEntries LedgerEntry[]
  payments Payment[]

  employeeBenefitUsages EmployeeBenefitUsage[] 

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@map("Invoice") // Ensures Prisma maps to correct table name
}

model InvoiceItem {
  id Int @id @default(autoincrement())

  invoiceId Int
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  itemType InvoiceItemType

  serviceId Int?
  service   Service? @relation(fields: [serviceId], references: [id])

  productId Int?
  product   Product? @relation(fields: [productId], references: [id])

  // Optional: link to legacy Procedure if still used
  procedureCode String?
  procedure     Procedure? @relation(fields: [procedureCode], references: [code])

  name      String
  unitPrice Float
  quantity  Int    @default(1)
  lineTotal Float

  createdAt DateTime @default(now())

  source InvoiceItemSource @default(MANUAL)

  allocations PaymentAllocation[]

  @@index([invoiceId])
}

// Legacy Payment model (do NOT use for new flows)
model Payment {
  id        Int      @id @default(autoincrement())
  invoiceId Int
  amount    Float
  method    String
  qpayTxnId String?
  meta      Json?
  timestamp DateTime

  invoice Invoice @relation(fields: [invoiceId], references: [id])

  allocations PaymentAllocation[]

  @@index([invoiceId])
  @@index([qpayTxnId])
}

// Per-service allocation of a payment to an invoice line
model PaymentAllocation {
  id            Int      @id @default(autoincrement())
  paymentId     Int
  invoiceItemId Int
  amount        Float
  createdAt     DateTime @default(now())

  payment     Payment     @relation(fields: [paymentId], references: [id])
  invoiceItem InvoiceItem @relation(fields: [invoiceItemId], references: [id])

  @@index([paymentId])
  @@index([invoiceItemId])
}

model EBarimtReceipt {
  id        Int     @id @default(autoincrement())
  invoiceId Int     @unique
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  receiptNumber String   @unique
  timestamp     DateTime @default(now())
}

// ==========================================================
// LEDGER (FINANCIAL TRUTH)
// ==========================================================
model LedgerEntry {
  id Int @id @default(autoincrement())

  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  patientId Int
  patient   Patient @relation(fields: [patientId], references: [id])

  invoiceId Int?
  invoice   Invoice? @relation(fields: [invoiceId], references: [id])

  type   LedgerEntryType
  amount Float

  createdById Int
  createdBy   User @relation("LedgerCreatedBy", fields: [createdById], references: [id])

  approvedById Int?
  approvedBy   User? @relation("LedgerApprovedBy", fields: [approvedById], references: [id])

  approvalCodeId Int?
  approvalCode   AuthorizationCode? @relation(fields: [approvalCodeId], references: [id])

  // If EMPLOYEE_VOUCHER, link to specific voucher
  employeeVoucherId Int?
  employeeVoucher   EmployeeVoucher? @relation(fields: [employeeVoucherId], references: [id])

  meta      Json?
  createdAt DateTime @default(now())

  @@index([branchId])
  @@index([patientId])
  @@index([invoiceId])
  @@index([type])
}

// ==========================================================
// AUTHORIZATION CODES (ADMIN CONTROLLED EXCEPTIONS)
// ==========================================================
model AuthorizationCode {
  id        Int       @id @default(autoincrement())
  code      String    @unique
  purpose   String
  isEnabled Boolean   @default(true)
  expiresAt DateTime?
  maxUses   Int?
  usedCount Int       @default(0)

  createdById Int
  createdBy   User @relation(fields: [createdById], references: [id])

  ledgerEntries LedgerEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([purpose])
}

// ==========================================================
// EMPLOYEE VOUCHERS (INTERNAL BENEFIT POOLS)
// ==========================================================
model EmployeeVoucher {
  id Int @id @default(autoincrement())

  branchId Int
  branch   Branch @relation(fields: [branchId], references: [id])

  employeeId Int
  employee   User @relation("EmployeeVoucherEmployee", fields: [employeeId], references: [id])

  code       String                @unique
  status     EmployeeVoucherStatus @default(ACTIVE)
  balanceCap Float
  usedAmount Float                 @default(0)

  eligibility       Json
  allowedPatientIds Json

  // Ledger entries using this voucher (EMPLOYEE_VOUCHER type)
  ledgerEntries LedgerEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  createdById Int
  createdBy   User @relation("EmployeeVoucherCreatedBy", fields: [createdById], references: [id])

  @@index([branchId])
  @@index([employeeId])
}

// ==========================================================
// MEDIA
// ==========================================================
model Media {
  id          Int     @id @default(autoincrement())
  encounterId Int
  filePath    String
  toothCode   String?
  type        String

  encounter Encounter @relation(fields: [encounterId], references: [id])
}

// ==========================================================
// SCHEDULES (Doctor / Reception / Nurse)
// ==========================================================
model DoctorSchedule {
  id        Int      @id @default(autoincrement())
  doctorId  Int
  branchId  Int
  date      DateTime
  startTime String
  endTime   String
  note      String?

  doctor User   @relation(fields: [doctorId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@unique([doctorId, branchId, date])
  @@index([doctorId, date])
  @@index([branchId, date])
}

model ReceptionSchedule {
  id          Int      @id @default(autoincrement())
  receptionId Int
  branchId    Int
  date        DateTime
  startTime   String
  endTime     String
  note        String?

  reception User   @relation(fields: [receptionId], references: [id])
  branch    Branch @relation(fields: [branchId], references: [id])

  @@unique([receptionId, branchId, date])
  @@index([receptionId, date])
  @@index([branchId, date])
}

model DoctorBranch {
  id       Int @id @default(autoincrement())
  doctorId Int
  branchId Int

  doctor User   @relation(fields: [doctorId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@unique([doctorId, branchId])
}

model ReceptionBranch {
  id          Int @id @default(autoincrement())
  receptionId Int
  branchId    Int

  reception User   @relation(fields: [receptionId], references: [id])
  branch    Branch @relation(fields: [branchId], references: [id])

  @@unique([receptionId, branchId])
}

model NurseBranch {
  id       Int @id @default(autoincrement())
  nurseId  Int
  branchId Int

  nurse  User   @relation(fields: [nurseId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@unique([nurseId, branchId])
}

model NurseSchedule {
  id        Int      @id @default(autoincrement())
  nurseId   Int
  branchId  Int
  date      DateTime
  startTime String
  endTime   String
  note      String?

  nurse  User   @relation(fields: [nurseId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@unique([nurseId, branchId, date])
  @@index([nurseId, date])
  @@index([branchId, date])
}

// ==========================================================
// PAYMENT SETTINGS (Phase 1: Configurable Payment Methods)
// ==========================================================

// Payment method configuration (global, not per-branch)
model PaymentMethodConfig {
  id        Int      @id @default(autoincrement())
  key       String   @unique // CASH, POS, TRANSFER, INSURANCE, APPLICATION, VOUCHER, EMPLOYEE_BENEFIT, WALLET, BARTER, OTHER
  label     String // Display name (editable, e.g. "Бэлэн мөнгө")
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  providers PaymentProviderConfig[]

  @@index([isActive, sortOrder])
}

// Payment provider configuration (banks for TRANSFER, insurance for INSURANCE, apps for APPLICATION)
model PaymentProviderConfig {
  id        Int                 @id @default(autoincrement())
  methodKey String // References PaymentMethodConfig.key
  method    PaymentMethodConfig @relation(fields: [methodKey], references: [key], onDelete: Cascade)
  name      String // Provider name (e.g. "Bodi Daatgal", "Storepay", "Хаан банк")
  isActive  Boolean             @default(true)
  sortOrder Int                 @default(0)
  note      String? // Optional free text
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  @@index([methodKey, isActive, sortOrder])
}

// ==========================================================
// QPAY INTEGRATION (SANDBOX + LIVE)
// ==========================================================

model QPayIntent {
  id              Int      @id @default(autoincrement())
  environment     String // "sandbox" | "live"
  objectType      String // "INVOICE" | "BOOKING"
  objectId        Int // invoiceId or bookingId
  qpayInvoiceId   String   @unique
  senderInvoiceNo String   @unique
  amount          Float
  status          String   @default("NEW") // NEW | PAID | FAILED | CANCELLED
  paidAmount      Float?
  qpayPaymentId   String?
  raw             Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([objectType, objectId])
}

// ==========================================================
// SETTINGS (Global Finance Configuration)
// ==========================================================
model Settings {
  id        Int      @id @default(autoincrement())
  key       String   @unique
  value     String // stored as string, parse as needed (JSON, number, etc.)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
}

// ==========================================================
// DOCTOR COMMISSION CONFIGURATION
// ==========================================================
model DoctorCommissionConfig {
  id       Int  @id @default(autoincrement())
  doctorId Int  @unique
  doctor   User @relation(fields: [doctorId], references: [id])

  orthoPct   Float @default(0) // orthodontic treatment commission %
  defectPct  Float @default(0) // defect correction commission %
  surgeryPct Float @default(0) // surgery commission %
  generalPct Float @default(0) // general treatment commission %

  monthlyGoalAmountMnt Float @default(0)

  updatedAt DateTime @updatedAt

  @@index([doctorId])
}
