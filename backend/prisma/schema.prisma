// ==========================================================
// M DENT SOFTWARE — COMPLETE OVERVIEW → PRISMA SCHEMA
// Mon Family Dental Clinic System
// ==========================================================

// DATASOURCE
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum BookingStatus {
  PENDING      // Захиалсан
  CONFIRMED    // Баталгаажсан
  IN_PROGRESS  // Явж байна
  COMPLETED    // Дууссан
  CANCELLED    // Цуцалсан
}

// GENERATOR
generator client {
  provider = "prisma-client-js"
}

// ==========================================================
// ENUMS
// ==========================================================
enum UserRole {
  admin
  doctor
  receptionist
  accountant
  nurse
  manager
}

enum ServiceCategory {
  ORTHODONTIC_TREATMENT   // гажиг заслын эмчилгээ
  IMAGING                 // зураг авах
  DEFECT_CORRECTION       // согог засал
  ADULT_TREATMENT         // том хүний эмчилгээ
  WHITENING               // цайруулалт
  CHILD_TREATMENT         // хүүхдийн эмчилгээ
  SURGERY                 // мэс засал
}

enum VisitCardType {
  ADULT   // Үзлэгийн карт (том хүн)
  CHILD   // Үзлэгийн карт (хүүхэд)
}

// NEW: discount levels explicitly constrained
enum DiscountPercent {
  ZERO   // 0%
  FIVE   // 5%
  TEN    // 10%
}

// NEW: invoice status enum (source-of-truth for billing state)
enum InvoiceStatus {
  UNPAID
  PARTIAL
  PAID
  INSURANCE_PENDING
}

// NEW: invoice line type (service vs product)
enum InvoiceItemType {
  SERVICE
  PRODUCT
}

// NEW: ledger entry type – full financial truth
enum LedgerEntryType {
  CASH
  QPAY
  POS
  FIN_APP
  BOOKING_ADVANCE
  INSURANCE_PENDING
  INSURANCE_SETTLED
  EMPLOYEE_VOUCHER
  BARTER
  REFUND
}

// NEW: employee voucher status
enum EmployeeVoucherStatus {
  ACTIVE
  DISABLED
  EXPIRED
}

// ==========================================================
// BRANCHES (Multi-Branch Support)
// ==========================================================
model Branch {
  id        Int              @id @default(autoincrement())
  name      String
  address   String?
  createdAt DateTime         @default(now())

  // Users directly assigned to this branch (legacy single-branch link)
  users     User[]

  // Patients registered under this branch
  patients  Patient[]

  // Doctor schedules per branch (per-day entries)
  doctorSchedules DoctorSchedule[]

  // Services available in this branch (many-to-many via ServiceBranch)
  serviceBranches ServiceBranch[]

  // Doctors assigned to this branch (many-to-many via DoctorBranch)
  doctorBranches  DoctorBranch[]

  // Appointments booked in this branch
  appointments    Appointment[]

  // Bookings in this branch
  bookings        Booking[]

  // NEW: Receptionist schedules per branch
  receptionSchedules ReceptionSchedule[]

  // NEW: Receptionist many-to-many assignment
  receptionBranches  ReceptionBranch[]

  // NEW for nurses
  nurseSchedules     NurseSchedule[]
  nurseBranches      NurseBranch[]

  // NEW: invoices created for encounters in this branch
  invoices           Invoice[]

  // NEW: ledger entries belonging to this branch
  ledgerEntries      LedgerEntry[]

  // NEW: employee vouchers scoped to this branch (if needed)
  employeeVouchers   EmployeeVoucher[]
}

model VisitCard {
  id             Int           @id @default(autoincrement())

  /// One card per PatientBook (patient)
  patientBookId  Int           @unique
  patientBook    PatientBook   @relation(fields: [patientBookId], references: [id])

  /// ADULT or CHILD
  type           VisitCardType

  /// All answers from the form.
  /// JSON so we can evolve fields without migrations.
  answers        Json

  /// Optional path to PNG signature image stored under /media.
  patientSignaturePath String?

  /// When the card was first created (patient agreed).
  signedAt      DateTime?

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

// ==========================================================
// USERS (Doctors, Nurses, Admin, etc.)
// ==========================================================
model User {
  id                 Int              @id @default(autoincrement())
  email              String           @unique
  password           String
  ovog               String?
  name               String?
  role               UserRole         @default(receptionist)
  branchId           Int?
  branch             Branch?          @relation(fields: [branchId], references: [id])
  createdAt          DateTime         @default(now())

  encounters         Encounter[]      @relation("DoctorEncounters")
  nurseEncounters    Encounter[]      @relation("NurseEncounters")

  phone              String?
  regNo              String?          @unique
  licenseNumber      String?          @unique
  licenseExpiryDate  DateTime?
  signatureImagePath String?
  stampImagePath     String?
  idPhotoPath        String?

  doctorSchedules    DoctorSchedule[]
  doctorBranches     DoctorBranch[]
  receptionSchedules ReceptionSchedule[]
  receptionBranches  ReceptionBranch[]
  nurseSchedules     NurseSchedule[]
  nurseBranches      NurseBranch[]
  appointments       Appointment[]
  bookings           Booking[]
  calendarOrder      Int?

  // --- NEW RELATIONS (ensure they use explicit names) ---

  // LedgerEntry.createdBy
  createdLedgerEntries  LedgerEntry[] @relation("LedgerCreatedBy")

  // LedgerEntry.approvedBy
  approvedLedgerEntries LedgerEntry[] @relation("LedgerApprovedBy")

  // EmployeeVoucher.employee
  employeeVouchers      EmployeeVoucher[] @relation("EmployeeVoucherEmployee")

  // EmployeeVoucher.createdBy
  createdEmployeeVouchers EmployeeVoucher[] @relation("EmployeeVoucherCreatedBy")
}

// Join table for many-to-many between Doctor (User) and Branch
model DoctorBranch {
  id        Int    @id @default(autoincrement())

  doctorId  Int
  branchId  Int

  doctor    User   @relation(fields: [doctorId], references: [id])
  branch    Branch @relation(fields: [branchId], references: [id])

  @@unique([doctorId, branchId])
}

// NEW: Join table for many-to-many between Receptionist (User) and Branch
model ReceptionBranch {
  id           Int    @id @default(autoincrement())

  receptionId  Int
  branchId     Int

  reception    User   @relation(fields: [receptionId], references: [id])
  branch       Branch @relation(fields: [branchId], references: [id])

  @@unique([receptionId, branchId])
}

// ==========================================================
// PATIENTS & DIGITAL HISTORY BOOK
// ==========================================================
model Patient {
  id             Int          @id @default(autoincrement())

  /// Mongolian citizen ID (РД), unique per patient
  regNo          String?       @unique

  /// Father’s name
  ovog           String?

  /// Given name
  name           String

  gender         String?
  birthDate      DateTime?

  /// Phone numbers are non-unique (one parent can register multiple children)
  phone          String?

  address        String?
  bloodType      String?
  citizenship    String?      @default("Mongolian")
  emergencyPhone String?
  notes          String?

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  /// Primary branch where the patient is registered
  branchId       Int
  branch         Branch       @relation(fields: [branchId], references: [id])

  /// Each patient has exactly one digital history book
  patientBook    PatientBook?

  // Back-relation to appointments
  appointments   Appointment[]

  // Bookings for this patient
  bookings       Booking[]

  // NEW: ledger entries related to this patient (payments, advances, wallet)
  ledgerEntries  LedgerEntry[]
}

// ==========================================================
// CHARTING (Tooth Records)
// ==========================================================
model ChartTooth {
  id          Int        @id @default(autoincrement())

  /// FDI tooth code (e.g. "11", "26", "85")
  toothCode   String

  /// Optional group/range description (e.g. "21-24", "25-26", "all molars")
  toothGroup  String?

  /// General tooth condition/status (optional, e.g. "Healthy", "Caries")
  status      String?

  /// Free-form note for this tooth in this encounter
  notes       String?

  encounterId Int
  encounter   Encounter  @relation(fields: [encounterId], references: [id])

  chartNotes  ChartNote[]
}

model ChartNote {
  id           Int        @id @default(autoincrement())
  chartToothId Int
  description  String
  createdAt    DateTime   @default(now())

  chartTooth   ChartTooth @relation(fields: [chartToothId], references: [id])
}

// Appointment model
model Appointment {
  id          Int       @id @default(autoincrement())

  patientId   Int
  doctorId    Int?
  branchId    Int

  scheduledAt DateTime
  endAt       DateTime?   // Дуусах цаг (шинэ)
  status      String      @default("booked")
  notes       String?

  patient     Patient   @relation(fields: [patientId], references: [id])
  doctor      User?     @relation(fields: [doctorId], references: [id])
  branch      Branch    @relation(fields: [branchId], references: [id])

  @@index([branchId, scheduledAt])

  // Back relation to Encounter (1 appointment → 0 or 1 encounter)
  encounters  Encounter[]
}

model Booking {
  id        Int           @id @default(autoincrement())

  doctorId  Int
  branchId  Int
  patientId Int

  /// Stored as date-only (we normalize to 00:00:00 UTC/local)
  date      DateTime

  /// HH:MM 24h format (e.g. "09:30")
  startTime String

  /// HH:MM 24h format (e.g. "10:00")
  endTime   String

  status    BookingStatus @default(PENDING)
  note      String?       @db.Text

  doctor  User    @relation(fields: [doctorId], references: [id])
  branch  Branch  @relation(fields: [branchId], references: [id])
  patient Patient @relation(fields: [patientId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // NOTE: Booking advances are represented in LedgerEntry with type BOOKING_ADVANCE
}

// DIGITAL HISTORY BOOK
model PatientBook {
  id         Int         @id @default(autoincrement())

  /// Human-friendly book number (e.g., "6", "000123")
  bookNumber String      @unique

  patientId  Int         @unique
  patient    Patient     @relation(fields: [patientId], references: [id])

  // All encounters (visits) recorded in this book
  encounters Encounter[]

  // One general visit card per patient book
  visitCard  VisitCard?

  // NEW: one orthodontic card per patient book
  orthoCard  OrthoCard?
}

model OrthoCard {
  id            Int         @id @default(autoincrement())

  /// One orthodontic card per patient book
  patientBookId Int         @unique
  patientBook   PatientBook @relation(fields: [patientBookId], references: [id])

  /// Full orthodontic card data as JSON (matches OrthoCardData in frontend)
  data          Json

  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model Diagnosis {
  id          Int                  @id @default(autoincrement())
  code        String               @unique
  name        String               // Short name/title
  description String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  problems    DiagnosisProblem[]
  encounters  EncounterDiagnosis[]
}

model DiagnosisProblem {
  id           Int        @id @default(autoincrement())
  diagnosisId  Int
  label        String
  order        Int        @default(0)
  active       Boolean    @default(true)

  diagnosis    Diagnosis  @relation(fields: [diagnosisId], references: [id])
}

model Encounter {
  id                 Int           @id @default(autoincrement())
  patientBookId      Int
  doctorId           Int
  visitDate          DateTime
  notes              String?

  // Link to Appointment (one appointment can have many encounters)
  appointmentId      Int?
  appointment        Appointment? @relation(fields: [appointmentId], references: [id])

  patientBook        PatientBook   @relation(fields: [patientBookId], references: [id])
  doctor             User          @relation("DoctorEncounters", fields: [doctorId], references: [id])

  // NEW: optional nurse working on this encounter
  nurseId            Int?
  nurse              User?         @relation("NurseEncounters", fields: [nurseId], references: [id])

  // Per-tooth charting for this encounter
  chartTeeth         ChartTooth[]

  // Generated invoice for this encounter (1:1)
  invoice            Invoice?
  prescription       Prescription?

  // Attached media (photos, X-rays, docs)
  media              Media[]

  // Services performed in this encounter
  encounterServices  EncounterService[]

  diagnoses          EncounterDiagnosis[]

  // NEW: optional consent form for this encounter
  consent            EncounterConsent?
}

model EncounterConsent {
  id                  Int       @id @default(autoincrement())
  encounterId         Int       @unique
  type                String    // "root_canal" | "surgery" | "orthodontic" | "prosthodontic"
  answers             Json      // form answers (structure depends on type)

  patientSignedAt     DateTime?
  doctorSignedAt      DateTime?

  patientSignaturePath String?
  doctorSignaturePath  String?

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  encounter           Encounter @relation(fields: [encounterId], references: [id])
}

model EncounterDiagnosis {
  id                  Int        @id @default(autoincrement())
  encounterId         Int
  diagnosisId         Int

  /// Which tooth this diagnosis applies to (optional, null = general)
  toothCode           String?    // e.g. "11", "26", "85"

  // List of problem IDs from DiagnosisProblem for this encounter
  selectedProblemIds  Json?      // e.g. [1,3,5]
  note                String?

  encounter           Encounter  @relation(fields: [encounterId], references: [id])
  diagnosis           Diagnosis  @relation(fields: [diagnosisId], references: [id])

  createdAt           DateTime   @default(now())

  // TEMP: allow same diagnosis multiple times per encounter
  // @@unique([encounterId, diagnosisId])
}

// ==========================================================
// SERVICES, PROCEDURES, DIAGNOSES
// ==========================================================
model Service {
  id                Int              @id @default(autoincrement())

  /// Service code / ID
  /// - Auto-generated in backend when creating if not provided
  /// - Must be unique, but can be edited manually
  code              String?          @unique

  category          ServiceCategory
  name              String

  /// Price in ₮ (integer is usually safer, but Float kept to match existing)
  price             Float

  /// Active/inactive flag (true = active, false = inactive)
  isActive          Boolean          @default(true)

  description       String?

  // Link to encounters that used this service
  encounterServices EncounterService[]

  /// Many-to-many to Branch through ServiceBranch
  serviceBranches   ServiceBranch[]

  // NEW: invoice items referencing this service (type=SERVICE)
  invoiceItems      InvoiceItem[]
}

// Many-to-many link: which services are available at which branches
model ServiceBranch {
  serviceId Int
  branchId  Int

  service   Service @relation(fields: [serviceId], references: [id])
  branch    Branch  @relation(fields: [branchId], references: [id])

  @@id([serviceId, branchId])
}

// Service usage in an encounter (line-like, but tied directly to Service)
model EncounterService {
  id           Int       @id @default(autoincrement())

  encounterId  Int
  serviceId    Int

  encounter    Encounter @relation(fields: [encounterId], references: [id])
  service      Service   @relation(fields: [serviceId], references: [id])

  quantity     Int       @default(1)
  price        Float
}

// Legacy or additional procedure catalog (if needed alongside Service)
model Procedure {
  code         String       @id
  name         String
  price        Float
  invoiceItems InvoiceItem[]
}

// OPTIONAL: separate product catalog for retail (if needed now or later)
model Product {
  id           Int          @id @default(autoincrement())
  branchId     Int          // product belongs to a branch (stock, reporting)
  code         String?      @unique
  name         String
  price        Float
  isActive     Boolean      @default(true)
  description  String?

  branch       Branch       @relation(fields: [branchId], references: [id])

  // Invoice lines referencing this product (type=PRODUCT)
  invoiceItems InvoiceItem[]

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@index([branchId, isActive])
}

// ==========================================================
// INVOICES, PAYMENTS, E-BARIMT
// ==========================================================
// NEW SOURCE-OF-TRUTH INVOICE MODEL (replacing legacy Invoice/InvoiceItem/Payment)
model Invoice {
  id                 Int             @id @default(autoincrement())

  /// Multi-branch: every invoice belongs to exactly one branch
  branchId           Int
  branch             Branch          @relation(fields: [branchId], references: [id])

  /// One invoice per encounter (post-treatment)
  encounterId        Int             @unique
  encounter          Encounter       @relation(fields: [encounterId], references: [id])

  /// Patient for reporting / linking (denormalized from encounter->book->patient)
  patientId          Int
  patient            Patient         @relation(fields: [patientId], references: [id])

  /// Clinical & retail lines:
  /// - service items (clinical)
  /// - product items (retail)
  items              InvoiceItem[]

  /// Sum of all item totals BEFORE discount
  totalBeforeDiscount Float

  /// Discount percent (0 / 5 / 10) – constrained by enum
  discountPercent     DiscountPercent @default(ZERO)

  /// Final amount after discount (this is what needs to be settled)
  finalAmount         Float

  /// Status controlled ONLY by settlement / insurance flow
  status              InvoiceStatus   @default(UNPAID)

  /// One e-Barimt per invoice (optional until issued)
  eBarimtReceipt      EBarimtReceipt?

  /// Ledger entries referencing this invoice (settlements, refunds, etc.)
  ledgerEntries       LedgerEntry[]

  /// Flags and metadata
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
}

// NEW: unified invoice line items (supports both services & products)
model InvoiceItem {
  id          Int             @id @default(autoincrement())

  invoiceId   Int
  invoice     Invoice         @relation(fields: [invoiceId], references: [id])

  /// SERVICE or PRODUCT
  itemType    InvoiceItemType

  /// Clinical service reference (if itemType = SERVICE)
  serviceId   Int?
  service     Service?        @relation(fields: [serviceId], references: [id])

  /// Retail product reference (if itemType = PRODUCT)
  productId   Int?
  product     Product?        @relation(fields: [productId], references: [id])

  /// Snapshot fields to keep invoice stable over time
  name        String
  unitPrice   Float
  quantity    Int             @default(1)

  /// Per-line total BEFORE invoice-level discount
  lineTotal   Float

  createdAt   DateTime        @default(now())

  @@index([invoiceId])
}

// Legacy Payment model is kept for backwards compatibility,
// but must NOT be used for new flows (all new payments go into LedgerEntry).
model Payment {
  id        Int      @id @default(autoincrement())
  invoiceId Int      @unique
  amount    Float
  method    String
  qpayTxnId String?
  timestamp DateTime @default(now())

  // This relation is preserved for legacy data only.
  invoice   Invoice  @relation(fields: [invoiceId], references: [id])
}

model Prescription {
  id          Int                 @id @default(autoincrement())
  encounter   Encounter           @relation(fields: [encounterId], references: [id])
  encounterId Int                 @unique

  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // optional snapshot fields for printing stability
  doctorNameSnapshot   String? 
  patientNameSnapshot  String?
  diagnosisSummary     String?
  clinicNameSnapshot   String?

  items      PrescriptionItem[]
}

model PrescriptionItem {
  id             Int          @id @default(autoincrement())
  prescription   Prescription @relation(fields: [prescriptionId], references: [id])
  prescriptionId Int

  order          Int          // 1..3, for consistent print order

  drugName       String       // free text or chosen from med list
  durationDays   Int          // e.g. 7
  quantityPerTake Int         // e.g. 1 tab
  frequencyPerDay Int         // e.g. 3 times/day
  note           String?      // optional extra info

  @@index([prescriptionId])
}

model EBarimtReceipt {
  id            Int      @id @default(autoincrement())

  /// One e-Barimt per invoice (STRICT)
  invoiceId     Int      @unique
  invoice       Invoice  @relation(fields: [invoiceId], references: [id])

  receiptNumber String   @unique
  timestamp     DateTime @default(now())
}

// ==========================================================
// LEDGER (FINANCIAL TRUTH)
// ==========================================================
// All financial movements are stored here. Immutable: never updated/deleted.
model LedgerEntry {
  id           Int             @id @default(autoincrement())

  /// Multi-branch enforcement: every ledger entry must belong to a branch
  branchId     Int
  branch       Branch          @relation(fields: [branchId], references: [id])

  /// Patient whose wallet / account this affects
  patientId    Int
  patient      Patient         @relation(fields: [patientId], references: [id])

  /// Optional invoice this entry belongs to (null for booking advances, etc.)
  invoiceId    Int?
  invoice      Invoice?        @relation(fields: [invoiceId], references: [id])

  /// Financial type (CASH, QPAY, BOOKING_ADVANCE, etc.)
  type         LedgerEntryType

  /// Amount: +in / −out (overpayments → positive credit)
  amount       Float

  /// Creator (who recorded the entry)
  createdById  Int
  createdBy    User            @relation("LedgerCreatedBy", fields: [createdById], references: [id])

  /// Optional approver for exceptional flows (discounts, refunds, barter, etc.)
  approvedById Int?
  approvedBy   User?           @relation("LedgerApprovedBy", fields: [approvedById], references: [id])

  /// Link to authorization code used (discount, barter, refund, etc.) – optional
  approvalCodeId Int?
  approvalCode   AuthorizationCode? @relation(fields: [approvalCodeId], references: [id])

  /// Additional metadata (payment provider payload, QPay txn ref, etc.)
  meta         Json?

  createdAt    DateTime        @default(now())

  @@index([branchId])
  @@index([patientId])
  @@index([invoiceId])
  @@index([type])
}

// ==========================================================
// AUTHORIZATION CODES (ADMIN CONTROLLED EXCEPTIONS)
// ==========================================================
model AuthorizationCode {
  id           Int       @id @default(autoincrement())
  code         String    @unique

  /// What is this code allowed to authorize:
  /// "DISCOUNT_5", "DISCOUNT_10", "BARTER", "REFUND", "VOUCHER_TOPUP", etc.
  purpose      String

  /// Whether this code is currently usable
  isEnabled    Boolean   @default(true)

  /// Optional expiry (date-time, not just date)
  expiresAt    DateTime?

  /// Optional usage limit (e.g. 10 times). Null = unlimited.
  maxUses      Int?
  usedCount    Int       @default(0)

  /// Who created this code (admin)
  createdById  Int
  createdBy    User      @relation(fields: [createdById], references: [id])

  /// Ledger entries that consumed this code
  ledgerEntries LedgerEntry[]

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([purpose])
}

// ==========================================================
// EMPLOYEE VOUCHERS (INTERNAL BENEFIT POOLS)
// ==========================================================
model EmployeeVoucher {
  id             Int                     @id @default(autoincrement())

  branchId       Int
  branch         Branch                  @relation(fields: [branchId], references: [id])

  /// Employee who owns this voucher pool
  employeeId     Int
  employee       User                    @relation("EmployeeVoucherEmployee", fields: [employeeId], references: [id])

  code           String                  @unique
  status         EmployeeVoucherStatus   @default(ACTIVE)
  balanceCap     Float
  usedAmount     Float                   @default(0)
  eligibility    Json
  allowedPatientIds Json
  ledgerEntries  LedgerEntry[]

  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt

  createdById    Int
  createdBy      User                    @relation("EmployeeVoucherCreatedBy", fields: [createdById], references: [id])

  @@index([branchId])
  @@index([employeeId])
}

// ==========================================================
// MEDIA (Photos, Files, X-rays, etc.)
// ==========================================================
model Media {
  id          Int      @id @default(autoincrement())
  encounterId Int
  filePath    String
  toothCode   String?
  type        String

  encounter   Encounter @relation(fields: [encounterId], references: [id])
}

// ==========================================================
// DOCTOR SCHEDULES (Per-day, per-branch work schedule)
// ==========================================================
model DoctorSchedule {
  id        Int      @id @default(autoincrement())

  doctorId  Int
  branchId  Int

  /// Calendar date (store as date-only; time is in startTime/endTime)
  date      DateTime

  /// e.g. "09:00" — 24h format
  startTime String

  /// e.g. "15:00" — 24h format
  endTime   String

  note      String?

  doctor    User     @relation(fields: [doctorId], references: [id])
  branch    Branch   @relation(fields: [branchId], references: [id])

  @@index([doctorId, date])
  @@index([branchId, date])
  @@unique([doctorId, branchId, date])
}

// ==========================================================
// RECEPTION SCHEDULES (Per-day, per-branch work schedule)
// ==========================================================
model ReceptionSchedule {
  id          Int      @id @default(autoincrement())

  receptionId Int
  branchId    Int

  /// Calendar date (store as date-only; time is in startTime/endTime)
  date        DateTime

  /// e.g. "09:00" — 24h format
  startTime   String

  /// e.g. "15:00" — 24h format
  endTime     String

  note        String?

  reception   User   @relation(fields: [receptionId], references: [id])
  branch      Branch @relation(fields: [branchId], references: [id])

  @@index([receptionId, date])
  @@index([branchId, date])
  @@unique([receptionId, branchId, date])
}

model NurseBranch {
  id       Int    @id @default(autoincrement())
  nurseId  Int
  branchId Int

  nurse  User   @relation(fields: [nurseId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@unique([nurseId, branchId])
}

model NurseSchedule {
  id       Int      @id @default(autoincrement())
  nurseId  Int
  branchId Int
  date     DateTime
  startTime String
  endTime   String
  note      String?

  nurse  User   @relation(fields: [nurseId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])

  @@index([nurseId, date])
  @@index([branchId, date])
  @@unique([nurseId, branchId, date])
}
