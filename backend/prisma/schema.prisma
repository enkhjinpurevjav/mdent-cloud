// ==========================================================
// M DENT SOFTWARE — COMPLETE OVERVIEW → PRISMA SCHEMA
// Mon Family Dental Clinic System
// ==========================================================

// DATASOURCE
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum BookingStatus {
  PENDING      // Захиалсан
  CONFIRMED    // Баталгаажсан
  IN_PROGRESS  // Явж байна
  COMPLETED    // Дууссан
  CANCELLED    // Цуцалсан
}

// GENERATOR
generator client {
  provider = "prisma-client-js"
}

// ==========================================================
// ENUMS
// ==========================================================
enum UserRole {
  admin
  doctor
  receptionist
  accountant
  nurse
  manager
}

enum ServiceCategory {
  GENERAL_DENTISTRY
  IMPLANTS
  ORTHODONTICS
  COSMETIC_DENTISTRY
  CHILDRENS
}

// ==========================================================
// BRANCHES (Multi-Branch Support)
// ==========================================================
model Branch {
  id        Int              @id @default(autoincrement())
  name      String
  address   String?
  createdAt DateTime         @default(now())

  // Users directly assigned to this branch (legacy single-branch link)
  users     User[]

  // Patients registered under this branch
  patients  Patient[]

  // Doctor schedules per branch (per-day entries)
  doctorSchedules DoctorSchedule[]

  // Services available in this branch (many-to-many via ServiceBranch)
  serviceBranches ServiceBranch[]

  // Doctors assigned to this branch (many-to-many via DoctorBranch)
  doctorBranches  DoctorBranch[]

  // Appointments booked in this branch
  appointments    Appointment[]

  // Bookings in this branch
  bookings        Booking[]
}

// ==========================================================
// USERS (Doctors, Nurses, Admin, etc.)
// ==========================================================
model User {
  id                 Int              @id @default(autoincrement())
  email              String           @unique
  password           String

  /// Father’s name for all users
  ovog               String?

  /// Given name
  name               String?

  role               UserRole         @default(receptionist)

  /// Legacy single-branch assignment
  branchId           Int?
  branch             Branch?          @relation(fields: [branchId], references: [id])

  createdAt          DateTime         @default(now())

  // Encounters where this user is the doctor
  encounters         Encounter[]      @relation("DoctorEncounters")

  // Contact
  phone              String?          // employee phone (optional)

  // Advanced Doctor/Nurse Info
  regNo              String?          @unique
  licenseNumber      String?          @unique
  licenseExpiryDate  DateTime?
  signatureImagePath String?
  stampImagePath     String?
  idPhotoPath        String?

  // Per-day work schedules across branches
  doctorSchedules    DoctorSchedule[]

  // Many-to-many doctor-to-branch assignment
  doctorBranches     DoctorBranch[]

  // Appointments where this user is the doctor
  appointments       Appointment[]

  // Bookings for this user as doctor
  bookings           Booking[]
}

// Join table for many-to-many between Doctor (User) and Branch
model DoctorBranch {
  id        Int    @id @default(autoincrement())

  doctorId  Int
  branchId  Int

  doctor    User   @relation(fields: [doctorId], references: [id])
  branch    Branch @relation(fields: [branchId], references: [id])

  @@unique([doctorId, branchId])
}

// ==========================================================
// PATIENTS & DIGITAL HISTORY BOOK
// ==========================================================
model Patient {
  id             Int          @id @default(autoincrement())

  /// Mongolian citizen ID (РД), unique per patient
  regNo          String?       @unique

  /// Father’s name
  ovog           String?

  /// Given name
  name           String

  gender         String?
  birthDate      DateTime?

  /// Phone numbers are non-unique (one parent can register multiple children)
  phone          String?

  address        String?
  bloodType      String?
  citizenship    String?      @default("Mongolian")
  emergencyPhone String?
  notes          String?

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  /// Primary branch where the patient is registered
  branchId       Int
  branch         Branch       @relation(fields: [branchId], references: [id])

  /// Each patient has exactly one digital history book
  patientBook    PatientBook?

  // Back-relation to appointments
  appointments   Appointment[]

  // Bookings for this patient
  bookings       Booking[]
}

// ==========================================================
// CHARTING (Tooth Records)
// ==========================================================
model ChartTooth {
  id          Int        @id @default(autoincrement())

  /// FDI tooth code (e.g. "11", "26", "85")
  toothCode   String

  /// General tooth condition/status (optional, e.g. "Healthy", "Caries")
  status      String?

  /// Free-form note for this tooth in this encounter
  notes       String?

  encounterId Int
  encounter   Encounter  @relation(fields: [encounterId], references: [id])

  chartNotes  ChartNote[]
}

model ChartNote {
  id           Int        @id @default(autoincrement())
  chartToothId Int
  description  String
  createdAt    DateTime   @default(now())

  chartTooth   ChartTooth @relation(fields: [chartToothId], references: [id])
}

// Appointment model
model Appointment {
  id          Int       @id @default(autoincrement())

  patientId   Int
  doctorId    Int?
  branchId    Int

  scheduledAt DateTime
  endAt       DateTime?   // Дуусах цаг (шинэ)
  status      String      @default("booked")
  notes       String?

  patient     Patient   @relation(fields: [patientId], references: [id])
  doctor      User?     @relation(fields: [doctorId], references: [id])
  branch      Branch    @relation(fields: [branchId], references: [id])

  @@index([branchId, scheduledAt])

  // Back relation to Encounter (1 appointment → 0 or 1 encounter)
  encounters  Encounter[]
}

model Booking {
  id        Int           @id @default(autoincrement())

  doctorId  Int
  branchId  Int
  patientId Int

  /// Stored as date-only (we normalize to 00:00:00 UTC/local)
  date      DateTime

  /// HH:MM 24h format (e.g. "09:30")
  startTime String

  /// HH:MM 24h format (e.g. "10:00")
  endTime   String

  status    BookingStatus @default(PENDING)
  note      String?       @db.Text

  doctor  User    @relation(fields: [doctorId], references: [id])
  branch  Branch  @relation(fields: [branchId], references: [id])
  patient Patient @relation(fields: [patientId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// DIGITAL HISTORY BOOK
model PatientBook {
  id         Int         @id @default(autoincrement())

  /// Human-friendly book number (e.g., "6", "000123")
  bookNumber String      @unique

  patientId  Int         @unique
  patient    Patient     @relation(fields: [patientId], references: [id])

  // All encounters (visits) recorded in this book
  encounters Encounter[]
}

model Diagnosis {
  id          Int                  @id @default(autoincrement())
  code        String               @unique
  name        String               // Short name/title
  description String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  problems    DiagnosisProblem[]
  encounters  EncounterDiagnosis[]
}

model DiagnosisProblem {
  id           Int        @id @default(autoincrement())
  diagnosisId  Int
  label        String
  order        Int        @default(0)
  active       Boolean    @default(true)

  diagnosis    Diagnosis  @relation(fields: [diagnosisId], references: [id])
}

model Encounter {
  id                 Int           @id @default(autoincrement())
  patientBookId      Int
  doctorId           Int
  visitDate          DateTime
  notes              String?

  // Link to Appointment (one appointment can have many encounters)
  appointmentId      Int?
  appointment        Appointment? @relation(fields: [appointmentId], references: [id])

  patientBook        PatientBook   @relation(fields: [patientBookId], references: [id])
  doctor             User          @relation("DoctorEncounters", fields: [doctorId], references: [id])

  // Per-tooth charting for this encounter
  chartTeeth         ChartTooth[]

  // Generated invoice for this encounter
  invoice            Invoice?

  // Attached media (photos, X-rays, docs)
  media              Media[]

  // Services performed in this encounter
  encounterServices  EncounterService[]

  diagnoses          EncounterDiagnosis[]
}

model EncounterDiagnosis {
  id                  Int        @id @default(autoincrement())
  encounterId         Int
  diagnosisId         Int

  /// Which tooth this diagnosis applies to (optional, null = general)
  toothCode           String?    // e.g. "11", "26", "85"

  // List of problem IDs from DiagnosisProblem for this encounter
  selectedProblemIds  Json?      // e.g. [1,3,5]
  note                String?

  encounter           Encounter  @relation(fields: [encounterId], references: [id])
  diagnosis           Diagnosis  @relation(fields: [diagnosisId], references: [id])

  createdAt           DateTime   @default(now())

  // TEMP: allow same diagnosis multiple times per encounter
  // @@unique([encounterId, diagnosisId])
}

// ==========================================================
// SERVICES, PROCEDURES, DIAGNOSES
// ==========================================================
model Service {
  id                Int              @id @default(autoincrement())

  /// Service code / ID
  /// - Auto-generated in backend when creating if not provided
  /// - Must be unique, but can be edited manually
  code              String?          @unique

  category          ServiceCategory
  name              String

  /// Price in ₮ (integer is usually safer, but Float kept to match existing)
  price             Float

  /// Active/inactive flag (true = active, false = inactive)
  isActive          Boolean          @default(true)

  description       String?

  // Link to encounters that used this service
  encounterServices EncounterService[]

  /// Many-to-many to Branch through ServiceBranch
  serviceBranches   ServiceBranch[]
}

// Many-to-many link: which services are available at which branches
model ServiceBranch {
  serviceId Int
  branchId  Int

  service   Service @relation(fields: [serviceId], references: [id])
  branch    Branch  @relation(fields: [branchId], references: [id])

  @@id([serviceId, branchId])
}

// Service usage in an encounter (line-like, but tied directly to Service)
model EncounterService {
  id           Int       @id @default(autoincrement())

  encounterId  Int
  serviceId    Int

  encounter    Encounter @relation(fields: [encounterId], references: [id])
  service      Service   @relation(fields: [serviceId], references: [id])

  quantity     Int       @default(1)
  price        Float
}

// Legacy or additional procedure catalog (if needed alongside Service)
model Procedure {
  code         String       @id
  name         String
  price        Float
  invoiceItems InvoiceItem[]
}

// ==========================================================
// INVOICES, PAYMENTS, E-BARIMT
// ==========================================================
model Invoice {
  id             Int           @id @default(autoincrement())
  encounterId    Int           @unique
  totalAmount    Float
  status         String
  createdAt      DateTime      @default(now())

  encounter      Encounter     @relation(fields: [encounterId], references: [id])
  invoiceItems   InvoiceItem[]
  payment        Payment?
  eBarimtReceipt EBarimtReceipt?
}

model InvoiceItem {
  id          Int       @id @default(autoincrement())
  invoiceId   Int
  procedureId String
  price       Float
  quantity    Int

  invoice     Invoice   @relation(fields: [invoiceId], references: [id])
  procedure   Procedure @relation(fields: [procedureId], references: [code])
}

model Payment {
  id        Int      @id @default(autoincrement())
  invoiceId Int      @unique
  amount    Float
  method    String
  qpayTxnId String?
  timestamp DateTime @default(now())

  invoice   Invoice  @relation(fields: [invoiceId], references: [id])
}

model EBarimtReceipt {
  id            Int      @id @default(autoincrement())
  invoiceId     Int      @unique
  receiptNumber String   @unique
  timestamp     DateTime @default(now())

  invoice       Invoice  @relation(fields: [invoiceId], references: [id])
}

// ==========================================================
// MEDIA (Photos, Files, X-rays, etc.)
// ==========================================================
model Media {
  id          Int      @id @default(autoincrement())
  encounterId Int
  filePath    String
  toothCode   String?
  type        String

  encounter   Encounter @relation(fields: [encounterId], references: [id])
}

// ==========================================================
// DOCTOR SCHEDULES (Per-day, per-branch work schedule)
// ==========================================================
model DoctorSchedule {
  id        Int      @id @default(autoincrement())

  doctorId  Int
  branchId  Int

  /// Calendar date (store as date-only; time is in startTime/endTime)
  date      DateTime

  /// e.g. "09:00" — 24h format
  startTime String

  /// e.g. "15:00" — 24h format
  endTime   String

  note      String?

  doctor    User     @relation(fields: [doctorId], references: [id])
  branch    Branch   @relation(fields: [branchId], references: [id])

  @@index([doctorId, date])
  @@index([branchId, date])
  @@unique([doctorId, branchId, date])
}
